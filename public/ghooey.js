var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __toCommonJS = (from) => {
  const moduleCache = __toCommonJS.moduleCache ??= new WeakMap;
  var cached = moduleCache.get(from);
  if (cached)
    return cached;
  var to = __defProp({}, "__esModule", { value: true });
  var desc = { enumerable: false };
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key))
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
  }
  moduleCache.set(from, to);
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node:buffer
var exports_buffer = {};
__export(exports_buffer, {
  default: () => {
    {
      return export_default;
    }
  }
});
var Er, $, dr, gr, mr, Ir, b, Fr, D, _, J, Q, v, z, S, xr, export_default;
var init_buffer = __esm(() => {
  Er = Object.create;
  $ = Object.defineProperty;
  dr = Object.getOwnPropertyDescriptor;
  gr = Object.getOwnPropertyNames;
  mr = Object.getPrototypeOf;
  Ir = Object.prototype.hasOwnProperty;
  b = (i, r) => () => (r || i((r = { exports: {} }).exports, r), r.exports);
  Fr = (i, r) => {
    for (var t in r)
      $(i, t, { get: r[t], enumerable: true });
  };
  D = (i, r, t, n) => {
    if (r && typeof r == "object" || typeof r == "function")
      for (let e of gr(r))
        !Ir.call(i, e) && e !== t && $(i, e, { get: () => r[e], enumerable: !(n = dr(r, e)) || n.enumerable });
    return i;
  };
  _ = (i, r, t) => (D(i, r, "default"), t && D(t, r, "default"));
  J = (i, r, t) => (t = i != null ? Er(mr(i)) : {}, D(r || !i || !i.__esModule ? $(t, "default", { value: i, enumerable: true }) : t, i));
  Q = b((L) => {
    L.byteLength = Ur;
    L.toByteArray = Tr;
    L.fromByteArray = _r;
    var B = [], w = [], Ar = typeof Uint8Array < "u" ? Uint8Array : Array, P = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (m = 0, K = P.length;m < K; ++m)
      B[m] = P[m], w[P.charCodeAt(m)] = m;
    var m, K;
    w["-".charCodeAt(0)] = 62;
    w["_".charCodeAt(0)] = 63;
    function Z(i) {
      var r = i.length;
      if (r % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var t = i.indexOf("=");
      t === -1 && (t = r);
      var n = t === r ? 0 : 4 - t % 4;
      return [t, n];
    }
    function Ur(i) {
      var r = Z(i), t = r[0], n = r[1];
      return (t + n) * 3 / 4 - n;
    }
    function Rr(i, r, t) {
      return (r + t) * 3 / 4 - t;
    }
    function Tr(i) {
      var r, t = Z(i), n = t[0], e = t[1], o = new Ar(Rr(i, n, e)), u = 0, f = e > 0 ? n - 4 : n, c;
      for (c = 0;c < f; c += 4)
        r = w[i.charCodeAt(c)] << 18 | w[i.charCodeAt(c + 1)] << 12 | w[i.charCodeAt(c + 2)] << 6 | w[i.charCodeAt(c + 3)], o[u++] = r >> 16 & 255, o[u++] = r >> 8 & 255, o[u++] = r & 255;
      return e === 2 && (r = w[i.charCodeAt(c)] << 2 | w[i.charCodeAt(c + 1)] >> 4, o[u++] = r & 255), e === 1 && (r = w[i.charCodeAt(c)] << 10 | w[i.charCodeAt(c + 1)] << 4 | w[i.charCodeAt(c + 2)] >> 2, o[u++] = r >> 8 & 255, o[u++] = r & 255), o;
    }
    function Cr(i) {
      return B[i >> 18 & 63] + B[i >> 12 & 63] + B[i >> 6 & 63] + B[i & 63];
    }
    function Sr(i, r, t) {
      for (var n, e = [], o = r;o < t; o += 3)
        n = (i[o] << 16 & 16711680) + (i[o + 1] << 8 & 65280) + (i[o + 2] & 255), e.push(Cr(n));
      return e.join("");
    }
    function _r(i) {
      for (var r, t = i.length, n = t % 3, e = [], o = 16383, u = 0, f = t - n;u < f; u += o)
        e.push(Sr(i, u, u + o > f ? f : u + o));
      return n === 1 ? (r = i[t - 1], e.push(B[r >> 2] + B[r << 4 & 63] + "==")) : n === 2 && (r = (i[t - 2] << 8) + i[t - 1], e.push(B[r >> 10] + B[r >> 4 & 63] + B[r << 2 & 63] + "=")), e.join("");
    }
  });
  v = b((O) => {
    O.read = function(i, r, t, n, e) {
      var o, u, f = e * 8 - n - 1, c = (1 << f) - 1, l = c >> 1, s = -7, p = t ? e - 1 : 0, F = t ? -1 : 1, x = i[r + p];
      for (p += F, o = x & (1 << -s) - 1, x >>= -s, s += f;s > 0; o = o * 256 + i[r + p], p += F, s -= 8)
        ;
      for (u = o & (1 << -s) - 1, o >>= -s, s += n;s > 0; u = u * 256 + i[r + p], p += F, s -= 8)
        ;
      if (o === 0)
        o = 1 - l;
      else {
        if (o === c)
          return u ? NaN : (x ? -1 : 1) * (1 / 0);
        u = u + Math.pow(2, n), o = o - l;
      }
      return (x ? -1 : 1) * u * Math.pow(2, o - n);
    };
    O.write = function(i, r, t, n, e, o) {
      var u, f, c, l = o * 8 - e - 1, s = (1 << l) - 1, p = s >> 1, F = e === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = n ? 0 : o - 1, k = n ? 1 : -1, Br = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
      for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f = isNaN(r) ? 1 : 0, u = s) : (u = Math.floor(Math.log(r) / Math.LN2), r * (c = Math.pow(2, -u)) < 1 && (u--, c *= 2), u + p >= 1 ? r += F / c : r += F * Math.pow(2, 1 - p), r * c >= 2 && (u++, c /= 2), u + p >= s ? (f = 0, u = s) : u + p >= 1 ? (f = (r * c - 1) * Math.pow(2, e), u = u + p) : (f = r * Math.pow(2, p - 1) * Math.pow(2, e), u = 0));e >= 8; i[t + x] = f & 255, x += k, f /= 256, e -= 8)
        ;
      for (u = u << e | f, l += e;l > 0; i[t + x] = u & 255, x += k, u /= 256, l -= 8)
        ;
      i[t + x - k] |= Br * 128;
    };
  });
  z = b((T) => {
    var G = Q(), U = v(), rr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    T.Buffer = h;
    T.SlowBuffer = $r;
    T.INSPECT_MAX_BYTES = 50;
    var N = 2147483647;
    T.kMaxLength = N;
    h.TYPED_ARRAY_SUPPORT = Lr();
    !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Lr() {
      try {
        let i = new Uint8Array(1), r = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(h.prototype, "parent", { enumerable: true, get: function() {
      if (!!h.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(h.prototype, "offset", { enumerable: true, get: function() {
      if (!!h.isBuffer(this))
        return this.byteOffset;
    } });
    function d(i) {
      if (i > N)
        throw new RangeError('The value "' + i + '" is invalid for option "size"');
      let r = new Uint8Array(i);
      return Object.setPrototypeOf(r, h.prototype), r;
    }
    function h(i, r, t) {
      if (typeof i == "number") {
        if (typeof r == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return j(i);
      }
      return er(i, r, t);
    }
    h.poolSize = 8192;
    function er(i, r, t) {
      if (typeof i == "string")
        return Mr(i, r);
      if (ArrayBuffer.isView(i))
        return kr(i);
      if (i == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
      if (E(i, ArrayBuffer) || i && E(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (E(i, SharedArrayBuffer) || i && E(i.buffer, SharedArrayBuffer)))
        return q(i, r, t);
      if (typeof i == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let n = i.valueOf && i.valueOf();
      if (n != null && n !== i)
        return h.from(n, r, t);
      let e = Dr(i);
      if (e)
        return e;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function")
        return h.from(i[Symbol.toPrimitive]("string"), r, t);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    }
    h.from = function(i, r, t) {
      return er(i, r, t);
    };
    Object.setPrototypeOf(h.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h, Uint8Array);
    function or(i) {
      if (typeof i != "number")
        throw new TypeError('"size" argument must be of type number');
      if (i < 0)
        throw new RangeError('The value "' + i + '" is invalid for option "size"');
    }
    function Nr(i, r, t) {
      return or(i), i <= 0 ? d(i) : r !== undefined ? typeof t == "string" ? d(i).fill(r, t) : d(i).fill(r) : d(i);
    }
    h.alloc = function(i, r, t) {
      return Nr(i, r, t);
    };
    function j(i) {
      return or(i), d(i < 0 ? 0 : H(i) | 0);
    }
    h.allocUnsafe = function(i) {
      return j(i);
    };
    h.allocUnsafeSlow = function(i) {
      return j(i);
    };
    function Mr(i, r) {
      if ((typeof r != "string" || r === "") && (r = "utf8"), !h.isEncoding(r))
        throw new TypeError("Unknown encoding: " + r);
      let t = ur(i, r) | 0, n = d(t), e = n.write(i, r);
      return e !== t && (n = n.slice(0, e)), n;
    }
    function Y(i) {
      let r = i.length < 0 ? 0 : H(i.length) | 0, t = d(r);
      for (let n = 0;n < r; n += 1)
        t[n] = i[n] & 255;
      return t;
    }
    function kr(i) {
      if (E(i, Uint8Array)) {
        let r = new Uint8Array(i);
        return q(r.buffer, r.byteOffset, r.byteLength);
      }
      return Y(i);
    }
    function q(i, r, t) {
      if (r < 0 || i.byteLength < r)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (i.byteLength < r + (t || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return r === undefined && t === undefined ? n = new Uint8Array(i) : t === undefined ? n = new Uint8Array(i, r) : n = new Uint8Array(i, r, t), Object.setPrototypeOf(n, h.prototype), n;
    }
    function Dr(i) {
      if (h.isBuffer(i)) {
        let r = H(i.length) | 0, t = d(r);
        return t.length === 0 || i.copy(t, 0, 0, r), t;
      }
      if (i.length !== undefined)
        return typeof i.length != "number" || X(i.length) ? d(0) : Y(i);
      if (i.type === "Buffer" && Array.isArray(i.data))
        return Y(i.data);
    }
    function H(i) {
      if (i >= N)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + N.toString(16) + " bytes");
      return i | 0;
    }
    function $r(i) {
      return +i != i && (i = 0), h.alloc(+i);
    }
    h.isBuffer = function(r) {
      return r != null && r._isBuffer === true && r !== h.prototype;
    };
    h.compare = function(r, t) {
      if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), E(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(r) || !h.isBuffer(t))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (r === t)
        return 0;
      let n = r.length, e = t.length;
      for (let o = 0, u = Math.min(n, e);o < u; ++o)
        if (r[o] !== t[o]) {
          n = r[o], e = t[o];
          break;
        }
      return n < e ? -1 : e < n ? 1 : 0;
    };
    h.isEncoding = function(r) {
      switch (String(r).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    h.concat = function(r, t) {
      if (!Array.isArray(r))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (r.length === 0)
        return h.alloc(0);
      let n;
      if (t === undefined)
        for (t = 0, n = 0;n < r.length; ++n)
          t += r[n].length;
      let e = h.allocUnsafe(t), o = 0;
      for (n = 0;n < r.length; ++n) {
        let u = r[n];
        if (E(u, Uint8Array))
          o + u.length > e.length ? (h.isBuffer(u) || (u = h.from(u)), u.copy(e, o)) : Uint8Array.prototype.set.call(e, u, o);
        else if (h.isBuffer(u))
          u.copy(e, o);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o += u.length;
      }
      return e;
    };
    function ur(i, r) {
      if (h.isBuffer(i))
        return i.length;
      if (ArrayBuffer.isView(i) || E(i, ArrayBuffer))
        return i.byteLength;
      if (typeof i != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
      let t = i.length, n = arguments.length > 2 && arguments[2] === true;
      if (!n && t === 0)
        return 0;
      let e = false;
      for (;; )
        switch (r) {
          case "ascii":
          case "latin1":
          case "binary":
            return t;
          case "utf8":
          case "utf-8":
            return W(i).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return t * 2;
          case "hex":
            return t >>> 1;
          case "base64":
            return wr(i).length;
          default:
            if (e)
              return n ? -1 : W(i).length;
            r = ("" + r).toLowerCase(), e = true;
        }
    }
    h.byteLength = ur;
    function br(i, r, t) {
      let n = false;
      if ((r === undefined || r < 0) && (r = 0), r > this.length || ((t === undefined || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r))
        return "";
      for (i || (i = "utf8");; )
        switch (i) {
          case "hex":
            return Xr(this, r, t);
          case "utf8":
          case "utf-8":
            return fr(this, r, t);
          case "ascii":
            return Hr(this, r, t);
          case "latin1":
          case "binary":
            return Vr(this, r, t);
          case "base64":
            return Wr(this, r, t);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return zr(this, r, t);
          default:
            if (n)
              throw new TypeError("Unknown encoding: " + i);
            i = (i + "").toLowerCase(), n = true;
        }
    }
    h.prototype._isBuffer = true;
    function I(i, r, t) {
      let n = i[r];
      i[r] = i[t], i[t] = n;
    }
    h.prototype.swap16 = function() {
      let r = this.length;
      if (r % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let t = 0;t < r; t += 2)
        I(this, t, t + 1);
      return this;
    };
    h.prototype.swap32 = function() {
      let r = this.length;
      if (r % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let t = 0;t < r; t += 4)
        I(this, t, t + 3), I(this, t + 1, t + 2);
      return this;
    };
    h.prototype.swap64 = function() {
      let r = this.length;
      if (r % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let t = 0;t < r; t += 8)
        I(this, t, t + 7), I(this, t + 1, t + 6), I(this, t + 2, t + 5), I(this, t + 3, t + 4);
      return this;
    };
    h.prototype.toString = function() {
      let r = this.length;
      return r === 0 ? "" : arguments.length === 0 ? fr(this, 0, r) : br.apply(this, arguments);
    };
    h.prototype.toLocaleString = h.prototype.toString;
    h.prototype.equals = function(r) {
      if (!h.isBuffer(r))
        throw new TypeError("Argument must be a Buffer");
      return this === r ? true : h.compare(this, r) === 0;
    };
    h.prototype.inspect = function() {
      let r = "", t = T.INSPECT_MAX_BYTES;
      return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
    };
    rr && (h.prototype[rr] = h.prototype.inspect);
    h.prototype.compare = function(r, t, n, e, o) {
      if (E(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), !h.isBuffer(r))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
      if (t === undefined && (t = 0), n === undefined && (n = r ? r.length : 0), e === undefined && (e = 0), o === undefined && (o = this.length), t < 0 || n > r.length || e < 0 || o > this.length)
        throw new RangeError("out of range index");
      if (e >= o && t >= n)
        return 0;
      if (e >= o)
        return -1;
      if (t >= n)
        return 1;
      if (t >>>= 0, n >>>= 0, e >>>= 0, o >>>= 0, this === r)
        return 0;
      let u = o - e, f = n - t, c = Math.min(u, f), l = this.slice(e, o), s = r.slice(t, n);
      for (let p = 0;p < c; ++p)
        if (l[p] !== s[p]) {
          u = l[p], f = s[p];
          break;
        }
      return u < f ? -1 : f < u ? 1 : 0;
    };
    function hr(i, r, t, n, e) {
      if (i.length === 0)
        return -1;
      if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, X(t) && (t = e ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
        if (e)
          return -1;
        t = i.length - 1;
      } else if (t < 0)
        if (e)
          t = 0;
        else
          return -1;
      if (typeof r == "string" && (r = h.from(r, n)), h.isBuffer(r))
        return r.length === 0 ? -1 : tr(i, r, t, n, e);
      if (typeof r == "number")
        return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? e ? Uint8Array.prototype.indexOf.call(i, r, t) : Uint8Array.prototype.lastIndexOf.call(i, r, t) : tr(i, [r], t, n, e);
      throw new TypeError("val must be string, number or Buffer");
    }
    function tr(i, r, t, n, e) {
      let o = 1, u = i.length, f = r.length;
      if (n !== undefined && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
        if (i.length < 2 || r.length < 2)
          return -1;
        o = 2, u /= 2, f /= 2, t /= 2;
      }
      function c(s, p) {
        return o === 1 ? s[p] : s.readUInt16BE(p * o);
      }
      let l;
      if (e) {
        let s = -1;
        for (l = t;l < u; l++)
          if (c(i, l) === c(r, s === -1 ? 0 : l - s)) {
            if (s === -1 && (s = l), l - s + 1 === f)
              return s * o;
          } else
            s !== -1 && (l -= l - s), s = -1;
      } else
        for (t + f > u && (t = u - f), l = t;l >= 0; l--) {
          let s = true;
          for (let p = 0;p < f; p++)
            if (c(i, l + p) !== c(r, p)) {
              s = false;
              break;
            }
          if (s)
            return l;
        }
      return -1;
    }
    h.prototype.includes = function(r, t, n) {
      return this.indexOf(r, t, n) !== -1;
    };
    h.prototype.indexOf = function(r, t, n) {
      return hr(this, r, t, n, true);
    };
    h.prototype.lastIndexOf = function(r, t, n) {
      return hr(this, r, t, n, false);
    };
    function Pr(i, r, t, n) {
      t = Number(t) || 0;
      let e = i.length - t;
      n ? (n = Number(n), n > e && (n = e)) : n = e;
      let o = r.length;
      n > o / 2 && (n = o / 2);
      let u;
      for (u = 0;u < n; ++u) {
        let f = parseInt(r.substr(u * 2, 2), 16);
        if (X(f))
          return u;
        i[t + u] = f;
      }
      return u;
    }
    function Or(i, r, t, n) {
      return M(W(r, i.length - t), i, t, n);
    }
    function Gr(i, r, t, n) {
      return M(Qr(r), i, t, n);
    }
    function Yr(i, r, t, n) {
      return M(wr(r), i, t, n);
    }
    function qr(i, r, t, n) {
      return M(vr(r, i.length - t), i, t, n);
    }
    h.prototype.write = function(r, t, n, e) {
      if (t === undefined)
        e = "utf8", n = this.length, t = 0;
      else if (n === undefined && typeof t == "string")
        e = t, n = this.length, t = 0;
      else if (isFinite(t))
        t = t >>> 0, isFinite(n) ? (n = n >>> 0, e === undefined && (e = "utf8")) : (e = n, n = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o = this.length - t;
      if ((n === undefined || n > o) && (n = o), r.length > 0 && (n < 0 || t < 0) || t > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      e || (e = "utf8");
      let u = false;
      for (;; )
        switch (e) {
          case "hex":
            return Pr(this, r, t, n);
          case "utf8":
          case "utf-8":
            return Or(this, r, t, n);
          case "ascii":
          case "latin1":
          case "binary":
            return Gr(this, r, t, n);
          case "base64":
            return Yr(this, r, t, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return qr(this, r, t, n);
          default:
            if (u)
              throw new TypeError("Unknown encoding: " + e);
            e = ("" + e).toLowerCase(), u = true;
        }
    };
    h.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Wr(i, r, t) {
      return r === 0 && t === i.length ? G.fromByteArray(i) : G.fromByteArray(i.slice(r, t));
    }
    function fr(i, r, t) {
      t = Math.min(i.length, t);
      let n = [], e = r;
      for (;e < t; ) {
        let o = i[e], u = null, f = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
        if (e + f <= t) {
          let c, l, s, p;
          switch (f) {
            case 1:
              o < 128 && (u = o);
              break;
            case 2:
              c = i[e + 1], (c & 192) === 128 && (p = (o & 31) << 6 | c & 63, p > 127 && (u = p));
              break;
            case 3:
              c = i[e + 1], l = i[e + 2], (c & 192) === 128 && (l & 192) === 128 && (p = (o & 15) << 12 | (c & 63) << 6 | l & 63, p > 2047 && (p < 55296 || p > 57343) && (u = p));
              break;
            case 4:
              c = i[e + 1], l = i[e + 2], s = i[e + 3], (c & 192) === 128 && (l & 192) === 128 && (s & 192) === 128 && (p = (o & 15) << 18 | (c & 63) << 12 | (l & 63) << 6 | s & 63, p > 65535 && p < 1114112 && (u = p));
          }
        }
        u === null ? (u = 65533, f = 1) : u > 65535 && (u -= 65536, n.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), n.push(u), e += f;
      }
      return jr(n);
    }
    var ir = 4096;
    function jr(i) {
      let r = i.length;
      if (r <= ir)
        return String.fromCharCode.apply(String, i);
      let t = "", n = 0;
      for (;n < r; )
        t += String.fromCharCode.apply(String, i.slice(n, n += ir));
      return t;
    }
    function Hr(i, r, t) {
      let n = "";
      t = Math.min(i.length, t);
      for (let e = r;e < t; ++e)
        n += String.fromCharCode(i[e] & 127);
      return n;
    }
    function Vr(i, r, t) {
      let n = "";
      t = Math.min(i.length, t);
      for (let e = r;e < t; ++e)
        n += String.fromCharCode(i[e]);
      return n;
    }
    function Xr(i, r, t) {
      let n = i.length;
      (!r || r < 0) && (r = 0), (!t || t < 0 || t > n) && (t = n);
      let e = "";
      for (let o = r;o < t; ++o)
        e += rt[i[o]];
      return e;
    }
    function zr(i, r, t) {
      let n = i.slice(r, t), e = "";
      for (let o = 0;o < n.length - 1; o += 2)
        e += String.fromCharCode(n[o] + n[o + 1] * 256);
      return e;
    }
    h.prototype.slice = function(r, t) {
      let n = this.length;
      r = ~~r, t = t === undefined ? n : ~~t, r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < r && (t = r);
      let e = this.subarray(r, t);
      return Object.setPrototypeOf(e, h.prototype), e;
    };
    function a(i, r, t) {
      if (i % 1 !== 0 || i < 0)
        throw new RangeError("offset is not uint");
      if (i + r > t)
        throw new RangeError("Trying to access beyond buffer length");
    }
    h.prototype.readUintLE = h.prototype.readUIntLE = function(r, t, n) {
      r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
      let e = this[r], o = 1, u = 0;
      for (;++u < t && (o *= 256); )
        e += this[r + u] * o;
      return e;
    };
    h.prototype.readUintBE = h.prototype.readUIntBE = function(r, t, n) {
      r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
      let e = this[r + --t], o = 1;
      for (;t > 0 && (o *= 256); )
        e += this[r + --t] * o;
      return e;
    };
    h.prototype.readUint8 = h.prototype.readUInt8 = function(r, t) {
      return r = r >>> 0, t || a(r, 1, this.length), this[r];
    };
    h.prototype.readUint16LE = h.prototype.readUInt16LE = function(r, t) {
      return r = r >>> 0, t || a(r, 2, this.length), this[r] | this[r + 1] << 8;
    };
    h.prototype.readUint16BE = h.prototype.readUInt16BE = function(r, t) {
      return r = r >>> 0, t || a(r, 2, this.length), this[r] << 8 | this[r + 1];
    };
    h.prototype.readUint32LE = h.prototype.readUInt32LE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
    };
    h.prototype.readUint32BE = h.prototype.readUInt32BE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
    };
    h.prototype.readBigUInt64LE = g(function(r) {
      r = r >>> 0, R(r, "offset");
      let t = this[r], n = this[r + 7];
      (t === undefined || n === undefined) && C(r, this.length - 8);
      let e = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + n * 2 ** 24;
      return BigInt(e) + (BigInt(o) << BigInt(32));
    });
    h.prototype.readBigUInt64BE = g(function(r) {
      r = r >>> 0, R(r, "offset");
      let t = this[r], n = this[r + 7];
      (t === undefined || n === undefined) && C(r, this.length - 8);
      let e = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], o = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n;
      return (BigInt(e) << BigInt(32)) + BigInt(o);
    });
    h.prototype.readIntLE = function(r, t, n) {
      r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
      let e = this[r], o = 1, u = 0;
      for (;++u < t && (o *= 256); )
        e += this[r + u] * o;
      return o *= 128, e >= o && (e -= Math.pow(2, 8 * t)), e;
    };
    h.prototype.readIntBE = function(r, t, n) {
      r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
      let e = t, o = 1, u = this[r + --e];
      for (;e > 0 && (o *= 256); )
        u += this[r + --e] * o;
      return o *= 128, u >= o && (u -= Math.pow(2, 8 * t)), u;
    };
    h.prototype.readInt8 = function(r, t) {
      return r = r >>> 0, t || a(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
    };
    h.prototype.readInt16LE = function(r, t) {
      r = r >>> 0, t || a(r, 2, this.length);
      let n = this[r] | this[r + 1] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt16BE = function(r, t) {
      r = r >>> 0, t || a(r, 2, this.length);
      let n = this[r + 1] | this[r] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    h.prototype.readInt32LE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
    };
    h.prototype.readInt32BE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
    };
    h.prototype.readBigInt64LE = g(function(r) {
      r = r >>> 0, R(r, "offset");
      let t = this[r], n = this[r + 7];
      (t === undefined || n === undefined) && C(r, this.length - 8);
      let e = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (n << 24);
      return (BigInt(e) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
    });
    h.prototype.readBigInt64BE = g(function(r) {
      r = r >>> 0, R(r, "offset");
      let t = this[r], n = this[r + 7];
      (t === undefined || n === undefined) && C(r, this.length - 8);
      let e = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
      return (BigInt(e) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n);
    });
    h.prototype.readFloatLE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), U.read(this, r, true, 23, 4);
    };
    h.prototype.readFloatBE = function(r, t) {
      return r = r >>> 0, t || a(r, 4, this.length), U.read(this, r, false, 23, 4);
    };
    h.prototype.readDoubleLE = function(r, t) {
      return r = r >>> 0, t || a(r, 8, this.length), U.read(this, r, true, 52, 8);
    };
    h.prototype.readDoubleBE = function(r, t) {
      return r = r >>> 0, t || a(r, 8, this.length), U.read(this, r, false, 52, 8);
    };
    function y(i, r, t, n, e, o) {
      if (!h.isBuffer(i))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (r > e || r < o)
        throw new RangeError('"value" argument is out of bounds');
      if (t + n > i.length)
        throw new RangeError("Index out of range");
    }
    h.prototype.writeUintLE = h.prototype.writeUIntLE = function(r, t, n, e) {
      if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
        let f = Math.pow(2, 8 * n) - 1;
        y(this, r, t, n, f, 0);
      }
      let o = 1, u = 0;
      for (this[t] = r & 255;++u < n && (o *= 256); )
        this[t + u] = r / o & 255;
      return t + n;
    };
    h.prototype.writeUintBE = h.prototype.writeUIntBE = function(r, t, n, e) {
      if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
        let f = Math.pow(2, 8 * n) - 1;
        y(this, r, t, n, f, 0);
      }
      let o = n - 1, u = 1;
      for (this[t + o] = r & 255;--o >= 0 && (u *= 256); )
        this[t + o] = r / u & 255;
      return t + n;
    };
    h.prototype.writeUint8 = h.prototype.writeUInt8 = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
    };
    h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
    };
    h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    function cr(i, r, t, n, e) {
      yr(r, n, e, i, t, 7);
      let o = Number(r & BigInt(4294967295));
      i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o;
      let u = Number(r >> BigInt(32) & BigInt(4294967295));
      return i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, t;
    }
    function pr(i, r, t, n, e) {
      yr(r, n, e, i, t, 7);
      let o = Number(r & BigInt(4294967295));
      i[t + 7] = o, o = o >> 8, i[t + 6] = o, o = o >> 8, i[t + 5] = o, o = o >> 8, i[t + 4] = o;
      let u = Number(r >> BigInt(32) & BigInt(4294967295));
      return i[t + 3] = u, u = u >> 8, i[t + 2] = u, u = u >> 8, i[t + 1] = u, u = u >> 8, i[t] = u, t + 8;
    }
    h.prototype.writeBigUInt64LE = g(function(r, t = 0) {
      return cr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeBigUInt64BE = g(function(r, t = 0) {
      return pr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeIntLE = function(r, t, n, e) {
      if (r = +r, t = t >>> 0, !e) {
        let c = Math.pow(2, 8 * n - 1);
        y(this, r, t, n, c - 1, -c);
      }
      let o = 0, u = 1, f = 0;
      for (this[t] = r & 255;++o < n && (u *= 256); )
        r < 0 && f === 0 && this[t + o - 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
      return t + n;
    };
    h.prototype.writeIntBE = function(r, t, n, e) {
      if (r = +r, t = t >>> 0, !e) {
        let c = Math.pow(2, 8 * n - 1);
        y(this, r, t, n, c - 1, -c);
      }
      let o = n - 1, u = 1, f = 0;
      for (this[t + o] = r & 255;--o >= 0 && (u *= 256); )
        r < 0 && f === 0 && this[t + o + 1] !== 0 && (f = 1), this[t + o] = (r / u >> 0) - f & 255;
      return t + n;
    };
    h.prototype.writeInt8 = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
    };
    h.prototype.writeInt16LE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h.prototype.writeInt16BE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h.prototype.writeInt32LE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
    };
    h.prototype.writeInt32BE = function(r, t, n) {
      return r = +r, t = t >>> 0, n || y(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    h.prototype.writeBigInt64LE = g(function(r, t = 0) {
      return cr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h.prototype.writeBigInt64BE = g(function(r, t = 0) {
      return pr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function sr(i, r, t, n, e, o) {
      if (t + n > i.length)
        throw new RangeError("Index out of range");
      if (t < 0)
        throw new RangeError("Index out of range");
    }
    function lr(i, r, t, n, e) {
      return r = +r, t = t >>> 0, e || sr(i, r, t, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), U.write(i, r, t, n, 23, 4), t + 4;
    }
    h.prototype.writeFloatLE = function(r, t, n) {
      return lr(this, r, t, true, n);
    };
    h.prototype.writeFloatBE = function(r, t, n) {
      return lr(this, r, t, false, n);
    };
    function ar(i, r, t, n, e) {
      return r = +r, t = t >>> 0, e || sr(i, r, t, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), U.write(i, r, t, n, 52, 8), t + 8;
    }
    h.prototype.writeDoubleLE = function(r, t, n) {
      return ar(this, r, t, true, n);
    };
    h.prototype.writeDoubleBE = function(r, t, n) {
      return ar(this, r, t, false, n);
    };
    h.prototype.copy = function(r, t, n, e) {
      if (!h.isBuffer(r))
        throw new TypeError("argument should be a Buffer");
      if (n || (n = 0), !e && e !== 0 && (e = this.length), t >= r.length && (t = r.length), t || (t = 0), e > 0 && e < n && (e = n), e === n || r.length === 0 || this.length === 0)
        return 0;
      if (t < 0)
        throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length)
        throw new RangeError("Index out of range");
      if (e < 0)
        throw new RangeError("sourceEnd out of bounds");
      e > this.length && (e = this.length), r.length - t < e - n && (e = r.length - t + n);
      let o = e - n;
      return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, e) : Uint8Array.prototype.set.call(r, this.subarray(n, e), t), o;
    };
    h.prototype.fill = function(r, t, n, e) {
      if (typeof r == "string") {
        if (typeof t == "string" ? (e = t, t = 0, n = this.length) : typeof n == "string" && (e = n, n = this.length), e !== undefined && typeof e != "string")
          throw new TypeError("encoding must be a string");
        if (typeof e == "string" && !h.isEncoding(e))
          throw new TypeError("Unknown encoding: " + e);
        if (r.length === 1) {
          let u = r.charCodeAt(0);
          (e === "utf8" && u < 128 || e === "latin1") && (r = u);
        }
      } else
        typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
      if (t < 0 || this.length < t || this.length < n)
        throw new RangeError("Out of range index");
      if (n <= t)
        return this;
      t = t >>> 0, n = n === undefined ? this.length : n >>> 0, r || (r = 0);
      let o;
      if (typeof r == "number")
        for (o = t;o < n; ++o)
          this[o] = r;
      else {
        let u = h.isBuffer(r) ? r : h.from(r, e), f = u.length;
        if (f === 0)
          throw new TypeError('The value "' + r + '" is invalid for argument "value"');
        for (o = 0;o < n - t; ++o)
          this[o + t] = u[o % f];
      }
      return this;
    };
    var A = {};
    function V(i, r, t) {
      A[i] = class extends t {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: r.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
        }
        get code() {
          return i;
        }
        set code(e) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e, writable: true });
        }
        toString() {
          return `${this.name} [${i}]: ${this.message}`;
        }
      };
    }
    V("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
      return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    V("ERR_INVALID_ARG_TYPE", function(i, r) {
      return `The "${i}" argument must be of type number. Received type ${typeof r}`;
    }, TypeError);
    V("ERR_OUT_OF_RANGE", function(i, r, t) {
      let n = `The value of "${i}" is out of range.`, e = t;
      return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? e = nr(String(t)) : typeof t == "bigint" && (e = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (e = nr(e)), e += "n"), n += ` It must be ${r}. Received ${e}`, n;
    }, RangeError);
    function nr(i) {
      let r = "", t = i.length, n = i[0] === "-" ? 1 : 0;
      for (;t >= n + 4; t -= 3)
        r = `_${i.slice(t - 3, t)}${r}`;
      return `${i.slice(0, t)}${r}`;
    }
    function Jr(i, r, t) {
      R(r, "offset"), (i[r] === undefined || i[r + t] === undefined) && C(r, i.length - (t + 1));
    }
    function yr(i, r, t, n, e, o) {
      if (i > t || i < r) {
        let u = typeof r == "bigint" ? "n" : "", f;
        throw o > 3 ? r === 0 || r === BigInt(0) ? f = `>= 0${u} and < 2${u} ** ${(o + 1) * 8}${u}` : f = `>= -(2${u} ** ${(o + 1) * 8 - 1}${u}) and < 2 ** ${(o + 1) * 8 - 1}${u}` : f = `>= ${r}${u} and <= ${t}${u}`, new A.ERR_OUT_OF_RANGE("value", f, i);
      }
      Jr(n, e, o);
    }
    function R(i, r) {
      if (typeof i != "number")
        throw new A.ERR_INVALID_ARG_TYPE(r, "number", i);
    }
    function C(i, r, t) {
      throw Math.floor(i) !== i ? (R(i, t), new A.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r < 0 ? new A.ERR_BUFFER_OUT_OF_BOUNDS : new A.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${r}`, i);
    }
    var Kr = /[^+/0-9A-Za-z-_]/g;
    function Zr(i) {
      if (i = i.split("=")[0], i = i.trim().replace(Kr, ""), i.length < 2)
        return "";
      for (;i.length % 4 !== 0; )
        i = i + "=";
      return i;
    }
    function W(i, r) {
      r = r || 1 / 0;
      let t, n = i.length, e = null, o = [];
      for (let u = 0;u < n; ++u) {
        if (t = i.charCodeAt(u), t > 55295 && t < 57344) {
          if (!e) {
            if (t > 56319) {
              (r -= 3) > -1 && o.push(239, 191, 189);
              continue;
            } else if (u + 1 === n) {
              (r -= 3) > -1 && o.push(239, 191, 189);
              continue;
            }
            e = t;
            continue;
          }
          if (t < 56320) {
            (r -= 3) > -1 && o.push(239, 191, 189), e = t;
            continue;
          }
          t = (e - 55296 << 10 | t - 56320) + 65536;
        } else
          e && (r -= 3) > -1 && o.push(239, 191, 189);
        if (e = null, t < 128) {
          if ((r -= 1) < 0)
            break;
          o.push(t);
        } else if (t < 2048) {
          if ((r -= 2) < 0)
            break;
          o.push(t >> 6 | 192, t & 63 | 128);
        } else if (t < 65536) {
          if ((r -= 3) < 0)
            break;
          o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
        } else if (t < 1114112) {
          if ((r -= 4) < 0)
            break;
          o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o;
    }
    function Qr(i) {
      let r = [];
      for (let t = 0;t < i.length; ++t)
        r.push(i.charCodeAt(t) & 255);
      return r;
    }
    function vr(i, r) {
      let t, n, e, o = [];
      for (let u = 0;u < i.length && !((r -= 2) < 0); ++u)
        t = i.charCodeAt(u), n = t >> 8, e = t % 256, o.push(e), o.push(n);
      return o;
    }
    function wr(i) {
      return G.toByteArray(Zr(i));
    }
    function M(i, r, t, n) {
      let e;
      for (e = 0;e < n && !(e + t >= r.length || e >= i.length); ++e)
        r[e + t] = i[e];
      return e;
    }
    function E(i, r) {
      return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
    }
    function X(i) {
      return i !== i;
    }
    var rt = function() {
      let i = "0123456789abcdef", r = new Array(256);
      for (let t = 0;t < 16; ++t) {
        let n = t * 16;
        for (let e = 0;e < 16; ++e)
          r[n + e] = i[t] + i[e];
      }
      return r;
    }();
    function g(i) {
      return typeof BigInt > "u" ? tt : i;
    }
    function tt() {
      throw new Error("BigInt not supported");
    }
  });
  S = {};
  Fr(S, { default: () => xr.Buffer });
  _(S, J(z()));
  xr = J(z());
  export_default = xr.Buffer;
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS((exports, module) => {
  (function(module2, exports2) {
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor;
      ctor.prototype.constructor = ctor;
    }
    function BN(number, base, endian) {
      if (BN.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base === "le" || base === "be") {
          endian = base;
          base = 10;
        }
        this._init(number || 0, base || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN;
    } else {
      exports2.BN = BN;
    }
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
      }
    } catch (e) {
    }
    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN.prototype._init = function init(number, base, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base, endian);
      }
      if (base === "hex") {
        base = 16;
      }
      assert(base === (base | 0) && base >= 2 && base <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;
      if (number[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number.length) {
        if (base === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base, endian);
          }
        }
      }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
      assert(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i = number.length - 1, j = 0;i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0;i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string, index) {
      var c = string.charCodeAt(index);
      if (c >= 48 && c <= 57) {
        return c - 48;
      } else if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        assert(false, "Invalid character in " + string);
      }
    }
    function parseHexByte(string, lowerBound, index) {
      var r = parseHex4Bits(string, index);
      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }
      return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i = number.length - 1;i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start;i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str, start, end, mul) {
      var r = 0;
      var b2 = 0;
      var len = Math.min(str.length, end);
      for (var i = start;i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul;
        if (c >= 49) {
          b2 = c - 49 + 10;
        } else if (c >= 17) {
          b2 = c - 17 + 10;
        } else {
          b2 = c;
        }
        assert(c >= 0 && b2 < mul, "Invalid character");
        r += b2;
      }
      return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start;i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);
        for (i = 0;i < mod; i++) {
          pow *= base;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this._strip();
    };
    BN.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src) {
      dest.words = src.words;
      dest.length = src.length;
      dest.negative = src.negative;
      dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };
    BN.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
      } catch (e) {
        BN.prototype.inspect = inspect;
      }
    } else {
      BN.prototype.inspect = inspect;
    }
    function inspect() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64000000,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      24300000,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
      var out;
      if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0;i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base === (base | 0) && base >= 2 && base <= 36) {
        var groupSize = groupSizes[base];
        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modrn(groupBase).toString(base);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer2, endian, length);
      };
    }
    BN.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
      }
      return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert(byteLength <= reqLength, "byte array longer than desired length");
      assert(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength);
      return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
      var position = 0;
      var carry = 0;
      for (var i = 0, shift = 0;i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
          res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
      var position = res.length - 1;
      var carry = 0;
      for (var i = 0, shift = 0;i < this.length; i++) {
        var word = this.words[i] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
          res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r = 0;
      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r++;
      }
      return r;
    };
    BN.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0;bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 1;
      }
      return w;
    }
    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r = 0;
      for (var i = 0;i < this.length; i++) {
        var b2 = this._zeroBits(this.words[i]);
        r += b2;
        if (b2 !== 26)
          break;
      }
      return r;
    };
    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0;i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this._strip();
    };
    BN.prototype.ior = function ior(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i = 0;i < b2.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b2.length;
      return this._strip();
    };
    BN.prototype.iand = function iand(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN.prototype.iuxor = function iuxor(num) {
      var a;
      var b2;
      if (this.length > num.length) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      for (var i = 0;i < b2.length; i++) {
        this.words[i] = a.words[i] ^ b2.words[i];
      }
      if (this !== a) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN.prototype.inotn = function inotn(width) {
      assert(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0;i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN.prototype.setn = function setn(bit, val) {
      assert(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN.prototype.iadd = function iadd(num) {
      var r;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }
      var a, b2;
      if (this.length > num.length) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0;i < b2.length; i++) {
        r = (a.words[i] | 0) + (b2.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      for (;carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN.prototype.add = function add(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b2;
      if (cmp > 0) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0;i < b2.length; i++) {
        r = (a.words[i] | 0) - (b2.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      for (;carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r = a * b2;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1;k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i = k - j | 0;
          a = self2.words[i] | 0;
          b2 = num.words[j] | 0;
          r = a * b2 + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo(self2, num, out) {
      var a = self2.words;
      var b2 = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0;k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i = k - j;
          var a = self2.words[i] | 0;
          var b2 = num.words[j] | 0;
          var r = a * b2;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x, y) {
      this.x = x;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;
      for (var i = 0;i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1)
        return x;
      var rb = 0;
      for (var i = 0;i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0;i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);
      for (var s = 1;s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for (var p = 0;p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j = 0;j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;
      for (N = N / 2 | 0;N; N = N >>> 1) {
        i++;
      }
      return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1)
        return;
      for (var i = 0;i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;
      for (var i = 0;i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 67108863;
        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;
      for (var i = 0;i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i = 2 * len;i < N; ++i) {
        rws[i] = 0;
      }
      assert(carry === 0);
      assert((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);
      for (var i = 0;i < N; i++) {
        ph[i] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);
      var _2 = this.stub(N);
      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _2, rwst, iwst, N, rbt);
      this.transform(nrws, _2, nrwst, niwst, N, rbt);
      for (var i = 0;i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }
      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _2, N, rbt);
      this.conjugate(rmws, _2, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out._strip();
    };
    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert(typeof num === "number");
      assert(num < 67108864);
      var carry = 0;
      for (var i = 0;i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0)
        return new BN(1);
      var res = this;
      for (var i = 0;i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0)
          break;
      }
      if (++i < w.length) {
        for (var q = res.sqr();i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN.prototype.iushln = function iushln(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i;
      if (r !== 0) {
        var carry = 0;
        for (i = 0;i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i = this.length - 1;i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }
        for (i = 0;i < s; i++) {
          this.words[i] = 0;
        }
        this.length += s;
      }
      return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
      assert(this.negative === 0);
      return this.iushln(bits);
    };
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0;i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
      }
      if (s === 0) {
      } else if (this.length > s) {
        this.length -= s;
        for (i = 0;i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1;i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN.prototype.testn = function testn(bit) {
      assert(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s)
        return false;
      var w = this.words[s];
      return !!(w & q);
    };
    BN.prototype.imaskn = function imaskn(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s) {
        return this;
      }
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask = 67108863 ^ 67108863 >>> r << r;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN.prototype.iaddn = function iaddn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0;i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN.prototype.isubn = function isubn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0;i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0;i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (;i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert(carry === -1);
      carry = 0;
      for (i = 0;i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m = a.length - b2.length;
      var q;
      if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0;i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b2, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1;j >= 0; j--) {
        var qj = (a.words[b2.length + j] | 0) * 67108864 + (a.words[b2.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b2, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b2, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q._strip();
      }
      a._strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN(1);
      var B = new BN(0);
      var C = new BN(0);
      var D2 = new BN(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1;(x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D2.isOdd()) {
              C.iadd(yp);
              D2.isub(xp);
            }
            C.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D2);
        } else {
          y.isub(x);
          C.isub(A);
          D2.isub(B);
        }
      }
      return {
        a: C,
        b: D2,
        gcd: y.iushln(g)
      };
    };
    BN.prototype._invmp = function _invmp(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var a = this;
      var b2 = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b2.clone();
      while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i = 0, im = 1;(a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b2.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b2) >= 0) {
          a.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b2 = num.clone();
      a.negative = 0;
      b2.negative = 0;
      for (var shift = 0;a.isEven() && b2.isEven(); shift++) {
        a.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r = a.cmp(b2);
        if (r < 0) {
          var t = a;
          a = b2;
          b2 = t;
        } else if (r === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN.prototype.bincn = function bincn(bit) {
      assert(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }
      var carry = q;
      for (var i = s;carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        var a = this.words[i] | 0;
        var b2 = num.words[i] | 0;
        if (a === b2)
          continue;
        if (a < b2) {
          res = -1;
        } else if (a > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };
    BN.red = function red(num) {
      return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
      assert(!this.red, "Already a number in reduction context");
      assert(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
      assert(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
      assert(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
      assert(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
      assert(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
      assert(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
      assert(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
      assert(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
      assert(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
      assert(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
      assert(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
      assert(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN.prototype.redSqrt = function redSqrt() {
      assert(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
      assert(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN.prototype.redNeg = function redNeg() {
      assert(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
      assert(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p) {
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== undefined) {
          r.strip();
        } else {
          r._strip();
        }
      }
      return r;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0;i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i = 10;i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0;i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0;i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime;
      if (name === "k256") {
        prime = new K256;
      } else if (name === "p224") {
        prime = new P224;
      } else if (name === "p192") {
        prime = new P192;
      } else if (name === "p25519") {
        prime = new P25519;
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime;
      return prime;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert(a.negative === 0, "red works only with positives");
      assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b2) {
      assert((a.negative | b2.negative) === 0, "red works only with positives");
      assert(a.red && a.red === b2.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      move(a, a.umod(this.m)._forceRed(this));
      return a;
    };
    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b2) {
      this._verify2(a, b2);
      var res = a.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b2) {
      this._verify2(a, b2);
      var res = a.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b2) {
      this._verify2(a, b2);
      var res = a.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b2) {
      this._verify2(a, b2);
      var res = a.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b2) {
      this._verify2(a, b2);
      return this.imod(a.imul(b2));
    };
    Red.prototype.mul = function mul(a, b2) {
      this._verify2(a, b2);
      return this.imod(a.mul(b2));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert(!q.isZero());
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c = this.pow(z2, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0;tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert(i < m);
        var b2 = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b2);
        c = b2.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this);
      wnd[1] = a;
      for (var i = 2;i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1;i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1;j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul(a, b2) {
      if (a.isZero() || b2.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b2);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b2) {
      if (a.isZero() || b2.isZero())
        return new BN(0)._forceRed(this);
      var t = a.mul(b2);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(typeof module === "undefined" || module, exports);
});

// node_modules/@ethersproject/logger/lib/_version.js
var require__version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "logger/5.7.0";
});

// node_modules/@ethersproject/logger/lib/index.js
var require_lib = __commonJS((exports) => {
  var _checkNormalize = function() {
    try {
      var missing_1 = [];
      ["NFD", "NFC", "NFKD", "NFKC"].forEach(function(form) {
        try {
          if ("test".normalize(form) !== "test") {
            throw new Error("bad normalize");
          }
        } catch (error) {
          missing_1.push(form);
        }
      });
      if (missing_1.length) {
        throw new Error("missing " + missing_1.join(", "));
      }
      if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
        throw new Error("broken implementation");
      }
    } catch (error) {
      return error.message;
    }
    return null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Logger = exports.ErrorCode = exports.LogLevel = undefined;
  var _permanentCensorErrors = false;
  var _censorErrors = false;
  var LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
  var _logLevel = LogLevels["default"];
  var _version_1 = require__version();
  var _globalLogger = null;
  var _normalizeError = _checkNormalize();
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2["DEBUG"] = "DEBUG";
    LogLevel2["INFO"] = "INFO";
    LogLevel2["WARNING"] = "WARNING";
    LogLevel2["ERROR"] = "ERROR";
    LogLevel2["OFF"] = "OFF";
  })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
    ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
    ErrorCode2["TIMEOUT"] = "TIMEOUT";
    ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
    ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
  })(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
  var HEX = "0123456789abcdef";
  var Logger = function() {
    function Logger2(version) {
      Object.defineProperty(this, "version", {
        enumerable: true,
        value: version,
        writable: false
      });
    }
    Logger2.prototype._log = function(logLevel, args) {
      var level = logLevel.toLowerCase();
      if (LogLevels[level] == null) {
        this.throwArgumentError("invalid log level name", "logLevel", logLevel);
      }
      if (_logLevel > LogLevels[level]) {
        return;
      }
      console.log.apply(console, args);
    };
    Logger2.prototype.debug = function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      this._log(Logger2.levels.DEBUG, args);
    };
    Logger2.prototype.info = function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      this._log(Logger2.levels.INFO, args);
    };
    Logger2.prototype.warn = function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      this._log(Logger2.levels.WARNING, args);
    };
    Logger2.prototype.makeError = function(message, code, params) {
      if (_censorErrors) {
        return this.makeError("censored error", code, {});
      }
      if (!code) {
        code = Logger2.errors.UNKNOWN_ERROR;
      }
      if (!params) {
        params = {};
      }
      var messageDetails = [];
      Object.keys(params).forEach(function(key) {
        var value = params[key];
        try {
          if (value instanceof Uint8Array) {
            var hex = "";
            for (var i = 0;i < value.length; i++) {
              hex += HEX[value[i] >> 4];
              hex += HEX[value[i] & 15];
            }
            messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
          } else {
            messageDetails.push(key + "=" + JSON.stringify(value));
          }
        } catch (error2) {
          messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
        }
      });
      messageDetails.push("code=" + code);
      messageDetails.push("version=" + this.version);
      var reason = message;
      var url = "";
      switch (code) {
        case ErrorCode.NUMERIC_FAULT: {
          url = "NUMERIC_FAULT";
          var fault = message;
          switch (fault) {
            case "overflow":
            case "underflow":
            case "division-by-zero":
              url += "-" + fault;
              break;
            case "negative-power":
            case "negative-width":
              url += "-unsupported";
              break;
            case "unbound-bitwise-result":
              url += "-unbound-result";
              break;
          }
          break;
        }
        case ErrorCode.CALL_EXCEPTION:
        case ErrorCode.INSUFFICIENT_FUNDS:
        case ErrorCode.MISSING_NEW:
        case ErrorCode.NONCE_EXPIRED:
        case ErrorCode.REPLACEMENT_UNDERPRICED:
        case ErrorCode.TRANSACTION_REPLACED:
        case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
          url = code;
          break;
      }
      if (url) {
        message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
      }
      if (messageDetails.length) {
        message += " (" + messageDetails.join(", ") + ")";
      }
      var error = new Error(message);
      error.reason = reason;
      error.code = code;
      Object.keys(params).forEach(function(key) {
        error[key] = params[key];
      });
      return error;
    };
    Logger2.prototype.throwError = function(message, code, params) {
      throw this.makeError(message, code, params);
    };
    Logger2.prototype.throwArgumentError = function(message, name, value) {
      return this.throwError(message, Logger2.errors.INVALID_ARGUMENT, {
        argument: name,
        value
      });
    };
    Logger2.prototype.assert = function(condition, message, code, params) {
      if (!!condition) {
        return;
      }
      this.throwError(message, code, params);
    };
    Logger2.prototype.assertArgument = function(condition, message, name, value) {
      if (!!condition) {
        return;
      }
      this.throwArgumentError(message, name, value);
    };
    Logger2.prototype.checkNormalize = function(message) {
      if (message == null) {
        message = "platform missing String.prototype.normalize";
      }
      if (_normalizeError) {
        this.throwError("platform missing String.prototype.normalize", Logger2.errors.UNSUPPORTED_OPERATION, {
          operation: "String.prototype.normalize",
          form: _normalizeError
        });
      }
    };
    Logger2.prototype.checkSafeUint53 = function(value, message) {
      if (typeof value !== "number") {
        return;
      }
      if (message == null) {
        message = "value not safe";
      }
      if (value < 0 || value >= 9007199254740991) {
        this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "out-of-safe-range",
          value
        });
      }
      if (value % 1) {
        this.throwError(message, Logger2.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "non-integer",
          value
        });
      }
    };
    Logger2.prototype.checkArgumentCount = function(count, expectedCount, message) {
      if (message) {
        message = ": " + message;
      } else {
        message = "";
      }
      if (count < expectedCount) {
        this.throwError("missing argument" + message, Logger2.errors.MISSING_ARGUMENT, {
          count,
          expectedCount
        });
      }
      if (count > expectedCount) {
        this.throwError("too many arguments" + message, Logger2.errors.UNEXPECTED_ARGUMENT, {
          count,
          expectedCount
        });
      }
    };
    Logger2.prototype.checkNew = function(target, kind) {
      if (target === Object || target == null) {
        this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
      }
    };
    Logger2.prototype.checkAbstract = function(target, kind) {
      if (target === kind) {
        this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger2.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
      } else if (target === Object || target == null) {
        this.throwError("missing new", Logger2.errors.MISSING_NEW, { name: kind.name });
      }
    };
    Logger2.globalLogger = function() {
      if (!_globalLogger) {
        _globalLogger = new Logger2(_version_1.version);
      }
      return _globalLogger;
    };
    Logger2.setCensorship = function(censorship, permanent) {
      if (!censorship && permanent) {
        this.globalLogger().throwError("cannot permanently disable censorship", Logger2.errors.UNSUPPORTED_OPERATION, {
          operation: "setCensorship"
        });
      }
      if (_permanentCensorErrors) {
        if (!censorship) {
          return;
        }
        this.globalLogger().throwError("error censorship permanent", Logger2.errors.UNSUPPORTED_OPERATION, {
          operation: "setCensorship"
        });
      }
      _censorErrors = !!censorship;
      _permanentCensorErrors = !!permanent;
    };
    Logger2.setLogLevel = function(logLevel) {
      var level = LogLevels[logLevel.toLowerCase()];
      if (level == null) {
        Logger2.globalLogger().warn("invalid log level - " + logLevel);
        return;
      }
      _logLevel = level;
    };
    Logger2.from = function(version) {
      return new Logger2(version);
    };
    Logger2.errors = ErrorCode;
    Logger2.levels = LogLevel;
    return Logger2;
  }();
  exports.Logger = Logger;
});

// node_modules/@ethersproject/bytes/lib/_version.js
var require__version2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "bytes/5.7.0";
});

// node_modules/@ethersproject/bytes/lib/index.js
var require_lib2 = __commonJS((exports) => {
  var isHexable = function(value) {
    return !!value.toHexString;
  };
  var addSlice = function(array) {
    if (array.slice) {
      return array;
    }
    array.slice = function() {
      var args = Array.prototype.slice.call(arguments);
      return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
  };
  var isBytesLike = function(value) {
    return isHexString(value) && !(value.length % 2) || isBytes(value);
  };
  var isInteger = function(value) {
    return typeof value === "number" && value == value && value % 1 === 0;
  };
  var isBytes = function(value) {
    if (value == null) {
      return false;
    }
    if (value.constructor === Uint8Array) {
      return true;
    }
    if (typeof value === "string") {
      return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
      return false;
    }
    for (var i = 0;i < value.length; i++) {
      var v2 = value[i];
      if (!isInteger(v2) || v2 < 0 || v2 >= 256) {
        return false;
      }
    }
    return true;
  };
  var arrayify = function(value, options) {
    if (!options) {
      options = {};
    }
    if (typeof value === "number") {
      logger.checkSafeUint53(value, "invalid arrayify value");
      var result = [];
      while (value) {
        result.unshift(value & 255);
        value = parseInt(String(value / 256));
      }
      if (result.length === 0) {
        result.push(0);
      }
      return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
      value = "0x" + value;
    }
    if (isHexable(value)) {
      value = value.toHexString();
    }
    if (isHexString(value)) {
      var hex = value.substring(2);
      if (hex.length % 2) {
        if (options.hexPad === "left") {
          hex = "0" + hex;
        } else if (options.hexPad === "right") {
          hex += "0";
        } else {
          logger.throwArgumentError("hex data is odd-length", "value", value);
        }
      }
      var result = [];
      for (var i = 0;i < hex.length; i += 2) {
        result.push(parseInt(hex.substring(i, i + 2), 16));
      }
      return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) {
      return addSlice(new Uint8Array(value));
    }
    return logger.throwArgumentError("invalid arrayify value", "value", value);
  };
  var concat = function(items) {
    var objects = items.map(function(item) {
      return arrayify(item);
    });
    var length = objects.reduce(function(accum, item) {
      return accum + item.length;
    }, 0);
    var result = new Uint8Array(length);
    objects.reduce(function(offset, object) {
      result.set(object, offset);
      return offset + object.length;
    }, 0);
    return addSlice(result);
  };
  var stripZeros = function(value) {
    var result = arrayify(value);
    if (result.length === 0) {
      return result;
    }
    var start = 0;
    while (start < result.length && result[start] === 0) {
      start++;
    }
    if (start) {
      result = result.slice(start);
    }
    return result;
  };
  var zeroPad = function(value, length) {
    value = arrayify(value);
    if (value.length > length) {
      logger.throwArgumentError("value out of range", "value", arguments[0]);
    }
    var result = new Uint8Array(length);
    result.set(value, length - value.length);
    return addSlice(result);
  };
  var isHexString = function(value, length) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (length && value.length !== 2 + 2 * length) {
      return false;
    }
    return true;
  };
  var hexlify = function(value, options) {
    if (!options) {
      options = {};
    }
    if (typeof value === "number") {
      logger.checkSafeUint53(value, "invalid hexlify value");
      var hex = "";
      while (value) {
        hex = HexCharacters[value & 15] + hex;
        value = Math.floor(value / 16);
      }
      if (hex.length) {
        if (hex.length % 2) {
          hex = "0" + hex;
        }
        return "0x" + hex;
      }
      return "0x00";
    }
    if (typeof value === "bigint") {
      value = value.toString(16);
      if (value.length % 2) {
        return "0x0" + value;
      }
      return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
      value = "0x" + value;
    }
    if (isHexable(value)) {
      return value.toHexString();
    }
    if (isHexString(value)) {
      if (value.length % 2) {
        if (options.hexPad === "left") {
          value = "0x0" + value.substring(2);
        } else if (options.hexPad === "right") {
          value += "0";
        } else {
          logger.throwArgumentError("hex data is odd-length", "value", value);
        }
      }
      return value.toLowerCase();
    }
    if (isBytes(value)) {
      var result = "0x";
      for (var i = 0;i < value.length; i++) {
        var v2 = value[i];
        result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
      }
      return result;
    }
    return logger.throwArgumentError("invalid hexlify value", "value", value);
  };
  var hexDataLength = function(data) {
    if (typeof data !== "string") {
      data = hexlify(data);
    } else if (!isHexString(data) || data.length % 2) {
      return null;
    }
    return (data.length - 2) / 2;
  };
  var hexDataSlice = function(data, offset, endOffset) {
    if (typeof data !== "string") {
      data = hexlify(data);
    } else if (!isHexString(data) || data.length % 2) {
      logger.throwArgumentError("invalid hexData", "value", data);
    }
    offset = 2 + 2 * offset;
    if (endOffset != null) {
      return "0x" + data.substring(offset, 2 + 2 * endOffset);
    }
    return "0x" + data.substring(offset);
  };
  var hexConcat = function(items) {
    var result = "0x";
    items.forEach(function(item) {
      result += hexlify(item).substring(2);
    });
    return result;
  };
  var hexValue = function(value) {
    var trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
    if (trimmed === "0x") {
      return "0x0";
    }
    return trimmed;
  };
  var hexStripZeros = function(value) {
    if (typeof value !== "string") {
      value = hexlify(value);
    }
    if (!isHexString(value)) {
      logger.throwArgumentError("invalid hex string", "value", value);
    }
    value = value.substring(2);
    var offset = 0;
    while (offset < value.length && value[offset] === "0") {
      offset++;
    }
    return "0x" + value.substring(offset);
  };
  var hexZeroPad = function(value, length) {
    if (typeof value !== "string") {
      value = hexlify(value);
    } else if (!isHexString(value)) {
      logger.throwArgumentError("invalid hex string", "value", value);
    }
    if (value.length > 2 * length + 2) {
      logger.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value.length < 2 * length + 2) {
      value = "0x0" + value.substring(2);
    }
    return value;
  };
  var splitSignature = function(signature) {
    var result = {
      r: "0x",
      s: "0x",
      _vs: "0x",
      recoveryParam: 0,
      v: 0,
      yParityAndS: "0x",
      compact: "0x"
    };
    if (isBytesLike(signature)) {
      var bytes = arrayify(signature);
      if (bytes.length === 64) {
        result.v = 27 + (bytes[32] >> 7);
        bytes[32] &= 127;
        result.r = hexlify(bytes.slice(0, 32));
        result.s = hexlify(bytes.slice(32, 64));
      } else if (bytes.length === 65) {
        result.r = hexlify(bytes.slice(0, 32));
        result.s = hexlify(bytes.slice(32, 64));
        result.v = bytes[64];
      } else {
        logger.throwArgumentError("invalid signature string", "signature", signature);
      }
      if (result.v < 27) {
        if (result.v === 0 || result.v === 1) {
          result.v += 27;
        } else {
          logger.throwArgumentError("signature invalid v byte", "signature", signature);
        }
      }
      result.recoveryParam = 1 - result.v % 2;
      if (result.recoveryParam) {
        bytes[32] |= 128;
      }
      result._vs = hexlify(bytes.slice(32, 64));
    } else {
      result.r = signature.r;
      result.s = signature.s;
      result.v = signature.v;
      result.recoveryParam = signature.recoveryParam;
      result._vs = signature._vs;
      if (result._vs != null) {
        var vs_1 = zeroPad(arrayify(result._vs), 32);
        result._vs = hexlify(vs_1);
        var recoveryParam = vs_1[0] >= 128 ? 1 : 0;
        if (result.recoveryParam == null) {
          result.recoveryParam = recoveryParam;
        } else if (result.recoveryParam !== recoveryParam) {
          logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
        }
        vs_1[0] &= 127;
        var s = hexlify(vs_1);
        if (result.s == null) {
          result.s = s;
        } else if (result.s !== s) {
          logger.throwArgumentError("signature v mismatch _vs", "signature", signature);
        }
      }
      if (result.recoveryParam == null) {
        if (result.v == null) {
          logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
        } else if (result.v === 0 || result.v === 1) {
          result.recoveryParam = result.v;
        } else {
          result.recoveryParam = 1 - result.v % 2;
        }
      } else {
        if (result.v == null) {
          result.v = 27 + result.recoveryParam;
        } else {
          var recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
          if (result.recoveryParam !== recId) {
            logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
          }
        }
      }
      if (result.r == null || !isHexString(result.r)) {
        logger.throwArgumentError("signature missing or invalid r", "signature", signature);
      } else {
        result.r = hexZeroPad(result.r, 32);
      }
      if (result.s == null || !isHexString(result.s)) {
        logger.throwArgumentError("signature missing or invalid s", "signature", signature);
      } else {
        result.s = hexZeroPad(result.s, 32);
      }
      var vs = arrayify(result.s);
      if (vs[0] >= 128) {
        logger.throwArgumentError("signature s out of range", "signature", signature);
      }
      if (result.recoveryParam) {
        vs[0] |= 128;
      }
      var _vs = hexlify(vs);
      if (result._vs) {
        if (!isHexString(result._vs)) {
          logger.throwArgumentError("signature invalid _vs", "signature", signature);
        }
        result._vs = hexZeroPad(result._vs, 32);
      }
      if (result._vs == null) {
        result._vs = _vs;
      } else if (result._vs !== _vs) {
        logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
      }
    }
    result.yParityAndS = result._vs;
    result.compact = result.r + result.yParityAndS.substring(2);
    return result;
  };
  var joinSignature = function(signature) {
    signature = splitSignature(signature);
    return hexlify(concat([
      signature.r,
      signature.s,
      signature.recoveryParam ? "0x1c" : "0x1b"
    ]));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.joinSignature = exports.splitSignature = exports.hexZeroPad = exports.hexStripZeros = exports.hexValue = exports.hexConcat = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.isBytes = exports.isBytesLike = undefined;
  var logger_1 = require_lib();
  var _version_1 = require__version2();
  var logger = new logger_1.Logger(_version_1.version);
  exports.isBytesLike = isBytesLike;
  exports.isBytes = isBytes;
  exports.arrayify = arrayify;
  exports.concat = concat;
  exports.stripZeros = stripZeros;
  exports.zeroPad = zeroPad;
  exports.isHexString = isHexString;
  var HexCharacters = "0123456789abcdef";
  exports.hexlify = hexlify;
  exports.hexDataLength = hexDataLength;
  exports.hexDataSlice = hexDataSlice;
  exports.hexConcat = hexConcat;
  exports.hexValue = hexValue;
  exports.hexStripZeros = hexStripZeros;
  exports.hexZeroPad = hexZeroPad;
  exports.splitSignature = splitSignature;
  exports.joinSignature = joinSignature;
});

// node_modules/@ethersproject/bignumber/lib/_version.js
var require__version3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "bignumber/5.7.0";
});

// node_modules/@ethersproject/bignumber/lib/bignumber.js
var require_bignumber = __commonJS((exports) => {
  var isBigNumberish = function(value) {
    return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || (0, bytes_1.isHexString)(value) || typeof value === "bigint" || (0, bytes_1.isBytes)(value));
  };
  var toHex = function(value) {
    if (typeof value !== "string") {
      return toHex(value.toString(16));
    }
    if (value[0] === "-") {
      value = value.substring(1);
      if (value[0] === "-") {
        logger.throwArgumentError("invalid hex", "value", value);
      }
      value = toHex(value);
      if (value === "0x00") {
        return value;
      }
      return "-" + value;
    }
    if (value.substring(0, 2) !== "0x") {
      value = "0x" + value;
    }
    if (value === "0x") {
      return "0x00";
    }
    if (value.length % 2) {
      value = "0x0" + value.substring(2);
    }
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
      value = "0x" + value.substring(4);
    }
    return value;
  };
  var toBigNumber = function(value) {
    return BigNumber.from(toHex(value));
  };
  var toBN = function(value) {
    var hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") {
      return new BN("-" + hex.substring(3), 16);
    }
    return new BN(hex.substring(2), 16);
  };
  var throwFault = function(fault, operation, value) {
    var params = { fault, operation };
    if (value != null) {
      params.value = value;
    }
    return logger.throwError(fault, logger_1.Logger.errors.NUMERIC_FAULT, params);
  };
  var _base36To16 = function(value) {
    return new BN(value, 36).toString(16);
  };
  var _base16To36 = function(value) {
    return new BN(value, 16).toString(36);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._base16To36 = exports._base36To16 = exports.BigNumber = exports.isBigNumberish = undefined;
  var bn_js_1 = __importDefault(require_bn());
  var BN = bn_js_1.default.BN;
  var bytes_1 = require_lib2();
  var logger_1 = require_lib();
  var _version_1 = require__version3();
  var logger = new logger_1.Logger(_version_1.version);
  var _constructorGuard = {};
  var MAX_SAFE = 9007199254740991;
  exports.isBigNumberish = isBigNumberish;
  var _warnedToStringRadix = false;
  var BigNumber = function() {
    function BigNumber2(constructorGuard, hex) {
      if (constructorGuard !== _constructorGuard) {
        logger.throwError("cannot call constructor directly; use BigNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new (BigNumber)"
        });
      }
      this._hex = hex;
      this._isBigNumber = true;
      Object.freeze(this);
    }
    BigNumber2.prototype.fromTwos = function(value) {
      return toBigNumber(toBN(this).fromTwos(value));
    };
    BigNumber2.prototype.toTwos = function(value) {
      return toBigNumber(toBN(this).toTwos(value));
    };
    BigNumber2.prototype.abs = function() {
      if (this._hex[0] === "-") {
        return BigNumber2.from(this._hex.substring(1));
      }
      return this;
    };
    BigNumber2.prototype.add = function(other) {
      return toBigNumber(toBN(this).add(toBN(other)));
    };
    BigNumber2.prototype.sub = function(other) {
      return toBigNumber(toBN(this).sub(toBN(other)));
    };
    BigNumber2.prototype.div = function(other) {
      var o = BigNumber2.from(other);
      if (o.isZero()) {
        throwFault("division-by-zero", "div");
      }
      return toBigNumber(toBN(this).div(toBN(other)));
    };
    BigNumber2.prototype.mul = function(other) {
      return toBigNumber(toBN(this).mul(toBN(other)));
    };
    BigNumber2.prototype.mod = function(other) {
      var value = toBN(other);
      if (value.isNeg()) {
        throwFault("division-by-zero", "mod");
      }
      return toBigNumber(toBN(this).umod(value));
    };
    BigNumber2.prototype.pow = function(other) {
      var value = toBN(other);
      if (value.isNeg()) {
        throwFault("negative-power", "pow");
      }
      return toBigNumber(toBN(this).pow(value));
    };
    BigNumber2.prototype.and = function(other) {
      var value = toBN(other);
      if (this.isNegative() || value.isNeg()) {
        throwFault("unbound-bitwise-result", "and");
      }
      return toBigNumber(toBN(this).and(value));
    };
    BigNumber2.prototype.or = function(other) {
      var value = toBN(other);
      if (this.isNegative() || value.isNeg()) {
        throwFault("unbound-bitwise-result", "or");
      }
      return toBigNumber(toBN(this).or(value));
    };
    BigNumber2.prototype.xor = function(other) {
      var value = toBN(other);
      if (this.isNegative() || value.isNeg()) {
        throwFault("unbound-bitwise-result", "xor");
      }
      return toBigNumber(toBN(this).xor(value));
    };
    BigNumber2.prototype.mask = function(value) {
      if (this.isNegative() || value < 0) {
        throwFault("negative-width", "mask");
      }
      return toBigNumber(toBN(this).maskn(value));
    };
    BigNumber2.prototype.shl = function(value) {
      if (this.isNegative() || value < 0) {
        throwFault("negative-width", "shl");
      }
      return toBigNumber(toBN(this).shln(value));
    };
    BigNumber2.prototype.shr = function(value) {
      if (this.isNegative() || value < 0) {
        throwFault("negative-width", "shr");
      }
      return toBigNumber(toBN(this).shrn(value));
    };
    BigNumber2.prototype.eq = function(other) {
      return toBN(this).eq(toBN(other));
    };
    BigNumber2.prototype.lt = function(other) {
      return toBN(this).lt(toBN(other));
    };
    BigNumber2.prototype.lte = function(other) {
      return toBN(this).lte(toBN(other));
    };
    BigNumber2.prototype.gt = function(other) {
      return toBN(this).gt(toBN(other));
    };
    BigNumber2.prototype.gte = function(other) {
      return toBN(this).gte(toBN(other));
    };
    BigNumber2.prototype.isNegative = function() {
      return this._hex[0] === "-";
    };
    BigNumber2.prototype.isZero = function() {
      return toBN(this).isZero();
    };
    BigNumber2.prototype.toNumber = function() {
      try {
        return toBN(this).toNumber();
      } catch (error) {
        throwFault("overflow", "toNumber", this.toString());
      }
      return null;
    };
    BigNumber2.prototype.toBigInt = function() {
      try {
        return BigInt(this.toString());
      } catch (e) {
      }
      return logger.throwError("this platform does not support BigInt", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        value: this.toString()
      });
    };
    BigNumber2.prototype.toString = function() {
      if (arguments.length > 0) {
        if (arguments[0] === 10) {
          if (!_warnedToStringRadix) {
            _warnedToStringRadix = true;
            logger.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
          }
        } else if (arguments[0] === 16) {
          logger.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
        } else {
          logger.throwError("BigNumber.toString does not accept parameters", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
        }
      }
      return toBN(this).toString(10);
    };
    BigNumber2.prototype.toHexString = function() {
      return this._hex;
    };
    BigNumber2.prototype.toJSON = function(key) {
      return { type: "BigNumber", hex: this.toHexString() };
    };
    BigNumber2.from = function(value) {
      if (value instanceof BigNumber2) {
        return value;
      }
      if (typeof value === "string") {
        if (value.match(/^-?0x[0-9a-f]+$/i)) {
          return new BigNumber2(_constructorGuard, toHex(value));
        }
        if (value.match(/^-?[0-9]+$/)) {
          return new BigNumber2(_constructorGuard, toHex(new BN(value)));
        }
        return logger.throwArgumentError("invalid BigNumber string", "value", value);
      }
      if (typeof value === "number") {
        if (value % 1) {
          throwFault("underflow", "BigNumber.from", value);
        }
        if (value >= MAX_SAFE || value <= -MAX_SAFE) {
          throwFault("overflow", "BigNumber.from", value);
        }
        return BigNumber2.from(String(value));
      }
      var anyValue = value;
      if (typeof anyValue === "bigint") {
        return BigNumber2.from(anyValue.toString());
      }
      if ((0, bytes_1.isBytes)(anyValue)) {
        return BigNumber2.from((0, bytes_1.hexlify)(anyValue));
      }
      if (anyValue) {
        if (anyValue.toHexString) {
          var hex = anyValue.toHexString();
          if (typeof hex === "string") {
            return BigNumber2.from(hex);
          }
        } else {
          var hex = anyValue._hex;
          if (hex == null && anyValue.type === "BigNumber") {
            hex = anyValue.hex;
          }
          if (typeof hex === "string") {
            if ((0, bytes_1.isHexString)(hex) || hex[0] === "-" && (0, bytes_1.isHexString)(hex.substring(1))) {
              return BigNumber2.from(hex);
            }
          }
        }
      }
      return logger.throwArgumentError("invalid BigNumber value", "value", value);
    };
    BigNumber2.isBigNumber = function(value) {
      return !!(value && value._isBigNumber);
    };
    return BigNumber2;
  }();
  exports.BigNumber = BigNumber;
  exports._base36To16 = _base36To16;
  exports._base16To36 = _base16To36;
});

// node_modules/@ethersproject/bignumber/lib/fixednumber.js
var require_fixednumber = __commonJS((exports) => {
  var throwFault = function(message, fault, operation, value) {
    var params = { fault, operation };
    if (value !== undefined) {
      params.value = value;
    }
    return logger.throwError(message, logger_1.Logger.errors.NUMERIC_FAULT, params);
  };
  var getMultiplier = function(decimals) {
    if (typeof decimals !== "number") {
      try {
        decimals = bignumber_1.BigNumber.from(decimals).toNumber();
      } catch (e) {
      }
    }
    if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
      return "1" + zeros.substring(0, decimals);
    }
    return logger.throwArgumentError("invalid decimal size", "decimals", decimals);
  };
  var formatFixed = function(value, decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    var multiplier = getMultiplier(decimals);
    value = bignumber_1.BigNumber.from(value);
    var negative = value.lt(Zero);
    if (negative) {
      value = value.mul(NegativeOne);
    }
    var fraction = value.mod(multiplier).toString();
    while (fraction.length < multiplier.length - 1) {
      fraction = "0" + fraction;
    }
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    var whole = value.div(multiplier).toString();
    if (multiplier.length === 1) {
      value = whole;
    } else {
      value = whole + "." + fraction;
    }
    if (negative) {
      value = "-" + value;
    }
    return value;
  };
  var parseFixed = function(value, decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    var multiplier = getMultiplier(decimals);
    if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
      logger.throwArgumentError("invalid decimal value", "value", value);
    }
    var negative = value.substring(0, 1) === "-";
    if (negative) {
      value = value.substring(1);
    }
    if (value === ".") {
      logger.throwArgumentError("missing value", "value", value);
    }
    var comps = value.split(".");
    if (comps.length > 2) {
      logger.throwArgumentError("too many decimal points", "value", value);
    }
    var whole = comps[0], fraction = comps[1];
    if (!whole) {
      whole = "0";
    }
    if (!fraction) {
      fraction = "0";
    }
    while (fraction[fraction.length - 1] === "0") {
      fraction = fraction.substring(0, fraction.length - 1);
    }
    if (fraction.length > multiplier.length - 1) {
      throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
    }
    if (fraction === "") {
      fraction = "0";
    }
    while (fraction.length < multiplier.length - 1) {
      fraction += "0";
    }
    var wholeValue = bignumber_1.BigNumber.from(whole);
    var fractionValue = bignumber_1.BigNumber.from(fraction);
    var wei = wholeValue.mul(multiplier).add(fractionValue);
    if (negative) {
      wei = wei.mul(NegativeOne);
    }
    return wei;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FixedNumber = exports.FixedFormat = exports.parseFixed = exports.formatFixed = undefined;
  var bytes_1 = require_lib2();
  var logger_1 = require_lib();
  var _version_1 = require__version3();
  var logger = new logger_1.Logger(_version_1.version);
  var bignumber_1 = require_bignumber();
  var _constructorGuard = {};
  var Zero = bignumber_1.BigNumber.from(0);
  var NegativeOne = bignumber_1.BigNumber.from(-1);
  var zeros = "0";
  while (zeros.length < 256) {
    zeros += zeros;
  }
  exports.formatFixed = formatFixed;
  exports.parseFixed = parseFixed;
  var FixedFormat = function() {
    function FixedFormat2(constructorGuard, signed, width, decimals) {
      if (constructorGuard !== _constructorGuard) {
        logger.throwError("cannot use FixedFormat constructor; use FixedFormat.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new FixedFormat"
        });
      }
      this.signed = signed;
      this.width = width;
      this.decimals = decimals;
      this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
      this._multiplier = getMultiplier(decimals);
      Object.freeze(this);
    }
    FixedFormat2.from = function(value) {
      if (value instanceof FixedFormat2) {
        return value;
      }
      if (typeof value === "number") {
        value = "fixed128x" + value;
      }
      var signed = true;
      var width = 128;
      var decimals = 18;
      if (typeof value === "string") {
        if (value === "fixed") {
        } else if (value === "ufixed") {
          signed = false;
        } else {
          var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          if (!match) {
            logger.throwArgumentError("invalid fixed format", "format", value);
          }
          signed = match[1] !== "u";
          width = parseInt(match[2]);
          decimals = parseInt(match[3]);
        }
      } else if (value) {
        var check = function(key, type, defaultValue) {
          if (value[key] == null) {
            return defaultValue;
          }
          if (typeof value[key] !== type) {
            logger.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
          }
          return value[key];
        };
        signed = check("signed", "boolean", signed);
        width = check("width", "number", width);
        decimals = check("decimals", "number", decimals);
      }
      if (width % 8) {
        logger.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
      }
      if (decimals > 80) {
        logger.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
      }
      return new FixedFormat2(_constructorGuard, signed, width, decimals);
    };
    return FixedFormat2;
  }();
  exports.FixedFormat = FixedFormat;
  var FixedNumber = function() {
    function FixedNumber2(constructorGuard, hex, value, format) {
      if (constructorGuard !== _constructorGuard) {
        logger.throwError("cannot use FixedNumber constructor; use FixedNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new FixedFormat"
        });
      }
      this.format = format;
      this._hex = hex;
      this._value = value;
      this._isFixedNumber = true;
      Object.freeze(this);
    }
    FixedNumber2.prototype._checkFormat = function(other) {
      if (this.format.name !== other.format.name) {
        logger.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
      }
    };
    FixedNumber2.prototype.addUnsafe = function(other) {
      this._checkFormat(other);
      var a = parseFixed(this._value, this.format.decimals);
      var b2 = parseFixed(other._value, other.format.decimals);
      return FixedNumber2.fromValue(a.add(b2), this.format.decimals, this.format);
    };
    FixedNumber2.prototype.subUnsafe = function(other) {
      this._checkFormat(other);
      var a = parseFixed(this._value, this.format.decimals);
      var b2 = parseFixed(other._value, other.format.decimals);
      return FixedNumber2.fromValue(a.sub(b2), this.format.decimals, this.format);
    };
    FixedNumber2.prototype.mulUnsafe = function(other) {
      this._checkFormat(other);
      var a = parseFixed(this._value, this.format.decimals);
      var b2 = parseFixed(other._value, other.format.decimals);
      return FixedNumber2.fromValue(a.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
    };
    FixedNumber2.prototype.divUnsafe = function(other) {
      this._checkFormat(other);
      var a = parseFixed(this._value, this.format.decimals);
      var b2 = parseFixed(other._value, other.format.decimals);
      return FixedNumber2.fromValue(a.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
    };
    FixedNumber2.prototype.floor = function() {
      var comps = this.toString().split(".");
      if (comps.length === 1) {
        comps.push("0");
      }
      var result = FixedNumber2.from(comps[0], this.format);
      var hasFraction = !comps[1].match(/^(0*)$/);
      if (this.isNegative() && hasFraction) {
        result = result.subUnsafe(ONE.toFormat(result.format));
      }
      return result;
    };
    FixedNumber2.prototype.ceiling = function() {
      var comps = this.toString().split(".");
      if (comps.length === 1) {
        comps.push("0");
      }
      var result = FixedNumber2.from(comps[0], this.format);
      var hasFraction = !comps[1].match(/^(0*)$/);
      if (!this.isNegative() && hasFraction) {
        result = result.addUnsafe(ONE.toFormat(result.format));
      }
      return result;
    };
    FixedNumber2.prototype.round = function(decimals) {
      if (decimals == null) {
        decimals = 0;
      }
      var comps = this.toString().split(".");
      if (comps.length === 1) {
        comps.push("0");
      }
      if (decimals < 0 || decimals > 80 || decimals % 1) {
        logger.throwArgumentError("invalid decimal count", "decimals", decimals);
      }
      if (comps[1].length <= decimals) {
        return this;
      }
      var factor = FixedNumber2.from("1" + zeros.substring(0, decimals), this.format);
      var bump = BUMP.toFormat(this.format);
      return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
    };
    FixedNumber2.prototype.isZero = function() {
      return this._value === "0.0" || this._value === "0";
    };
    FixedNumber2.prototype.isNegative = function() {
      return this._value[0] === "-";
    };
    FixedNumber2.prototype.toString = function() {
      return this._value;
    };
    FixedNumber2.prototype.toHexString = function(width) {
      if (width == null) {
        return this._hex;
      }
      if (width % 8) {
        logger.throwArgumentError("invalid byte width", "width", width);
      }
      var hex = bignumber_1.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
      return (0, bytes_1.hexZeroPad)(hex, width / 8);
    };
    FixedNumber2.prototype.toUnsafeFloat = function() {
      return parseFloat(this.toString());
    };
    FixedNumber2.prototype.toFormat = function(format) {
      return FixedNumber2.fromString(this._value, format);
    };
    FixedNumber2.fromValue = function(value, decimals, format) {
      if (format == null && decimals != null && !(0, bignumber_1.isBigNumberish)(decimals)) {
        format = decimals;
        decimals = null;
      }
      if (decimals == null) {
        decimals = 0;
      }
      if (format == null) {
        format = "fixed";
      }
      return FixedNumber2.fromString(formatFixed(value, decimals), FixedFormat.from(format));
    };
    FixedNumber2.fromString = function(value, format) {
      if (format == null) {
        format = "fixed";
      }
      var fixedFormat = FixedFormat.from(format);
      var numeric = parseFixed(value, fixedFormat.decimals);
      if (!fixedFormat.signed && numeric.lt(Zero)) {
        throwFault("unsigned value cannot be negative", "overflow", "value", value);
      }
      var hex = null;
      if (fixedFormat.signed) {
        hex = numeric.toTwos(fixedFormat.width).toHexString();
      } else {
        hex = numeric.toHexString();
        hex = (0, bytes_1.hexZeroPad)(hex, fixedFormat.width / 8);
      }
      var decimal = formatFixed(numeric, fixedFormat.decimals);
      return new FixedNumber2(_constructorGuard, hex, decimal, fixedFormat);
    };
    FixedNumber2.fromBytes = function(value, format) {
      if (format == null) {
        format = "fixed";
      }
      var fixedFormat = FixedFormat.from(format);
      if ((0, bytes_1.arrayify)(value).length > fixedFormat.width / 8) {
        throw new Error("overflow");
      }
      var numeric = bignumber_1.BigNumber.from(value);
      if (fixedFormat.signed) {
        numeric = numeric.fromTwos(fixedFormat.width);
      }
      var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
      var decimal = formatFixed(numeric, fixedFormat.decimals);
      return new FixedNumber2(_constructorGuard, hex, decimal, fixedFormat);
    };
    FixedNumber2.from = function(value, format) {
      if (typeof value === "string") {
        return FixedNumber2.fromString(value, format);
      }
      if ((0, bytes_1.isBytes)(value)) {
        return FixedNumber2.fromBytes(value, format);
      }
      try {
        return FixedNumber2.fromValue(value, 0, format);
      } catch (error) {
        if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT) {
          throw error;
        }
      }
      return logger.throwArgumentError("invalid FixedNumber value", "value", value);
    };
    FixedNumber2.isFixedNumber = function(value) {
      return !!(value && value._isFixedNumber);
    };
    return FixedNumber2;
  }();
  exports.FixedNumber = FixedNumber;
  var ONE = FixedNumber.from(1);
  var BUMP = FixedNumber.from("0.5");
});

// node_modules/@ethersproject/bignumber/lib/index.js
var require_lib3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._base36To16 = exports._base16To36 = exports.parseFixed = exports.FixedNumber = exports.FixedFormat = exports.formatFixed = exports.BigNumber = undefined;
  var bignumber_1 = require_bignumber();
  Object.defineProperty(exports, "BigNumber", { enumerable: true, get: function() {
    return bignumber_1.BigNumber;
  } });
  var fixednumber_1 = require_fixednumber();
  Object.defineProperty(exports, "formatFixed", { enumerable: true, get: function() {
    return fixednumber_1.formatFixed;
  } });
  Object.defineProperty(exports, "FixedFormat", { enumerable: true, get: function() {
    return fixednumber_1.FixedFormat;
  } });
  Object.defineProperty(exports, "FixedNumber", { enumerable: true, get: function() {
    return fixednumber_1.FixedNumber;
  } });
  Object.defineProperty(exports, "parseFixed", { enumerable: true, get: function() {
    return fixednumber_1.parseFixed;
  } });
  var bignumber_2 = require_bignumber();
  Object.defineProperty(exports, "_base16To36", { enumerable: true, get: function() {
    return bignumber_2._base16To36;
  } });
  Object.defineProperty(exports, "_base36To16", { enumerable: true, get: function() {
    return bignumber_2._base36To16;
  } });
});

// node_modules/@ethersproject/properties/lib/_version.js
var require__version4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "properties/5.7.0";
});

// node_modules/@ethersproject/properties/lib/index.js
var require_lib4 = __commonJS((exports) => {
  var defineReadOnly = function(object, name, value) {
    Object.defineProperty(object, name, {
      enumerable: true,
      value,
      writable: false
    });
  };
  var getStatic = function(ctor, key) {
    for (var i = 0;i < 32; i++) {
      if (ctor[key]) {
        return ctor[key];
      }
      if (!ctor.prototype || typeof ctor.prototype !== "object") {
        break;
      }
      ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
  };
  var resolveProperties = function(object) {
    return __awaiter(this, undefined, undefined, function() {
      var promises, results;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            promises = Object.keys(object).map(function(key) {
              var value = object[key];
              return Promise.resolve(value).then(function(v2) {
                return { key, value: v2 };
              });
            });
            return [4, Promise.all(promises)];
          case 1:
            results = _a.sent();
            return [2, results.reduce(function(accum, result) {
              accum[result.key] = result.value;
              return accum;
            }, {})];
        }
      });
    });
  };
  var checkProperties = function(object, properties) {
    if (!object || typeof object !== "object") {
      logger.throwArgumentError("invalid object", "object", object);
    }
    Object.keys(object).forEach(function(key) {
      if (!properties[key]) {
        logger.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
      }
    });
  };
  var shallowCopy = function(object) {
    var result = {};
    for (var key in object) {
      result[key] = object[key];
    }
    return result;
  };
  var _isFrozen = function(object) {
    if (object === undefined || object === null || opaque[typeof object]) {
      return true;
    }
    if (Array.isArray(object) || typeof object === "object") {
      if (!Object.isFrozen(object)) {
        return false;
      }
      var keys = Object.keys(object);
      for (var i = 0;i < keys.length; i++) {
        var value = null;
        try {
          value = object[keys[i]];
        } catch (error) {
          continue;
        }
        if (!_isFrozen(value)) {
          return false;
        }
      }
      return true;
    }
    return logger.throwArgumentError("Cannot deepCopy " + typeof object, "object", object);
  };
  var _deepCopy = function(object) {
    if (_isFrozen(object)) {
      return object;
    }
    if (Array.isArray(object)) {
      return Object.freeze(object.map(function(item) {
        return deepCopy(item);
      }));
    }
    if (typeof object === "object") {
      var result = {};
      for (var key in object) {
        var value = object[key];
        if (value === undefined) {
          continue;
        }
        defineReadOnly(result, key, deepCopy(value));
      }
      return result;
    }
    return logger.throwArgumentError("Cannot deepCopy " + typeof object, "object", object);
  };
  var deepCopy = function(object) {
    return _deepCopy(object);
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v2) {
        return step([n, v2]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t[1]) {
                _2.label = t[1];
                t = op;
                break;
              }
              if (t && _2.label < t[2]) {
                _2.label = t[2];
                _2.ops.push(op);
                break;
              }
              if (t[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Description = exports.deepCopy = exports.shallowCopy = exports.checkProperties = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = undefined;
  var logger_1 = require_lib();
  var _version_1 = require__version4();
  var logger = new logger_1.Logger(_version_1.version);
  exports.defineReadOnly = defineReadOnly;
  exports.getStatic = getStatic;
  exports.resolveProperties = resolveProperties;
  exports.checkProperties = checkProperties;
  exports.shallowCopy = shallowCopy;
  var opaque = { bigint: true, boolean: true, function: true, number: true, string: true };
  exports.deepCopy = deepCopy;
  var Description = function() {
    function Description2(info) {
      for (var key in info) {
        this[key] = deepCopy(info[key]);
      }
    }
    return Description2;
  }();
  exports.Description = Description;
});

// node_modules/@ethersproject/abi/lib/_version.js
var require__version5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "abi/5.7.0";
});

// node_modules/@ethersproject/abi/lib/fragments.js
var require_fragments = __commonJS((exports) => {
  var checkModifier = function(type, name) {
    if (type === "bytes" || type === "string") {
      if (ModifiersBytes[name]) {
        return true;
      }
    } else if (type === "address") {
      if (name === "payable") {
        return true;
      }
    } else if (type.indexOf("[") >= 0 || type === "tuple") {
      if (ModifiersNest[name]) {
        return true;
      }
    }
    if (ModifiersBytes[name] || name === "payable") {
      logger.throwArgumentError("invalid modifier", "name", name);
    }
    return false;
  };
  var parseParamType = function(param, allowIndexed) {
    var originalParam = param;
    function throwError(i2) {
      logger.throwArgumentError("unexpected character at position " + i2, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent2) {
      var node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
      if (allowIndexed) {
        node2.indexed = false;
      }
      return node2;
    }
    var parent = { type: "", name: "", state: { allowType: true } };
    var node = parent;
    for (var i = 0;i < param.length; i++) {
      var c = param[i];
      switch (c) {
        case "(":
          if (node.state.allowType && node.type === "") {
            node.type = "tuple";
          } else if (!node.state.allowParams) {
            throwError(i);
          }
          node.state.allowType = false;
          node.type = verifyType(node.type);
          node.components = [newNode(node)];
          node = node.components[0];
          break;
        case ")":
          delete node.state;
          if (node.name === "indexed") {
            if (!allowIndexed) {
              throwError(i);
            }
            node.indexed = true;
            node.name = "";
          }
          if (checkModifier(node.type, node.name)) {
            node.name = "";
          }
          node.type = verifyType(node.type);
          var child = node;
          node = node.parent;
          if (!node) {
            throwError(i);
          }
          delete child.parent;
          node.state.allowParams = false;
          node.state.allowName = true;
          node.state.allowArray = true;
          break;
        case ",":
          delete node.state;
          if (node.name === "indexed") {
            if (!allowIndexed) {
              throwError(i);
            }
            node.indexed = true;
            node.name = "";
          }
          if (checkModifier(node.type, node.name)) {
            node.name = "";
          }
          node.type = verifyType(node.type);
          var sibling = newNode(node.parent);
          node.parent.components.push(sibling);
          delete node.parent;
          node = sibling;
          break;
        case " ":
          if (node.state.allowType) {
            if (node.type !== "") {
              node.type = verifyType(node.type);
              delete node.state.allowType;
              node.state.allowName = true;
              node.state.allowParams = true;
            }
          }
          if (node.state.allowName) {
            if (node.name !== "") {
              if (node.name === "indexed") {
                if (!allowIndexed) {
                  throwError(i);
                }
                if (node.indexed) {
                  throwError(i);
                }
                node.indexed = true;
                node.name = "";
              } else if (checkModifier(node.type, node.name)) {
                node.name = "";
              } else {
                node.state.allowName = false;
              }
            }
          }
          break;
        case "[":
          if (!node.state.allowArray) {
            throwError(i);
          }
          node.type += c;
          node.state.allowArray = false;
          node.state.allowName = false;
          node.state.readArray = true;
          break;
        case "]":
          if (!node.state.readArray) {
            throwError(i);
          }
          node.type += c;
          node.state.readArray = false;
          node.state.allowArray = true;
          node.state.allowName = true;
          break;
        default:
          if (node.state.allowType) {
            node.type += c;
            node.state.allowParams = true;
            node.state.allowArray = true;
          } else if (node.state.allowName) {
            node.name += c;
            delete node.state.allowArray;
          } else if (node.state.readArray) {
            node.type += c;
          } else {
            throwError(i);
          }
      }
    }
    if (node.parent) {
      logger.throwArgumentError("unexpected eof", "param", param);
    }
    delete parent.state;
    if (node.name === "indexed") {
      if (!allowIndexed) {
        throwError(originalParam.length - 7);
      }
      if (node.indexed) {
        throwError(originalParam.length - 7);
      }
      node.indexed = true;
      node.name = "";
    } else if (checkModifier(node.type, node.name)) {
      node.name = "";
    }
    parent.type = verifyType(parent.type);
    return parent;
  };
  var populate = function(object, params) {
    for (var key in params) {
      (0, properties_1.defineReadOnly)(object, key, params[key]);
    }
  };
  var parseParams = function(value, allowIndex) {
    return splitNesting(value).map(function(param) {
      return ParamType.fromString(param, allowIndex);
    });
  };
  var parseGas = function(value, params) {
    params.gas = null;
    var comps = value.split("@");
    if (comps.length !== 1) {
      if (comps.length > 2) {
        logger.throwArgumentError("invalid human-readable ABI signature", "value", value);
      }
      if (!comps[1].match(/^[0-9]+$/)) {
        logger.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
      }
      params.gas = bignumber_1.BigNumber.from(comps[1]);
      return comps[0];
    }
    return value;
  };
  var parseModifiers = function(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach(function(modifier) {
      switch (modifier.trim()) {
        case "constant":
          params.constant = true;
          break;
        case "payable":
          params.payable = true;
          params.stateMutability = "payable";
          break;
        case "nonpayable":
          params.payable = false;
          params.stateMutability = "nonpayable";
          break;
        case "pure":
          params.constant = true;
          params.stateMutability = "pure";
          break;
        case "view":
          params.constant = true;
          params.stateMutability = "view";
          break;
        case "external":
        case "public":
        case "":
          break;
        default:
          console.log("unknown modifier: " + modifier);
      }
    });
  };
  var verifyState = function(value) {
    var result = {
      constant: false,
      payable: true,
      stateMutability: "payable"
    };
    if (value.stateMutability != null) {
      result.stateMutability = value.stateMutability;
      result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
      if (value.constant != null) {
        if (!!value.constant !== result.constant) {
          logger.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
        }
      }
      result.payable = result.stateMutability === "payable";
      if (value.payable != null) {
        if (!!value.payable !== result.payable) {
          logger.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
        }
      }
    } else if (value.payable != null) {
      result.payable = !!value.payable;
      if (value.constant == null && !result.payable && value.type !== "constructor") {
        logger.throwArgumentError("unable to determine stateMutability", "value", value);
      }
      result.constant = !!value.constant;
      if (result.constant) {
        result.stateMutability = "view";
      } else {
        result.stateMutability = result.payable ? "payable" : "nonpayable";
      }
      if (result.payable && result.constant) {
        logger.throwArgumentError("cannot have constant payable function", "value", value);
      }
    } else if (value.constant != null) {
      result.constant = !!value.constant;
      result.payable = !result.constant;
      result.stateMutability = result.constant ? "view" : "payable";
    } else if (value.type !== "constructor") {
      logger.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    return result;
  };
  var checkForbidden = function(fragment) {
    var sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") {
      logger.throwArgumentError("cannot specify user defined " + sig + " error", "fragment", fragment);
    }
    return fragment;
  };
  var verifyType = function(type) {
    if (type.match(/^uint($|[^1-9])/)) {
      type = "uint256" + type.substring(4);
    } else if (type.match(/^int($|[^1-9])/)) {
      type = "int256" + type.substring(3);
    }
    return type;
  };
  var verifyIdentifier = function(value) {
    if (!value || !value.match(regexIdentifier)) {
      logger.throwArgumentError("invalid identifier \"" + value + "\"", "value", value);
    }
    return value;
  };
  var splitNesting = function(value) {
    value = value.trim();
    var result = [];
    var accum = "";
    var depth = 0;
    for (var offset = 0;offset < value.length; offset++) {
      var c = value[offset];
      if (c === "," && depth === 0) {
        result.push(accum);
        accum = "";
      } else {
        accum += c;
        if (c === "(") {
          depth++;
        } else if (c === ")") {
          depth--;
          if (depth === -1) {
            logger.throwArgumentError("unbalanced parenthesis", "value", value);
          }
        }
      }
    }
    if (accum) {
      result.push(accum);
    }
    return result;
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ErrorFragment = exports.FunctionFragment = exports.ConstructorFragment = exports.EventFragment = exports.Fragment = exports.ParamType = exports.FormatTypes = undefined;
  var bignumber_1 = require_lib3();
  var properties_1 = require_lib4();
  var logger_1 = require_lib();
  var _version_1 = require__version5();
  var logger = new logger_1.Logger(_version_1.version);
  var _constructorGuard = {};
  var ModifiersBytes = { calldata: true, memory: true, storage: true };
  var ModifiersNest = { calldata: true, memory: true };
  exports.FormatTypes = Object.freeze({
    sighash: "sighash",
    minimal: "minimal",
    full: "full",
    json: "json"
  });
  var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
  var ParamType = function() {
    function ParamType2(constructorGuard, params) {
      if (constructorGuard !== _constructorGuard) {
        logger.throwError("use fromString", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new ParamType()"
        });
      }
      populate(this, params);
      var match = this.type.match(paramTypeArray);
      if (match) {
        populate(this, {
          arrayLength: parseInt(match[2] || "-1"),
          arrayChildren: ParamType2.fromObject({
            type: match[1],
            components: this.components
          }),
          baseType: "array"
        });
      } else {
        populate(this, {
          arrayLength: null,
          arrayChildren: null,
          baseType: this.components != null ? "tuple" : this.type
        });
      }
      this._isParamType = true;
      Object.freeze(this);
    }
    ParamType2.prototype.format = function(format) {
      if (!format) {
        format = exports.FormatTypes.sighash;
      }
      if (!exports.FormatTypes[format]) {
        logger.throwArgumentError("invalid format type", "format", format);
      }
      if (format === exports.FormatTypes.json) {
        var result_1 = {
          type: this.baseType === "tuple" ? "tuple" : this.type,
          name: this.name || undefined
        };
        if (typeof this.indexed === "boolean") {
          result_1.indexed = this.indexed;
        }
        if (this.components) {
          result_1.components = this.components.map(function(comp) {
            return JSON.parse(comp.format(format));
          });
        }
        return JSON.stringify(result_1);
      }
      var result = "";
      if (this.baseType === "array") {
        result += this.arrayChildren.format(format);
        result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
      } else {
        if (this.baseType === "tuple") {
          if (format !== exports.FormatTypes.sighash) {
            result += this.type;
          }
          result += "(" + this.components.map(function(comp) {
            return comp.format(format);
          }).join(format === exports.FormatTypes.full ? ", " : ",") + ")";
        } else {
          result += this.type;
        }
      }
      if (format !== exports.FormatTypes.sighash) {
        if (this.indexed === true) {
          result += " indexed";
        }
        if (format === exports.FormatTypes.full && this.name) {
          result += " " + this.name;
        }
      }
      return result;
    };
    ParamType2.from = function(value, allowIndexed) {
      if (typeof value === "string") {
        return ParamType2.fromString(value, allowIndexed);
      }
      return ParamType2.fromObject(value);
    };
    ParamType2.fromObject = function(value) {
      if (ParamType2.isParamType(value)) {
        return value;
      }
      return new ParamType2(_constructorGuard, {
        name: value.name || null,
        type: verifyType(value.type),
        indexed: value.indexed == null ? null : !!value.indexed,
        components: value.components ? value.components.map(ParamType2.fromObject) : null
      });
    };
    ParamType2.fromString = function(value, allowIndexed) {
      function ParamTypify(node) {
        return ParamType2.fromObject({
          name: node.name,
          type: node.type,
          indexed: node.indexed,
          components: node.components
        });
      }
      return ParamTypify(parseParamType(value, !!allowIndexed));
    };
    ParamType2.isParamType = function(value) {
      return !!(value != null && value._isParamType);
    };
    return ParamType2;
  }();
  exports.ParamType = ParamType;
  var Fragment = function() {
    function Fragment2(constructorGuard, params) {
      if (constructorGuard !== _constructorGuard) {
        logger.throwError("use a static from method", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Fragment()"
        });
      }
      populate(this, params);
      this._isFragment = true;
      Object.freeze(this);
    }
    Fragment2.from = function(value) {
      if (Fragment2.isFragment(value)) {
        return value;
      }
      if (typeof value === "string") {
        return Fragment2.fromString(value);
      }
      return Fragment2.fromObject(value);
    };
    Fragment2.fromObject = function(value) {
      if (Fragment2.isFragment(value)) {
        return value;
      }
      switch (value.type) {
        case "function":
          return FunctionFragment.fromObject(value);
        case "event":
          return EventFragment.fromObject(value);
        case "constructor":
          return ConstructorFragment.fromObject(value);
        case "error":
          return ErrorFragment.fromObject(value);
        case "fallback":
        case "receive":
          return null;
      }
      return logger.throwArgumentError("invalid fragment object", "value", value);
    };
    Fragment2.fromString = function(value) {
      value = value.replace(/\s/g, " ");
      value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
      value = value.trim();
      if (value.split(" ")[0] === "event") {
        return EventFragment.fromString(value.substring(5).trim());
      } else if (value.split(" ")[0] === "function") {
        return FunctionFragment.fromString(value.substring(8).trim());
      } else if (value.split("(")[0].trim() === "constructor") {
        return ConstructorFragment.fromString(value.trim());
      } else if (value.split(" ")[0] === "error") {
        return ErrorFragment.fromString(value.substring(5).trim());
      }
      return logger.throwArgumentError("unsupported fragment", "value", value);
    };
    Fragment2.isFragment = function(value) {
      return !!(value && value._isFragment);
    };
    return Fragment2;
  }();
  exports.Fragment = Fragment;
  var EventFragment = function(_super) {
    __extends(EventFragment2, _super);
    function EventFragment2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    EventFragment2.prototype.format = function(format) {
      if (!format) {
        format = exports.FormatTypes.sighash;
      }
      if (!exports.FormatTypes[format]) {
        logger.throwArgumentError("invalid format type", "format", format);
      }
      if (format === exports.FormatTypes.json) {
        return JSON.stringify({
          type: "event",
          anonymous: this.anonymous,
          name: this.name,
          inputs: this.inputs.map(function(input) {
            return JSON.parse(input.format(format));
          })
        });
      }
      var result = "";
      if (format !== exports.FormatTypes.sighash) {
        result += "event ";
      }
      result += this.name + "(" + this.inputs.map(function(input) {
        return input.format(format);
      }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
      if (format !== exports.FormatTypes.sighash) {
        if (this.anonymous) {
          result += "anonymous ";
        }
      }
      return result.trim();
    };
    EventFragment2.from = function(value) {
      if (typeof value === "string") {
        return EventFragment2.fromString(value);
      }
      return EventFragment2.fromObject(value);
    };
    EventFragment2.fromObject = function(value) {
      if (EventFragment2.isEventFragment(value)) {
        return value;
      }
      if (value.type !== "event") {
        logger.throwArgumentError("invalid event object", "value", value);
      }
      var params = {
        name: verifyIdentifier(value.name),
        anonymous: value.anonymous,
        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
        type: "event"
      };
      return new EventFragment2(_constructorGuard, params);
    };
    EventFragment2.fromString = function(value) {
      var match = value.match(regexParen);
      if (!match) {
        logger.throwArgumentError("invalid event string", "value", value);
      }
      var anonymous = false;
      match[3].split(" ").forEach(function(modifier) {
        switch (modifier.trim()) {
          case "anonymous":
            anonymous = true;
            break;
          case "":
            break;
          default:
            logger.warn("unknown modifier: " + modifier);
        }
      });
      return EventFragment2.fromObject({
        name: match[1].trim(),
        anonymous,
        inputs: parseParams(match[2], true),
        type: "event"
      });
    };
    EventFragment2.isEventFragment = function(value) {
      return value && value._isFragment && value.type === "event";
    };
    return EventFragment2;
  }(Fragment);
  exports.EventFragment = EventFragment;
  var ConstructorFragment = function(_super) {
    __extends(ConstructorFragment2, _super);
    function ConstructorFragment2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ConstructorFragment2.prototype.format = function(format) {
      if (!format) {
        format = exports.FormatTypes.sighash;
      }
      if (!exports.FormatTypes[format]) {
        logger.throwArgumentError("invalid format type", "format", format);
      }
      if (format === exports.FormatTypes.json) {
        return JSON.stringify({
          type: "constructor",
          stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
          payable: this.payable,
          gas: this.gas ? this.gas.toNumber() : undefined,
          inputs: this.inputs.map(function(input) {
            return JSON.parse(input.format(format));
          })
        });
      }
      if (format === exports.FormatTypes.sighash) {
        logger.throwError("cannot format a constructor for sighash", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "format(sighash)"
        });
      }
      var result = "constructor(" + this.inputs.map(function(input) {
        return input.format(format);
      }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
      if (this.stateMutability && this.stateMutability !== "nonpayable") {
        result += this.stateMutability + " ";
      }
      return result.trim();
    };
    ConstructorFragment2.from = function(value) {
      if (typeof value === "string") {
        return ConstructorFragment2.fromString(value);
      }
      return ConstructorFragment2.fromObject(value);
    };
    ConstructorFragment2.fromObject = function(value) {
      if (ConstructorFragment2.isConstructorFragment(value)) {
        return value;
      }
      if (value.type !== "constructor") {
        logger.throwArgumentError("invalid constructor object", "value", value);
      }
      var state = verifyState(value);
      if (state.constant) {
        logger.throwArgumentError("constructor cannot be constant", "value", value);
      }
      var params = {
        name: null,
        type: value.type,
        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
        payable: state.payable,
        stateMutability: state.stateMutability,
        gas: value.gas ? bignumber_1.BigNumber.from(value.gas) : null
      };
      return new ConstructorFragment2(_constructorGuard, params);
    };
    ConstructorFragment2.fromString = function(value) {
      var params = { type: "constructor" };
      value = parseGas(value, params);
      var parens = value.match(regexParen);
      if (!parens || parens[1].trim() !== "constructor") {
        logger.throwArgumentError("invalid constructor string", "value", value);
      }
      params.inputs = parseParams(parens[2].trim(), false);
      parseModifiers(parens[3].trim(), params);
      return ConstructorFragment2.fromObject(params);
    };
    ConstructorFragment2.isConstructorFragment = function(value) {
      return value && value._isFragment && value.type === "constructor";
    };
    return ConstructorFragment2;
  }(Fragment);
  exports.ConstructorFragment = ConstructorFragment;
  var FunctionFragment = function(_super) {
    __extends(FunctionFragment2, _super);
    function FunctionFragment2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    FunctionFragment2.prototype.format = function(format) {
      if (!format) {
        format = exports.FormatTypes.sighash;
      }
      if (!exports.FormatTypes[format]) {
        logger.throwArgumentError("invalid format type", "format", format);
      }
      if (format === exports.FormatTypes.json) {
        return JSON.stringify({
          type: "function",
          name: this.name,
          constant: this.constant,
          stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
          payable: this.payable,
          gas: this.gas ? this.gas.toNumber() : undefined,
          inputs: this.inputs.map(function(input) {
            return JSON.parse(input.format(format));
          }),
          outputs: this.outputs.map(function(output) {
            return JSON.parse(output.format(format));
          })
        });
      }
      var result = "";
      if (format !== exports.FormatTypes.sighash) {
        result += "function ";
      }
      result += this.name + "(" + this.inputs.map(function(input) {
        return input.format(format);
      }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
      if (format !== exports.FormatTypes.sighash) {
        if (this.stateMutability) {
          if (this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
          }
        } else if (this.constant) {
          result += "view ";
        }
        if (this.outputs && this.outputs.length) {
          result += "returns (" + this.outputs.map(function(output) {
            return output.format(format);
          }).join(", ") + ") ";
        }
        if (this.gas != null) {
          result += "@" + this.gas.toString() + " ";
        }
      }
      return result.trim();
    };
    FunctionFragment2.from = function(value) {
      if (typeof value === "string") {
        return FunctionFragment2.fromString(value);
      }
      return FunctionFragment2.fromObject(value);
    };
    FunctionFragment2.fromObject = function(value) {
      if (FunctionFragment2.isFunctionFragment(value)) {
        return value;
      }
      if (value.type !== "function") {
        logger.throwArgumentError("invalid function object", "value", value);
      }
      var state = verifyState(value);
      var params = {
        type: value.type,
        name: verifyIdentifier(value.name),
        constant: state.constant,
        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
        outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
        payable: state.payable,
        stateMutability: state.stateMutability,
        gas: value.gas ? bignumber_1.BigNumber.from(value.gas) : null
      };
      return new FunctionFragment2(_constructorGuard, params);
    };
    FunctionFragment2.fromString = function(value) {
      var params = { type: "function" };
      value = parseGas(value, params);
      var comps = value.split(" returns ");
      if (comps.length > 2) {
        logger.throwArgumentError("invalid function string", "value", value);
      }
      var parens = comps[0].match(regexParen);
      if (!parens) {
        logger.throwArgumentError("invalid function signature", "value", value);
      }
      params.name = parens[1].trim();
      if (params.name) {
        verifyIdentifier(params.name);
      }
      params.inputs = parseParams(parens[2], false);
      parseModifiers(parens[3].trim(), params);
      if (comps.length > 1) {
        var returns = comps[1].match(regexParen);
        if (returns[1].trim() != "" || returns[3].trim() != "") {
          logger.throwArgumentError("unexpected tokens", "value", value);
        }
        params.outputs = parseParams(returns[2], false);
      } else {
        params.outputs = [];
      }
      return FunctionFragment2.fromObject(params);
    };
    FunctionFragment2.isFunctionFragment = function(value) {
      return value && value._isFragment && value.type === "function";
    };
    return FunctionFragment2;
  }(ConstructorFragment);
  exports.FunctionFragment = FunctionFragment;
  var ErrorFragment = function(_super) {
    __extends(ErrorFragment2, _super);
    function ErrorFragment2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ErrorFragment2.prototype.format = function(format) {
      if (!format) {
        format = exports.FormatTypes.sighash;
      }
      if (!exports.FormatTypes[format]) {
        logger.throwArgumentError("invalid format type", "format", format);
      }
      if (format === exports.FormatTypes.json) {
        return JSON.stringify({
          type: "error",
          name: this.name,
          inputs: this.inputs.map(function(input) {
            return JSON.parse(input.format(format));
          })
        });
      }
      var result = "";
      if (format !== exports.FormatTypes.sighash) {
        result += "error ";
      }
      result += this.name + "(" + this.inputs.map(function(input) {
        return input.format(format);
      }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
      return result.trim();
    };
    ErrorFragment2.from = function(value) {
      if (typeof value === "string") {
        return ErrorFragment2.fromString(value);
      }
      return ErrorFragment2.fromObject(value);
    };
    ErrorFragment2.fromObject = function(value) {
      if (ErrorFragment2.isErrorFragment(value)) {
        return value;
      }
      if (value.type !== "error") {
        logger.throwArgumentError("invalid error object", "value", value);
      }
      var params = {
        type: value.type,
        name: verifyIdentifier(value.name),
        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
      };
      return checkForbidden(new ErrorFragment2(_constructorGuard, params));
    };
    ErrorFragment2.fromString = function(value) {
      var params = { type: "error" };
      var parens = value.match(regexParen);
      if (!parens) {
        logger.throwArgumentError("invalid error signature", "value", value);
      }
      params.name = parens[1].trim();
      if (params.name) {
        verifyIdentifier(params.name);
      }
      params.inputs = parseParams(parens[2], false);
      return checkForbidden(ErrorFragment2.fromObject(params));
    };
    ErrorFragment2.isErrorFragment = function(value) {
      return value && value._isFragment && value.type === "error";
    };
    return ErrorFragment2;
  }(Fragment);
  exports.ErrorFragment = ErrorFragment;
  var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
  var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
});

// node_modules/@ethersproject/abi/lib/coders/abstract-coder.js
var require_abstract_coder = __commonJS((exports) => {
  var checkResultErrors = function(result) {
    var errors = [];
    var checkErrors = function(path, object) {
      if (!Array.isArray(object)) {
        return;
      }
      for (var key in object) {
        var childPath = path.slice();
        childPath.push(key);
        try {
          checkErrors(childPath, object[key]);
        } catch (error) {
          errors.push({ path: childPath, error });
        }
      }
    };
    checkErrors([], result);
    return errors;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = undefined;
  var bytes_1 = require_lib2();
  var bignumber_1 = require_lib3();
  var properties_1 = require_lib4();
  var logger_1 = require_lib();
  var _version_1 = require__version5();
  var logger = new logger_1.Logger(_version_1.version);
  exports.checkResultErrors = checkResultErrors;
  var Coder = function() {
    function Coder2(name, type, localName, dynamic) {
      this.name = name;
      this.type = type;
      this.localName = localName;
      this.dynamic = dynamic;
    }
    Coder2.prototype._throwError = function(message, value) {
      logger.throwArgumentError(message, this.localName, value);
    };
    return Coder2;
  }();
  exports.Coder = Coder;
  var Writer = function() {
    function Writer2(wordSize) {
      (0, properties_1.defineReadOnly)(this, "wordSize", wordSize || 32);
      this._data = [];
      this._dataLength = 0;
      this._padding = new Uint8Array(wordSize);
    }
    Object.defineProperty(Writer2.prototype, "data", {
      get: function() {
        return (0, bytes_1.hexConcat)(this._data);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Writer2.prototype, "length", {
      get: function() {
        return this._dataLength;
      },
      enumerable: false,
      configurable: true
    });
    Writer2.prototype._writeData = function(data) {
      this._data.push(data);
      this._dataLength += data.length;
      return data.length;
    };
    Writer2.prototype.appendWriter = function(writer) {
      return this._writeData((0, bytes_1.concat)(writer._data));
    };
    Writer2.prototype.writeBytes = function(value) {
      var bytes = (0, bytes_1.arrayify)(value);
      var paddingOffset = bytes.length % this.wordSize;
      if (paddingOffset) {
        bytes = (0, bytes_1.concat)([bytes, this._padding.slice(paddingOffset)]);
      }
      return this._writeData(bytes);
    };
    Writer2.prototype._getValue = function(value) {
      var bytes = (0, bytes_1.arrayify)(bignumber_1.BigNumber.from(value));
      if (bytes.length > this.wordSize) {
        logger.throwError("value out-of-bounds", logger_1.Logger.errors.BUFFER_OVERRUN, {
          length: this.wordSize,
          offset: bytes.length
        });
      }
      if (bytes.length % this.wordSize) {
        bytes = (0, bytes_1.concat)([this._padding.slice(bytes.length % this.wordSize), bytes]);
      }
      return bytes;
    };
    Writer2.prototype.writeValue = function(value) {
      return this._writeData(this._getValue(value));
    };
    Writer2.prototype.writeUpdatableValue = function() {
      var _this = this;
      var offset = this._data.length;
      this._data.push(this._padding);
      this._dataLength += this.wordSize;
      return function(value) {
        _this._data[offset] = _this._getValue(value);
      };
    };
    return Writer2;
  }();
  exports.Writer = Writer;
  var Reader = function() {
    function Reader2(data, wordSize, coerceFunc, allowLoose) {
      (0, properties_1.defineReadOnly)(this, "_data", (0, bytes_1.arrayify)(data));
      (0, properties_1.defineReadOnly)(this, "wordSize", wordSize || 32);
      (0, properties_1.defineReadOnly)(this, "_coerceFunc", coerceFunc);
      (0, properties_1.defineReadOnly)(this, "allowLoose", allowLoose);
      this._offset = 0;
    }
    Object.defineProperty(Reader2.prototype, "data", {
      get: function() {
        return (0, bytes_1.hexlify)(this._data);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reader2.prototype, "consumed", {
      get: function() {
        return this._offset;
      },
      enumerable: false,
      configurable: true
    });
    Reader2.coerce = function(name, value) {
      var match = name.match("^u?int([0-9]+)$");
      if (match && parseInt(match[1]) <= 48) {
        value = value.toNumber();
      }
      return value;
    };
    Reader2.prototype.coerce = function(name, value) {
      if (this._coerceFunc) {
        return this._coerceFunc(name, value);
      }
      return Reader2.coerce(name, value);
    };
    Reader2.prototype._peekBytes = function(offset, length, loose) {
      var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
      if (this._offset + alignedLength > this._data.length) {
        if (this.allowLoose && loose && this._offset + length <= this._data.length) {
          alignedLength = length;
        } else {
          logger.throwError("data out-of-bounds", logger_1.Logger.errors.BUFFER_OVERRUN, {
            length: this._data.length,
            offset: this._offset + alignedLength
          });
        }
      }
      return this._data.slice(this._offset, this._offset + alignedLength);
    };
    Reader2.prototype.subReader = function(offset) {
      return new Reader2(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    };
    Reader2.prototype.readBytes = function(length, loose) {
      var bytes = this._peekBytes(0, length, !!loose);
      this._offset += bytes.length;
      return bytes.slice(0, length);
    };
    Reader2.prototype.readValue = function() {
      return bignumber_1.BigNumber.from(this.readBytes(this.wordSize));
    };
    return Reader2;
  }();
  exports.Reader = Reader;
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS((exports, module) => {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = global;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && exports;
    var AMD = typeof define === "function" && define.amd;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(bits2, padding, outputType) {
      return function(message) {
        return new Keccak(bits2, padding, bits2).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding, outputType) {
      return function(message, outputBits) {
        return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding, outputType) {
      return function(message, outputBits, n, s) {
        return methods["cshake" + bits2].update(message, outputBits, n, s)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding, outputType) {
      return function(key, message, outputBits, s) {
        return methods["kmac" + bits2].update(key, message, outputBits, s)[outputType]();
      };
    };
    var createOutputMethods = function(method, createMethod2, bits2, padding) {
      for (var i2 = 0;i2 < OUTPUT_TYPES.length; ++i2) {
        var type = OUTPUT_TYPES[i2];
        method[type] = createMethod2(bits2, padding, type);
      }
      return method;
    };
    var createMethod = function(bits2, padding) {
      var method = createOutputMethod(bits2, padding, "hex");
      method.create = function() {
        return new Keccak(bits2, padding, bits2);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits2, padding);
    };
    var createShakeMethod = function(bits2, padding) {
      var method = createShakeOutputMethod(bits2, padding, "hex");
      method.create = function(outputBits) {
        return new Keccak(bits2, padding, outputBits);
      };
      method.update = function(message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
    };
    var createCshakeMethod = function(bits2, padding) {
      var w = CSHAKE_BYTEPAD[bits2];
      var method = createCshakeOutputMethod(bits2, padding, "hex");
      method.create = function(outputBits, n, s) {
        if (!n && !s) {
          return methods["shake" + bits2].create(outputBits);
        } else {
          return new Keccak(bits2, padding, outputBits).bytepad([n, s], w);
        }
      };
      method.update = function(message, outputBits, n, s) {
        return method.create(outputBits, n, s).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
    };
    var createKmacMethod = function(bits2, padding) {
      var w = CSHAKE_BYTEPAD[bits2];
      var method = createKmacOutputMethod(bits2, padding, "hex");
      method.create = function(key, outputBits, s) {
        return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
      };
      method.update = function(key, message, outputBits, s) {
        return method.create(key, outputBits, s).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
    };
    var algorithms = [
      { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
      { name: "sha3", padding: PADDING, bits: BITS, createMethod },
      { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];
    var methods = {}, methodNames = [];
    for (var i = 0;i < algorithms.length; ++i) {
      var algorithm = algorithms[i];
      var bits = algorithm.bits;
      for (var j = 0;j < bits.length; ++j) {
        var methodName = algorithm.name + "_" + bits[j];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
        if (algorithm.name !== "sha3") {
          var newMethodName = algorithm.name + bits[j];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak(bits2, padding, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i2 = 0;i2 < 50; ++i2) {
        this.s[i2] = 0;
      }
    }
    Keccak.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
      while (index < length) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i2 = 1;i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        if (notString) {
          for (i2 = this.start;index < length && i2 < byteCount; ++index) {
            blocks[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
          }
        } else {
          for (i2 = this.start;index < length && i2 < byteCount; ++index) {
            code = message.charCodeAt(index);
            if (code < 128) {
              blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
            } else if (code < 2048) {
              blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
            } else if (code < 55296 || code >= 57344) {
              blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
            } else {
              code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
              blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
            }
          }
        }
        this.lastByteIndex = i2;
        if (i2 >= byteCount) {
          this.start = i2 - byteCount;
          this.block = blocks[blockCount];
          for (i2 = 0;i2 < blockCount; ++i2) {
            s[i2] ^= blocks[i2];
          }
          f(s);
          this.reset = true;
        } else {
          this.start = i2;
        }
      }
      return this;
    };
    Keccak.prototype.encode = function(x, right) {
      var o = x & 255, n = 1;
      var bytes = [o];
      x = x >> 8;
      o = x & 255;
      while (o > 0) {
        bytes.unshift(o);
        x = x >> 8;
        o = x & 255;
        ++n;
      }
      if (right) {
        bytes.push(n);
      } else {
        bytes.unshift(n);
      }
      this.update(bytes);
      return bytes.length;
    };
    Keccak.prototype.encodeString = function(str) {
      var notString, type = typeof str;
      if (type !== "string") {
        if (type === "object") {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes = 0, length = str.length;
      if (notString) {
        bytes = length;
      } else {
        for (var i2 = 0;i2 < str.length; ++i2) {
          var code = str.charCodeAt(i2);
          if (code < 128) {
            bytes += 1;
          } else if (code < 2048) {
            bytes += 2;
          } else if (code < 55296 || code >= 57344) {
            bytes += 3;
          } else {
            code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
            bytes += 4;
          }
        }
      }
      bytes += this.encode(bytes * 8);
      this.update(str);
      return bytes;
    };
    Keccak.prototype.bytepad = function(strs, w) {
      var bytes = this.encode(w);
      for (var i2 = 0;i2 < strs.length; ++i2) {
        bytes += this.encodeString(strs[i2]);
      }
      var paddingBytes = w - bytes % w;
      var zeros = [];
      zeros.length = paddingBytes;
      this.update(zeros);
      return this;
    };
    Keccak.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
      blocks[i2 >> 2] |= this.padding[i2 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i2 = 1;i2 < blockCount + 1; ++i2) {
          blocks[i2] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i2 = 0;i2 < blockCount; ++i2) {
        s[i2] ^= blocks[i2];
      }
      f(s);
    };
    Keccak.prototype.toString = Keccak.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
      var hex = "", block;
      while (j2 < outputBlocks) {
        for (i2 = 0;i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
          block = s[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
        }
        if (j2 % blockCount === 0) {
          f(s);
          i2 = 0;
        }
      }
      if (extraBytes) {
        block = s[i2];
        hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
        if (extraBytes > 1) {
          hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
        }
      }
      return hex;
    };
    Keccak.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
      var bytes = this.outputBits >> 3;
      var buffer;
      if (extraBytes) {
        buffer = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer = new ArrayBuffer(bytes);
      }
      var array = new Uint32Array(buffer);
      while (j2 < outputBlocks) {
        for (i2 = 0;i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
          array[j2] = s[i2];
        }
        if (j2 % blockCount === 0) {
          f(s);
        }
      }
      if (extraBytes) {
        array[i2] = s[i2];
        buffer = buffer.slice(0, bytes);
      }
      return buffer;
    };
    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    Keccak.prototype.digest = Keccak.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
      var array = [], offset, block;
      while (j2 < outputBlocks) {
        for (i2 = 0;i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          array[offset + 1] = block >> 8 & 255;
          array[offset + 2] = block >> 16 & 255;
          array[offset + 3] = block >> 24 & 255;
        }
        if (j2 % blockCount === 0) {
          f(s);
        }
      }
      if (extraBytes) {
        offset = j2 << 2;
        block = s[i2];
        array[offset] = block & 255;
        if (extraBytes > 1) {
          array[offset + 1] = block >> 8 & 255;
        }
        if (extraBytes > 2) {
          array[offset + 2] = block >> 16 & 255;
        }
      }
      return array;
    };
    function Kmac(bits2, padding, outputBits) {
      Keccak.call(this, bits2, padding, outputBits);
    }
    Kmac.prototype = new Keccak;
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak.prototype.finalize.call(this);
    };
    var f = function(s) {
      var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n = 0;n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
        h = c8 ^ (c2 << 1 | c3 >>> 31);
        l = c9 ^ (c3 << 1 | c2 >>> 31);
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ (c4 << 1 | c5 >>> 31);
        l = c1 ^ (c5 << 1 | c4 >>> 31);
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ (c6 << 1 | c7 >>> 31);
        l = c3 ^ (c7 << 1 | c6 >>> 31);
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ (c8 << 1 | c9 >>> 31);
        l = c5 ^ (c9 << 1 | c8 >>> 31);
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ (c0 << 1 | c1 >>> 31);
        l = c7 ^ (c1 << 1 | c0 >>> 31);
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;
        b0 = s[0];
        b1 = s[1];
        b32 = s[11] << 4 | s[10] >>> 28;
        b33 = s[10] << 4 | s[11] >>> 28;
        b14 = s[20] << 3 | s[21] >>> 29;
        b15 = s[21] << 3 | s[20] >>> 29;
        b46 = s[31] << 9 | s[30] >>> 23;
        b47 = s[30] << 9 | s[31] >>> 23;
        b28 = s[40] << 18 | s[41] >>> 14;
        b29 = s[41] << 18 | s[40] >>> 14;
        b20 = s[2] << 1 | s[3] >>> 31;
        b21 = s[3] << 1 | s[2] >>> 31;
        b2 = s[13] << 12 | s[12] >>> 20;
        b3 = s[12] << 12 | s[13] >>> 20;
        b34 = s[22] << 10 | s[23] >>> 22;
        b35 = s[23] << 10 | s[22] >>> 22;
        b16 = s[33] << 13 | s[32] >>> 19;
        b17 = s[32] << 13 | s[33] >>> 19;
        b48 = s[42] << 2 | s[43] >>> 30;
        b49 = s[43] << 2 | s[42] >>> 30;
        b40 = s[5] << 30 | s[4] >>> 2;
        b41 = s[4] << 30 | s[5] >>> 2;
        b22 = s[14] << 6 | s[15] >>> 26;
        b23 = s[15] << 6 | s[14] >>> 26;
        b4 = s[25] << 11 | s[24] >>> 21;
        b5 = s[24] << 11 | s[25] >>> 21;
        b36 = s[34] << 15 | s[35] >>> 17;
        b37 = s[35] << 15 | s[34] >>> 17;
        b18 = s[45] << 29 | s[44] >>> 3;
        b19 = s[44] << 29 | s[45] >>> 3;
        b10 = s[6] << 28 | s[7] >>> 4;
        b11 = s[7] << 28 | s[6] >>> 4;
        b42 = s[17] << 23 | s[16] >>> 9;
        b43 = s[16] << 23 | s[17] >>> 9;
        b24 = s[26] << 25 | s[27] >>> 7;
        b25 = s[27] << 25 | s[26] >>> 7;
        b6 = s[36] << 21 | s[37] >>> 11;
        b7 = s[37] << 21 | s[36] >>> 11;
        b38 = s[47] << 24 | s[46] >>> 8;
        b39 = s[46] << 24 | s[47] >>> 8;
        b30 = s[8] << 27 | s[9] >>> 5;
        b31 = s[9] << 27 | s[8] >>> 5;
        b12 = s[18] << 20 | s[19] >>> 12;
        b13 = s[19] << 20 | s[18] >>> 12;
        b44 = s[29] << 7 | s[28] >>> 25;
        b45 = s[28] << 7 | s[29] >>> 25;
        b26 = s[38] << 8 | s[39] >>> 24;
        b27 = s[39] << 8 | s[38] >>> 24;
        b8 = s[48] << 14 | s[49] >>> 18;
        b9 = s[49] << 14 | s[48] >>> 18;
        s[0] = b0 ^ ~b2 & b4;
        s[1] = b1 ^ ~b3 & b5;
        s[10] = b10 ^ ~b12 & b14;
        s[11] = b11 ^ ~b13 & b15;
        s[20] = b20 ^ ~b22 & b24;
        s[21] = b21 ^ ~b23 & b25;
        s[30] = b30 ^ ~b32 & b34;
        s[31] = b31 ^ ~b33 & b35;
        s[40] = b40 ^ ~b42 & b44;
        s[41] = b41 ^ ~b43 & b45;
        s[2] = b2 ^ ~b4 & b6;
        s[3] = b3 ^ ~b5 & b7;
        s[12] = b12 ^ ~b14 & b16;
        s[13] = b13 ^ ~b15 & b17;
        s[22] = b22 ^ ~b24 & b26;
        s[23] = b23 ^ ~b25 & b27;
        s[32] = b32 ^ ~b34 & b36;
        s[33] = b33 ^ ~b35 & b37;
        s[42] = b42 ^ ~b44 & b46;
        s[43] = b43 ^ ~b45 & b47;
        s[4] = b4 ^ ~b6 & b8;
        s[5] = b5 ^ ~b7 & b9;
        s[14] = b14 ^ ~b16 & b18;
        s[15] = b15 ^ ~b17 & b19;
        s[24] = b24 ^ ~b26 & b28;
        s[25] = b25 ^ ~b27 & b29;
        s[34] = b34 ^ ~b36 & b38;
        s[35] = b35 ^ ~b37 & b39;
        s[44] = b44 ^ ~b46 & b48;
        s[45] = b45 ^ ~b47 & b49;
        s[6] = b6 ^ ~b8 & b0;
        s[7] = b7 ^ ~b9 & b1;
        s[16] = b16 ^ ~b18 & b10;
        s[17] = b17 ^ ~b19 & b11;
        s[26] = b26 ^ ~b28 & b20;
        s[27] = b27 ^ ~b29 & b21;
        s[36] = b36 ^ ~b38 & b30;
        s[37] = b37 ^ ~b39 & b31;
        s[46] = b46 ^ ~b48 & b40;
        s[47] = b47 ^ ~b49 & b41;
        s[8] = b8 ^ ~b0 & b2;
        s[9] = b9 ^ ~b1 & b3;
        s[18] = b18 ^ ~b10 & b12;
        s[19] = b19 ^ ~b11 & b13;
        s[28] = b28 ^ ~b20 & b22;
        s[29] = b29 ^ ~b21 & b23;
        s[38] = b38 ^ ~b30 & b32;
        s[39] = b39 ^ ~b31 & b33;
        s[48] = b48 ^ ~b40 & b42;
        s[49] = b49 ^ ~b41 & b43;
        s[0] ^= RC[n];
        s[1] ^= RC[n + 1];
      }
    };
    if (COMMON_JS) {
      module.exports = methods;
    } else {
      for (i = 0;i < methodNames.length; ++i) {
        root[methodNames[i]] = methods[methodNames[i]];
      }
      if (AMD) {
        define(function() {
          return methods;
        });
      }
    }
  })();
});

// node_modules/@ethersproject/keccak256/lib/index.js
var require_lib5 = __commonJS((exports) => {
  var keccak256 = function(data) {
    return "0x" + js_sha3_1.default.keccak_256((0, bytes_1.arrayify)(data));
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.keccak256 = undefined;
  var js_sha3_1 = __importDefault(require_sha3());
  var bytes_1 = require_lib2();
  exports.keccak256 = keccak256;
});

// node_modules/@ethersproject/rlp/lib/_version.js
var require__version6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "rlp/5.7.0";
});

// node_modules/@ethersproject/rlp/lib/index.js
var require_lib6 = __commonJS((exports) => {
  var arrayifyInteger = function(value) {
    var result = [];
    while (value) {
      result.unshift(value & 255);
      value >>= 8;
    }
    return result;
  };
  var unarrayifyInteger = function(data, offset, length) {
    var result = 0;
    for (var i = 0;i < length; i++) {
      result = result * 256 + data[offset + i];
    }
    return result;
  };
  var _encode = function(object) {
    if (Array.isArray(object)) {
      var payload_1 = [];
      object.forEach(function(child) {
        payload_1 = payload_1.concat(_encode(child));
      });
      if (payload_1.length <= 55) {
        payload_1.unshift(192 + payload_1.length);
        return payload_1;
      }
      var length_1 = arrayifyInteger(payload_1.length);
      length_1.unshift(247 + length_1.length);
      return length_1.concat(payload_1);
    }
    if (!(0, bytes_1.isBytesLike)(object)) {
      logger.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    var data = Array.prototype.slice.call((0, bytes_1.arrayify)(object));
    if (data.length === 1 && data[0] <= 127) {
      return data;
    } else if (data.length <= 55) {
      data.unshift(128 + data.length);
      return data;
    }
    var length = arrayifyInteger(data.length);
    length.unshift(183 + length.length);
    return length.concat(data);
  };
  var encode = function(object) {
    return (0, bytes_1.hexlify)(_encode(object));
  };
  var _decodeChildren = function(data, offset, childOffset, length) {
    var result = [];
    while (childOffset < offset + 1 + length) {
      var decoded = _decode(data, childOffset);
      result.push(decoded.result);
      childOffset += decoded.consumed;
      if (childOffset > offset + 1 + length) {
        logger.throwError("child data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
      }
    }
    return { consumed: 1 + length, result };
  };
  var _decode = function(data, offset) {
    if (data.length === 0) {
      logger.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
    }
    if (data[offset] >= 248) {
      var lengthLength = data[offset] - 247;
      if (offset + 1 + lengthLength > data.length) {
        logger.throwError("data short segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
      }
      var length_2 = unarrayifyInteger(data, offset + 1, lengthLength);
      if (offset + 1 + lengthLength + length_2 > data.length) {
        logger.throwError("data long segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
      }
      return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length_2);
    } else if (data[offset] >= 192) {
      var length_3 = data[offset] - 192;
      if (offset + 1 + length_3 > data.length) {
        logger.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
      }
      return _decodeChildren(data, offset, offset + 1, length_3);
    } else if (data[offset] >= 184) {
      var lengthLength = data[offset] - 183;
      if (offset + 1 + lengthLength > data.length) {
        logger.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
      }
      var length_4 = unarrayifyInteger(data, offset + 1, lengthLength);
      if (offset + 1 + lengthLength + length_4 > data.length) {
        logger.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
      }
      var result = (0, bytes_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length_4));
      return { consumed: 1 + lengthLength + length_4, result };
    } else if (data[offset] >= 128) {
      var length_5 = data[offset] - 128;
      if (offset + 1 + length_5 > data.length) {
        logger.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
      }
      var result = (0, bytes_1.hexlify)(data.slice(offset + 1, offset + 1 + length_5));
      return { consumed: 1 + length_5, result };
    }
    return { consumed: 1, result: (0, bytes_1.hexlify)(data[offset]) };
  };
  var decode = function(data) {
    var bytes = (0, bytes_1.arrayify)(data);
    var decoded = _decode(bytes, 0);
    if (decoded.consumed !== bytes.length) {
      logger.throwArgumentError("invalid rlp data", "data", data);
    }
    return decoded.result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decode = exports.encode = undefined;
  var bytes_1 = require_lib2();
  var logger_1 = require_lib();
  var _version_1 = require__version6();
  var logger = new logger_1.Logger(_version_1.version);
  exports.encode = encode;
  exports.decode = decode;
});

// node_modules/@ethersproject/address/lib/_version.js
var require__version7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "address/5.7.0";
});

// node_modules/@ethersproject/address/lib/index.js
var require_lib7 = __commonJS((exports) => {
  var getChecksumAddress = function(address) {
    if (!(0, bytes_1.isHexString)(address, 20)) {
      logger.throwArgumentError("invalid address", "address", address);
    }
    address = address.toLowerCase();
    var chars = address.substring(2).split("");
    var expanded = new Uint8Array(40);
    for (var i2 = 0;i2 < 40; i2++) {
      expanded[i2] = chars[i2].charCodeAt(0);
    }
    var hashed = (0, bytes_1.arrayify)((0, keccak256_1.keccak256)(expanded));
    for (var i2 = 0;i2 < 40; i2 += 2) {
      if (hashed[i2 >> 1] >> 4 >= 8) {
        chars[i2] = chars[i2].toUpperCase();
      }
      if ((hashed[i2 >> 1] & 15) >= 8) {
        chars[i2 + 1] = chars[i2 + 1].toUpperCase();
      }
    }
    return "0x" + chars.join("");
  };
  var log10 = function(x) {
    if (Math.log10) {
      return Math.log10(x);
    }
    return Math.log(x) / Math.LN10;
  };
  var ibanChecksum = function(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    var expanded = address.split("").map(function(c) {
      return ibanLookup[c];
    }).join("");
    while (expanded.length >= safeDigits) {
      var block = expanded.substring(0, safeDigits);
      expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    var checksum = String(98 - parseInt(expanded, 10) % 97);
    while (checksum.length < 2) {
      checksum = "0" + checksum;
    }
    return checksum;
  };
  var getAddress = function(address) {
    var result = null;
    if (typeof address !== "string") {
      logger.throwArgumentError("invalid address", "address", address);
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
      if (address.substring(0, 2) !== "0x") {
        address = "0x" + address;
      }
      result = getChecksumAddress(address);
      if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
        logger.throwArgumentError("bad address checksum", "address", address);
      }
    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
      if (address.substring(2, 4) !== ibanChecksum(address)) {
        logger.throwArgumentError("bad icap checksum", "address", address);
      }
      result = (0, bignumber_1._base36To16)(address.substring(4));
      while (result.length < 40) {
        result = "0" + result;
      }
      result = getChecksumAddress("0x" + result);
    } else {
      logger.throwArgumentError("invalid address", "address", address);
    }
    return result;
  };
  var isAddress = function(address) {
    try {
      getAddress(address);
      return true;
    } catch (error) {
    }
    return false;
  };
  var getIcapAddress = function(address) {
    var base36 = (0, bignumber_1._base16To36)(getAddress(address).substring(2)).toUpperCase();
    while (base36.length < 30) {
      base36 = "0" + base36;
    }
    return "XE" + ibanChecksum("XE00" + base36) + base36;
  };
  var getContractAddress = function(transaction) {
    var from = null;
    try {
      from = getAddress(transaction.from);
    } catch (error) {
      logger.throwArgumentError("missing from address", "transaction", transaction);
    }
    var nonce = (0, bytes_1.stripZeros)((0, bytes_1.arrayify)(bignumber_1.BigNumber.from(transaction.nonce).toHexString()));
    return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, rlp_1.encode)([from, nonce])), 12));
  };
  var getCreate2Address = function(from, salt, initCodeHash) {
    if ((0, bytes_1.hexDataLength)(salt) !== 32) {
      logger.throwArgumentError("salt must be 32 bytes", "salt", salt);
    }
    if ((0, bytes_1.hexDataLength)(initCodeHash) !== 32) {
      logger.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
    }
    return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)(["0xff", getAddress(from), salt, initCodeHash])), 12));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.isAddress = exports.getAddress = undefined;
  var bytes_1 = require_lib2();
  var bignumber_1 = require_lib3();
  var keccak256_1 = require_lib5();
  var rlp_1 = require_lib6();
  var logger_1 = require_lib();
  var _version_1 = require__version7();
  var logger = new logger_1.Logger(_version_1.version);
  var MAX_SAFE_INTEGER = 9007199254740991;
  var ibanLookup = {};
  for (i = 0;i < 10; i++) {
    ibanLookup[String(i)] = String(i);
  }
  var i;
  for (i = 0;i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
  }
  var i;
  var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
  exports.getAddress = getAddress;
  exports.isAddress = isAddress;
  exports.getIcapAddress = getIcapAddress;
  exports.getContractAddress = getContractAddress;
  exports.getCreate2Address = getCreate2Address;
});

// node_modules/@ethersproject/abi/lib/coders/address.js
var require_address = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AddressCoder = undefined;
  var address_1 = require_lib7();
  var bytes_1 = require_lib2();
  var abstract_coder_1 = require_abstract_coder();
  var AddressCoder = function(_super) {
    __extends(AddressCoder2, _super);
    function AddressCoder2(localName) {
      return _super.call(this, "address", "address", localName, false) || this;
    }
    AddressCoder2.prototype.defaultValue = function() {
      return "0x0000000000000000000000000000000000000000";
    };
    AddressCoder2.prototype.encode = function(writer, value) {
      try {
        value = (0, address_1.getAddress)(value);
      } catch (error) {
        this._throwError(error.message, value);
      }
      return writer.writeValue(value);
    };
    AddressCoder2.prototype.decode = function(reader) {
      return (0, address_1.getAddress)((0, bytes_1.hexZeroPad)(reader.readValue().toHexString(), 20));
    };
    return AddressCoder2;
  }(abstract_coder_1.Coder);
  exports.AddressCoder = AddressCoder;
});

// node_modules/@ethersproject/abi/lib/coders/anonymous.js
var require_anonymous = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnonymousCoder = undefined;
  var abstract_coder_1 = require_abstract_coder();
  var AnonymousCoder = function(_super) {
    __extends(AnonymousCoder2, _super);
    function AnonymousCoder2(coder) {
      var _this = _super.call(this, coder.name, coder.type, undefined, coder.dynamic) || this;
      _this.coder = coder;
      return _this;
    }
    AnonymousCoder2.prototype.defaultValue = function() {
      return this.coder.defaultValue();
    };
    AnonymousCoder2.prototype.encode = function(writer, value) {
      return this.coder.encode(writer, value);
    };
    AnonymousCoder2.prototype.decode = function(reader) {
      return this.coder.decode(reader);
    };
    return AnonymousCoder2;
  }(abstract_coder_1.Coder);
  exports.AnonymousCoder = AnonymousCoder;
});

// node_modules/@ethersproject/abi/lib/coders/array.js
var require_array = __commonJS((exports) => {
  var pack = function(writer, coders, values) {
    var arrayValues = null;
    if (Array.isArray(values)) {
      arrayValues = values;
    } else if (values && typeof values === "object") {
      var unique_1 = {};
      arrayValues = coders.map(function(coder) {
        var name = coder.localName;
        if (!name) {
          logger.throwError("cannot encode object for signature with missing names", logger_1.Logger.errors.INVALID_ARGUMENT, {
            argument: "values",
            coder,
            value: values
          });
        }
        if (unique_1[name]) {
          logger.throwError("cannot encode object for signature with duplicate names", logger_1.Logger.errors.INVALID_ARGUMENT, {
            argument: "values",
            coder,
            value: values
          });
        }
        unique_1[name] = true;
        return values[name];
      });
    } else {
      logger.throwArgumentError("invalid tuple value", "tuple", values);
    }
    if (coders.length !== arrayValues.length) {
      logger.throwArgumentError("types/value length mismatch", "tuple", values);
    }
    var staticWriter = new abstract_coder_1.Writer(writer.wordSize);
    var dynamicWriter = new abstract_coder_1.Writer(writer.wordSize);
    var updateFuncs = [];
    coders.forEach(function(coder, index) {
      var value = arrayValues[index];
      if (coder.dynamic) {
        var dynamicOffset_1 = dynamicWriter.length;
        coder.encode(dynamicWriter, value);
        var updateFunc_1 = staticWriter.writeUpdatableValue();
        updateFuncs.push(function(baseOffset) {
          updateFunc_1(baseOffset + dynamicOffset_1);
        });
      } else {
        coder.encode(staticWriter, value);
      }
    });
    updateFuncs.forEach(function(func) {
      func(staticWriter.length);
    });
    var length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
  };
  var unpack = function(reader, coders) {
    var values = [];
    var baseReader = reader.subReader(0);
    coders.forEach(function(coder) {
      var value = null;
      if (coder.dynamic) {
        var offset = reader.readValue();
        var offsetReader = baseReader.subReader(offset.toNumber());
        try {
          value = coder.decode(offsetReader);
        } catch (error) {
          if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {
            throw error;
          }
          value = error;
          value.baseType = coder.name;
          value.name = coder.localName;
          value.type = coder.type;
        }
      } else {
        try {
          value = coder.decode(reader);
        } catch (error) {
          if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {
            throw error;
          }
          value = error;
          value.baseType = coder.name;
          value.name = coder.localName;
          value.type = coder.type;
        }
      }
      if (value != null) {
        values.push(value);
      }
    });
    var uniqueNames = coders.reduce(function(accum, coder) {
      var name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    coders.forEach(function(coder, index) {
      var name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      var value = values[index];
      if (value instanceof Error) {
        Object.defineProperty(values, name, {
          enumerable: true,
          get: function() {
            throw value;
          }
        });
      } else {
        values[name] = value;
      }
    });
    var _loop_1 = function(i2) {
      var value = values[i2];
      if (value instanceof Error) {
        Object.defineProperty(values, i2, {
          enumerable: true,
          get: function() {
            throw value;
          }
        });
      }
    };
    for (var i = 0;i < values.length; i++) {
      _loop_1(i);
    }
    return Object.freeze(values);
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ArrayCoder = exports.unpack = exports.pack = undefined;
  var logger_1 = require_lib();
  var _version_1 = require__version5();
  var logger = new logger_1.Logger(_version_1.version);
  var abstract_coder_1 = require_abstract_coder();
  var anonymous_1 = require_anonymous();
  exports.pack = pack;
  exports.unpack = unpack;
  var ArrayCoder = function(_super) {
    __extends(ArrayCoder2, _super);
    function ArrayCoder2(coder, length, localName) {
      var _this = this;
      var type = coder.type + "[" + (length >= 0 ? length : "") + "]";
      var dynamic = length === -1 || coder.dynamic;
      _this = _super.call(this, "array", type, localName, dynamic) || this;
      _this.coder = coder;
      _this.length = length;
      return _this;
    }
    ArrayCoder2.prototype.defaultValue = function() {
      var defaultChild = this.coder.defaultValue();
      var result = [];
      for (var i = 0;i < this.length; i++) {
        result.push(defaultChild);
      }
      return result;
    };
    ArrayCoder2.prototype.encode = function(writer, value) {
      if (!Array.isArray(value)) {
        this._throwError("expected array value", value);
      }
      var count = this.length;
      if (count === -1) {
        count = value.length;
        writer.writeValue(value.length);
      }
      logger.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
      var coders = [];
      for (var i = 0;i < value.length; i++) {
        coders.push(this.coder);
      }
      return pack(writer, coders, value);
    };
    ArrayCoder2.prototype.decode = function(reader) {
      var count = this.length;
      if (count === -1) {
        count = reader.readValue().toNumber();
        if (count * 32 > reader._data.length) {
          logger.throwError("insufficient data length", logger_1.Logger.errors.BUFFER_OVERRUN, {
            length: reader._data.length,
            count
          });
        }
      }
      var coders = [];
      for (var i = 0;i < count; i++) {
        coders.push(new anonymous_1.AnonymousCoder(this.coder));
      }
      return reader.coerce(this.name, unpack(reader, coders));
    };
    return ArrayCoder2;
  }(abstract_coder_1.Coder);
  exports.ArrayCoder = ArrayCoder;
});

// node_modules/@ethersproject/abi/lib/coders/boolean.js
var require_boolean = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BooleanCoder = undefined;
  var abstract_coder_1 = require_abstract_coder();
  var BooleanCoder = function(_super) {
    __extends(BooleanCoder2, _super);
    function BooleanCoder2(localName) {
      return _super.call(this, "bool", "bool", localName, false) || this;
    }
    BooleanCoder2.prototype.defaultValue = function() {
      return false;
    };
    BooleanCoder2.prototype.encode = function(writer, value) {
      return writer.writeValue(value ? 1 : 0);
    };
    BooleanCoder2.prototype.decode = function(reader) {
      return reader.coerce(this.type, !reader.readValue().isZero());
    };
    return BooleanCoder2;
  }(abstract_coder_1.Coder);
  exports.BooleanCoder = BooleanCoder;
});

// node_modules/@ethersproject/abi/lib/coders/bytes.js
var require_bytes = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BytesCoder = exports.DynamicBytesCoder = undefined;
  var bytes_1 = require_lib2();
  var abstract_coder_1 = require_abstract_coder();
  var DynamicBytesCoder = function(_super) {
    __extends(DynamicBytesCoder2, _super);
    function DynamicBytesCoder2(type, localName) {
      return _super.call(this, type, type, localName, true) || this;
    }
    DynamicBytesCoder2.prototype.defaultValue = function() {
      return "0x";
    };
    DynamicBytesCoder2.prototype.encode = function(writer, value) {
      value = (0, bytes_1.arrayify)(value);
      var length = writer.writeValue(value.length);
      length += writer.writeBytes(value);
      return length;
    };
    DynamicBytesCoder2.prototype.decode = function(reader) {
      return reader.readBytes(reader.readValue().toNumber(), true);
    };
    return DynamicBytesCoder2;
  }(abstract_coder_1.Coder);
  exports.DynamicBytesCoder = DynamicBytesCoder;
  var BytesCoder = function(_super) {
    __extends(BytesCoder2, _super);
    function BytesCoder2(localName) {
      return _super.call(this, "bytes", localName) || this;
    }
    BytesCoder2.prototype.decode = function(reader) {
      return reader.coerce(this.name, (0, bytes_1.hexlify)(_super.prototype.decode.call(this, reader)));
    };
    return BytesCoder2;
  }(DynamicBytesCoder);
  exports.BytesCoder = BytesCoder;
});

// node_modules/@ethersproject/abi/lib/coders/fixed-bytes.js
var require_fixed_bytes = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FixedBytesCoder = undefined;
  var bytes_1 = require_lib2();
  var abstract_coder_1 = require_abstract_coder();
  var FixedBytesCoder = function(_super) {
    __extends(FixedBytesCoder2, _super);
    function FixedBytesCoder2(size, localName) {
      var _this = this;
      var name = "bytes" + String(size);
      _this = _super.call(this, name, name, localName, false) || this;
      _this.size = size;
      return _this;
    }
    FixedBytesCoder2.prototype.defaultValue = function() {
      return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
    };
    FixedBytesCoder2.prototype.encode = function(writer, value) {
      var data = (0, bytes_1.arrayify)(value);
      if (data.length !== this.size) {
        this._throwError("incorrect data length", value);
      }
      return writer.writeBytes(data);
    };
    FixedBytesCoder2.prototype.decode = function(reader) {
      return reader.coerce(this.name, (0, bytes_1.hexlify)(reader.readBytes(this.size)));
    };
    return FixedBytesCoder2;
  }(abstract_coder_1.Coder);
  exports.FixedBytesCoder = FixedBytesCoder;
});

// node_modules/@ethersproject/abi/lib/coders/null.js
var require_null = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NullCoder = undefined;
  var abstract_coder_1 = require_abstract_coder();
  var NullCoder = function(_super) {
    __extends(NullCoder2, _super);
    function NullCoder2(localName) {
      return _super.call(this, "null", "", localName, false) || this;
    }
    NullCoder2.prototype.defaultValue = function() {
      return null;
    };
    NullCoder2.prototype.encode = function(writer, value) {
      if (value != null) {
        this._throwError("not null", value);
      }
      return writer.writeBytes([]);
    };
    NullCoder2.prototype.decode = function(reader) {
      reader.readBytes(0);
      return reader.coerce(this.name, null);
    };
    return NullCoder2;
  }(abstract_coder_1.Coder);
  exports.NullCoder = NullCoder;
});

// node_modules/@ethersproject/constants/lib/addresses.js
var require_addresses = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AddressZero = undefined;
  exports.AddressZero = "0x0000000000000000000000000000000000000000";
});

// node_modules/@ethersproject/constants/lib/bignumbers.js
var require_bignumbers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = undefined;
  var bignumber_1 = require_lib3();
  var NegativeOne = bignumber_1.BigNumber.from(-1);
  exports.NegativeOne = NegativeOne;
  var Zero = bignumber_1.BigNumber.from(0);
  exports.Zero = Zero;
  var One = bignumber_1.BigNumber.from(1);
  exports.One = One;
  var Two = bignumber_1.BigNumber.from(2);
  exports.Two = Two;
  var WeiPerEther = bignumber_1.BigNumber.from("1000000000000000000");
  exports.WeiPerEther = WeiPerEther;
  var MaxUint256 = bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  exports.MaxUint256 = MaxUint256;
  var MinInt256 = bignumber_1.BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
  exports.MinInt256 = MinInt256;
  var MaxInt256 = bignumber_1.BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  exports.MaxInt256 = MaxInt256;
});

// node_modules/@ethersproject/constants/lib/hashes.js
var require_hashes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HashZero = undefined;
  exports.HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
});

// node_modules/@ethersproject/constants/lib/strings.js
var require_strings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EtherSymbol = undefined;
  exports.EtherSymbol = "\u039E";
});

// node_modules/@ethersproject/constants/lib/index.js
var require_lib8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EtherSymbol = exports.HashZero = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = exports.AddressZero = undefined;
  var addresses_1 = require_addresses();
  Object.defineProperty(exports, "AddressZero", { enumerable: true, get: function() {
    return addresses_1.AddressZero;
  } });
  var bignumbers_1 = require_bignumbers();
  Object.defineProperty(exports, "NegativeOne", { enumerable: true, get: function() {
    return bignumbers_1.NegativeOne;
  } });
  Object.defineProperty(exports, "Zero", { enumerable: true, get: function() {
    return bignumbers_1.Zero;
  } });
  Object.defineProperty(exports, "One", { enumerable: true, get: function() {
    return bignumbers_1.One;
  } });
  Object.defineProperty(exports, "Two", { enumerable: true, get: function() {
    return bignumbers_1.Two;
  } });
  Object.defineProperty(exports, "WeiPerEther", { enumerable: true, get: function() {
    return bignumbers_1.WeiPerEther;
  } });
  Object.defineProperty(exports, "MaxUint256", { enumerable: true, get: function() {
    return bignumbers_1.MaxUint256;
  } });
  Object.defineProperty(exports, "MinInt256", { enumerable: true, get: function() {
    return bignumbers_1.MinInt256;
  } });
  Object.defineProperty(exports, "MaxInt256", { enumerable: true, get: function() {
    return bignumbers_1.MaxInt256;
  } });
  var hashes_1 = require_hashes();
  Object.defineProperty(exports, "HashZero", { enumerable: true, get: function() {
    return hashes_1.HashZero;
  } });
  var strings_1 = require_strings();
  Object.defineProperty(exports, "EtherSymbol", { enumerable: true, get: function() {
    return strings_1.EtherSymbol;
  } });
});

// node_modules/@ethersproject/abi/lib/coders/number.js
var require_number = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NumberCoder = undefined;
  var bignumber_1 = require_lib3();
  var constants_1 = require_lib8();
  var abstract_coder_1 = require_abstract_coder();
  var NumberCoder = function(_super) {
    __extends(NumberCoder2, _super);
    function NumberCoder2(size, signed, localName) {
      var _this = this;
      var name = (signed ? "int" : "uint") + size * 8;
      _this = _super.call(this, name, name, localName, false) || this;
      _this.size = size;
      _this.signed = signed;
      return _this;
    }
    NumberCoder2.prototype.defaultValue = function() {
      return 0;
    };
    NumberCoder2.prototype.encode = function(writer, value) {
      var v2 = bignumber_1.BigNumber.from(value);
      var maxUintValue = constants_1.MaxUint256.mask(writer.wordSize * 8);
      if (this.signed) {
        var bounds = maxUintValue.mask(this.size * 8 - 1);
        if (v2.gt(bounds) || v2.lt(bounds.add(constants_1.One).mul(constants_1.NegativeOne))) {
          this._throwError("value out-of-bounds", value);
        }
      } else if (v2.lt(constants_1.Zero) || v2.gt(maxUintValue.mask(this.size * 8))) {
        this._throwError("value out-of-bounds", value);
      }
      v2 = v2.toTwos(this.size * 8).mask(this.size * 8);
      if (this.signed) {
        v2 = v2.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
      }
      return writer.writeValue(v2);
    };
    NumberCoder2.prototype.decode = function(reader) {
      var value = reader.readValue().mask(this.size * 8);
      if (this.signed) {
        value = value.fromTwos(this.size * 8);
      }
      return reader.coerce(this.name, value);
    };
    return NumberCoder2;
  }(abstract_coder_1.Coder);
  exports.NumberCoder = NumberCoder;
});

// node_modules/@ethersproject/strings/lib/_version.js
var require__version8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "strings/5.7.0";
});

// node_modules/@ethersproject/strings/lib/utf8.js
var require_utf8 = __commonJS((exports) => {
  var errorFunc = function(reason, offset, bytes, output, badCodepoint) {
    return logger.throwArgumentError("invalid codepoint at offset " + offset + "; " + reason, "bytes", bytes);
  };
  var ignoreFunc = function(reason, offset, bytes, output, badCodepoint) {
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
      var i = 0;
      for (var o = offset + 1;o < bytes.length; o++) {
        if (bytes[o] >> 6 !== 2) {
          break;
        }
        i++;
      }
      return i;
    }
    if (reason === Utf8ErrorReason.OVERRUN) {
      return bytes.length - offset - 1;
    }
    return 0;
  };
  var replaceFunc = function(reason, offset, bytes, output, badCodepoint) {
    if (reason === Utf8ErrorReason.OVERLONG) {
      output.push(badCodepoint);
      return 0;
    }
    output.push(65533);
    return ignoreFunc(reason, offset, bytes, output, badCodepoint);
  };
  var getUtf8CodePoints = function(bytes, onError) {
    if (onError == null) {
      onError = exports.Utf8ErrorFuncs.error;
    }
    bytes = (0, bytes_1.arrayify)(bytes);
    var result = [];
    var i = 0;
    while (i < bytes.length) {
      var c = bytes[i++];
      if (c >> 7 === 0) {
        result.push(c);
        continue;
      }
      var extraLength = null;
      var overlongMask = null;
      if ((c & 224) === 192) {
        extraLength = 1;
        overlongMask = 127;
      } else if ((c & 240) === 224) {
        extraLength = 2;
        overlongMask = 2047;
      } else if ((c & 248) === 240) {
        extraLength = 3;
        overlongMask = 65535;
      } else {
        if ((c & 192) === 128) {
          i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
        } else {
          i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
        }
        continue;
      }
      if (i - 1 + extraLength >= bytes.length) {
        i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
        continue;
      }
      var res = c & (1 << 8 - extraLength - 1) - 1;
      for (var j = 0;j < extraLength; j++) {
        var nextChar = bytes[i];
        if ((nextChar & 192) != 128) {
          i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
          res = null;
          break;
        }
        res = res << 6 | nextChar & 63;
        i++;
      }
      if (res === null) {
        continue;
      }
      if (res > 1114111) {
        i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
        continue;
      }
      if (res >= 55296 && res <= 57343) {
        i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
        continue;
      }
      if (res <= overlongMask) {
        i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
        continue;
      }
      result.push(res);
    }
    return result;
  };
  var toUtf8Bytes = function(str, form) {
    if (form === undefined) {
      form = UnicodeNormalizationForm.current;
    }
    if (form != UnicodeNormalizationForm.current) {
      logger.checkNormalize();
      str = str.normalize(form);
    }
    var result = [];
    for (var i = 0;i < str.length; i++) {
      var c = str.charCodeAt(i);
      if (c < 128) {
        result.push(c);
      } else if (c < 2048) {
        result.push(c >> 6 | 192);
        result.push(c & 63 | 128);
      } else if ((c & 64512) == 55296) {
        i++;
        var c2 = str.charCodeAt(i);
        if (i >= str.length || (c2 & 64512) !== 56320) {
          throw new Error("invalid utf-8 string");
        }
        var pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
        result.push(pair >> 18 | 240);
        result.push(pair >> 12 & 63 | 128);
        result.push(pair >> 6 & 63 | 128);
        result.push(pair & 63 | 128);
      } else {
        result.push(c >> 12 | 224);
        result.push(c >> 6 & 63 | 128);
        result.push(c & 63 | 128);
      }
    }
    return (0, bytes_1.arrayify)(result);
  };
  var escapeChar = function(value) {
    var hex = "0000" + value.toString(16);
    return "\\u" + hex.substring(hex.length - 4);
  };
  var _toEscapedUtf8String = function(bytes, onError) {
    return '"' + getUtf8CodePoints(bytes, onError).map(function(codePoint) {
      if (codePoint < 256) {
        switch (codePoint) {
          case 8:
            return "\\b";
          case 9:
            return "\\t";
          case 10:
            return "\\n";
          case 13:
            return "\\r";
          case 34:
            return "\\\"";
          case 92:
            return "\\\\";
        }
        if (codePoint >= 32 && codePoint < 127) {
          return String.fromCharCode(codePoint);
        }
      }
      if (codePoint <= 65535) {
        return escapeChar(codePoint);
      }
      codePoint -= 65536;
      return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
    }).join("") + '"';
  };
  var _toUtf8String = function(codePoints) {
    return codePoints.map(function(codePoint) {
      if (codePoint <= 65535) {
        return String.fromCharCode(codePoint);
      }
      codePoint -= 65536;
      return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
    }).join("");
  };
  var toUtf8String = function(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
  };
  var toUtf8CodePoints = function(str, form) {
    if (form === undefined) {
      form = UnicodeNormalizationForm.current;
    }
    return getUtf8CodePoints(toUtf8Bytes(str, form));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toUtf8CodePoints = exports.toUtf8String = exports._toUtf8String = exports._toEscapedUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = undefined;
  var bytes_1 = require_lib2();
  var logger_1 = require_lib();
  var _version_1 = require__version8();
  var logger = new logger_1.Logger(_version_1.version);
  var UnicodeNormalizationForm;
  (function(UnicodeNormalizationForm2) {
    UnicodeNormalizationForm2["current"] = "";
    UnicodeNormalizationForm2["NFC"] = "NFC";
    UnicodeNormalizationForm2["NFD"] = "NFD";
    UnicodeNormalizationForm2["NFKC"] = "NFKC";
    UnicodeNormalizationForm2["NFKD"] = "NFKD";
  })(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));
  var Utf8ErrorReason;
  (function(Utf8ErrorReason2) {
    Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
    Utf8ErrorReason2["OVERRUN"] = "string overrun";
    Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
    Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
    Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
    Utf8ErrorReason2["OVERLONG"] = "overlong representation";
  })(Utf8ErrorReason = exports.Utf8ErrorReason || (exports.Utf8ErrorReason = {}));
  exports.Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
  });
  exports.toUtf8Bytes = toUtf8Bytes;
  exports._toEscapedUtf8String = _toEscapedUtf8String;
  exports._toUtf8String = _toUtf8String;
  exports.toUtf8String = toUtf8String;
  exports.toUtf8CodePoints = toUtf8CodePoints;
});

// node_modules/@ethersproject/strings/lib/bytes32.js
var require_bytes32 = __commonJS((exports) => {
  var formatBytes32String = function(text) {
    var bytes = (0, utf8_1.toUtf8Bytes)(text);
    if (bytes.length > 31) {
      throw new Error("bytes32 string must be less than 32 bytes");
    }
    return (0, bytes_1.hexlify)((0, bytes_1.concat)([bytes, constants_1.HashZero]).slice(0, 32));
  };
  var parseBytes32String = function(bytes) {
    var data = (0, bytes_1.arrayify)(bytes);
    if (data.length !== 32) {
      throw new Error("invalid bytes32 - not 32 bytes long");
    }
    if (data[31] !== 0) {
      throw new Error("invalid bytes32 string - no null terminator");
    }
    var length = 31;
    while (data[length - 1] === 0) {
      length--;
    }
    return (0, utf8_1.toUtf8String)(data.slice(0, length));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseBytes32String = exports.formatBytes32String = undefined;
  var constants_1 = require_lib8();
  var bytes_1 = require_lib2();
  var utf8_1 = require_utf8();
  exports.formatBytes32String = formatBytes32String;
  exports.parseBytes32String = parseBytes32String;
});

// node_modules/@ethersproject/strings/lib/idna.js
var require_idna = __commonJS((exports) => {
  var bytes2 = function(data) {
    if (data.length % 4 !== 0) {
      throw new Error("bad data");
    }
    var result = [];
    for (var i = 0;i < data.length; i += 4) {
      result.push(parseInt(data.substring(i, i + 4), 16));
    }
    return result;
  };
  var createTable = function(data, func) {
    if (!func) {
      func = function(value) {
        return [parseInt(value, 16)];
      };
    }
    var lo = 0;
    var result = {};
    data.split(",").forEach(function(pair) {
      var comps = pair.split(":");
      lo += parseInt(comps[0], 16);
      result[lo] = func(comps[1]);
    });
    return result;
  };
  var createRangeTable = function(data) {
    var hi = 0;
    return data.split(",").map(function(v2) {
      var comps = v2.split("-");
      if (comps.length === 1) {
        comps[1] = "0";
      } else if (comps[1] === "") {
        comps[1] = "1";
      }
      var lo = hi + parseInt(comps[0], 16);
      hi = parseInt(comps[1], 16);
      return { l: lo, h: hi };
    });
  };
  var matchMap = function(value, ranges) {
    var lo = 0;
    for (var i = 0;i < ranges.length; i++) {
      var range = ranges[i];
      lo += range.l;
      if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
        if (range.e && range.e.indexOf(value - lo) !== -1) {
          continue;
        }
        return range;
      }
    }
    return null;
  };
  var flatten = function(values) {
    return values.reduce(function(accum, value) {
      value.forEach(function(value2) {
        accum.push(value2);
      });
      return accum;
    }, []);
  };
  var _nameprepTableA1 = function(codepoint) {
    return !!matchMap(codepoint, Table_A_1_ranges);
  };
  var _nameprepTableB2 = function(codepoint) {
    var range = matchMap(codepoint, Table_B_2_ranges);
    if (range) {
      return [codepoint + range.s];
    }
    var codes = Table_B_2_lut_abs[codepoint];
    if (codes) {
      return codes;
    }
    var shift = Table_B_2_lut_rel[codepoint];
    if (shift) {
      return [codepoint + shift[0]];
    }
    var complex = Table_B_2_complex[codepoint];
    if (complex) {
      return complex;
    }
    return null;
  };
  var _nameprepTableC = function(codepoint) {
    return !!matchMap(codepoint, Table_C_ranges);
  };
  var nameprep = function(value) {
    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
      return value.toLowerCase();
    }
    var codes = (0, utf8_1.toUtf8CodePoints)(value);
    codes = flatten(codes.map(function(code) {
      if (Table_B_1_flags.indexOf(code) >= 0) {
        return [];
      }
      if (code >= 65024 && code <= 65039) {
        return [];
      }
      var codesTableB2 = _nameprepTableB2(code);
      if (codesTableB2) {
        return codesTableB2;
      }
      return [code];
    }));
    codes = (0, utf8_1.toUtf8CodePoints)((0, utf8_1._toUtf8String)(codes), utf8_1.UnicodeNormalizationForm.NFKC);
    codes.forEach(function(code) {
      if (_nameprepTableC(code)) {
        throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
      }
    });
    codes.forEach(function(code) {
      if (_nameprepTableA1(code)) {
        throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
      }
    });
    var name = (0, utf8_1._toUtf8String)(codes);
    if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
      throw new Error("invalid hyphen");
    }
    return name;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.nameprep = exports._nameprepTableC = exports._nameprepTableB2 = exports._nameprepTableA1 = undefined;
  var utf8_1 = require_utf8();
  var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
  var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(function(v2) {
    return parseInt(v2, 16);
  });
  var Table_B_2_ranges = [
    { h: 25, s: 32, l: 65 },
    { h: 30, s: 32, e: [23], l: 127 },
    { h: 54, s: 1, e: [48], l: 64, d: 2 },
    { h: 14, s: 1, l: 57, d: 2 },
    { h: 44, s: 1, l: 17, d: 2 },
    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
    { h: 16, s: 1, l: 68, d: 2 },
    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
    { h: 26, s: 32, e: [17], l: 435 },
    { h: 22, s: 1, l: 71, d: 2 },
    { h: 15, s: 80, l: 40 },
    { h: 31, s: 32, l: 16 },
    { h: 32, s: 1, l: 80, d: 2 },
    { h: 52, s: 1, l: 42, d: 2 },
    { h: 12, s: 1, l: 55, d: 2 },
    { h: 40, s: 1, e: [38], l: 15, d: 2 },
    { h: 14, s: 1, l: 48, d: 2 },
    { h: 37, s: 48, l: 49 },
    { h: 148, s: 1, l: 6351, d: 2 },
    { h: 88, s: 1, l: 160, d: 2 },
    { h: 15, s: 16, l: 704 },
    { h: 25, s: 26, l: 854 },
    { h: 25, s: 32, l: 55915 },
    { h: 37, s: 40, l: 1247 },
    { h: 25, s: -119711, l: 53248 },
    { h: 25, s: -119763, l: 52 },
    { h: 25, s: -119815, l: 52 },
    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
    { h: 25, s: -119919, l: 52 },
    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
    { h: 25, s: -120075, l: 52 },
    { h: 25, s: -120127, l: 52 },
    { h: 25, s: -120179, l: 52 },
    { h: 25, s: -120231, l: 52 },
    { h: 25, s: -120283, l: 52 },
    { h: 25, s: -120335, l: 52 },
    { h: 24, s: -119543, e: [17], l: 56 },
    { h: 24, s: -119601, e: [17], l: 58 },
    { h: 24, s: -119659, e: [17], l: 58 },
    { h: 24, s: -119717, e: [17], l: 58 },
    { h: 24, s: -119775, e: [17], l: 58 }
  ];
  var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
  var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
  var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
  var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
  exports._nameprepTableA1 = _nameprepTableA1;
  exports._nameprepTableB2 = _nameprepTableB2;
  exports._nameprepTableC = _nameprepTableC;
  exports.nameprep = nameprep;
});

// node_modules/@ethersproject/strings/lib/index.js
var require_lib9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.nameprep = exports.parseBytes32String = exports.formatBytes32String = exports.UnicodeNormalizationForm = exports.Utf8ErrorReason = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = undefined;
  var bytes32_1 = require_bytes32();
  Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
    return bytes32_1.formatBytes32String;
  } });
  Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
    return bytes32_1.parseBytes32String;
  } });
  var idna_1 = require_idna();
  Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
    return idna_1.nameprep;
  } });
  var utf8_1 = require_utf8();
  Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
    return utf8_1._toEscapedUtf8String;
  } });
  Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
    return utf8_1.toUtf8Bytes;
  } });
  Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
    return utf8_1.toUtf8CodePoints;
  } });
  Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
    return utf8_1.toUtf8String;
  } });
  Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
    return utf8_1.UnicodeNormalizationForm;
  } });
  Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
    return utf8_1.Utf8ErrorFuncs;
  } });
  Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
    return utf8_1.Utf8ErrorReason;
  } });
});

// node_modules/@ethersproject/abi/lib/coders/string.js
var require_string = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StringCoder = undefined;
  var strings_1 = require_lib9();
  var bytes_1 = require_bytes();
  var StringCoder = function(_super) {
    __extends(StringCoder2, _super);
    function StringCoder2(localName) {
      return _super.call(this, "string", localName) || this;
    }
    StringCoder2.prototype.defaultValue = function() {
      return "";
    };
    StringCoder2.prototype.encode = function(writer, value) {
      return _super.prototype.encode.call(this, writer, (0, strings_1.toUtf8Bytes)(value));
    };
    StringCoder2.prototype.decode = function(reader) {
      return (0, strings_1.toUtf8String)(_super.prototype.decode.call(this, reader));
    };
    return StringCoder2;
  }(bytes_1.DynamicBytesCoder);
  exports.StringCoder = StringCoder;
});

// node_modules/@ethersproject/abi/lib/coders/tuple.js
var require_tuple = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TupleCoder = undefined;
  var abstract_coder_1 = require_abstract_coder();
  var array_1 = require_array();
  var TupleCoder = function(_super) {
    __extends(TupleCoder2, _super);
    function TupleCoder2(coders, localName) {
      var _this = this;
      var dynamic = false;
      var types = [];
      coders.forEach(function(coder) {
        if (coder.dynamic) {
          dynamic = true;
        }
        types.push(coder.type);
      });
      var type = "tuple(" + types.join(",") + ")";
      _this = _super.call(this, "tuple", type, localName, dynamic) || this;
      _this.coders = coders;
      return _this;
    }
    TupleCoder2.prototype.defaultValue = function() {
      var values = [];
      this.coders.forEach(function(coder) {
        values.push(coder.defaultValue());
      });
      var uniqueNames = this.coders.reduce(function(accum, coder) {
        var name = coder.localName;
        if (name) {
          if (!accum[name]) {
            accum[name] = 0;
          }
          accum[name]++;
        }
        return accum;
      }, {});
      this.coders.forEach(function(coder, index) {
        var name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
          return;
        }
        if (name === "length") {
          name = "_length";
        }
        if (values[name] != null) {
          return;
        }
        values[name] = values[index];
      });
      return Object.freeze(values);
    };
    TupleCoder2.prototype.encode = function(writer, value) {
      return (0, array_1.pack)(writer, this.coders, value);
    };
    TupleCoder2.prototype.decode = function(reader) {
      return reader.coerce(this.name, (0, array_1.unpack)(reader, this.coders));
    };
    return TupleCoder2;
  }(abstract_coder_1.Coder);
  exports.TupleCoder = TupleCoder;
});

// node_modules/@ethersproject/abi/lib/abi-coder.js
var require_abi_coder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultAbiCoder = exports.AbiCoder = undefined;
  var bytes_1 = require_lib2();
  var properties_1 = require_lib4();
  var logger_1 = require_lib();
  var _version_1 = require__version5();
  var logger = new logger_1.Logger(_version_1.version);
  var abstract_coder_1 = require_abstract_coder();
  var address_1 = require_address();
  var array_1 = require_array();
  var boolean_1 = require_boolean();
  var bytes_2 = require_bytes();
  var fixed_bytes_1 = require_fixed_bytes();
  var null_1 = require_null();
  var number_1 = require_number();
  var string_1 = require_string();
  var tuple_1 = require_tuple();
  var fragments_1 = require_fragments();
  var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
  var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
  var AbiCoder = function() {
    function AbiCoder2(coerceFunc) {
      (0, properties_1.defineReadOnly)(this, "coerceFunc", coerceFunc || null);
    }
    AbiCoder2.prototype._getCoder = function(param) {
      var _this = this;
      switch (param.baseType) {
        case "address":
          return new address_1.AddressCoder(param.name);
        case "bool":
          return new boolean_1.BooleanCoder(param.name);
        case "string":
          return new string_1.StringCoder(param.name);
        case "bytes":
          return new bytes_2.BytesCoder(param.name);
        case "array":
          return new array_1.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
        case "tuple":
          return new tuple_1.TupleCoder((param.components || []).map(function(component) {
            return _this._getCoder(component);
          }), param.name);
        case "":
          return new null_1.NullCoder(param.name);
      }
      var match = param.type.match(paramTypeNumber);
      if (match) {
        var size = parseInt(match[2] || "256");
        if (size === 0 || size > 256 || size % 8 !== 0) {
          logger.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
        }
        return new number_1.NumberCoder(size / 8, match[1] === "int", param.name);
      }
      match = param.type.match(paramTypeBytes);
      if (match) {
        var size = parseInt(match[1]);
        if (size === 0 || size > 32) {
          logger.throwArgumentError("invalid bytes length", "param", param);
        }
        return new fixed_bytes_1.FixedBytesCoder(size, param.name);
      }
      return logger.throwArgumentError("invalid type", "type", param.type);
    };
    AbiCoder2.prototype._getWordSize = function() {
      return 32;
    };
    AbiCoder2.prototype._getReader = function(data, allowLoose) {
      return new abstract_coder_1.Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
    };
    AbiCoder2.prototype._getWriter = function() {
      return new abstract_coder_1.Writer(this._getWordSize());
    };
    AbiCoder2.prototype.getDefaultValue = function(types) {
      var _this = this;
      var coders = types.map(function(type) {
        return _this._getCoder(fragments_1.ParamType.from(type));
      });
      var coder = new tuple_1.TupleCoder(coders, "_");
      return coder.defaultValue();
    };
    AbiCoder2.prototype.encode = function(types, values) {
      var _this = this;
      if (types.length !== values.length) {
        logger.throwError("types/values length mismatch", logger_1.Logger.errors.INVALID_ARGUMENT, {
          count: { types: types.length, values: values.length },
          value: { types, values }
        });
      }
      var coders = types.map(function(type) {
        return _this._getCoder(fragments_1.ParamType.from(type));
      });
      var coder = new tuple_1.TupleCoder(coders, "_");
      var writer = this._getWriter();
      coder.encode(writer, values);
      return writer.data;
    };
    AbiCoder2.prototype.decode = function(types, data, loose) {
      var _this = this;
      var coders = types.map(function(type) {
        return _this._getCoder(fragments_1.ParamType.from(type));
      });
      var coder = new tuple_1.TupleCoder(coders, "_");
      return coder.decode(this._getReader((0, bytes_1.arrayify)(data), loose));
    };
    return AbiCoder2;
  }();
  exports.AbiCoder = AbiCoder;
  exports.defaultAbiCoder = new AbiCoder;
});

// node_modules/@ethersproject/hash/lib/id.js
var require_id = __commonJS((exports) => {
  var id = function(text) {
    return (0, keccak256_1.keccak256)((0, strings_1.toUtf8Bytes)(text));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.id = undefined;
  var keccak256_1 = require_lib5();
  var strings_1 = require_lib9();
  exports.id = id;
});

// node_modules/@ethersproject/hash/lib/_version.js
var require__version9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "hash/5.7.0";
});

// node_modules/@ethersproject/base64/lib/browser-base64.js
var require_browser_base64 = __commonJS((exports) => {
  var decode = function(textData) {
    textData = atob(textData);
    var data = [];
    for (var i = 0;i < textData.length; i++) {
      data.push(textData.charCodeAt(i));
    }
    return (0, bytes_1.arrayify)(data);
  };
  var encode = function(data) {
    data = (0, bytes_1.arrayify)(data);
    var textData = "";
    for (var i = 0;i < data.length; i++) {
      textData += String.fromCharCode(data[i]);
    }
    return btoa(textData);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encode = exports.decode = undefined;
  var bytes_1 = require_lib2();
  exports.decode = decode;
  exports.encode = encode;
});

// node_modules/@ethersproject/base64/lib/index.js
var require_lib10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encode = exports.decode = undefined;
  var base64_1 = require_browser_base64();
  Object.defineProperty(exports, "decode", { enumerable: true, get: function() {
    return base64_1.decode;
  } });
  Object.defineProperty(exports, "encode", { enumerable: true, get: function() {
    return base64_1.encode;
  } });
});

// node_modules/@ethersproject/hash/lib/ens-normalize/decoder.js
var require_decoder = __commonJS((exports) => {
  var flat = function(array, depth) {
    if (depth == null) {
      depth = 1;
    }
    var result = [];
    var forEach = result.forEach;
    var flatDeep = function(arr, depth2) {
      forEach.call(arr, function(val) {
        if (depth2 > 0 && Array.isArray(val)) {
          flatDeep(val, depth2 - 1);
        } else {
          result.push(val);
        }
      });
    };
    flatDeep(array, depth);
    return result;
  };
  var fromEntries = function(array) {
    var result = {};
    for (var i = 0;i < array.length; i++) {
      var value = array[i];
      result[value[0]] = value[1];
    }
    return result;
  };
  var decode_arithmetic = function(bytes) {
    var pos = 0;
    function u16() {
      return bytes[pos++] << 8 | bytes[pos++];
    }
    var symbol_count = u16();
    var total = 1;
    var acc = [0, 1];
    for (var i = 1;i < symbol_count; i++) {
      acc.push(total += u16());
    }
    var skip = u16();
    var pos_payload = pos;
    pos += skip;
    var read_width = 0;
    var read_buffer = 0;
    function read_bit() {
      if (read_width == 0) {
        read_buffer = read_buffer << 8 | bytes[pos++];
        read_width = 8;
      }
      return read_buffer >> --read_width & 1;
    }
    var N = 31;
    var FULL = Math.pow(2, N);
    var HALF = FULL >>> 1;
    var QRTR = HALF >> 1;
    var MASK = FULL - 1;
    var register = 0;
    for (var i = 0;i < N; i++)
      register = register << 1 | read_bit();
    var symbols = [];
    var low = 0;
    var range = FULL;
    while (true) {
      var value = Math.floor(((register - low + 1) * total - 1) / range);
      var start = 0;
      var end = symbol_count;
      while (end - start > 1) {
        var mid = start + end >>> 1;
        if (value < acc[mid]) {
          end = mid;
        } else {
          start = mid;
        }
      }
      if (start == 0)
        break;
      symbols.push(start);
      var a = low + Math.floor(range * acc[start] / total);
      var b2 = low + Math.floor(range * acc[start + 1] / total) - 1;
      while (((a ^ b2) & HALF) == 0) {
        register = register << 1 & MASK | read_bit();
        a = a << 1 & MASK;
        b2 = b2 << 1 & MASK | 1;
      }
      while (a & ~b2 & QRTR) {
        register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
        a = a << 1 ^ HALF;
        b2 = (b2 ^ HALF) << 1 | HALF | 1;
      }
      low = a;
      range = 1 + b2 - a;
    }
    var offset = symbol_count - 4;
    return symbols.map(function(x) {
      switch (x - offset) {
        case 3:
          return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
        case 2:
          return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
        case 1:
          return offset + bytes[pos_payload++];
        default:
          return x - 1;
      }
    });
  };
  var read_payload = function(v2) {
    var pos = 0;
    return function() {
      return v2[pos++];
    };
  };
  var read_compressed_payload = function(bytes) {
    return read_payload(decode_arithmetic(bytes));
  };
  var signed = function(i) {
    return i & 1 ? ~i >> 1 : i >> 1;
  };
  var read_counts = function(n, next) {
    var v2 = Array(n);
    for (var i = 0;i < n; i++)
      v2[i] = 1 + next();
    return v2;
  };
  var read_ascending = function(n, next) {
    var v2 = Array(n);
    for (var i = 0, x = -1;i < n; i++)
      v2[i] = x += 1 + next();
    return v2;
  };
  var read_deltas = function(n, next) {
    var v2 = Array(n);
    for (var i = 0, x = 0;i < n; i++)
      v2[i] = x += signed(next());
    return v2;
  };
  var read_member_array = function(next, lookup) {
    var v2 = read_ascending(next(), next);
    var n = next();
    var vX = read_ascending(n, next);
    var vN = read_counts(n, next);
    for (var i = 0;i < n; i++) {
      for (var j = 0;j < vN[i]; j++) {
        v2.push(vX[i] + j);
      }
    }
    return lookup ? v2.map(function(x) {
      return lookup[x];
    }) : v2;
  };
  var read_mapped_map = function(next) {
    var ret = [];
    while (true) {
      var w = next();
      if (w == 0)
        break;
      ret.push(read_linear_table(w, next));
    }
    while (true) {
      var w = next() - 1;
      if (w < 0)
        break;
      ret.push(read_replacement_table(w, next));
    }
    return fromEntries(flat(ret));
  };
  var read_zero_terminated_array = function(next) {
    var v2 = [];
    while (true) {
      var i = next();
      if (i == 0)
        break;
      v2.push(i);
    }
    return v2;
  };
  var read_transposed = function(n, w, next) {
    var m = Array(n).fill(undefined).map(function() {
      return [];
    });
    for (var i = 0;i < w; i++) {
      read_deltas(n, next).forEach(function(x, j) {
        return m[j].push(x);
      });
    }
    return m;
  };
  var read_linear_table = function(w, next) {
    var dx = 1 + next();
    var dy = next();
    var vN = read_zero_terminated_array(next);
    var m = read_transposed(vN.length, 1 + w, next);
    return flat(m.map(function(v2, i) {
      var x = v2[0], ys = v2.slice(1);
      return Array(vN[i]).fill(undefined).map(function(_2, j) {
        var j_dy = j * dy;
        return [x + j * dx, ys.map(function(y) {
          return y + j_dy;
        })];
      });
    }));
  };
  var read_replacement_table = function(w, next) {
    var n = 1 + next();
    var m = read_transposed(n, 1 + w, next);
    return m.map(function(v2) {
      return [v2[0], v2.slice(1)];
    });
  };
  var read_emoji_trie = function(next) {
    var sorted = read_member_array(next).sort(function(a, b2) {
      return a - b2;
    });
    return read();
    function read() {
      var branches = [];
      while (true) {
        var keys = read_member_array(next, sorted);
        if (keys.length == 0)
          break;
        branches.push({ set: new Set(keys), node: read() });
      }
      branches.sort(function(a, b2) {
        return b2.set.size - a.set.size;
      });
      var temp = next();
      var valid = temp % 3;
      temp = temp / 3 | 0;
      var fe0f = !!(temp & 1);
      temp >>= 1;
      var save = temp == 1;
      var check = temp == 2;
      return { branches, valid, fe0f, save, check };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.read_emoji_trie = exports.read_zero_terminated_array = exports.read_mapped_map = exports.read_member_array = exports.signed = exports.read_compressed_payload = exports.read_payload = exports.decode_arithmetic = undefined;
  exports.decode_arithmetic = decode_arithmetic;
  exports.read_payload = read_payload;
  exports.read_compressed_payload = read_compressed_payload;
  exports.signed = signed;
  exports.read_member_array = read_member_array;
  exports.read_mapped_map = read_mapped_map;
  exports.read_zero_terminated_array = read_zero_terminated_array;
  exports.read_emoji_trie = read_emoji_trie;
});

// node_modules/@ethersproject/hash/lib/ens-normalize/include.js
var require_include = __commonJS((exports) => {
  var getData = function() {
    return (0, decoder_js_1.read_compressed_payload)((0, base64_1.decode)("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getData = undefined;
  var base64_1 = require_lib10();
  var decoder_js_1 = require_decoder();
  exports.getData = getData;
});

// node_modules/@ethersproject/hash/lib/ens-normalize/lib.js
var require_lib11 = __commonJS((exports) => {
  var explode_cp = function(name) {
    return (0, strings_1.toUtf8CodePoints)(name);
  };
  var filter_fe0f = function(cps) {
    return cps.filter(function(cp) {
      return cp != 65039;
    });
  };
  var ens_normalize_post_check = function(name) {
    for (var _i = 0, _a = name.split(".");_i < _a.length; _i++) {
      var label = _a[_i];
      var cps = explode_cp(label);
      try {
        for (var i = cps.lastIndexOf(UNDERSCORE) - 1;i >= 0; i--) {
          if (cps[i] !== UNDERSCORE) {
            throw new Error("underscore only allowed at start");
          }
        }
        if (cps.length >= 4 && cps.every(function(cp) {
          return cp < 128;
        }) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
          throw new Error("invalid label extension");
        }
      } catch (err) {
        throw new Error("Invalid label \"" + label + "\": " + err.message);
      }
    }
    return name;
  };
  var ens_normalize = function(name) {
    return ens_normalize_post_check(normalize(name, filter_fe0f));
  };
  var normalize = function(name, emoji_filter) {
    var input = explode_cp(name).reverse();
    var output = [];
    while (input.length) {
      var emoji = consume_emoji_reversed(input);
      if (emoji) {
        output.push.apply(output, emoji_filter(emoji));
        continue;
      }
      var cp = input.pop();
      if (VALID.has(cp)) {
        output.push(cp);
        continue;
      }
      if (IGNORED.has(cp)) {
        continue;
      }
      var cps = MAPPED[cp];
      if (cps) {
        output.push.apply(output, cps);
        continue;
      }
      throw new Error("Disallowed codepoint: 0x" + cp.toString(16).toUpperCase());
    }
    return ens_normalize_post_check(nfc(String.fromCodePoint.apply(String, output)));
  };
  var nfc = function(s) {
    return s.normalize("NFC");
  };
  var consume_emoji_reversed = function(cps, eaten) {
    var _a;
    var node = EMOJI_ROOT;
    var emoji;
    var saved;
    var stack = [];
    var pos = cps.length;
    if (eaten)
      eaten.length = 0;
    var _loop_1 = function() {
      var cp = cps[--pos];
      node = (_a = node.branches.find(function(x) {
        return x.set.has(cp);
      })) === null || _a === undefined ? undefined : _a.node;
      if (!node)
        return "break";
      if (node.save) {
        saved = cp;
      } else if (node.check) {
        if (cp === saved)
          return "break";
      }
      stack.push(cp);
      if (node.fe0f) {
        stack.push(65039);
        if (pos > 0 && cps[pos - 1] == 65039)
          pos--;
      }
      if (node.valid) {
        emoji = stack.slice();
        if (node.valid == 2)
          emoji.splice(1, 1);
        if (eaten)
          eaten.push.apply(eaten, cps.slice(pos).reverse());
        cps.length = pos;
      }
    };
    while (pos) {
      var state_1 = _loop_1();
      if (state_1 === "break")
        break;
    }
    return emoji;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ens_normalize = exports.ens_normalize_post_check = undefined;
  var strings_1 = require_lib9();
  var include_js_1 = require_include();
  var r = (0, include_js_1.getData)();
  var decoder_js_1 = require_decoder();
  var VALID = new Set((0, decoder_js_1.read_member_array)(r));
  var IGNORED = new Set((0, decoder_js_1.read_member_array)(r));
  var MAPPED = (0, decoder_js_1.read_mapped_map)(r);
  var EMOJI_ROOT = (0, decoder_js_1.read_emoji_trie)(r);
  var HYPHEN = 45;
  var UNDERSCORE = 95;
  exports.ens_normalize_post_check = ens_normalize_post_check;
  exports.ens_normalize = ens_normalize;
});

// node_modules/@ethersproject/hash/lib/namehash.js
var require_namehash = __commonJS((exports) => {
  var checkComponent = function(comp) {
    if (comp.length === 0) {
      throw new Error("invalid ENS name; empty component");
    }
    return comp;
  };
  var ensNameSplit = function(name) {
    var bytes = (0, strings_1.toUtf8Bytes)((0, lib_1.ens_normalize)(name));
    var comps = [];
    if (name.length === 0) {
      return comps;
    }
    var last = 0;
    for (var i = 0;i < bytes.length; i++) {
      var d = bytes[i];
      if (d === 46) {
        comps.push(checkComponent(bytes.slice(last, i)));
        last = i + 1;
      }
    }
    if (last >= bytes.length) {
      throw new Error("invalid ENS name; empty component");
    }
    comps.push(checkComponent(bytes.slice(last)));
    return comps;
  };
  var ensNormalize = function(name) {
    return ensNameSplit(name).map(function(comp) {
      return (0, strings_1.toUtf8String)(comp);
    }).join(".");
  };
  var isValidName = function(name) {
    try {
      return ensNameSplit(name).length !== 0;
    } catch (error) {
    }
    return false;
  };
  var namehash = function(name) {
    if (typeof name !== "string") {
      logger.throwArgumentError("invalid ENS name; not a string", "name", name);
    }
    var result = Zeros;
    var comps = ensNameSplit(name);
    while (comps.length) {
      result = (0, keccak256_1.keccak256)((0, bytes_1.concat)([result, (0, keccak256_1.keccak256)(comps.pop())]));
    }
    return (0, bytes_1.hexlify)(result);
  };
  var dnsEncode = function(name) {
    return (0, bytes_1.hexlify)((0, bytes_1.concat)(ensNameSplit(name).map(function(comp) {
      if (comp.length > 63) {
        throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
      }
      var bytes = new Uint8Array(comp.length + 1);
      bytes.set(comp, 1);
      bytes[0] = bytes.length - 1;
      return bytes;
    }))) + "00";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = undefined;
  var bytes_1 = require_lib2();
  var strings_1 = require_lib9();
  var keccak256_1 = require_lib5();
  var logger_1 = require_lib();
  var _version_1 = require__version9();
  var logger = new logger_1.Logger(_version_1.version);
  var lib_1 = require_lib11();
  var Zeros = new Uint8Array(32);
  Zeros.fill(0);
  exports.ensNormalize = ensNormalize;
  exports.isValidName = isValidName;
  exports.namehash = namehash;
  exports.dnsEncode = dnsEncode;
});

// node_modules/@ethersproject/hash/lib/message.js
var require_message = __commonJS((exports) => {
  var hashMessage = function(message) {
    if (typeof message === "string") {
      message = (0, strings_1.toUtf8Bytes)(message);
    }
    return (0, keccak256_1.keccak256)((0, bytes_1.concat)([
      (0, strings_1.toUtf8Bytes)(exports.messagePrefix),
      (0, strings_1.toUtf8Bytes)(String(message.length)),
      message
    ]));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hashMessage = exports.messagePrefix = undefined;
  var bytes_1 = require_lib2();
  var keccak256_1 = require_lib5();
  var strings_1 = require_lib9();
  exports.messagePrefix = `\x19Ethereum Signed Message:
`;
  exports.hashMessage = hashMessage;
});

// node_modules/@ethersproject/hash/lib/typed-data.js
var require_typed_data = __commonJS((exports) => {
  var hexPadRight = function(value) {
    var bytes = (0, bytes_1.arrayify)(value);
    var padOffset = bytes.length % 32;
    if (padOffset) {
      return (0, bytes_1.hexConcat)([bytes, padding.slice(padOffset)]);
    }
    return (0, bytes_1.hexlify)(bytes);
  };
  var checkString = function(key) {
    return function(value) {
      if (typeof value !== "string") {
        logger.throwArgumentError("invalid domain value for " + JSON.stringify(key), "domain." + key, value);
      }
      return value;
    };
  };
  var getBaseEncoder = function(type) {
    {
      var match = type.match(/^(u?)int(\d*)$/);
      if (match) {
        var signed = match[1] === "";
        var width = parseInt(match[2] || "256");
        if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
          logger.throwArgumentError("invalid numeric width", "type", type);
        }
        var boundsUpper_1 = MaxUint256.mask(signed ? width - 1 : width);
        var boundsLower_1 = signed ? boundsUpper_1.add(One).mul(NegativeOne) : Zero;
        return function(value) {
          var v2 = bignumber_1.BigNumber.from(value);
          if (v2.lt(boundsLower_1) || v2.gt(boundsUpper_1)) {
            logger.throwArgumentError("value out-of-bounds for " + type, "value", value);
          }
          return (0, bytes_1.hexZeroPad)(v2.toTwos(256).toHexString(), 32);
        };
      }
    }
    {
      var match = type.match(/^bytes(\d+)$/);
      if (match) {
        var width_1 = parseInt(match[1]);
        if (width_1 === 0 || width_1 > 32 || match[1] !== String(width_1)) {
          logger.throwArgumentError("invalid bytes width", "type", type);
        }
        return function(value) {
          var bytes = (0, bytes_1.arrayify)(value);
          if (bytes.length !== width_1) {
            logger.throwArgumentError("invalid length for " + type, "value", value);
          }
          return hexPadRight(value);
        };
      }
    }
    switch (type) {
      case "address":
        return function(value) {
          return (0, bytes_1.hexZeroPad)((0, address_1.getAddress)(value), 32);
        };
      case "bool":
        return function(value) {
          return !value ? hexFalse : hexTrue;
        };
      case "bytes":
        return function(value) {
          return (0, keccak256_1.keccak256)(value);
        };
      case "string":
        return function(value) {
          return (0, id_1.id)(value);
        };
    }
    return null;
  };
  var encodeType = function(name, fields) {
    return name + "(" + fields.map(function(_a) {
      var { name: name2, type } = _a;
      return type + " " + name2;
    }).join(",") + ")";
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v2) {
        return step([n, v2]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t[1]) {
                _2.label = t[1];
                t = op;
                break;
              }
              if (t && _2.label < t[2]) {
                _2.label = t[2];
                _2.ops.push(op);
                break;
              }
              if (t[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypedDataEncoder = undefined;
  var address_1 = require_lib7();
  var bignumber_1 = require_lib3();
  var bytes_1 = require_lib2();
  var keccak256_1 = require_lib5();
  var properties_1 = require_lib4();
  var logger_1 = require_lib();
  var _version_1 = require__version9();
  var logger = new logger_1.Logger(_version_1.version);
  var id_1 = require_id();
  var padding = new Uint8Array(32);
  padding.fill(0);
  var NegativeOne = bignumber_1.BigNumber.from(-1);
  var Zero = bignumber_1.BigNumber.from(0);
  var One = bignumber_1.BigNumber.from(1);
  var MaxUint256 = bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var hexTrue = (0, bytes_1.hexZeroPad)(One.toHexString(), 32);
  var hexFalse = (0, bytes_1.hexZeroPad)(Zero.toHexString(), 32);
  var domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
  };
  var domainFieldNames = [
    "name",
    "version",
    "chainId",
    "verifyingContract",
    "salt"
  ];
  var domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function(value) {
      try {
        return bignumber_1.BigNumber.from(value).toString();
      } catch (error) {
      }
      return logger.throwArgumentError("invalid domain value for \"chainId\"", "domain.chainId", value);
    },
    verifyingContract: function(value) {
      try {
        return (0, address_1.getAddress)(value).toLowerCase();
      } catch (error) {
      }
      return logger.throwArgumentError("invalid domain value \"verifyingContract\"", "domain.verifyingContract", value);
    },
    salt: function(value) {
      try {
        var bytes = (0, bytes_1.arrayify)(value);
        if (bytes.length !== 32) {
          throw new Error("bad length");
        }
        return (0, bytes_1.hexlify)(bytes);
      } catch (error) {
      }
      return logger.throwArgumentError("invalid domain value \"salt\"", "domain.salt", value);
    }
  };
  var TypedDataEncoder = function() {
    function TypedDataEncoder2(types) {
      (0, properties_1.defineReadOnly)(this, "types", Object.freeze((0, properties_1.deepCopy)(types)));
      (0, properties_1.defineReadOnly)(this, "_encoderCache", {});
      (0, properties_1.defineReadOnly)(this, "_types", {});
      var links = {};
      var parents = {};
      var subtypes = {};
      Object.keys(types).forEach(function(type) {
        links[type] = {};
        parents[type] = [];
        subtypes[type] = {};
      });
      var _loop_1 = function(name_12) {
        var uniqueNames = {};
        types[name_12].forEach(function(field) {
          if (uniqueNames[field.name]) {
            logger.throwArgumentError("duplicate variable name " + JSON.stringify(field.name) + " in " + JSON.stringify(name_12), "types", types);
          }
          uniqueNames[field.name] = true;
          var baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
          if (baseType === name_12) {
            logger.throwArgumentError("circular type reference to " + JSON.stringify(baseType), "types", types);
          }
          var encoder = getBaseEncoder(baseType);
          if (encoder) {
            return;
          }
          if (!parents[baseType]) {
            logger.throwArgumentError("unknown type " + JSON.stringify(baseType), "types", types);
          }
          parents[baseType].push(name_12);
          links[name_12][baseType] = true;
        });
      };
      for (var name_1 in types) {
        _loop_1(name_1);
      }
      var primaryTypes = Object.keys(parents).filter(function(n) {
        return parents[n].length === 0;
      });
      if (primaryTypes.length === 0) {
        logger.throwArgumentError("missing primary type", "types", types);
      } else if (primaryTypes.length > 1) {
        logger.throwArgumentError("ambiguous primary types or unused types: " + primaryTypes.map(function(t) {
          return JSON.stringify(t);
        }).join(", "), "types", types);
      }
      (0, properties_1.defineReadOnly)(this, "primaryType", primaryTypes[0]);
      function checkCircular(type, found) {
        if (found[type]) {
          logger.throwArgumentError("circular type reference to " + JSON.stringify(type), "types", types);
        }
        found[type] = true;
        Object.keys(links[type]).forEach(function(child) {
          if (!parents[child]) {
            return;
          }
          checkCircular(child, found);
          Object.keys(found).forEach(function(subtype) {
            subtypes[subtype][child] = true;
          });
        });
        delete found[type];
      }
      checkCircular(this.primaryType, {});
      for (var name_2 in subtypes) {
        var st = Object.keys(subtypes[name_2]);
        st.sort();
        this._types[name_2] = encodeType(name_2, types[name_2]) + st.map(function(t) {
          return encodeType(t, types[t]);
        }).join("");
      }
    }
    TypedDataEncoder2.prototype.getEncoder = function(type) {
      var encoder = this._encoderCache[type];
      if (!encoder) {
        encoder = this._encoderCache[type] = this._getEncoder(type);
      }
      return encoder;
    };
    TypedDataEncoder2.prototype._getEncoder = function(type) {
      var _this = this;
      {
        var encoder = getBaseEncoder(type);
        if (encoder) {
          return encoder;
        }
      }
      var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
      if (match) {
        var subtype_1 = match[1];
        var subEncoder_1 = this.getEncoder(subtype_1);
        var length_1 = parseInt(match[3]);
        return function(value) {
          if (length_1 >= 0 && value.length !== length_1) {
            logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
          }
          var result = value.map(subEncoder_1);
          if (_this._types[subtype_1]) {
            result = result.map(keccak256_1.keccak256);
          }
          return (0, keccak256_1.keccak256)((0, bytes_1.hexConcat)(result));
        };
      }
      var fields = this.types[type];
      if (fields) {
        var encodedType_1 = (0, id_1.id)(this._types[type]);
        return function(value) {
          var values = fields.map(function(_a) {
            var { name, type: type2 } = _a;
            var result = _this.getEncoder(type2)(value[name]);
            if (_this._types[type2]) {
              return (0, keccak256_1.keccak256)(result);
            }
            return result;
          });
          values.unshift(encodedType_1);
          return (0, bytes_1.hexConcat)(values);
        };
      }
      return logger.throwArgumentError("unknown type: " + type, "type", type);
    };
    TypedDataEncoder2.prototype.encodeType = function(name) {
      var result = this._types[name];
      if (!result) {
        logger.throwArgumentError("unknown type: " + JSON.stringify(name), "name", name);
      }
      return result;
    };
    TypedDataEncoder2.prototype.encodeData = function(type, value) {
      return this.getEncoder(type)(value);
    };
    TypedDataEncoder2.prototype.hashStruct = function(name, value) {
      return (0, keccak256_1.keccak256)(this.encodeData(name, value));
    };
    TypedDataEncoder2.prototype.encode = function(value) {
      return this.encodeData(this.primaryType, value);
    };
    TypedDataEncoder2.prototype.hash = function(value) {
      return this.hashStruct(this.primaryType, value);
    };
    TypedDataEncoder2.prototype._visit = function(type, value, callback) {
      var _this = this;
      {
        var encoder = getBaseEncoder(type);
        if (encoder) {
          return callback(type, value);
        }
      }
      var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
      if (match) {
        var subtype_2 = match[1];
        var length_2 = parseInt(match[3]);
        if (length_2 >= 0 && value.length !== length_2) {
          logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        return value.map(function(v2) {
          return _this._visit(subtype_2, v2, callback);
        });
      }
      var fields = this.types[type];
      if (fields) {
        return fields.reduce(function(accum, _a) {
          var { name, type: type2 } = _a;
          accum[name] = _this._visit(type2, value[name], callback);
          return accum;
        }, {});
      }
      return logger.throwArgumentError("unknown type: " + type, "type", type);
    };
    TypedDataEncoder2.prototype.visit = function(value, callback) {
      return this._visit(this.primaryType, value, callback);
    };
    TypedDataEncoder2.from = function(types) {
      return new TypedDataEncoder2(types);
    };
    TypedDataEncoder2.getPrimaryType = function(types) {
      return TypedDataEncoder2.from(types).primaryType;
    };
    TypedDataEncoder2.hashStruct = function(name, types, value) {
      return TypedDataEncoder2.from(types).hashStruct(name, value);
    };
    TypedDataEncoder2.hashDomain = function(domain) {
      var domainFields = [];
      for (var name_3 in domain) {
        var type = domainFieldTypes[name_3];
        if (!type) {
          logger.throwArgumentError("invalid typed-data domain key: " + JSON.stringify(name_3), "domain", domain);
        }
        domainFields.push({ name: name_3, type });
      }
      domainFields.sort(function(a, b2) {
        return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b2.name);
      });
      return TypedDataEncoder2.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
    };
    TypedDataEncoder2.encode = function(domain, types, value) {
      return (0, bytes_1.hexConcat)([
        "0x1901",
        TypedDataEncoder2.hashDomain(domain),
        TypedDataEncoder2.from(types).hash(value)
      ]);
    };
    TypedDataEncoder2.hash = function(domain, types, value) {
      return (0, keccak256_1.keccak256)(TypedDataEncoder2.encode(domain, types, value));
    };
    TypedDataEncoder2.resolveNames = function(domain, types, value, resolveName) {
      return __awaiter(this, undefined, undefined, function() {
        var ensCache, encoder, _a, _b, _i, name_4, _c, _d;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              domain = (0, properties_1.shallowCopy)(domain);
              ensCache = {};
              if (domain.verifyingContract && !(0, bytes_1.isHexString)(domain.verifyingContract, 20)) {
                ensCache[domain.verifyingContract] = "0x";
              }
              encoder = TypedDataEncoder2.from(types);
              encoder.visit(value, function(type, value2) {
                if (type === "address" && !(0, bytes_1.isHexString)(value2, 20)) {
                  ensCache[value2] = "0x";
                }
                return value2;
              });
              _a = [];
              for (_b in ensCache)
                _a.push(_b);
              _i = 0;
              _e.label = 1;
            case 1:
              if (!(_i < _a.length))
                return [3, 4];
              name_4 = _a[_i];
              _c = ensCache;
              _d = name_4;
              return [4, resolveName(name_4)];
            case 2:
              _c[_d] = _e.sent();
              _e.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
                domain.verifyingContract = ensCache[domain.verifyingContract];
              }
              value = encoder.visit(value, function(type, value2) {
                if (type === "address" && ensCache[value2]) {
                  return ensCache[value2];
                }
                return value2;
              });
              return [2, { domain, value }];
          }
        });
      });
    };
    TypedDataEncoder2.getPayload = function(domain, types, value) {
      TypedDataEncoder2.hashDomain(domain);
      var domainValues = {};
      var domainTypes = [];
      domainFieldNames.forEach(function(name) {
        var value2 = domain[name];
        if (value2 == null) {
          return;
        }
        domainValues[name] = domainChecks[name](value2);
        domainTypes.push({ name, type: domainFieldTypes[name] });
      });
      var encoder = TypedDataEncoder2.from(types);
      var typesWithDomain = (0, properties_1.shallowCopy)(types);
      if (typesWithDomain.EIP712Domain) {
        logger.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
      } else {
        typesWithDomain.EIP712Domain = domainTypes;
      }
      encoder.encode(value);
      return {
        types: typesWithDomain,
        domain: domainValues,
        primaryType: encoder.primaryType,
        message: encoder.visit(value, function(type, value2) {
          if (type.match(/^bytes(\d*)/)) {
            return (0, bytes_1.hexlify)((0, bytes_1.arrayify)(value2));
          }
          if (type.match(/^u?int/)) {
            return bignumber_1.BigNumber.from(value2).toString();
          }
          switch (type) {
            case "address":
              return value2.toLowerCase();
            case "bool":
              return !!value2;
            case "string":
              if (typeof value2 !== "string") {
                logger.throwArgumentError("invalid string", "value", value2);
              }
              return value2;
          }
          return logger.throwArgumentError("unsupported type", "type", type);
        })
      };
    };
    return TypedDataEncoder2;
  }();
  exports.TypedDataEncoder = TypedDataEncoder;
});

// node_modules/@ethersproject/hash/lib/index.js
var require_lib12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._TypedDataEncoder = exports.hashMessage = exports.messagePrefix = exports.ensNormalize = exports.isValidName = exports.namehash = exports.dnsEncode = exports.id = undefined;
  var id_1 = require_id();
  Object.defineProperty(exports, "id", { enumerable: true, get: function() {
    return id_1.id;
  } });
  var namehash_1 = require_namehash();
  Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
    return namehash_1.dnsEncode;
  } });
  Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
    return namehash_1.isValidName;
  } });
  Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
    return namehash_1.namehash;
  } });
  var message_1 = require_message();
  Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
    return message_1.hashMessage;
  } });
  Object.defineProperty(exports, "messagePrefix", { enumerable: true, get: function() {
    return message_1.messagePrefix;
  } });
  var namehash_2 = require_namehash();
  Object.defineProperty(exports, "ensNormalize", { enumerable: true, get: function() {
    return namehash_2.ensNormalize;
  } });
  var typed_data_1 = require_typed_data();
  Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
    return typed_data_1.TypedDataEncoder;
  } });
});

// node_modules/@ethersproject/abi/lib/interface.js
var require_interface = __commonJS((exports) => {
  var wrapAccessError = function(property, error) {
    var wrap = new Error("deferred error during ABI decoding triggered accessing " + property);
    wrap.error = error;
    return wrap;
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.checkResultErrors = undefined;
  var address_1 = require_lib7();
  var bignumber_1 = require_lib3();
  var bytes_1 = require_lib2();
  var hash_1 = require_lib12();
  var keccak256_1 = require_lib5();
  var properties_1 = require_lib4();
  var abi_coder_1 = require_abi_coder();
  var abstract_coder_1 = require_abstract_coder();
  Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
    return abstract_coder_1.checkResultErrors;
  } });
  var fragments_1 = require_fragments();
  var logger_1 = require_lib();
  var _version_1 = require__version5();
  var logger = new logger_1.Logger(_version_1.version);
  var LogDescription = function(_super) {
    __extends(LogDescription2, _super);
    function LogDescription2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return LogDescription2;
  }(properties_1.Description);
  exports.LogDescription = LogDescription;
  var TransactionDescription = function(_super) {
    __extends(TransactionDescription2, _super);
    function TransactionDescription2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return TransactionDescription2;
  }(properties_1.Description);
  exports.TransactionDescription = TransactionDescription;
  var ErrorDescription = function(_super) {
    __extends(ErrorDescription2, _super);
    function ErrorDescription2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return ErrorDescription2;
  }(properties_1.Description);
  exports.ErrorDescription = ErrorDescription;
  var Indexed = function(_super) {
    __extends(Indexed2, _super);
    function Indexed2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Indexed2.isIndexed = function(value) {
      return !!(value && value._isIndexed);
    };
    return Indexed2;
  }(properties_1.Description);
  exports.Indexed = Indexed;
  var BuiltinErrors = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
  };
  var Interface = function() {
    function Interface2(fragments) {
      var _newTarget = this.constructor;
      var _this = this;
      var abi = [];
      if (typeof fragments === "string") {
        abi = JSON.parse(fragments);
      } else {
        abi = fragments;
      }
      (0, properties_1.defineReadOnly)(this, "fragments", abi.map(function(fragment) {
        return fragments_1.Fragment.from(fragment);
      }).filter(function(fragment) {
        return fragment != null;
      }));
      (0, properties_1.defineReadOnly)(this, "_abiCoder", (0, properties_1.getStatic)(_newTarget, "getAbiCoder")());
      (0, properties_1.defineReadOnly)(this, "functions", {});
      (0, properties_1.defineReadOnly)(this, "errors", {});
      (0, properties_1.defineReadOnly)(this, "events", {});
      (0, properties_1.defineReadOnly)(this, "structs", {});
      this.fragments.forEach(function(fragment) {
        var bucket = null;
        switch (fragment.type) {
          case "constructor":
            if (_this.deploy) {
              logger.warn("duplicate definition - constructor");
              return;
            }
            (0, properties_1.defineReadOnly)(_this, "deploy", fragment);
            return;
          case "function":
            bucket = _this.functions;
            break;
          case "event":
            bucket = _this.events;
            break;
          case "error":
            bucket = _this.errors;
            break;
          default:
            return;
        }
        var signature = fragment.format();
        if (bucket[signature]) {
          logger.warn("duplicate definition - " + signature);
          return;
        }
        bucket[signature] = fragment;
      });
      if (!this.deploy) {
        (0, properties_1.defineReadOnly)(this, "deploy", fragments_1.ConstructorFragment.from({
          payable: false,
          type: "constructor"
        }));
      }
      (0, properties_1.defineReadOnly)(this, "_isInterface", true);
    }
    Interface2.prototype.format = function(format) {
      if (!format) {
        format = fragments_1.FormatTypes.full;
      }
      if (format === fragments_1.FormatTypes.sighash) {
        logger.throwArgumentError("interface does not support formatting sighash", "format", format);
      }
      var abi = this.fragments.map(function(fragment) {
        return fragment.format(format);
      });
      if (format === fragments_1.FormatTypes.json) {
        return JSON.stringify(abi.map(function(j) {
          return JSON.parse(j);
        }));
      }
      return abi;
    };
    Interface2.getAbiCoder = function() {
      return abi_coder_1.defaultAbiCoder;
    };
    Interface2.getAddress = function(address) {
      return (0, address_1.getAddress)(address);
    };
    Interface2.getSighash = function(fragment) {
      return (0, bytes_1.hexDataSlice)((0, hash_1.id)(fragment.format()), 0, 4);
    };
    Interface2.getEventTopic = function(eventFragment) {
      return (0, hash_1.id)(eventFragment.format());
    };
    Interface2.prototype.getFunction = function(nameOrSignatureOrSighash) {
      if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {
        for (var name_1 in this.functions) {
          if (nameOrSignatureOrSighash === this.getSighash(name_1)) {
            return this.functions[name_1];
          }
        }
        logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
      }
      if (nameOrSignatureOrSighash.indexOf("(") === -1) {
        var name_2 = nameOrSignatureOrSighash.trim();
        var matching = Object.keys(this.functions).filter(function(f) {
          return f.split("(")[0] === name_2;
        });
        if (matching.length === 0) {
          logger.throwArgumentError("no matching function", "name", name_2);
        } else if (matching.length > 1) {
          logger.throwArgumentError("multiple matching functions", "name", name_2);
        }
        return this.functions[matching[0]];
      }
      var result = this.functions[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
      if (!result) {
        logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
      }
      return result;
    };
    Interface2.prototype.getEvent = function(nameOrSignatureOrTopic) {
      if ((0, bytes_1.isHexString)(nameOrSignatureOrTopic)) {
        var topichash = nameOrSignatureOrTopic.toLowerCase();
        for (var name_3 in this.events) {
          if (topichash === this.getEventTopic(name_3)) {
            return this.events[name_3];
          }
        }
        logger.throwArgumentError("no matching event", "topichash", topichash);
      }
      if (nameOrSignatureOrTopic.indexOf("(") === -1) {
        var name_4 = nameOrSignatureOrTopic.trim();
        var matching = Object.keys(this.events).filter(function(f) {
          return f.split("(")[0] === name_4;
        });
        if (matching.length === 0) {
          logger.throwArgumentError("no matching event", "name", name_4);
        } else if (matching.length > 1) {
          logger.throwArgumentError("multiple matching events", "name", name_4);
        }
        return this.events[matching[0]];
      }
      var result = this.events[fragments_1.EventFragment.fromString(nameOrSignatureOrTopic).format()];
      if (!result) {
        logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
      }
      return result;
    };
    Interface2.prototype.getError = function(nameOrSignatureOrSighash) {
      if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {
        var getSighash = (0, properties_1.getStatic)(this.constructor, "getSighash");
        for (var name_5 in this.errors) {
          var error = this.errors[name_5];
          if (nameOrSignatureOrSighash === getSighash(error)) {
            return this.errors[name_5];
          }
        }
        logger.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
      }
      if (nameOrSignatureOrSighash.indexOf("(") === -1) {
        var name_6 = nameOrSignatureOrSighash.trim();
        var matching = Object.keys(this.errors).filter(function(f) {
          return f.split("(")[0] === name_6;
        });
        if (matching.length === 0) {
          logger.throwArgumentError("no matching error", "name", name_6);
        } else if (matching.length > 1) {
          logger.throwArgumentError("multiple matching errors", "name", name_6);
        }
        return this.errors[matching[0]];
      }
      var result = this.errors[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
      if (!result) {
        logger.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
      }
      return result;
    };
    Interface2.prototype.getSighash = function(fragment) {
      if (typeof fragment === "string") {
        try {
          fragment = this.getFunction(fragment);
        } catch (error) {
          try {
            fragment = this.getError(fragment);
          } catch (_2) {
            throw error;
          }
        }
      }
      return (0, properties_1.getStatic)(this.constructor, "getSighash")(fragment);
    };
    Interface2.prototype.getEventTopic = function(eventFragment) {
      if (typeof eventFragment === "string") {
        eventFragment = this.getEvent(eventFragment);
      }
      return (0, properties_1.getStatic)(this.constructor, "getEventTopic")(eventFragment);
    };
    Interface2.prototype._decodeParams = function(params, data) {
      return this._abiCoder.decode(params, data);
    };
    Interface2.prototype._encodeParams = function(params, values) {
      return this._abiCoder.encode(params, values);
    };
    Interface2.prototype.encodeDeploy = function(values) {
      return this._encodeParams(this.deploy.inputs, values || []);
    };
    Interface2.prototype.decodeErrorResult = function(fragment, data) {
      if (typeof fragment === "string") {
        fragment = this.getError(fragment);
      }
      var bytes = (0, bytes_1.arrayify)(data);
      if ((0, bytes_1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
        logger.throwArgumentError("data signature does not match error " + fragment.name + ".", "data", (0, bytes_1.hexlify)(bytes));
      }
      return this._decodeParams(fragment.inputs, bytes.slice(4));
    };
    Interface2.prototype.encodeErrorResult = function(fragment, values) {
      if (typeof fragment === "string") {
        fragment = this.getError(fragment);
      }
      return (0, bytes_1.hexlify)((0, bytes_1.concat)([
        this.getSighash(fragment),
        this._encodeParams(fragment.inputs, values || [])
      ]));
    };
    Interface2.prototype.decodeFunctionData = function(functionFragment, data) {
      if (typeof functionFragment === "string") {
        functionFragment = this.getFunction(functionFragment);
      }
      var bytes = (0, bytes_1.arrayify)(data);
      if ((0, bytes_1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
        logger.throwArgumentError("data signature does not match function " + functionFragment.name + ".", "data", (0, bytes_1.hexlify)(bytes));
      }
      return this._decodeParams(functionFragment.inputs, bytes.slice(4));
    };
    Interface2.prototype.encodeFunctionData = function(functionFragment, values) {
      if (typeof functionFragment === "string") {
        functionFragment = this.getFunction(functionFragment);
      }
      return (0, bytes_1.hexlify)((0, bytes_1.concat)([
        this.getSighash(functionFragment),
        this._encodeParams(functionFragment.inputs, values || [])
      ]));
    };
    Interface2.prototype.decodeFunctionResult = function(functionFragment, data) {
      if (typeof functionFragment === "string") {
        functionFragment = this.getFunction(functionFragment);
      }
      var bytes = (0, bytes_1.arrayify)(data);
      var reason = null;
      var message = "";
      var errorArgs = null;
      var errorName = null;
      var errorSignature = null;
      switch (bytes.length % this._abiCoder._getWordSize()) {
        case 0:
          try {
            return this._abiCoder.decode(functionFragment.outputs, bytes);
          } catch (error2) {
          }
          break;
        case 4: {
          var selector = (0, bytes_1.hexlify)(bytes.slice(0, 4));
          var builtin = BuiltinErrors[selector];
          if (builtin) {
            errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
            errorName = builtin.name;
            errorSignature = builtin.signature;
            if (builtin.reason) {
              reason = errorArgs[0];
            }
            if (errorName === "Error") {
              message = "; VM Exception while processing transaction: reverted with reason string " + JSON.stringify(errorArgs[0]);
            } else if (errorName === "Panic") {
              message = "; VM Exception while processing transaction: reverted with panic code " + errorArgs[0];
            }
          } else {
            try {
              var error = this.getError(selector);
              errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
              errorName = error.name;
              errorSignature = error.format();
            } catch (error2) {
            }
          }
          break;
        }
      }
      return logger.throwError("call revert exception" + message, logger_1.Logger.errors.CALL_EXCEPTION, {
        method: functionFragment.format(),
        data: (0, bytes_1.hexlify)(data),
        errorArgs,
        errorName,
        errorSignature,
        reason
      });
    };
    Interface2.prototype.encodeFunctionResult = function(functionFragment, values) {
      if (typeof functionFragment === "string") {
        functionFragment = this.getFunction(functionFragment);
      }
      return (0, bytes_1.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));
    };
    Interface2.prototype.encodeFilterTopics = function(eventFragment, values) {
      var _this = this;
      if (typeof eventFragment === "string") {
        eventFragment = this.getEvent(eventFragment);
      }
      if (values.length > eventFragment.inputs.length) {
        logger.throwError("too many arguments for " + eventFragment.format(), logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {
          argument: "values",
          value: values
        });
      }
      var topics = [];
      if (!eventFragment.anonymous) {
        topics.push(this.getEventTopic(eventFragment));
      }
      var encodeTopic = function(param, value) {
        if (param.type === "string") {
          return (0, hash_1.id)(value);
        } else if (param.type === "bytes") {
          return (0, keccak256_1.keccak256)((0, bytes_1.hexlify)(value));
        }
        if (param.type === "bool" && typeof value === "boolean") {
          value = value ? "0x01" : "0x00";
        }
        if (param.type.match(/^u?int/)) {
          value = bignumber_1.BigNumber.from(value).toHexString();
        }
        if (param.type === "address") {
          _this._abiCoder.encode(["address"], [value]);
        }
        return (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(value), 32);
      };
      values.forEach(function(value, index) {
        var param = eventFragment.inputs[index];
        if (!param.indexed) {
          if (value != null) {
            logger.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
          }
          return;
        }
        if (value == null) {
          topics.push(null);
        } else if (param.baseType === "array" || param.baseType === "tuple") {
          logger.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
        } else if (Array.isArray(value)) {
          topics.push(value.map(function(value2) {
            return encodeTopic(param, value2);
          }));
        } else {
          topics.push(encodeTopic(param, value));
        }
      });
      while (topics.length && topics[topics.length - 1] === null) {
        topics.pop();
      }
      return topics;
    };
    Interface2.prototype.encodeEventLog = function(eventFragment, values) {
      var _this = this;
      if (typeof eventFragment === "string") {
        eventFragment = this.getEvent(eventFragment);
      }
      var topics = [];
      var dataTypes = [];
      var dataValues = [];
      if (!eventFragment.anonymous) {
        topics.push(this.getEventTopic(eventFragment));
      }
      if (values.length !== eventFragment.inputs.length) {
        logger.throwArgumentError("event arguments/values mismatch", "values", values);
      }
      eventFragment.inputs.forEach(function(param, index) {
        var value = values[index];
        if (param.indexed) {
          if (param.type === "string") {
            topics.push((0, hash_1.id)(value));
          } else if (param.type === "bytes") {
            topics.push((0, keccak256_1.keccak256)(value));
          } else if (param.baseType === "tuple" || param.baseType === "array") {
            throw new Error("not implemented");
          } else {
            topics.push(_this._abiCoder.encode([param.type], [value]));
          }
        } else {
          dataTypes.push(param);
          dataValues.push(value);
        }
      });
      return {
        data: this._abiCoder.encode(dataTypes, dataValues),
        topics
      };
    };
    Interface2.prototype.decodeEventLog = function(eventFragment, data, topics) {
      if (typeof eventFragment === "string") {
        eventFragment = this.getEvent(eventFragment);
      }
      if (topics != null && !eventFragment.anonymous) {
        var topicHash = this.getEventTopic(eventFragment);
        if (!(0, bytes_1.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
          logger.throwError("fragment/topic mismatch", logger_1.Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
        }
        topics = topics.slice(1);
      }
      var indexed = [];
      var nonIndexed = [];
      var dynamic = [];
      eventFragment.inputs.forEach(function(param, index) {
        if (param.indexed) {
          if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
            indexed.push(fragments_1.ParamType.fromObject({ type: "bytes32", name: param.name }));
            dynamic.push(true);
          } else {
            indexed.push(param);
            dynamic.push(false);
          }
        } else {
          nonIndexed.push(param);
          dynamic.push(false);
        }
      });
      var resultIndexed = topics != null ? this._abiCoder.decode(indexed, (0, bytes_1.concat)(topics)) : null;
      var resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
      var result = [];
      var nonIndexedIndex = 0, indexedIndex = 0;
      eventFragment.inputs.forEach(function(param, index) {
        if (param.indexed) {
          if (resultIndexed == null) {
            result[index] = new Indexed({ _isIndexed: true, hash: null });
          } else if (dynamic[index]) {
            result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
          } else {
            try {
              result[index] = resultIndexed[indexedIndex++];
            } catch (error) {
              result[index] = error;
            }
          }
        } else {
          try {
            result[index] = resultNonIndexed[nonIndexedIndex++];
          } catch (error) {
            result[index] = error;
          }
        }
        if (param.name && result[param.name] == null) {
          var value_1 = result[index];
          if (value_1 instanceof Error) {
            Object.defineProperty(result, param.name, {
              enumerable: true,
              get: function() {
                throw wrapAccessError("property " + JSON.stringify(param.name), value_1);
              }
            });
          } else {
            result[param.name] = value_1;
          }
        }
      });
      var _loop_1 = function(i2) {
        var value = result[i2];
        if (value instanceof Error) {
          Object.defineProperty(result, i2, {
            enumerable: true,
            get: function() {
              throw wrapAccessError("index " + i2, value);
            }
          });
        }
      };
      for (var i = 0;i < result.length; i++) {
        _loop_1(i);
      }
      return Object.freeze(result);
    };
    Interface2.prototype.parseTransaction = function(tx) {
      var fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
      if (!fragment) {
        return null;
      }
      return new TransactionDescription({
        args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
        functionFragment: fragment,
        name: fragment.name,
        signature: fragment.format(),
        sighash: this.getSighash(fragment),
        value: bignumber_1.BigNumber.from(tx.value || "0")
      });
    };
    Interface2.prototype.parseLog = function(log) {
      var fragment = this.getEvent(log.topics[0]);
      if (!fragment || fragment.anonymous) {
        return null;
      }
      return new LogDescription({
        eventFragment: fragment,
        name: fragment.name,
        signature: fragment.format(),
        topic: this.getEventTopic(fragment),
        args: this.decodeEventLog(fragment, log.data, log.topics)
      });
    };
    Interface2.prototype.parseError = function(data) {
      var hexData = (0, bytes_1.hexlify)(data);
      var fragment = this.getError(hexData.substring(0, 10).toLowerCase());
      if (!fragment) {
        return null;
      }
      return new ErrorDescription({
        args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
        errorFragment: fragment,
        name: fragment.name,
        signature: fragment.format(),
        sighash: this.getSighash(fragment)
      });
    };
    Interface2.isInterface = function(value) {
      return !!(value && value._isInterface);
    };
    return Interface2;
  }();
  exports.Interface = Interface;
});

// node_modules/@ethersproject/abi/lib/index.js
var require_lib13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransactionDescription = exports.LogDescription = exports.checkResultErrors = exports.Indexed = exports.Interface = exports.defaultAbiCoder = exports.AbiCoder = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.Fragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = undefined;
  var fragments_1 = require_fragments();
  Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
    return fragments_1.ConstructorFragment;
  } });
  Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
    return fragments_1.ErrorFragment;
  } });
  Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
    return fragments_1.EventFragment;
  } });
  Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
    return fragments_1.FormatTypes;
  } });
  Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
    return fragments_1.Fragment;
  } });
  Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
    return fragments_1.FunctionFragment;
  } });
  Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
    return fragments_1.ParamType;
  } });
  var abi_coder_1 = require_abi_coder();
  Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
    return abi_coder_1.AbiCoder;
  } });
  Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
    return abi_coder_1.defaultAbiCoder;
  } });
  var interface_1 = require_interface();
  Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
    return interface_1.checkResultErrors;
  } });
  Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
    return interface_1.Indexed;
  } });
  Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
    return interface_1.Interface;
  } });
  Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
    return interface_1.LogDescription;
  } });
  Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
    return interface_1.TransactionDescription;
  } });
});

// node_modules/@ethersproject/basex/lib/index.js
var require_lib14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Base58 = exports.Base32 = exports.BaseX = undefined;
  var bytes_1 = require_lib2();
  var properties_1 = require_lib4();
  var BaseX = function() {
    function BaseX2(alphabet) {
      (0, properties_1.defineReadOnly)(this, "alphabet", alphabet);
      (0, properties_1.defineReadOnly)(this, "base", alphabet.length);
      (0, properties_1.defineReadOnly)(this, "_alphabetMap", {});
      (0, properties_1.defineReadOnly)(this, "_leader", alphabet.charAt(0));
      for (var i = 0;i < alphabet.length; i++) {
        this._alphabetMap[alphabet.charAt(i)] = i;
      }
    }
    BaseX2.prototype.encode = function(value) {
      var source = (0, bytes_1.arrayify)(value);
      if (source.length === 0) {
        return "";
      }
      var digits = [0];
      for (var i = 0;i < source.length; ++i) {
        var carry = source[i];
        for (var j = 0;j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % this.base;
          carry = carry / this.base | 0;
        }
        while (carry > 0) {
          digits.push(carry % this.base);
          carry = carry / this.base | 0;
        }
      }
      var string = "";
      for (var k = 0;source[k] === 0 && k < source.length - 1; ++k) {
        string += this._leader;
      }
      for (var q = digits.length - 1;q >= 0; --q) {
        string += this.alphabet[digits[q]];
      }
      return string;
    };
    BaseX2.prototype.decode = function(value) {
      if (typeof value !== "string") {
        throw new TypeError("Expected String");
      }
      var bytes = [];
      if (value.length === 0) {
        return new Uint8Array(bytes);
      }
      bytes.push(0);
      for (var i = 0;i < value.length; i++) {
        var byte = this._alphabetMap[value[i]];
        if (byte === undefined) {
          throw new Error("Non-base" + this.base + " character");
        }
        var carry = byte;
        for (var j = 0;j < bytes.length; ++j) {
          carry += bytes[j] * this.base;
          bytes[j] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k = 0;value[k] === this._leader && k < value.length - 1; ++k) {
        bytes.push(0);
      }
      return (0, bytes_1.arrayify)(new Uint8Array(bytes.reverse()));
    };
    return BaseX2;
  }();
  exports.BaseX = BaseX;
  var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
  exports.Base32 = Base32;
  var Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  exports.Base58 = Base58;
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS((exports, module) => {
  var assert = function(val, msg) {
    if (!val)
      throw new Error(msg || "Assertion failed");
  };
  module.exports = assert;
  assert.equal = function assertEqual(l, r, msg) {
    if (l != r)
      throw new Error(msg || "Assertion failed: " + l + " != " + r);
  };
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils = __commonJS((exports) => {
  var isSurrogatePair = function(msg, i) {
    if ((msg.charCodeAt(i) & 64512) !== 55296) {
      return false;
    }
    if (i < 0 || i + 1 >= msg.length) {
      return false;
    }
    return (msg.charCodeAt(i + 1) & 64512) === 56320;
  };
  var toArray = function(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === "string") {
      if (!enc) {
        var p = 0;
        for (var i = 0;i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          if (c < 128) {
            res[p++] = c;
          } else if (c < 2048) {
            res[p++] = c >> 6 | 192;
            res[p++] = c & 63 | 128;
          } else if (isSurrogatePair(msg, i)) {
            c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
            res[p++] = c >> 18 | 240;
            res[p++] = c >> 12 & 63 | 128;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          } else {
            res[p++] = c >> 12 | 224;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          }
        }
      } else if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (i = 0;i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      }
    } else {
      for (i = 0;i < msg.length; i++)
        res[i] = msg[i] | 0;
    }
    return res;
  };
  var toHex = function(msg) {
    var res = "";
    for (var i = 0;i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  };
  var htonl = function(w) {
    var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
    return res >>> 0;
  };
  var toHex32 = function(msg, endian) {
    var res = "";
    for (var i = 0;i < msg.length; i++) {
      var w = msg[i];
      if (endian === "little")
        w = htonl(w);
      res += zero8(w.toString(16));
    }
    return res;
  };
  var zero2 = function(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  };
  var zero8 = function(word) {
    if (word.length === 7)
      return "0" + word;
    else if (word.length === 6)
      return "00" + word;
    else if (word.length === 5)
      return "000" + word;
    else if (word.length === 4)
      return "0000" + word;
    else if (word.length === 3)
      return "00000" + word;
    else if (word.length === 2)
      return "000000" + word;
    else if (word.length === 1)
      return "0000000" + word;
    else
      return word;
  };
  var join32 = function(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i = 0, k = start;i < res.length; i++, k += 4) {
      var w;
      if (endian === "big")
        w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
      else
        w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
      res[i] = w >>> 0;
    }
    return res;
  };
  var split32 = function(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i = 0, k = 0;i < msg.length; i++, k += 4) {
      var m = msg[i];
      if (endian === "big") {
        res[k] = m >>> 24;
        res[k + 1] = m >>> 16 & 255;
        res[k + 2] = m >>> 8 & 255;
        res[k + 3] = m & 255;
      } else {
        res[k + 3] = m >>> 24;
        res[k + 2] = m >>> 16 & 255;
        res[k + 1] = m >>> 8 & 255;
        res[k] = m & 255;
      }
    }
    return res;
  };
  var rotr32 = function(w, b2) {
    return w >>> b2 | w << 32 - b2;
  };
  var rotl32 = function(w, b2) {
    return w << b2 | w >>> 32 - b2;
  };
  var sum32 = function(a, b2) {
    return a + b2 >>> 0;
  };
  var sum32_3 = function(a, b2, c) {
    return a + b2 + c >>> 0;
  };
  var sum32_4 = function(a, b2, c, d) {
    return a + b2 + c + d >>> 0;
  };
  var sum32_5 = function(a, b2, c, d, e) {
    return a + b2 + c + d + e >>> 0;
  };
  var sum64 = function(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  };
  var sum64_hi = function(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  };
  var sum64_lo = function(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  };
  var sum64_4_hi = function(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  };
  var sum64_4_lo = function(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  };
  var sum64_5_hi = function(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  };
  var sum64_5_lo = function(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
  };
  var rotr64_hi = function(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
  };
  var rotr64_lo = function(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  };
  var shr64_hi = function(ah, al, num) {
    return ah >>> num;
  };
  var shr64_lo = function(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  };
  var assert = require_minimalistic_assert();
  var inherits = require_inherits_browser();
  exports.inherits = inherits;
  exports.toArray = toArray;
  exports.toHex = toHex;
  exports.htonl = htonl;
  exports.toHex32 = toHex32;
  exports.zero2 = zero2;
  exports.zero8 = zero8;
  exports.join32 = join32;
  exports.split32 = split32;
  exports.rotr32 = rotr32;
  exports.rotl32 = rotl32;
  exports.sum32 = sum32;
  exports.sum32_3 = sum32_3;
  exports.sum32_4 = sum32_4;
  exports.sum32_5 = sum32_5;
  exports.sum64 = sum64;
  exports.sum64_hi = sum64_hi;
  exports.sum64_lo = sum64_lo;
  exports.sum64_4_hi = sum64_4_hi;
  exports.sum64_4_lo = sum64_4_lo;
  exports.sum64_5_hi = sum64_5_hi;
  exports.sum64_5_lo = sum64_5_lo;
  exports.rotr64_hi = rotr64_hi;
  exports.rotr64_lo = rotr64_lo;
  exports.shr64_hi = shr64_hi;
  exports.shr64_lo = shr64_lo;
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS((exports) => {
  var BlockHash = function() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  };
  var utils = require_utils();
  var assert = require_minimalistic_assert();
  exports.BlockHash = BlockHash;
  BlockHash.prototype.update = function update(msg, enc) {
    msg = utils.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
      msg = utils.join32(msg, 0, msg.length - r, this.endian);
      for (var i = 0;i < msg.length; i += this._delta32)
        this._update(msg, i, i + this._delta32);
    }
    return this;
  };
  BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
  };
  BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 128;
    for (var i = 1;i < k; i++)
      res[i] = 0;
    len <<= 3;
    if (this.endian === "big") {
      for (var t = 8;t < this.padLength; t++)
        res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = len >>> 24 & 255;
      res[i++] = len >>> 16 & 255;
      res[i++] = len >>> 8 & 255;
      res[i++] = len & 255;
    } else {
      res[i++] = len & 255;
      res[i++] = len >>> 8 & 255;
      res[i++] = len >>> 16 & 255;
      res[i++] = len >>> 24 & 255;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      for (t = 8;t < this.padLength; t++)
        res[i++] = 0;
    }
    return res;
  };
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS((exports) => {
  var ft_1 = function(s, x, y, z2) {
    if (s === 0)
      return ch32(x, y, z2);
    if (s === 1 || s === 3)
      return p32(x, y, z2);
    if (s === 2)
      return maj32(x, y, z2);
  };
  var ch32 = function(x, y, z2) {
    return x & y ^ ~x & z2;
  };
  var maj32 = function(x, y, z2) {
    return x & y ^ x & z2 ^ y & z2;
  };
  var p32 = function(x, y, z2) {
    return x ^ y ^ z2;
  };
  var s0_256 = function(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
  };
  var s1_256 = function(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
  };
  var g0_256 = function(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
  };
  var g1_256 = function(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
  };
  var utils = require_utils();
  var rotr32 = utils.rotr32;
  exports.ft_1 = ft_1;
  exports.ch32 = ch32;
  exports.maj32 = maj32;
  exports.p32 = p32;
  exports.s0_256 = s0_256;
  exports.s1_256 = s1_256;
  exports.g0_256 = g0_256;
  exports.g1_256 = g1_256;
});

// node_modules/hash.js/lib/hash/sha/1.js
var require_1 = __commonJS((exports, module) => {
  var SHA1 = function() {
    if (!(this instanceof SHA1))
      return new SHA1;
    BlockHash.call(this);
    this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ];
    this.W = new Array(80);
  };
  var utils = require_utils();
  var common = require_common();
  var shaCommon = require_common2();
  var rotl32 = utils.rotl32;
  var sum32 = utils.sum32;
  var sum32_5 = utils.sum32_5;
  var ft_1 = shaCommon.ft_1;
  var BlockHash = common.BlockHash;
  var sha1_K = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  utils.inherits(SHA1, BlockHash);
  module.exports = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0;i < 16; i++)
      W[i] = msg[start + i];
    for (;i < W.length; i++)
      W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b2 = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for (i = 0;i < W.length; i++) {
      var s = ~~(i / 20);
      var t = sum32_5(rotl32(a, 5), ft_1(s, b2, c, d), e, W[i], sha1_K[s]);
      e = d;
      d = c;
      c = rotl32(b2, 30);
      b2 = a;
      a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b2);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils.toHex32(this.h, "big");
    else
      return utils.split32(this.h, "big");
  };
});

// node_modules/hash.js/lib/hash/sha/256.js
var require_256 = __commonJS((exports, module) => {
  var SHA256 = function() {
    if (!(this instanceof SHA256))
      return new SHA256;
    BlockHash.call(this);
    this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    this.k = sha256_K;
    this.W = new Array(64);
  };
  var utils = require_utils();
  var common = require_common();
  var shaCommon = require_common2();
  var assert = require_minimalistic_assert();
  var sum32 = utils.sum32;
  var sum32_4 = utils.sum32_4;
  var sum32_5 = utils.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;
  var BlockHash = common.BlockHash;
  var sha256_K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  utils.inherits(SHA256, BlockHash);
  module.exports = SHA256;
  SHA256.blockSize = 512;
  SHA256.outSize = 256;
  SHA256.hmacStrength = 192;
  SHA256.padLength = 64;
  SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0;i < 16; i++)
      W[i] = msg[start + i];
    for (;i < W.length; i++)
      W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b2 = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert(this.k.length === W.length);
    for (i = 0;i < W.length; i++) {
      var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
      var T2 = sum32(s0_256(a), maj32(a, b2, c));
      h = g;
      g = f;
      f = e;
      e = sum32(d, T1);
      d = c;
      c = b2;
      b2 = a;
      a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b2);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
  };
  SHA256.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils.toHex32(this.h, "big");
    else
      return utils.split32(this.h, "big");
  };
});

// node_modules/hash.js/lib/hash/sha/224.js
var require_224 = __commonJS((exports, module) => {
  var SHA224 = function() {
    if (!(this instanceof SHA224))
      return new SHA224;
    SHA256.call(this);
    this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  };
  var utils = require_utils();
  var SHA256 = require_256();
  utils.inherits(SHA224, SHA256);
  module.exports = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  SHA224.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils.toHex32(this.h.slice(0, 7), "big");
    else
      return utils.split32(this.h.slice(0, 7), "big");
  };
});

// node_modules/hash.js/lib/hash/sha/512.js
var require_512 = __commonJS((exports, module) => {
  var SHA512 = function() {
    if (!(this instanceof SHA512))
      return new SHA512;
    BlockHash.call(this);
    this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ];
    this.k = sha512_K;
    this.W = new Array(160);
  };
  var ch64_hi = function(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ ~xh & zh;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var ch64_lo = function(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var maj64_hi = function(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var maj64_lo = function(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var s0_512_hi = function(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);
    var c2_hi = rotr64_hi(xl, xh, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var s0_512_lo = function(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);
    var c2_lo = rotr64_lo(xl, xh, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var s1_512_hi = function(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var s1_512_lo = function(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var g0_512_hi = function(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var g0_512_lo = function(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var g1_512_hi = function(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var g1_512_lo = function(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  };
  var utils = require_utils();
  var common = require_common();
  var assert = require_minimalistic_assert();
  var rotr64_hi = utils.rotr64_hi;
  var rotr64_lo = utils.rotr64_lo;
  var shr64_hi = utils.shr64_hi;
  var shr64_lo = utils.shr64_lo;
  var sum64 = utils.sum64;
  var sum64_hi = utils.sum64_hi;
  var sum64_lo = utils.sum64_lo;
  var sum64_4_hi = utils.sum64_4_hi;
  var sum64_4_lo = utils.sum64_4_lo;
  var sum64_5_hi = utils.sum64_5_hi;
  var sum64_5_lo = utils.sum64_5_lo;
  var BlockHash = common.BlockHash;
  var sha512_K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  utils.inherits(SHA512, BlockHash);
  module.exports = SHA512;
  SHA512.blockSize = 1024;
  SHA512.outSize = 512;
  SHA512.hmacStrength = 192;
  SHA512.padLength = 128;
  SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    for (var i = 0;i < 32; i++)
      W[i] = msg[start + i];
    for (;i < W.length; i += 2) {
      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      var c1_hi = W[i - 14];
      var c1_lo = W[i - 13];
      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      var c3_hi = W[i - 32];
      var c3_lo = W[i - 31];
      W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
  };
  SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for (var i = 0;i < W.length; i += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i];
      var c3_lo = this.k[i + 1];
      var c4_hi = W[i];
      var c4_lo = W[i + 1];
      var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };
  SHA512.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils.toHex32(this.h, "big");
    else
      return utils.split32(this.h, "big");
  };
});

// node_modules/hash.js/lib/hash/sha/384.js
var require_384 = __commonJS((exports, module) => {
  var SHA384 = function() {
    if (!(this instanceof SHA384))
      return new SHA384;
    SHA512.call(this);
    this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  };
  var utils = require_utils();
  var SHA512 = require_512();
  utils.inherits(SHA384, SHA512);
  module.exports = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils.toHex32(this.h.slice(0, 12), "big");
    else
      return utils.split32(this.h.slice(0, 12), "big");
  };
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS((exports) => {
  exports.sha1 = require_1();
  exports.sha224 = require_224();
  exports.sha256 = require_256();
  exports.sha384 = require_384();
  exports.sha512 = require_512();
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS((exports) => {
  var RIPEMD160 = function() {
    if (!(this instanceof RIPEMD160))
      return new RIPEMD160;
    BlockHash.call(this);
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    this.endian = "little";
  };
  var f = function(j, x, y, z2) {
    if (j <= 15)
      return x ^ y ^ z2;
    else if (j <= 31)
      return x & y | ~x & z2;
    else if (j <= 47)
      return (x | ~y) ^ z2;
    else if (j <= 63)
      return x & z2 | y & ~z2;
    else
      return x ^ (y | ~z2);
  };
  var K = function(j) {
    if (j <= 15)
      return 0;
    else if (j <= 31)
      return 1518500249;
    else if (j <= 47)
      return 1859775393;
    else if (j <= 63)
      return 2400959708;
    else
      return 2840853838;
  };
  var Kh = function(j) {
    if (j <= 15)
      return 1352829926;
    else if (j <= 31)
      return 1548603684;
    else if (j <= 47)
      return 1836072691;
    else if (j <= 63)
      return 2053994217;
    else
      return 0;
  };
  var utils = require_utils();
  var common = require_common();
  var rotl32 = utils.rotl32;
  var sum32 = utils.sum32;
  var sum32_3 = utils.sum32_3;
  var sum32_4 = utils.sum32_4;
  var BlockHash = common.BlockHash;
  utils.inherits(RIPEMD160, BlockHash);
  exports.ripemd160 = RIPEMD160;
  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;
  RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D2 = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D2;
    var Eh = E;
    for (var j = 0;j < 80; j++) {
      var T = sum32(rotl32(sum32_4(A, f(j, B, C, D2), msg[r[j] + start], K(j)), s[j]), E);
      A = E;
      E = D2;
      D2 = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D2, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };
  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils.toHex32(this.h, "little");
    else
      return utils.split32(this.h, "little");
  };
  var r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ];
  var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ];
  var s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ];
  var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS((exports, module) => {
  var Hmac = function(hash, key, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils.toArray(key, enc));
  };
  var utils = require_utils();
  var assert = require_minimalistic_assert();
  module.exports = Hmac;
  Hmac.prototype._init = function init(key) {
    if (key.length > this.blockSize)
      key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    for (var i = key.length;i < this.blockSize; i++)
      key.push(0);
    for (i = 0;i < key.length; i++)
      key[i] ^= 54;
    this.inner = new this.Hash().update(key);
    for (i = 0;i < key.length; i++)
      key[i] ^= 106;
    this.outer = new this.Hash().update(key);
  };
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS((exports) => {
  var hash = exports;
  hash.utils = require_utils();
  hash.common = require_common();
  hash.sha = require_sha();
  hash.ripemd = require_ripemd();
  hash.hmac = require_hmac();
  hash.sha1 = hash.sha.sha1;
  hash.sha256 = hash.sha.sha256;
  hash.sha224 = hash.sha.sha224;
  hash.sha384 = hash.sha.sha384;
  hash.sha512 = hash.sha.sha512;
  hash.ripemd160 = hash.ripemd.ripemd160;
});

// node_modules/@ethersproject/sha2/lib/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SupportedAlgorithm = undefined;
  var SupportedAlgorithm;
  (function(SupportedAlgorithm2) {
    SupportedAlgorithm2["sha256"] = "sha256";
    SupportedAlgorithm2["sha512"] = "sha512";
  })(SupportedAlgorithm = exports.SupportedAlgorithm || (exports.SupportedAlgorithm = {}));
});

// node_modules/@ethersproject/sha2/lib/_version.js
var require__version10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "sha2/5.7.0";
});

// node_modules/@ethersproject/sha2/lib/browser-sha2.js
var require_browser_sha2 = __commonJS((exports) => {
  var ripemd160 = function(data) {
    return "0x" + hash_js_1.default.ripemd160().update((0, bytes_1.arrayify)(data)).digest("hex");
  };
  var sha256 = function(data) {
    return "0x" + hash_js_1.default.sha256().update((0, bytes_1.arrayify)(data)).digest("hex");
  };
  var sha512 = function(data) {
    return "0x" + hash_js_1.default.sha512().update((0, bytes_1.arrayify)(data)).digest("hex");
  };
  var computeHmac = function(algorithm, key, data) {
    if (!types_1.SupportedAlgorithm[algorithm]) {
      logger.throwError("unsupported algorithm " + algorithm, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "hmac",
        algorithm
      });
    }
    return "0x" + hash_js_1.default.hmac(hash_js_1.default[algorithm], (0, bytes_1.arrayify)(key)).update((0, bytes_1.arrayify)(data)).digest("hex");
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.computeHmac = exports.sha512 = exports.sha256 = exports.ripemd160 = undefined;
  var hash_js_1 = __importDefault(require_hash());
  var bytes_1 = require_lib2();
  var types_1 = require_types();
  var logger_1 = require_lib();
  var _version_1 = require__version10();
  var logger = new logger_1.Logger(_version_1.version);
  exports.ripemd160 = ripemd160;
  exports.sha256 = sha256;
  exports.sha512 = sha512;
  exports.computeHmac = computeHmac;
});

// node_modules/@ethersproject/sha2/lib/index.js
var require_lib15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SupportedAlgorithm = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.computeHmac = undefined;
  var sha2_1 = require_browser_sha2();
  Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
    return sha2_1.computeHmac;
  } });
  Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
    return sha2_1.ripemd160;
  } });
  Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
    return sha2_1.sha256;
  } });
  Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
    return sha2_1.sha512;
  } });
  var types_1 = require_types();
  Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
    return types_1.SupportedAlgorithm;
  } });
});

// node_modules/@ethersproject/pbkdf2/lib/browser-pbkdf2.js
var require_browser_pbkdf2 = __commonJS((exports) => {
  var pbkdf2 = function(password, salt, iterations, keylen, hashAlgorithm) {
    password = (0, bytes_1.arrayify)(password);
    salt = (0, bytes_1.arrayify)(salt);
    var hLen;
    var l = 1;
    var DK = new Uint8Array(keylen);
    var block1 = new Uint8Array(salt.length + 4);
    block1.set(salt);
    var r;
    var T;
    for (var i = 1;i <= l; i++) {
      block1[salt.length] = i >> 24 & 255;
      block1[salt.length + 1] = i >> 16 & 255;
      block1[salt.length + 2] = i >> 8 & 255;
      block1[salt.length + 3] = i & 255;
      var U = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(hashAlgorithm, password, block1));
      if (!hLen) {
        hLen = U.length;
        T = new Uint8Array(hLen);
        l = Math.ceil(keylen / hLen);
        r = keylen - (l - 1) * hLen;
      }
      T.set(U);
      for (var j = 1;j < iterations; j++) {
        U = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(hashAlgorithm, password, U));
        for (var k = 0;k < hLen; k++)
          T[k] ^= U[k];
      }
      var destPos = (i - 1) * hLen;
      var len = i === l ? r : hLen;
      DK.set((0, bytes_1.arrayify)(T).slice(0, len), destPos);
    }
    return (0, bytes_1.hexlify)(DK);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pbkdf2 = undefined;
  var bytes_1 = require_lib2();
  var sha2_1 = require_lib15();
  exports.pbkdf2 = pbkdf2;
});

// node_modules/@ethersproject/pbkdf2/lib/index.js
var require_lib16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pbkdf2 = undefined;
  var pbkdf2_1 = require_browser_pbkdf2();
  Object.defineProperty(exports, "pbkdf2", { enumerable: true, get: function() {
    return pbkdf2_1.pbkdf2;
  } });
});

// node_modules/elliptic/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "elliptic",
    version: "6.5.4",
    description: "EC cryptography",
    main: "lib/elliptic.js",
    files: [
      "lib"
    ],
    scripts: {
      lint: "eslint lib test",
      "lint:fix": "npm run lint -- --fix",
      unit: "istanbul test _mocha --reporter=spec test/index.js",
      test: "npm run lint && npm run unit",
      version: "grunt dist && git add dist/"
    },
    repository: {
      type: "git",
      url: "git@github.com:indutny/elliptic"
    },
    keywords: [
      "EC",
      "Elliptic",
      "curve",
      "Cryptography"
    ],
    author: "Fedor Indutny <fedor@indutny.com>",
    license: "MIT",
    bugs: {
      url: "https://github.com/indutny/elliptic/issues"
    },
    homepage: "https://github.com/indutny/elliptic",
    devDependencies: {
      brfs: "^2.0.2",
      coveralls: "^3.1.0",
      eslint: "^7.6.0",
      grunt: "^1.2.1",
      "grunt-browserify": "^5.3.0",
      "grunt-cli": "^1.3.2",
      "grunt-contrib-connect": "^3.0.0",
      "grunt-contrib-copy": "^1.0.0",
      "grunt-contrib-uglify": "^5.0.0",
      "grunt-mocha-istanbul": "^5.0.2",
      "grunt-saucelabs": "^9.0.1",
      istanbul: "^0.4.5",
      mocha: "^8.0.1"
    },
    dependencies: {
      "bn.js": "^4.11.9",
      brorand: "^1.1.0",
      "hash.js": "^1.0.0",
      "hmac-drbg": "^1.0.1",
      inherits: "^2.0.4",
      "minimalistic-assert": "^1.0.1",
      "minimalistic-crypto-utils": "^1.0.1"
    }
  };
});

// node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS((exports, module) => {
  (function(module2, exports2) {
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor;
      ctor.prototype.constructor = ctor;
    }
    function BN(number, base, endian) {
      if (BN.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base === "le" || base === "be") {
          endian = base;
          base = 10;
        }
        this._init(number || 0, base || 10, endian || "be");
      }
    }
    if (typeof module2 === "object") {
      module2.exports = BN;
    } else {
      exports2.BN = BN;
    }
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
      }
    } catch (e) {
    }
    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN.prototype._init = function init(number, base, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base, endian);
      }
      if (base === "hex") {
        base = 16;
      }
      assert(base === (base | 0) && base >= 2 && base <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;
      if (number[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number.length) {
        if (base === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base, endian);
          }
        }
      }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
      assert(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i = number.length - 1, j = 0;i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0;i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this.strip();
    };
    function parseHex4Bits(string, index) {
      var c = string.charCodeAt(index);
      if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        return c - 48 & 15;
      }
    }
    function parseHexByte(string, lowerBound, index) {
      var r = parseHex4Bits(string, index);
      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }
      return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i = number.length - 1;i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start;i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this.strip();
    };
    function parseBase(str, start, end, mul) {
      var r = 0;
      var len = Math.min(str.length, end);
      for (var i = start;i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul;
        if (c >= 49) {
          r += c - 49 + 10;
        } else if (c >= 17) {
          r += c - 17 + 10;
        } else {
          r += c;
        }
      }
      return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start;i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);
        for (i = 0;i < mod; i++) {
          pow *= base;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this.strip();
    };
    BN.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0;i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };
    BN.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN.prototype.inspect = function inspect() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64000000,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      24300000,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
      var out;
      if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0;i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base === (base | 0) && base >= 2 && base <= 36) {
        var groupSize = groupSizes[base];
        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modn(groupBase).toString(base);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
      return this.toString(16);
    };
    BN.prototype.toBuffer = function toBuffer(endian, length) {
      assert(typeof Buffer2 !== "undefined");
      return this.toArrayLike(Buffer2, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert(byteLength <= reqLength, "byte array longer than desired length");
      assert(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b2, i;
      var q = this.clone();
      if (!littleEndian) {
        for (i = 0;i < reqLength - byteLength; i++) {
          res[i] = 0;
        }
        for (i = 0;!q.isZero(); i++) {
          b2 = q.andln(255);
          q.iushrn(8);
          res[reqLength - i - 1] = b2;
        }
      } else {
        for (i = 0;!q.isZero(); i++) {
          b2 = q.andln(255);
          q.iushrn(8);
          res[i] = b2;
        }
        for (;i < reqLength; i++) {
          res[i] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r = 0;
      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r++;
      }
      return r;
    };
    BN.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0;bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }
      return w;
    }
    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r = 0;
      for (var i = 0;i < this.length; i++) {
        var b2 = this._zeroBits(this.words[i]);
        r += b2;
        if (b2 !== 26)
          break;
      }
      return r;
    };
    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0;i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this.strip();
    };
    BN.prototype.ior = function ior(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i = 0;i < b2.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b2.length;
      return this.strip();
    };
    BN.prototype.iand = function iand(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN.prototype.iuxor = function iuxor(num) {
      var a;
      var b2;
      if (this.length > num.length) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      for (var i = 0;i < b2.length; i++) {
        this.words[i] = a.words[i] ^ b2.words[i];
      }
      if (this !== a) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this.strip();
    };
    BN.prototype.ixor = function ixor(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN.prototype.inotn = function inotn(width) {
      assert(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0;i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this.strip();
    };
    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN.prototype.setn = function setn(bit, val) {
      assert(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN.prototype.iadd = function iadd(num) {
      var r;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }
      var a, b2;
      if (this.length > num.length) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0;i < b2.length; i++) {
        r = (a.words[i] | 0) + (b2.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      for (;carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN.prototype.add = function add(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b2;
      if (cmp > 0) {
        a = this;
        b2 = num;
      } else {
        a = num;
        b2 = this;
      }
      var carry = 0;
      for (var i = 0;i < b2.length; i++) {
        r = (a.words[i] | 0) - (b2.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      for (;carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (;i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r = a * b2;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1;k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i = k - j | 0;
          a = self2.words[i] | 0;
          b2 = num.words[j] | 0;
          r = a * b2 + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo(self2, num, out) {
      var a = self2.words;
      var b2 = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0;k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
          var i = k - j;
          var a = self2.words[i] | 0;
          var b2 = num.words[j] | 0;
          var r = a * b2;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo(self2, num, out) {
      var fftm = new FFTM;
      return fftm.mulp(self2, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x, y) {
      this.x = x;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;
      for (var i = 0;i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1)
        return x;
      var rb = 0;
      for (var i = 0;i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0;i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);
      for (var s = 1;s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for (var p = 0;p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j = 0;j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;
      for (N = N / 2 | 0;N; N = N >>> 1) {
        i++;
      }
      return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1)
        return;
      for (var i = 0;i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;
      for (var i = 0;i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 67108863;
        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;
      for (var i = 0;i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i = 2 * len;i < N; ++i) {
        rws[i] = 0;
      }
      assert(carry === 0);
      assert((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);
      for (var i = 0;i < N; i++) {
        ph[i] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);
      var _2 = this.stub(N);
      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _2, rwst, iwst, N, rbt);
      this.transform(nrws, _2, nrwst, niwst, N, rbt);
      for (var i = 0;i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }
      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _2, N, rbt);
      this.conjugate(rmws, _2, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out.strip();
    };
    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      var carry = 0;
      for (var i = 0;i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0)
        return new BN(1);
      var res = this;
      for (var i = 0;i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0)
          break;
      }
      if (++i < w.length) {
        for (var q = res.sqr();i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN.prototype.iushln = function iushln(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i;
      if (r !== 0) {
        var carry = 0;
        for (i = 0;i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i = this.length - 1;i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }
        for (i = 0;i < s; i++) {
          this.words[i] = 0;
        }
        this.length += s;
      }
      return this.strip();
    };
    BN.prototype.ishln = function ishln(bits) {
      assert(this.negative === 0);
      return this.iushln(bits);
    };
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0;i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
      }
      if (s === 0) {
      } else if (this.length > s) {
        this.length -= s;
        for (i = 0;i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1;i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN.prototype.testn = function testn(bit) {
      assert(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s)
        return false;
      var w = this.words[s];
      return !!(w & q);
    };
    BN.prototype.imaskn = function imaskn(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s) {
        return this;
      }
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask = 67108863 ^ 67108863 >>> r << r;
        this.words[this.length - 1] &= mask;
      }
      return this.strip();
    };
    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN.prototype.iaddn = function iaddn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0;i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN.prototype.isubn = function isubn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0;i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0;i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (;i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0)
        return this.strip();
      assert(carry === -1);
      carry = 0;
      for (i = 0;i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this.strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m = a.length - b2.length;
      var q;
      if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0;i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b2, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1;j >= 0; j--) {
        var qj = (a.words[b2.length + j] | 0) * 67108864 + (a.words[b2.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b2, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b2, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q.strip();
      }
      a.strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modn = function modn(num) {
      assert(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return acc;
    };
    BN.prototype.idivn = function idivn(num) {
      assert(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      return this.strip();
    };
    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN(1);
      var B = new BN(0);
      var C = new BN(0);
      var D2 = new BN(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1;(x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D2.isOdd()) {
              C.iadd(yp);
              D2.isub(xp);
            }
            C.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D2);
        } else {
          y.isub(x);
          C.isub(A);
          D2.isub(B);
        }
      }
      return {
        a: C,
        b: D2,
        gcd: y.iushln(g)
      };
    };
    BN.prototype._invmp = function _invmp(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var a = this;
      var b2 = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b2.clone();
      while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i = 0, im = 1;(a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1;(b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b2.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b2) >= 0) {
          a.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b2 = num.clone();
      a.negative = 0;
      b2.negative = 0;
      for (var shift = 0;a.isEven() && b2.isEven(); shift++) {
        a.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r = a.cmp(b2);
        if (r < 0) {
          var t = a;
          a = b2;
          b2 = t;
        } else if (r === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN.prototype.bincn = function bincn(bit) {
      assert(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }
      var carry = q;
      for (var i = s;carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1;i >= 0; i--) {
        var a = this.words[i] | 0;
        var b2 = num.words[i] | 0;
        if (a === b2)
          continue;
        if (a < b2) {
          res = -1;
        } else if (a > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };
    BN.red = function red(num) {
      return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
      assert(!this.red, "Already a number in reduction context");
      assert(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
      assert(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
      assert(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
      assert(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
      assert(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
      assert(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
      assert(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
      assert(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
      assert(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
      assert(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
      assert(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
      assert(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN.prototype.redSqrt = function redSqrt() {
      assert(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
      assert(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN.prototype.redNeg = function redNeg() {
      assert(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
      assert(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p) {
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== undefined) {
          r.strip();
        } else {
          r._strip();
        }
      }
      return r;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0;i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i = 10;i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0;i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0;i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime;
      if (name === "k256") {
        prime = new K256;
      } else if (name === "p224") {
        prime = new P224;
      } else if (name === "p192") {
        prime = new P192;
      } else if (name === "p25519") {
        prime = new P25519;
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime;
      return prime;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert(a.negative === 0, "red works only with positives");
      assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b2) {
      assert((a.negative | b2.negative) === 0, "red works only with positives");
      assert(a.red && a.red === b2.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      return a.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b2) {
      this._verify2(a, b2);
      var res = a.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b2) {
      this._verify2(a, b2);
      var res = a.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b2) {
      this._verify2(a, b2);
      var res = a.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b2) {
      this._verify2(a, b2);
      var res = a.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b2) {
      this._verify2(a, b2);
      return this.imod(a.imul(b2));
    };
    Red.prototype.mul = function mul(a, b2) {
      this._verify2(a, b2);
      return this.imod(a.mul(b2));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert(!q.isZero());
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c = this.pow(z2, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0;tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert(i < m);
        var b2 = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b2);
        c = b2.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this);
      wnd[1] = a;
      for (var i = 2;i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1;i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1;j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul(a, b2) {
      if (a.isZero() || b2.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b2);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b2) {
      if (a.isZero() || b2.isZero())
        return new BN(0)._forceRed(this);
      var t = a.mul(b2);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(typeof module === "undefined" || module, exports);
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils2 = __commonJS((exports) => {
  var toArray = function(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0;i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0;i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0;i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  };
  var zero2 = function(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  };
  var toHex = function(msg) {
    var res = "";
    for (var i = 0;i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  };
  var utils = exports;
  utils.toArray = toArray;
  utils.zero2 = zero2;
  utils.toHex = toHex;
  utils.encode = function encode(arr, enc) {
    if (enc === "hex")
      return toHex(arr);
    else
      return arr;
  };
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils3 = __commonJS((exports) => {
  var getNAF = function(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for (var i = 0;i < naf.length; i++) {
      var z2;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z2 = (ws >> 1) - mod;
        else
          z2 = mod;
        k.isubn(z2);
      } else {
        z2 = 0;
      }
      naf[i] = z2;
      k.iushrn(1);
    }
    return naf;
  };
  var getJSF = function(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  };
  var cachedProperty = function(obj, name, computer) {
    var key = "_" + name;
    obj.prototype[name] = function cachedProperty() {
      return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
    };
  };
  var parseBytes = function(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  };
  var intFromLE = function(bytes) {
    return new BN(bytes, "hex", "le");
  };
  var utils = exports;
  var BN = require_bn2();
  var minAssert = require_minimalistic_assert();
  var minUtils = require_utils2();
  utils.assert = minAssert;
  utils.toArray = minUtils.toArray;
  utils.zero2 = minUtils.zero2;
  utils.toHex = minUtils.toHex;
  utils.encode = minUtils.encode;
  utils.getNAF = getNAF;
  utils.getJSF = getJSF;
  utils.cachedProperty = cachedProperty;
  utils.parseBytes = parseBytes;
  utils.intFromLE = intFromLE;
});

// node:crypto
var exports_crypto = {};
__export(exports_crypto, {
  webcrypto: () => {
    {
      return cw;
    }
  },
  timingSafeEqual: () => {
    {
      return x0;
    }
  },
  scryptSync: () => {
    {
      return Id;
    }
  },
  scrypt: () => {
    {
      return Td;
    }
  },
  randomUUID: () => {
    {
      return lw;
    }
  },
  getRandomValues: () => {
    {
      return uw;
    }
  },
  getCurves: () => {
    {
      return dw;
    }
  },
  default: () => {
    {
      return Wq;
    }
  },
  DEFAULT_ENCODING: () => {
    {
      return Ga;
    }
  }
});
var dw, pw, Xa, vw, bw, mw, gw, R0, T, Ja, Ya, ot, rn, ur, Nd, Dd, Ut, Te, on, Ie, ki, W0, $f, pc, Z0, sn, V0, G0, J0, hn, co, Jf, po, Qf, vo, Pc, Oc, th, ph, Qc, np, ap, bh, Ao, Bo, pn, _p, Ep, gh, qp, yh, Op, ko, Tt, Gr, No, Jt, pa, Rh, pr, Y_, Oi, Fi, Ui, k1, yn, Vo, Go, Z1, Xo, Fh, ba, Jh, Dv, Qr, fu, ou, os, eb, cu, lb, bu, vf, S7, db, yi, bf, wb, mu, wu, Mu, Eb, _u, xu, Eu, Au, Ub, Iu, Tu, ar, vs, ku, Yb, Qb, em, im, nm, yf, om, um, dm, pm, bm, Pu, Ou, Fu, ws, Aa, Em, Wu, ju, Ba, Dm, Fm, Es, Hm, Vm, ji, Yu, Ym, Xm, As, tl, ol, rg, ag, hg, hl, pg, dl, kn, cl, bl, Ln, Ds, Lg, Dg, yl, Il, Yg, t2, i2, Ws, Ks, s2, ri, Nl, or, Oa, b2, y2, _2, Pl, Cr, Tf, Cl, N2, Fl, F2, Wl, Z2, V2, Q2, ty, e0, ny, t0, uy, dy, vy, yy, xy, Ey, Iy, o0, td, h0, u0, Kf, d0, c0, nd, Hy, od, hd, Jy, dd, r3, n3, o3, cd, d3, p3, v3, m3, Ha, bd, _3, A3, k3, N3, P3, _d, xd, w0, Ed, j3, Y3, X3, ow, qd, Xt, zq, Ga, uw, lw, Hq, x0, Id, Td, cw, Wq;
var init_crypto = __esm(() => {
  dw = function() {
    return Hq;
  };
  pw = Object.create;
  Xa = Object.defineProperty;
  vw = Object.getOwnPropertyDescriptor;
  bw = Object.getOwnPropertyNames;
  mw = Object.getPrototypeOf;
  gw = Object.prototype.hasOwnProperty;
  R0 = (t, e) => () => (t && (e = t(t = 0)), e);
  T = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
  Ja = (t, e) => {
    for (var r in e)
      Xa(t, r, { get: e[r], enumerable: true });
  };
  Ya = (t, e, r, o) => {
    if (e && typeof e == "object" || typeof e == "function")
      for (let f of bw(e))
        !gw.call(t, f) && f !== r && Xa(t, f, { get: () => e[f], enumerable: !(o = vw(e, f)) || o.enumerable });
    return t;
  };
  ot = (t, e, r) => (Ya(t, e, "default"), r && Ya(r, e, "default"));
  rn = (t, e, r) => (r = t != null ? pw(mw(t)) : {}, Ya(e || !t || !t.__esModule ? Xa(r, "default", { value: t, enumerable: true }) : r, t));
  ur = (t) => Ya(Xa({}, "__esModule", { value: true }), t);
  Nd = T((Qa) => {
    Qa.byteLength = ww;
    Qa.toByteArray = _w;
    Qa.fromByteArray = Ew;
    var jr = [], lr = [], yw = typeof Uint8Array < "u" ? Uint8Array : Array, B0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (nn = 0, kd = B0.length;nn < kd; ++nn)
      jr[nn] = B0[nn], lr[B0.charCodeAt(nn)] = nn;
    var nn, kd;
    lr["-".charCodeAt(0)] = 62;
    lr["_".charCodeAt(0)] = 63;
    function Ld(t) {
      var e = t.length;
      if (e % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = t.indexOf("=");
      r === -1 && (r = e);
      var o = r === e ? 0 : 4 - r % 4;
      return [r, o];
    }
    function ww(t) {
      var e = Ld(t), r = e[0], o = e[1];
      return (r + o) * 3 / 4 - o;
    }
    function Mw(t, e, r) {
      return (e + r) * 3 / 4 - r;
    }
    function _w(t) {
      var e, r = Ld(t), o = r[0], f = r[1], p = new yw(Mw(t, o, f)), m = 0, y = f > 0 ? o - 4 : o, M;
      for (M = 0;M < y; M += 4)
        e = lr[t.charCodeAt(M)] << 18 | lr[t.charCodeAt(M + 1)] << 12 | lr[t.charCodeAt(M + 2)] << 6 | lr[t.charCodeAt(M + 3)], p[m++] = e >> 16 & 255, p[m++] = e >> 8 & 255, p[m++] = e & 255;
      return f === 2 && (e = lr[t.charCodeAt(M)] << 2 | lr[t.charCodeAt(M + 1)] >> 4, p[m++] = e & 255), f === 1 && (e = lr[t.charCodeAt(M)] << 10 | lr[t.charCodeAt(M + 1)] << 4 | lr[t.charCodeAt(M + 2)] >> 2, p[m++] = e >> 8 & 255, p[m++] = e & 255), p;
    }
    function xw(t) {
      return jr[t >> 18 & 63] + jr[t >> 12 & 63] + jr[t >> 6 & 63] + jr[t & 63];
    }
    function Sw(t, e, r) {
      for (var o, f = [], p = e;p < r; p += 3)
        o = (t[p] << 16 & 16711680) + (t[p + 1] << 8 & 65280) + (t[p + 2] & 255), f.push(xw(o));
      return f.join("");
    }
    function Ew(t) {
      for (var e, r = t.length, o = r % 3, f = [], p = 16383, m = 0, y = r - o;m < y; m += p)
        f.push(Sw(t, m, m + p > y ? y : m + p));
      return o === 1 ? (e = t[r - 1], f.push(jr[e >> 2] + jr[e << 4 & 63] + "==")) : o === 2 && (e = (t[r - 2] << 8) + t[r - 1], f.push(jr[e >> 10] + jr[e >> 4 & 63] + jr[e << 2 & 63] + "=")), f.join("");
    }
  });
  Dd = T((q0) => {
    q0.read = function(t, e, r, o, f) {
      var p, m, y = f * 8 - o - 1, M = (1 << y) - 1, x = M >> 1, S2 = -7, E = r ? f - 1 : 0, B = r ? -1 : 1, q = t[e + E];
      for (E += B, p = q & (1 << -S2) - 1, q >>= -S2, S2 += y;S2 > 0; p = p * 256 + t[e + E], E += B, S2 -= 8)
        ;
      for (m = p & (1 << -S2) - 1, p >>= -S2, S2 += o;S2 > 0; m = m * 256 + t[e + E], E += B, S2 -= 8)
        ;
      if (p === 0)
        p = 1 - x;
      else {
        if (p === M)
          return m ? NaN : (q ? -1 : 1) * (1 / 0);
        m = m + Math.pow(2, o), p = p - x;
      }
      return (q ? -1 : 1) * m * Math.pow(2, p - o);
    };
    q0.write = function(t, e, r, o, f, p) {
      var m, y, M, x = p * 8 - f - 1, S2 = (1 << x) - 1, E = S2 >> 1, B = f === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, q = o ? 0 : p - 1, L = o ? 1 : -1, ge = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (y = isNaN(e) ? 1 : 0, m = S2) : (m = Math.floor(Math.log(e) / Math.LN2), e * (M = Math.pow(2, -m)) < 1 && (m--, M *= 2), m + E >= 1 ? e += B / M : e += B * Math.pow(2, 1 - E), e * M >= 2 && (m++, M /= 2), m + E >= S2 ? (y = 0, m = S2) : m + E >= 1 ? (y = (e * M - 1) * Math.pow(2, f), m = m + E) : (y = e * Math.pow(2, E - 1) * Math.pow(2, f), m = 0));f >= 8; t[r + q] = y & 255, q += L, y /= 256, f -= 8)
        ;
      for (m = m << f | y, x += f;x > 0; t[r + q] = m & 255, q += L, m /= 256, x -= 8)
        ;
      t[r + q - L] |= ge * 128;
    };
  });
  Ut = T((Xn) => {
    var I0 = Nd(), Gn = Dd(), Pd = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Xn.Buffer = me;
    Xn.SlowBuffer = Tw;
    Xn.INSPECT_MAX_BYTES = 50;
    var eo = 2147483647;
    Xn.kMaxLength = eo;
    me.TYPED_ARRAY_SUPPORT = Aw();
    !me.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Aw() {
      try {
        let t = new Uint8Array(1), e = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), t.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(me.prototype, "parent", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(me.prototype, "offset", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.byteOffset;
    } });
    function li(t) {
      if (t > eo)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      let e = new Uint8Array(t);
      return Object.setPrototypeOf(e, me.prototype), e;
    }
    function me(t, e, r) {
      if (typeof t == "number") {
        if (typeof e == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return N0(t);
      }
      return Ud(t, e, r);
    }
    me.poolSize = 8192;
    function Ud(t, e, r) {
      if (typeof t == "string")
        return Bw(t, e);
      if (ArrayBuffer.isView(t))
        return qw(t);
      if (t == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      if (Zr(t, ArrayBuffer) || t && Zr(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Zr(t, SharedArrayBuffer) || t && Zr(t.buffer, SharedArrayBuffer)))
        return k0(t, e, r);
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let o = t.valueOf && t.valueOf();
      if (o != null && o !== t)
        return me.from(o, e, r);
      let f = Iw(t);
      if (f)
        return f;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function")
        return me.from(t[Symbol.toPrimitive]("string"), e, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    }
    me.from = function(t, e, r) {
      return Ud(t, e, r);
    };
    Object.setPrototypeOf(me.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(me, Uint8Array);
    function zd(t) {
      if (typeof t != "number")
        throw new TypeError('"size" argument must be of type number');
      if (t < 0)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
    }
    function Rw(t, e, r) {
      return zd(t), t <= 0 ? li(t) : e !== undefined ? typeof r == "string" ? li(t).fill(e, r) : li(t).fill(e) : li(t);
    }
    me.alloc = function(t, e, r) {
      return Rw(t, e, r);
    };
    function N0(t) {
      return zd(t), li(t < 0 ? 0 : D0(t) | 0);
    }
    me.allocUnsafe = function(t) {
      return N0(t);
    };
    me.allocUnsafeSlow = function(t) {
      return N0(t);
    };
    function Bw(t, e) {
      if ((typeof e != "string" || e === "") && (e = "utf8"), !me.isEncoding(e))
        throw new TypeError("Unknown encoding: " + e);
      let r = Hd(t, e) | 0, o = li(r), f = o.write(t, e);
      return f !== r && (o = o.slice(0, f)), o;
    }
    function T0(t) {
      let e = t.length < 0 ? 0 : D0(t.length) | 0, r = li(e);
      for (let o = 0;o < e; o += 1)
        r[o] = t[o] & 255;
      return r;
    }
    function qw(t) {
      if (Zr(t, Uint8Array)) {
        let e = new Uint8Array(t);
        return k0(e.buffer, e.byteOffset, e.byteLength);
      }
      return T0(t);
    }
    function k0(t, e, r) {
      if (e < 0 || t.byteLength < e)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (t.byteLength < e + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let o;
      return e === undefined && r === undefined ? o = new Uint8Array(t) : r === undefined ? o = new Uint8Array(t, e) : o = new Uint8Array(t, e, r), Object.setPrototypeOf(o, me.prototype), o;
    }
    function Iw(t) {
      if (me.isBuffer(t)) {
        let e = D0(t.length) | 0, r = li(e);
        return r.length === 0 || t.copy(r, 0, 0, e), r;
      }
      if (t.length !== undefined)
        return typeof t.length != "number" || C0(t.length) ? li(0) : T0(t);
      if (t.type === "Buffer" && Array.isArray(t.data))
        return T0(t.data);
    }
    function D0(t) {
      if (t >= eo)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + eo.toString(16) + " bytes");
      return t | 0;
    }
    function Tw(t) {
      return +t != t && (t = 0), me.alloc(+t);
    }
    me.isBuffer = function(e) {
      return e != null && e._isBuffer === true && e !== me.prototype;
    };
    me.compare = function(e, r) {
      if (Zr(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), Zr(r, Uint8Array) && (r = me.from(r, r.offset, r.byteLength)), !me.isBuffer(e) || !me.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (e === r)
        return 0;
      let o = e.length, f = r.length;
      for (let p = 0, m = Math.min(o, f);p < m; ++p)
        if (e[p] !== r[p]) {
          o = e[p], f = r[p];
          break;
        }
      return o < f ? -1 : f < o ? 1 : 0;
    };
    me.isEncoding = function(e) {
      switch (String(e).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    me.concat = function(e, r) {
      if (!Array.isArray(e))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (e.length === 0)
        return me.alloc(0);
      let o;
      if (r === undefined)
        for (r = 0, o = 0;o < e.length; ++o)
          r += e[o].length;
      let f = me.allocUnsafe(r), p = 0;
      for (o = 0;o < e.length; ++o) {
        let m = e[o];
        if (Zr(m, Uint8Array))
          p + m.length > f.length ? (me.isBuffer(m) || (m = me.from(m)), m.copy(f, p)) : Uint8Array.prototype.set.call(f, m, p);
        else if (me.isBuffer(m))
          m.copy(f, p);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        p += m.length;
      }
      return f;
    };
    function Hd(t, e) {
      if (me.isBuffer(t))
        return t.length;
      if (ArrayBuffer.isView(t) || Zr(t, ArrayBuffer))
        return t.byteLength;
      if (typeof t != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
      let r = t.length, o = arguments.length > 2 && arguments[2] === true;
      if (!o && r === 0)
        return 0;
      let f = false;
      for (;; )
        switch (e) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return L0(t).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return Xd(t).length;
          default:
            if (f)
              return o ? -1 : L0(t).length;
            e = ("" + e).toLowerCase(), f = true;
        }
    }
    me.byteLength = Hd;
    function kw(t, e, r) {
      let o = false;
      if ((e === undefined || e < 0) && (e = 0), e > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e))
        return "";
      for (t || (t = "utf8");; )
        switch (t) {
          case "hex":
            return Hw(this, e, r);
          case "utf8":
          case "utf-8":
            return Kd(this, e, r);
          case "ascii":
            return Uw(this, e, r);
          case "latin1":
          case "binary":
            return zw(this, e, r);
          case "base64":
            return Ow(this, e, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ww(this, e, r);
          default:
            if (o)
              throw new TypeError("Unknown encoding: " + t);
            t = (t + "").toLowerCase(), o = true;
        }
    }
    me.prototype._isBuffer = true;
    function fn(t, e, r) {
      let o = t[e];
      t[e] = t[r], t[r] = o;
    }
    me.prototype.swap16 = function() {
      let e = this.length;
      if (e % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < e; r += 2)
        fn(this, r, r + 1);
      return this;
    };
    me.prototype.swap32 = function() {
      let e = this.length;
      if (e % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < e; r += 4)
        fn(this, r, r + 3), fn(this, r + 1, r + 2);
      return this;
    };
    me.prototype.swap64 = function() {
      let e = this.length;
      if (e % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < e; r += 8)
        fn(this, r, r + 7), fn(this, r + 1, r + 6), fn(this, r + 2, r + 5), fn(this, r + 3, r + 4);
      return this;
    };
    me.prototype.toString = function() {
      let e = this.length;
      return e === 0 ? "" : arguments.length === 0 ? Kd(this, 0, e) : kw.apply(this, arguments);
    };
    me.prototype.toLocaleString = me.prototype.toString;
    me.prototype.equals = function(e) {
      if (!me.isBuffer(e))
        throw new TypeError("Argument must be a Buffer");
      return this === e ? true : me.compare(this, e) === 0;
    };
    me.prototype.inspect = function() {
      let e = "", r = Xn.INSPECT_MAX_BYTES;
      return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">";
    };
    Pd && (me.prototype[Pd] = me.prototype.inspect);
    me.prototype.compare = function(e, r, o, f, p) {
      if (Zr(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), !me.isBuffer(e))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
      if (r === undefined && (r = 0), o === undefined && (o = e ? e.length : 0), f === undefined && (f = 0), p === undefined && (p = this.length), r < 0 || o > e.length || f < 0 || p > this.length)
        throw new RangeError("out of range index");
      if (f >= p && r >= o)
        return 0;
      if (f >= p)
        return -1;
      if (r >= o)
        return 1;
      if (r >>>= 0, o >>>= 0, f >>>= 0, p >>>= 0, this === e)
        return 0;
      let m = p - f, y = o - r, M = Math.min(m, y), x = this.slice(f, p), S2 = e.slice(r, o);
      for (let E = 0;E < M; ++E)
        if (x[E] !== S2[E]) {
          m = x[E], y = S2[E];
          break;
        }
      return m < y ? -1 : y < m ? 1 : 0;
    };
    function Wd(t, e, r, o, f) {
      if (t.length === 0)
        return -1;
      if (typeof r == "string" ? (o = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, C0(r) && (r = f ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
        if (f)
          return -1;
        r = t.length - 1;
      } else if (r < 0)
        if (f)
          r = 0;
        else
          return -1;
      if (typeof e == "string" && (e = me.from(e, o)), me.isBuffer(e))
        return e.length === 0 ? -1 : Cd(t, e, r, o, f);
      if (typeof e == "number")
        return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? f ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : Cd(t, [e], r, o, f);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Cd(t, e, r, o, f) {
      let p = 1, m = t.length, y = e.length;
      if (o !== undefined && (o = String(o).toLowerCase(), o === "ucs2" || o === "ucs-2" || o === "utf16le" || o === "utf-16le")) {
        if (t.length < 2 || e.length < 2)
          return -1;
        p = 2, m /= 2, y /= 2, r /= 2;
      }
      function M(S2, E) {
        return p === 1 ? S2[E] : S2.readUInt16BE(E * p);
      }
      let x;
      if (f) {
        let S2 = -1;
        for (x = r;x < m; x++)
          if (M(t, x) === M(e, S2 === -1 ? 0 : x - S2)) {
            if (S2 === -1 && (S2 = x), x - S2 + 1 === y)
              return S2 * p;
          } else
            S2 !== -1 && (x -= x - S2), S2 = -1;
      } else
        for (r + y > m && (r = m - y), x = r;x >= 0; x--) {
          let S2 = true;
          for (let E = 0;E < y; E++)
            if (M(t, x + E) !== M(e, E)) {
              S2 = false;
              break;
            }
          if (S2)
            return x;
        }
      return -1;
    }
    me.prototype.includes = function(e, r, o) {
      return this.indexOf(e, r, o) !== -1;
    };
    me.prototype.indexOf = function(e, r, o) {
      return Wd(this, e, r, o, true);
    };
    me.prototype.lastIndexOf = function(e, r, o) {
      return Wd(this, e, r, o, false);
    };
    function Lw(t, e, r, o) {
      r = Number(r) || 0;
      let f = t.length - r;
      o ? (o = Number(o), o > f && (o = f)) : o = f;
      let p = e.length;
      o > p / 2 && (o = p / 2);
      let m;
      for (m = 0;m < o; ++m) {
        let y = parseInt(e.substr(m * 2, 2), 16);
        if (C0(y))
          return m;
        t[r + m] = y;
      }
      return m;
    }
    function Nw(t, e, r, o) {
      return to(L0(e, t.length - r), t, r, o);
    }
    function Dw(t, e, r, o) {
      return to(Vw(e), t, r, o);
    }
    function Pw(t, e, r, o) {
      return to(Xd(e), t, r, o);
    }
    function Cw(t, e, r, o) {
      return to($w(e, t.length - r), t, r, o);
    }
    me.prototype.write = function(e, r, o, f) {
      if (r === undefined)
        f = "utf8", o = this.length, r = 0;
      else if (o === undefined && typeof r == "string")
        f = r, o = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(o) ? (o = o >>> 0, f === undefined && (f = "utf8")) : (f = o, o = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let p = this.length - r;
      if ((o === undefined || o > p) && (o = p), e.length > 0 && (o < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      f || (f = "utf8");
      let m = false;
      for (;; )
        switch (f) {
          case "hex":
            return Lw(this, e, r, o);
          case "utf8":
          case "utf-8":
            return Nw(this, e, r, o);
          case "ascii":
          case "latin1":
          case "binary":
            return Dw(this, e, r, o);
          case "base64":
            return Pw(this, e, r, o);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Cw(this, e, r, o);
          default:
            if (m)
              throw new TypeError("Unknown encoding: " + f);
            f = ("" + f).toLowerCase(), m = true;
        }
    };
    me.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Ow(t, e, r) {
      return e === 0 && r === t.length ? I0.fromByteArray(t) : I0.fromByteArray(t.slice(e, r));
    }
    function Kd(t, e, r) {
      r = Math.min(t.length, r);
      let o = [], f = e;
      for (;f < r; ) {
        let p = t[f], m = null, y = p > 239 ? 4 : p > 223 ? 3 : p > 191 ? 2 : 1;
        if (f + y <= r) {
          let M, x, S2, E;
          switch (y) {
            case 1:
              p < 128 && (m = p);
              break;
            case 2:
              M = t[f + 1], (M & 192) === 128 && (E = (p & 31) << 6 | M & 63, E > 127 && (m = E));
              break;
            case 3:
              M = t[f + 1], x = t[f + 2], (M & 192) === 128 && (x & 192) === 128 && (E = (p & 15) << 12 | (M & 63) << 6 | x & 63, E > 2047 && (E < 55296 || E > 57343) && (m = E));
              break;
            case 4:
              M = t[f + 1], x = t[f + 2], S2 = t[f + 3], (M & 192) === 128 && (x & 192) === 128 && (S2 & 192) === 128 && (E = (p & 15) << 18 | (M & 63) << 12 | (x & 63) << 6 | S2 & 63, E > 65535 && E < 1114112 && (m = E));
          }
        }
        m === null ? (m = 65533, y = 1) : m > 65535 && (m -= 65536, o.push(m >>> 10 & 1023 | 55296), m = 56320 | m & 1023), o.push(m), f += y;
      }
      return Fw(o);
    }
    var Od = 4096;
    function Fw(t) {
      let e = t.length;
      if (e <= Od)
        return String.fromCharCode.apply(String, t);
      let r = "", o = 0;
      for (;o < e; )
        r += String.fromCharCode.apply(String, t.slice(o, o += Od));
      return r;
    }
    function Uw(t, e, r) {
      let o = "";
      r = Math.min(t.length, r);
      for (let f = e;f < r; ++f)
        o += String.fromCharCode(t[f] & 127);
      return o;
    }
    function zw(t, e, r) {
      let o = "";
      r = Math.min(t.length, r);
      for (let f = e;f < r; ++f)
        o += String.fromCharCode(t[f]);
      return o;
    }
    function Hw(t, e, r) {
      let o = t.length;
      (!e || e < 0) && (e = 0), (!r || r < 0 || r > o) && (r = o);
      let f = "";
      for (let p = e;p < r; ++p)
        f += Gw[t[p]];
      return f;
    }
    function Ww(t, e, r) {
      let o = t.slice(e, r), f = "";
      for (let p = 0;p < o.length - 1; p += 2)
        f += String.fromCharCode(o[p] + o[p + 1] * 256);
      return f;
    }
    me.prototype.slice = function(e, r) {
      let o = this.length;
      e = ~~e, r = r === undefined ? o : ~~r, e < 0 ? (e += o, e < 0 && (e = 0)) : e > o && (e = o), r < 0 ? (r += o, r < 0 && (r = 0)) : r > o && (r = o), r < e && (r = e);
      let f = this.subarray(e, r);
      return Object.setPrototypeOf(f, me.prototype), f;
    };
    function Dt(t, e, r) {
      if (t % 1 !== 0 || t < 0)
        throw new RangeError("offset is not uint");
      if (t + e > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    me.prototype.readUintLE = me.prototype.readUIntLE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f = this[e], p = 1, m = 0;
      for (;++m < r && (p *= 256); )
        f += this[e + m] * p;
      return f;
    };
    me.prototype.readUintBE = me.prototype.readUIntBE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f = this[e + --r], p = 1;
      for (;r > 0 && (p *= 256); )
        f += this[e + --r] * p;
      return f;
    };
    me.prototype.readUint8 = me.prototype.readUInt8 = function(e, r) {
      return e = e >>> 0, r || Dt(e, 1, this.length), this[e];
    };
    me.prototype.readUint16LE = me.prototype.readUInt16LE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 2, this.length), this[e] | this[e + 1] << 8;
    };
    me.prototype.readUint16BE = me.prototype.readUInt16BE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 2, this.length), this[e] << 8 | this[e + 1];
    };
    me.prototype.readUint32LE = me.prototype.readUInt32LE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
    };
    me.prototype.readUint32BE = me.prototype.readUInt32BE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
    };
    me.prototype.readBigUInt64LE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f = r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, p = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + o * 2 ** 24;
      return BigInt(f) + (BigInt(p) << BigInt(32));
    });
    me.prototype.readBigUInt64BE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f = r * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], p = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o;
      return (BigInt(f) << BigInt(32)) + BigInt(p);
    });
    me.prototype.readIntLE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f = this[e], p = 1, m = 0;
      for (;++m < r && (p *= 256); )
        f += this[e + m] * p;
      return p *= 128, f >= p && (f -= Math.pow(2, 8 * r)), f;
    };
    me.prototype.readIntBE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f = r, p = 1, m = this[e + --f];
      for (;f > 0 && (p *= 256); )
        m += this[e + --f] * p;
      return p *= 128, m >= p && (m -= Math.pow(2, 8 * r)), m;
    };
    me.prototype.readInt8 = function(e, r) {
      return e = e >>> 0, r || Dt(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
    };
    me.prototype.readInt16LE = function(e, r) {
      e = e >>> 0, r || Dt(e, 2, this.length);
      let o = this[e] | this[e + 1] << 8;
      return o & 32768 ? o | 4294901760 : o;
    };
    me.prototype.readInt16BE = function(e, r) {
      e = e >>> 0, r || Dt(e, 2, this.length);
      let o = this[e + 1] | this[e] << 8;
      return o & 32768 ? o | 4294901760 : o;
    };
    me.prototype.readInt32LE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
    };
    me.prototype.readInt32BE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
    };
    me.prototype.readBigInt64LE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (o << 24);
      return (BigInt(f) << BigInt(32)) + BigInt(r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
    });
    me.prototype.readBigInt64BE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f = (r << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
      return (BigInt(f) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o);
    });
    me.prototype.readFloatLE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), Gn.read(this, e, true, 23, 4);
    };
    me.prototype.readFloatBE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), Gn.read(this, e, false, 23, 4);
    };
    me.prototype.readDoubleLE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 8, this.length), Gn.read(this, e, true, 52, 8);
    };
    me.prototype.readDoubleBE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 8, this.length), Gn.read(this, e, false, 52, 8);
    };
    function er(t, e, r, o, f, p) {
      if (!me.isBuffer(t))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e > f || e < p)
        throw new RangeError('"value" argument is out of bounds');
      if (r + o > t.length)
        throw new RangeError("Index out of range");
    }
    me.prototype.writeUintLE = me.prototype.writeUIntLE = function(e, r, o, f) {
      if (e = +e, r = r >>> 0, o = o >>> 0, !f) {
        let y = Math.pow(2, 8 * o) - 1;
        er(this, e, r, o, y, 0);
      }
      let p = 1, m = 0;
      for (this[r] = e & 255;++m < o && (p *= 256); )
        this[r + m] = e / p & 255;
      return r + o;
    };
    me.prototype.writeUintBE = me.prototype.writeUIntBE = function(e, r, o, f) {
      if (e = +e, r = r >>> 0, o = o >>> 0, !f) {
        let y = Math.pow(2, 8 * o) - 1;
        er(this, e, r, o, y, 0);
      }
      let p = o - 1, m = 1;
      for (this[r + p] = e & 255;--p >= 0 && (m *= 256); )
        this[r + p] = e / m & 255;
      return r + o;
    };
    me.prototype.writeUint8 = me.prototype.writeUInt8 = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 1, 255, 0), this[r] = e & 255, r + 1;
    };
    me.prototype.writeUint16LE = me.prototype.writeUInt16LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 65535, 0), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    me.prototype.writeUint16BE = me.prototype.writeUInt16BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 65535, 0), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    me.prototype.writeUint32LE = me.prototype.writeUInt32LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 4294967295, 0), this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255, r + 4;
    };
    me.prototype.writeUint32BE = me.prototype.writeUInt32BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 4294967295, 0), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    function jd(t, e, r, o, f) {
      Yd(e, o, f, t, r, 7);
      let p = Number(e & BigInt(4294967295));
      t[r++] = p, p = p >> 8, t[r++] = p, p = p >> 8, t[r++] = p, p = p >> 8, t[r++] = p;
      let m = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r++] = m, m = m >> 8, t[r++] = m, m = m >> 8, t[r++] = m, m = m >> 8, t[r++] = m, r;
    }
    function Zd(t, e, r, o, f) {
      Yd(e, o, f, t, r, 7);
      let p = Number(e & BigInt(4294967295));
      t[r + 7] = p, p = p >> 8, t[r + 6] = p, p = p >> 8, t[r + 5] = p, p = p >> 8, t[r + 4] = p;
      let m = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r + 3] = m, m = m >> 8, t[r + 2] = m, m = m >> 8, t[r + 1] = m, m = m >> 8, t[r] = m, r + 8;
    }
    me.prototype.writeBigUInt64LE = Ti(function(e, r = 0) {
      return jd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeBigUInt64BE = Ti(function(e, r = 0) {
      return Zd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeIntLE = function(e, r, o, f) {
      if (e = +e, r = r >>> 0, !f) {
        let M = Math.pow(2, 8 * o - 1);
        er(this, e, r, o, M - 1, -M);
      }
      let p = 0, m = 1, y = 0;
      for (this[r] = e & 255;++p < o && (m *= 256); )
        e < 0 && y === 0 && this[r + p - 1] !== 0 && (y = 1), this[r + p] = (e / m >> 0) - y & 255;
      return r + o;
    };
    me.prototype.writeIntBE = function(e, r, o, f) {
      if (e = +e, r = r >>> 0, !f) {
        let M = Math.pow(2, 8 * o - 1);
        er(this, e, r, o, M - 1, -M);
      }
      let p = o - 1, m = 1, y = 0;
      for (this[r + p] = e & 255;--p >= 0 && (m *= 256); )
        e < 0 && y === 0 && this[r + p + 1] !== 0 && (y = 1), this[r + p] = (e / m >> 0) - y & 255;
      return r + o;
    };
    me.prototype.writeInt8 = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
    };
    me.prototype.writeInt16LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 32767, -32768), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    me.prototype.writeInt16BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 32767, -32768), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    me.prototype.writeInt32LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 2147483647, -2147483648), this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24, r + 4;
    };
    me.prototype.writeInt32BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    me.prototype.writeBigInt64LE = Ti(function(e, r = 0) {
      return jd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    me.prototype.writeBigInt64BE = Ti(function(e, r = 0) {
      return Zd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Vd(t, e, r, o, f, p) {
      if (r + o > t.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function $d(t, e, r, o, f) {
      return e = +e, r = r >>> 0, f || Vd(t, e, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), Gn.write(t, e, r, o, 23, 4), r + 4;
    }
    me.prototype.writeFloatLE = function(e, r, o) {
      return $d(this, e, r, true, o);
    };
    me.prototype.writeFloatBE = function(e, r, o) {
      return $d(this, e, r, false, o);
    };
    function Gd(t, e, r, o, f) {
      return e = +e, r = r >>> 0, f || Vd(t, e, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), Gn.write(t, e, r, o, 52, 8), r + 8;
    }
    me.prototype.writeDoubleLE = function(e, r, o) {
      return Gd(this, e, r, true, o);
    };
    me.prototype.writeDoubleBE = function(e, r, o) {
      return Gd(this, e, r, false, o);
    };
    me.prototype.copy = function(e, r, o, f) {
      if (!me.isBuffer(e))
        throw new TypeError("argument should be a Buffer");
      if (o || (o = 0), !f && f !== 0 && (f = this.length), r >= e.length && (r = e.length), r || (r = 0), f > 0 && f < o && (f = o), f === o || e.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (o < 0 || o >= this.length)
        throw new RangeError("Index out of range");
      if (f < 0)
        throw new RangeError("sourceEnd out of bounds");
      f > this.length && (f = this.length), e.length - r < f - o && (f = e.length - r + o);
      let p = f - o;
      return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, o, f) : Uint8Array.prototype.set.call(e, this.subarray(o, f), r), p;
    };
    me.prototype.fill = function(e, r, o, f) {
      if (typeof e == "string") {
        if (typeof r == "string" ? (f = r, r = 0, o = this.length) : typeof o == "string" && (f = o, o = this.length), f !== undefined && typeof f != "string")
          throw new TypeError("encoding must be a string");
        if (typeof f == "string" && !me.isEncoding(f))
          throw new TypeError("Unknown encoding: " + f);
        if (e.length === 1) {
          let m = e.charCodeAt(0);
          (f === "utf8" && m < 128 || f === "latin1") && (e = m);
        }
      } else
        typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
      if (r < 0 || this.length < r || this.length < o)
        throw new RangeError("Out of range index");
      if (o <= r)
        return this;
      r = r >>> 0, o = o === undefined ? this.length : o >>> 0, e || (e = 0);
      let p;
      if (typeof e == "number")
        for (p = r;p < o; ++p)
          this[p] = e;
      else {
        let m = me.isBuffer(e) ? e : me.from(e, f), y = m.length;
        if (y === 0)
          throw new TypeError('The value "' + e + '" is invalid for argument "value"');
        for (p = 0;p < o - r; ++p)
          this[p + r] = m[p % y];
      }
      return this;
    };
    var $n = {};
    function P0(t, e, r) {
      $n[t] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t}]`, this.stack, delete this.name;
        }
        get code() {
          return t;
        }
        set code(f) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: f, writable: true });
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      };
    }
    P0("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
      return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    P0("ERR_INVALID_ARG_TYPE", function(t, e) {
      return `The "${t}" argument must be of type number. Received type ${typeof e}`;
    }, TypeError);
    P0("ERR_OUT_OF_RANGE", function(t, e, r) {
      let o = `The value of "${t}" is out of range.`, f = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? f = Fd(String(r)) : typeof r == "bigint" && (f = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (f = Fd(f)), f += "n"), o += ` It must be ${e}. Received ${f}`, o;
    }, RangeError);
    function Fd(t) {
      let e = "", r = t.length, o = t[0] === "-" ? 1 : 0;
      for (;r >= o + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function Kw(t, e, r) {
      Yn(e, "offset"), (t[e] === undefined || t[e + r] === undefined) && Vf(e, t.length - (r + 1));
    }
    function Yd(t, e, r, o, f, p) {
      if (t > r || t < e) {
        let m = typeof e == "bigint" ? "n" : "", y;
        throw p > 3 ? e === 0 || e === BigInt(0) ? y = `>= 0${m} and < 2${m} ** ${(p + 1) * 8}${m}` : y = `>= -(2${m} ** ${(p + 1) * 8 - 1}${m}) and < 2 ** ${(p + 1) * 8 - 1}${m}` : y = `>= ${e}${m} and <= ${r}${m}`, new $n.ERR_OUT_OF_RANGE("value", y, t);
      }
      Kw(o, f, p);
    }
    function Yn(t, e) {
      if (typeof t != "number")
        throw new $n.ERR_INVALID_ARG_TYPE(e, "number", t);
    }
    function Vf(t, e, r) {
      throw Math.floor(t) !== t ? (Yn(t, r), new $n.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : e < 0 ? new $n.ERR_BUFFER_OUT_OF_BOUNDS : new $n.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${e}`, t);
    }
    var jw = /[^+/0-9A-Za-z-_]/g;
    function Zw(t) {
      if (t = t.split("=")[0], t = t.trim().replace(jw, ""), t.length < 2)
        return "";
      for (;t.length % 4 !== 0; )
        t = t + "=";
      return t;
    }
    function L0(t, e) {
      e = e || 1 / 0;
      let r, o = t.length, f = null, p = [];
      for (let m = 0;m < o; ++m) {
        if (r = t.charCodeAt(m), r > 55295 && r < 57344) {
          if (!f) {
            if (r > 56319) {
              (e -= 3) > -1 && p.push(239, 191, 189);
              continue;
            } else if (m + 1 === o) {
              (e -= 3) > -1 && p.push(239, 191, 189);
              continue;
            }
            f = r;
            continue;
          }
          if (r < 56320) {
            (e -= 3) > -1 && p.push(239, 191, 189), f = r;
            continue;
          }
          r = (f - 55296 << 10 | r - 56320) + 65536;
        } else
          f && (e -= 3) > -1 && p.push(239, 191, 189);
        if (f = null, r < 128) {
          if ((e -= 1) < 0)
            break;
          p.push(r);
        } else if (r < 2048) {
          if ((e -= 2) < 0)
            break;
          p.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((e -= 3) < 0)
            break;
          p.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((e -= 4) < 0)
            break;
          p.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return p;
    }
    function Vw(t) {
      let e = [];
      for (let r = 0;r < t.length; ++r)
        e.push(t.charCodeAt(r) & 255);
      return e;
    }
    function $w(t, e) {
      let r, o, f, p = [];
      for (let m = 0;m < t.length && !((e -= 2) < 0); ++m)
        r = t.charCodeAt(m), o = r >> 8, f = r % 256, p.push(f), p.push(o);
      return p;
    }
    function Xd(t) {
      return I0.toByteArray(Zw(t));
    }
    function to(t, e, r, o) {
      let f;
      for (f = 0;f < o && !(f + r >= e.length || f >= t.length); ++f)
        e[f + r] = t[f];
      return f;
    }
    function Zr(t, e) {
      return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name;
    }
    function C0(t) {
      return t !== t;
    }
    var Gw = function() {
      let t = "0123456789abcdef", e = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let o = r * 16;
        for (let f = 0;f < 16; ++f)
          e[o + f] = t[r] + t[f];
      }
      return e;
    }();
    function Ti(t) {
      return typeof BigInt > "u" ? Yw : t;
    }
    function Yw() {
      throw new Error("BigInt not supported");
    }
  });
  Te = T((O0, Qd) => {
    var ro = Ut(), Vr = ro.Buffer;
    function Jd(t, e) {
      for (var r in t)
        e[r] = t[r];
    }
    Vr.from && Vr.alloc && Vr.allocUnsafe && Vr.allocUnsafeSlow ? Qd.exports = ro : (Jd(ro, O0), O0.Buffer = an);
    function an(t, e, r) {
      return Vr(t, e, r);
    }
    an.prototype = Object.create(Vr.prototype);
    Jd(Vr, an);
    an.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError("Argument must not be a number");
      return Vr(t, e, r);
    };
    an.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      var o = Vr(t);
      return e !== undefined ? typeof r == "string" ? o.fill(e, r) : o.fill(e) : o.fill(0), o;
    };
    an.allocUnsafe = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return Vr(t);
    };
    an.allocUnsafeSlow = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return ro.SlowBuffer(t);
    };
  });
  on = T((Gq, U0) => {
    var F0 = 65536, Xw = 4294967295;
    function Jw() {
      throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
    }
    var Qw = Te().Buffer, io = global.crypto || global.msCrypto;
    io && io.getRandomValues ? U0.exports = e6 : U0.exports = Jw;
    function e6(t, e) {
      if (t > Xw)
        throw new RangeError("requested too many random bytes");
      var r = Qw.allocUnsafe(t);
      if (t > 0)
        if (t > F0)
          for (var o = 0;o < t; o += F0)
            io.getRandomValues(r.slice(o, o + F0));
        else
          io.getRandomValues(r);
      return typeof e == "function" ? process.nextTick(function() {
        e(null, r);
      }) : r;
    }
  });
  Ie = T((Yq, z0) => {
    typeof Object.create == "function" ? z0.exports = function(e, r) {
      r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
    } : z0.exports = function(e, r) {
      if (r) {
        e.super_ = r;
        var o = function() {
        };
        o.prototype = r.prototype, e.prototype = new o, e.prototype.constructor = e;
      }
    };
  });
  ki = T((Xq, H0) => {
    var Jn = typeof Reflect == "object" ? Reflect : null, ec = Jn && typeof Jn.apply == "function" ? Jn.apply : function(e, r, o) {
      return Function.prototype.apply.call(e, r, o);
    }, no;
    Jn && typeof Jn.ownKeys == "function" ? no = Jn.ownKeys : Object.getOwnPropertySymbols ? no = function(e) {
      return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
    } : no = function(e) {
      return Object.getOwnPropertyNames(e);
    };
    function t6(t) {
      console && console.warn && console.warn(t);
    }
    var rc = Number.isNaN || function(e) {
      return e !== e;
    };
    function Fe() {
      Fe.init.call(this);
    }
    H0.exports = Fe;
    H0.exports.once = f6;
    Fe.EventEmitter = Fe;
    Fe.prototype._events = undefined;
    Fe.prototype._eventsCount = 0;
    Fe.prototype._maxListeners = undefined;
    var tc = 10;
    function fo(t) {
      if (typeof t != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
    }
    Object.defineProperty(Fe, "defaultMaxListeners", { enumerable: true, get: function() {
      return tc;
    }, set: function(t) {
      if (typeof t != "number" || t < 0 || rc(t))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
      tc = t;
    } });
    Fe.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    Fe.prototype.setMaxListeners = function(e) {
      if (typeof e != "number" || e < 0 || rc(e))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
      return this._maxListeners = e, this;
    };
    function ic(t) {
      return t._maxListeners === undefined ? Fe.defaultMaxListeners : t._maxListeners;
    }
    Fe.prototype.getMaxListeners = function() {
      return ic(this);
    };
    Fe.prototype.emit = function(e) {
      for (var r = [], o = 1;o < arguments.length; o++)
        r.push(arguments[o]);
      var f = e === "error", p = this._events;
      if (p !== undefined)
        f = f && p.error === undefined;
      else if (!f)
        return false;
      if (f) {
        var m;
        if (r.length > 0 && (m = r[0]), m instanceof Error)
          throw m;
        var y = new Error("Unhandled error." + (m ? " (" + m.message + ")" : ""));
        throw y.context = m, y;
      }
      var M = p[e];
      if (M === undefined)
        return false;
      if (typeof M == "function")
        ec(M, this, r);
      else
        for (var x = M.length, S2 = sc(M, x), o = 0;o < x; ++o)
          ec(S2[o], this, r);
      return true;
    };
    function nc(t, e, r, o) {
      var f, p, m;
      if (fo(r), p = t._events, p === undefined ? (p = t._events = Object.create(null), t._eventsCount = 0) : (p.newListener !== undefined && (t.emit("newListener", e, r.listener ? r.listener : r), p = t._events), m = p[e]), m === undefined)
        m = p[e] = r, ++t._eventsCount;
      else if (typeof m == "function" ? m = p[e] = o ? [r, m] : [m, r] : o ? m.unshift(r) : m.push(r), f = ic(t), f > 0 && m.length > f && !m.warned) {
        m.warned = true;
        var y = new Error("Possible EventEmitter memory leak detected. " + m.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        y.name = "MaxListenersExceededWarning", y.emitter = t, y.type = e, y.count = m.length, t6(y);
      }
      return t;
    }
    Fe.prototype.addListener = function(e, r) {
      return nc(this, e, r, false);
    };
    Fe.prototype.on = Fe.prototype.addListener;
    Fe.prototype.prependListener = function(e, r) {
      return nc(this, e, r, true);
    };
    function r6() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function fc(t, e, r) {
      var o = { fired: false, wrapFn: undefined, target: t, type: e, listener: r }, f = r6.bind(o);
      return f.listener = r, o.wrapFn = f, f;
    }
    Fe.prototype.once = function(e, r) {
      return fo(r), this.on(e, fc(this, e, r)), this;
    };
    Fe.prototype.prependOnceListener = function(e, r) {
      return fo(r), this.prependListener(e, fc(this, e, r)), this;
    };
    Fe.prototype.removeListener = function(e, r) {
      var o, f, p, m, y;
      if (fo(r), f = this._events, f === undefined)
        return this;
      if (o = f[e], o === undefined)
        return this;
      if (o === r || o.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete f[e], f.removeListener && this.emit("removeListener", e, o.listener || r));
      else if (typeof o != "function") {
        for (p = -1, m = o.length - 1;m >= 0; m--)
          if (o[m] === r || o[m].listener === r) {
            y = o[m].listener, p = m;
            break;
          }
        if (p < 0)
          return this;
        p === 0 ? o.shift() : i6(o, p), o.length === 1 && (f[e] = o[0]), f.removeListener !== undefined && this.emit("removeListener", e, y || r);
      }
      return this;
    };
    Fe.prototype.off = Fe.prototype.removeListener;
    Fe.prototype.removeAllListeners = function(e) {
      var r, o, f;
      if (o = this._events, o === undefined)
        return this;
      if (o.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : o[e] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete o[e]), this;
      if (arguments.length === 0) {
        var p = Object.keys(o), m;
        for (f = 0;f < p.length; ++f)
          m = p[f], m !== "removeListener" && this.removeAllListeners(m);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = o[e], typeof r == "function")
        this.removeListener(e, r);
      else if (r !== undefined)
        for (f = r.length - 1;f >= 0; f--)
          this.removeListener(e, r[f]);
      return this;
    };
    function ac(t, e, r) {
      var o = t._events;
      if (o === undefined)
        return [];
      var f = o[e];
      return f === undefined ? [] : typeof f == "function" ? r ? [f.listener || f] : [f] : r ? n6(f) : sc(f, f.length);
    }
    Fe.prototype.listeners = function(e) {
      return ac(this, e, true);
    };
    Fe.prototype.rawListeners = function(e) {
      return ac(this, e, false);
    };
    Fe.listenerCount = function(t, e) {
      return typeof t.listenerCount == "function" ? t.listenerCount(e) : oc.call(t, e);
    };
    Fe.prototype.listenerCount = oc;
    function oc(t) {
      var e = this._events;
      if (e !== undefined) {
        var r = e[t];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    Fe.prototype.eventNames = function() {
      return this._eventsCount > 0 ? no(this._events) : [];
    };
    function sc(t, e) {
      for (var r = new Array(e), o = 0;o < e; ++o)
        r[o] = t[o];
      return r;
    }
    function i6(t, e) {
      for (;e + 1 < t.length; e++)
        t[e] = t[e + 1];
      t.pop();
    }
    function n6(t) {
      for (var e = new Array(t.length), r = 0;r < e.length; ++r)
        e[r] = t[r].listener || t[r];
      return e;
    }
    function f6(t, e) {
      return new Promise(function(r, o) {
        function f(m) {
          t.removeListener(e, p), o(m);
        }
        function p() {
          typeof t.removeListener == "function" && t.removeListener("error", f), r([].slice.call(arguments));
        }
        hc(t, e, p, { once: true }), e !== "error" && a6(t, f, { once: true });
      });
    }
    function a6(t, e, r) {
      typeof t.on == "function" && hc(t, "error", e, r);
    }
    function hc(t, e, r, o) {
      if (typeof t.on == "function")
        o.once ? t.once(e, r) : t.on(e, r);
      else if (typeof t.addEventListener == "function")
        t.addEventListener(e, function f(p) {
          o.once && t.removeEventListener(e, f), r(p);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
    }
  });
  W0 = T((Jq, uc) => {
    uc.exports = ki().EventEmitter;
  });
  $f = T(() => {
  });
  pc = T((tI, cc) => {
    function lc(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(t);
        e && (o = o.filter(function(f) {
          return Object.getOwnPropertyDescriptor(t, f).enumerable;
        })), r.push.apply(r, o);
      }
      return r;
    }
    function o6(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? lc(Object(r), true).forEach(function(o) {
          s6(t, o, r[o]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lc(Object(r)).forEach(function(o) {
          Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(r, o));
        });
      }
      return t;
    }
    function s6(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function h6(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function dc(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o = e[r];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
      }
    }
    function u6(t, e, r) {
      return e && dc(t.prototype, e), r && dc(t, r), t;
    }
    var l6 = Ut(), ao = l6.Buffer, d6 = $f(), K0 = d6.inspect, c6 = K0 && K0.custom || "inspect";
    function p6(t, e, r) {
      ao.prototype.copy.call(t, e, r);
    }
    cc.exports = function() {
      function t() {
        h6(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return u6(t, [{ key: "push", value: function(r) {
        var o = { data: r, next: null };
        this.length > 0 ? this.tail.next = o : this.head = o, this.tail = o, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o = { data: r, next: this.head };
        this.length === 0 && (this.tail = o), this.head = o, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o = this.head, f = "" + o.data;o = o.next; )
          f += r + o.data;
        return f;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return ao.alloc(0);
        for (var o = ao.allocUnsafe(r >>> 0), f = this.head, p = 0;f; )
          p6(f.data, o, p), p += f.data.length, f = f.next;
        return o;
      } }, { key: "consume", value: function(r, o) {
        var f;
        return r < this.head.data.length ? (f = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f = this.shift() : f = o ? this._getString(r) : this._getBuffer(r), f;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o = this.head, f = 1, p = o.data;
        for (r -= p.length;o = o.next; ) {
          var m = o.data, y = r > m.length ? m.length : r;
          if (y === m.length ? p += m : p += m.slice(0, r), r -= y, r === 0) {
            y === m.length ? (++f, o.next ? this.head = o.next : this.head = this.tail = null) : (this.head = o, o.data = m.slice(y));
            break;
          }
          ++f;
        }
        return this.length -= f, p;
      } }, { key: "_getBuffer", value: function(r) {
        var o = ao.allocUnsafe(r), f = this.head, p = 1;
        for (f.data.copy(o), r -= f.data.length;f = f.next; ) {
          var m = f.data, y = r > m.length ? m.length : r;
          if (m.copy(o, o.length - r, 0, y), r -= y, r === 0) {
            y === m.length ? (++p, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = m.slice(y));
            break;
          }
          ++p;
        }
        return this.length -= p, o;
      } }, { key: c6, value: function(r, o) {
        return K0(this, o6({}, o, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  Z0 = T((rI, bc) => {
    function v6(t, e) {
      var r = this, o = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
      return o || f ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(j0, this, t)) : process.nextTick(j0, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p) {
        !e && p ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(oo, r) : (r._writableState.errorEmitted = true, process.nextTick(vc, r, p)) : process.nextTick(vc, r, p) : e ? (process.nextTick(oo, r), e(p)) : process.nextTick(oo, r);
      }), this);
    }
    function vc(t, e) {
      j0(t, e), oo(t);
    }
    function oo(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function b6() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function j0(t, e) {
      t.emit("error", e);
    }
    function m6(t, e) {
      var { _readableState: r, _writableState: o } = t;
      r && r.autoDestroy || o && o.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    bc.exports = { destroy: v6, undestroy: b6, errorOrDestroy: m6 };
  });
  sn = T((iI, yc) => {
    function g6(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var gc = {};
    function dr2(t, e, r) {
      r || (r = Error);
      function o(p, m, y) {
        return typeof e == "string" ? e : e(p, m, y);
      }
      var f = function(p) {
        g6(m, p);
        function m(y, M, x) {
          return p.call(this, o(y, M, x)) || this;
        }
        return m;
      }(r);
      f.prototype.name = r.name, f.prototype.code = t, gc[t] = f;
    }
    function mc(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o) {
          return String(o);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function y6(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function w6(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function M6(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    dr2("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    dr2("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o;
      typeof e == "string" && y6(e, "not ") ? (o = "must not be", e = e.replace(/^not /, "")) : o = "must be";
      var f;
      if (w6(t, " argument"))
        f = "The ".concat(t, " ").concat(o, " ").concat(mc(e, "type"));
      else {
        var p = M6(t, ".") ? "property" : "argument";
        f = 'The "'.concat(t, '" ').concat(p, " ").concat(o, " ").concat(mc(e, "type"));
      }
      return f += ". Received type ".concat(typeof r), f;
    }, TypeError);
    dr2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    dr2("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    dr2("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    dr2("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    dr2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    dr2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    dr2("ERR_STREAM_WRITE_AFTER_END", "write after end");
    dr2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    dr2("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    dr2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yc.exports.codes = gc;
  });
  V0 = T((nI, wc) => {
    var _6 = sn().codes.ERR_INVALID_OPT_VALUE;
    function x6(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function S6(t, e, r, o) {
      var f = x6(e, o, r);
      if (f != null) {
        if (!(isFinite(f) && Math.floor(f) === f) || f < 0) {
          var p = o ? r : "highWaterMark";
          throw new _6(p, f);
        }
        return Math.floor(f);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wc.exports = { getHighWaterMark: S6 };
  });
  G0 = T((fI, Mc) => {
    Mc.exports = E6;
    function E6(t, e) {
      if ($0("noDeprecation"))
        return t;
      var r = false;
      function o() {
        if (!r) {
          if ($0("throwDeprecation"))
            throw new Error(e);
          $0("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
        }
        return t.apply(this, arguments);
      }
      return o;
    }
    function $0(t) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var e = global.localStorage[t];
      return e == null ? false : String(e).toLowerCase() === "true";
    }
  });
  J0 = T((aI, Rc) => {
    Rc.exports = ht;
    function xc(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        J6(e, t);
      };
    }
    var Qn;
    ht.WritableState = Yf;
    var A6 = { deprecate: G0() }, Sc = W0(), ho = Ut().Buffer, R6 = global.Uint8Array || function() {
    };
    function B6(t) {
      return ho.from(t);
    }
    function q6(t) {
      return ho.isBuffer(t) || t instanceof R6;
    }
    var X0 = Z0(), I6 = V0(), T6 = I6.getHighWaterMark, Li = sn().codes, k6 = Li.ERR_INVALID_ARG_TYPE, L6 = Li.ERR_METHOD_NOT_IMPLEMENTED, N6 = Li.ERR_MULTIPLE_CALLBACK, D6 = Li.ERR_STREAM_CANNOT_PIPE, P6 = Li.ERR_STREAM_DESTROYED, C6 = Li.ERR_STREAM_NULL_VALUES, O6 = Li.ERR_STREAM_WRITE_AFTER_END, F6 = Li.ERR_UNKNOWN_ENCODING, ef = X0.errorOrDestroy;
    Ie()(ht, Sc);
    function U6() {
    }
    function Yf(t, e, r) {
      Qn = Qn || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof Qn), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = T6(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o = t.decodeStrings === false;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f) {
        V6(e, f);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new xc(this);
    }
    Yf.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Yf.prototype, "buffer", { get: A6.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var so;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (so = Function.prototype[Symbol.hasInstance], Object.defineProperty(ht, Symbol.hasInstance, { value: function(e) {
      return so.call(this, e) ? true : this !== ht ? false : e && e._writableState instanceof Yf;
    } })) : so = function(e) {
      return e instanceof this;
    };
    function ht(t) {
      Qn = Qn || hn();
      var e = this instanceof Qn;
      if (!e && !so.call(ht, this))
        return new ht(t);
      this._writableState = new Yf(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), Sc.call(this);
    }
    ht.prototype.pipe = function() {
      ef(this, new D6);
    };
    function z6(t, e) {
      var r = new O6;
      ef(t, r), process.nextTick(e, r);
    }
    function H6(t, e, r, o) {
      var f;
      return r === null ? f = new C6 : typeof r != "string" && !e.objectMode && (f = new k6("chunk", ["string", "Buffer"], r)), f ? (ef(t, f), process.nextTick(o, f), false) : true;
    }
    ht.prototype.write = function(t, e, r) {
      var o = this._writableState, f = false, p = !o.objectMode && q6(t);
      return p && !ho.isBuffer(t) && (t = B6(t)), typeof e == "function" && (r = e, e = null), p ? e = "buffer" : e || (e = o.defaultEncoding), typeof r != "function" && (r = U6), o.ending ? z6(this, r) : (p || H6(this, o, t, r)) && (o.pendingcb++, f = K6(this, o, p, t, e, r)), f;
    };
    ht.prototype.cork = function() {
      this._writableState.corked++;
    };
    ht.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Ec(this, t));
    };
    ht.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new F6(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ht.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function W6(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ho.from(e, r)), e;
    }
    Object.defineProperty(ht.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function K6(t, e, r, o, f, p) {
      if (!r) {
        var m = W6(e, o, f);
        o !== m && (r = true, f = "buffer", o = m);
      }
      var y = e.objectMode ? 1 : o.length;
      e.length += y;
      var M = e.length < e.highWaterMark;
      if (M || (e.needDrain = true), e.writing || e.corked) {
        var x = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o, encoding: f, isBuf: r, callback: p, next: null }, x ? x.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        Y0(t, e, false, y, o, f, p);
      return M;
    }
    function Y0(t, e, r, o, f, p, m) {
      e.writelen = o, e.writecb = m, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new P6("write")) : r ? t._writev(f, e.onwrite) : t._write(f, p, e.onwrite), e.sync = false;
    }
    function j6(t, e, r, o, f) {
      --e.pendingcb, r ? (process.nextTick(f, o), process.nextTick(Gf, t, e), t._writableState.errorEmitted = true, ef(t, o)) : (f(o), t._writableState.errorEmitted = true, ef(t, o), Gf(t, e));
    }
    function Z6(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function V6(t, e) {
      var r = t._writableState, o = r.sync, f = r.writecb;
      if (typeof f != "function")
        throw new N6;
      if (Z6(r), e)
        j6(t, r, o, e, f);
      else {
        var p = Ac(r) || t.destroyed;
        !p && !r.corked && !r.bufferProcessing && r.bufferedRequest && Ec(t, r), o ? process.nextTick(_c, t, r, p, f) : _c(t, r, p, f);
      }
    }
    function _c(t, e, r, o) {
      r || $6(t, e), e.pendingcb--, o(), Gf(t, e);
    }
    function $6(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Ec(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o = e.bufferedRequestCount, f = new Array(o), p = e.corkedRequestsFree;
        p.entry = r;
        for (var m = 0, y = true;r; )
          f[m] = r, r.isBuf || (y = false), r = r.next, m += 1;
        f.allBuffers = y, Y0(t, e, true, e.length, f, "", p.finish), e.pendingcb++, e.lastBufferedRequest = null, p.next ? (e.corkedRequestsFree = p.next, p.next = null) : e.corkedRequestsFree = new xc(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M, encoding: x, callback: S2 } = r, E = e.objectMode ? 1 : M.length;
          if (Y0(t, e, false, E, M, x, S2), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ht.prototype._write = function(t, e, r) {
      r(new L6("_write()"));
    };
    ht.prototype._writev = null;
    ht.prototype.end = function(t, e, r) {
      var o = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o.corked && (o.corked = 1, this.uncork()), o.ending || X6(this, o, r), this;
    };
    Object.defineProperty(ht.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Ac(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function G6(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && ef(t, r), e.prefinished = true, t.emit("prefinish"), Gf(t, e);
      });
    }
    function Y6(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(G6, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Gf(t, e) {
      var r = Ac(e);
      if (r && (Y6(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o = t._readableState;
        (!o || o.autoDestroy && o.endEmitted) && t.destroy();
      }
      return r;
    }
    function X6(t, e, r) {
      e.ending = true, Gf(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function J6(t, e, r) {
      var o = t.entry;
      for (t.entry = null;o; ) {
        var f = o.callback;
        e.pendingcb--, f(r), o = o.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ht.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ht.prototype.destroy = X0.destroy;
    ht.prototype._undestroy = X0.undestroy;
    ht.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  hn = T((oI, qc) => {
    var Q6 = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    qc.exports = $r;
    var Bc = th(), eh = J0();
    Ie()($r, Bc);
    for (Q0 = Q6(eh.prototype), uo = 0;uo < Q0.length; uo++)
      lo = Q0[uo], $r.prototype[lo] || ($r.prototype[lo] = eh.prototype[lo]);
    var Q0, lo, uo;
    function $r(t) {
      if (!(this instanceof $r))
        return new $r(t);
      Bc.call(this, t), eh.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", eM)));
    }
    Object.defineProperty($r.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($r.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($r.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function eM() {
      this._writableState.ended || process.nextTick(tM, this);
    }
    function tM(t) {
      t.end();
    }
    Object.defineProperty($r.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  co = T((Tc) => {
    var ih = Te().Buffer, Ic = ih.isEncoding || function(t) {
      switch (t = "" + t, t && t.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function rM(t) {
      if (!t)
        return "utf8";
      for (var e;; )
        switch (t) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t;
          default:
            if (e)
              return;
            t = ("" + t).toLowerCase(), e = true;
        }
    }
    function iM(t) {
      var e = rM(t);
      if (typeof e != "string" && (ih.isEncoding === Ic || !Ic(t)))
        throw new Error("Unknown encoding: " + t);
      return e || t;
    }
    Tc.StringDecoder = Xf;
    function Xf(t) {
      this.encoding = iM(t);
      var e;
      switch (this.encoding) {
        case "utf16le":
          this.text = hM, this.end = uM, e = 4;
          break;
        case "utf8":
          this.fillLast = aM, e = 4;
          break;
        case "base64":
          this.text = lM, this.end = dM, e = 3;
          break;
        default:
          this.write = cM, this.end = pM;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = ih.allocUnsafe(e);
    }
    Xf.prototype.write = function(t) {
      if (t.length === 0)
        return "";
      var e, r;
      if (this.lastNeed) {
        if (e = this.fillLast(t), e === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
    };
    Xf.prototype.end = sM;
    Xf.prototype.text = oM;
    Xf.prototype.fillLast = function(t) {
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
    };
    function rh(t) {
      return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
    }
    function nM(t, e, r) {
      var o = e.length - 1;
      if (o < r)
        return 0;
      var f = rh(e[o]);
      return f >= 0 ? (f > 0 && (t.lastNeed = f - 1), f) : --o < r || f === -2 ? 0 : (f = rh(e[o]), f >= 0 ? (f > 0 && (t.lastNeed = f - 2), f) : --o < r || f === -2 ? 0 : (f = rh(e[o]), f >= 0 ? (f > 0 && (f === 2 ? f = 0 : t.lastNeed = f - 3), f) : 0));
    }
    function fM(t, e, r) {
      if ((e[0] & 192) !== 128)
        return t.lastNeed = 0, "\uFFFD";
      if (t.lastNeed > 1 && e.length > 1) {
        if ((e[1] & 192) !== 128)
          return t.lastNeed = 1, "\uFFFD";
        if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
          return t.lastNeed = 2, "\uFFFD";
      }
    }
    function aM(t) {
      var e = this.lastTotal - this.lastNeed, r = fM(this, t, e);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
    }
    function oM(t, e) {
      var r = nM(this, t, e);
      if (!this.lastNeed)
        return t.toString("utf8", e);
      this.lastTotal = r;
      var o = t.length - (r - this.lastNeed);
      return t.copy(this.lastChar, 0, o), t.toString("utf8", e, o);
    }
    function sM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + "\uFFFD" : e;
    }
    function hM(t, e) {
      if ((t.length - e) % 2 === 0) {
        var r = t.toString("utf16le", e);
        if (r) {
          var o = r.charCodeAt(r.length - 1);
          if (o >= 55296 && o <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
    }
    function uM(t) {
      var e = t && t.length ? this.write(t) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return e + this.lastChar.toString("utf16le", 0, r);
      }
      return e;
    }
    function lM(t, e) {
      var r = (t.length - e) % 3;
      return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
    }
    function dM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
    }
    function cM(t) {
      return t.toString(this.encoding);
    }
    function pM(t) {
      return t && t.length ? this.write(t) : "";
    }
  });
  Jf = {};
  Ja(Jf, { StringDecoder: () => po.StringDecoder, default: () => po.StringDecoder });
  Qf = R0(() => {
    po = rn(co());
  });
  vo = T((hI, Nc) => {
    var kc = sn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function vM(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o = new Array(r), f = 0;f < r; f++)
            o[f] = arguments[f];
          t.apply(this, o);
        }
      };
    }
    function bM() {
    }
    function mM(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Lc(t, e, r) {
      if (typeof e == "function")
        return Lc(t, null, e);
      e || (e = {}), r = vM(r || bM);
      var o = e.readable || e.readable !== false && t.readable, f = e.writable || e.writable !== false && t.writable, p = function() {
        t.writable || y();
      }, m = t._writableState && t._writableState.finished, y = function() {
        f = false, m = true, o || r.call(t);
      }, M = t._readableState && t._readableState.endEmitted, x = function() {
        o = false, M = true, f || r.call(t);
      }, S2 = function(L) {
        r.call(t, L);
      }, E = function() {
        var L;
        if (o && !M)
          return (!t._readableState || !t._readableState.ended) && (L = new kc), r.call(t, L);
        if (f && !m)
          return (!t._writableState || !t._writableState.ended) && (L = new kc), r.call(t, L);
      }, B = function() {
        t.req.on("finish", y);
      };
      return mM(t) ? (t.on("complete", y), t.on("abort", E), t.req ? B() : t.on("request", B)) : f && !t._writableState && (t.on("end", p), t.on("close", p)), t.on("end", x), t.on("finish", y), e.error !== false && t.on("error", S2), t.on("close", E), function() {
        t.removeListener("complete", y), t.removeListener("abort", E), t.removeListener("request", B), t.req && t.req.removeListener("finish", y), t.removeListener("end", p), t.removeListener("close", p), t.removeListener("finish", y), t.removeListener("end", x), t.removeListener("error", S2), t.removeListener("close", E);
      };
    }
    Nc.exports = Lc;
  });
  Pc = T((uI, Dc) => {
    var bo;
    function Ni(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    var gM = vo(), Di = Symbol("lastResolve"), un = Symbol("lastReject"), ea = Symbol("error"), mo = Symbol("ended"), ln = Symbol("lastPromise"), nh = Symbol("handlePromise"), dn = Symbol("stream");
    function Pi(t, e) {
      return { value: t, done: e };
    }
    function yM(t) {
      var e = t[Di];
      if (e !== null) {
        var r = t[dn].read();
        r !== null && (t[ln] = null, t[Di] = null, t[un] = null, e(Pi(r, false)));
      }
    }
    function wM(t) {
      process.nextTick(yM, t);
    }
    function MM(t, e) {
      return function(r, o) {
        t.then(function() {
          if (e[mo]) {
            r(Pi(undefined, true));
            return;
          }
          e[nh](r, o);
        }, o);
      };
    }
    var _M = Object.getPrototypeOf(function() {
    }), xM = Object.setPrototypeOf((bo = { get stream() {
      return this[dn];
    }, next: function() {
      var e = this, r = this[ea];
      if (r !== null)
        return Promise.reject(r);
      if (this[mo])
        return Promise.resolve(Pi(undefined, true));
      if (this[dn].destroyed)
        return new Promise(function(m, y) {
          process.nextTick(function() {
            e[ea] ? y(e[ea]) : m(Pi(undefined, true));
          });
        });
      var o = this[ln], f;
      if (o)
        f = new Promise(MM(o, this));
      else {
        var p = this[dn].read();
        if (p !== null)
          return Promise.resolve(Pi(p, false));
        f = new Promise(this[nh]);
      }
      return this[ln] = f, f;
    } }, Ni(bo, Symbol.asyncIterator, function() {
      return this;
    }), Ni(bo, "return", function() {
      var e = this;
      return new Promise(function(r, o) {
        e[dn].destroy(null, function(f) {
          if (f) {
            o(f);
            return;
          }
          r(Pi(undefined, true));
        });
      });
    }), bo), _M), SM = function(e) {
      var r, o = Object.create(xM, (r = {}, Ni(r, dn, { value: e, writable: true }), Ni(r, Di, { value: null, writable: true }), Ni(r, un, { value: null, writable: true }), Ni(r, ea, { value: null, writable: true }), Ni(r, mo, { value: e._readableState.endEmitted, writable: true }), Ni(r, nh, { value: function(p, m) {
        var y = o[dn].read();
        y ? (o[ln] = null, o[Di] = null, o[un] = null, p(Pi(y, false))) : (o[Di] = p, o[un] = m);
      }, writable: true }), r));
      return o[ln] = null, gM(e, function(f) {
        if (f && f.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p = o[un];
          p !== null && (o[ln] = null, o[Di] = null, o[un] = null, p(f)), o[ea] = f;
          return;
        }
        var m = o[Di];
        m !== null && (o[ln] = null, o[Di] = null, o[un] = null, m(Pi(undefined, true))), o[mo] = true;
      }), e.on("readable", wM.bind(null, o)), o;
    };
    Dc.exports = SM;
  });
  Oc = T((lI, Cc) => {
    Cc.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  th = T((cI, $c) => {
    $c.exports = Ce;
    var tf;
    Ce.ReadableState = Hc;
    var dI = ki().EventEmitter, zc = function(e, r) {
      return e.listeners(r).length;
    }, ra = W0(), go = Ut().Buffer, EM = global.Uint8Array || function() {
    };
    function AM(t) {
      return go.from(t);
    }
    function RM(t) {
      return go.isBuffer(t) || t instanceof EM;
    }
    var fh = $f(), Ne;
    fh && fh.debuglog ? Ne = fh.debuglog("stream") : Ne = function() {
    };
    var BM = pc(), dh = Z0(), qM = V0(), IM = qM.getHighWaterMark, yo = sn().codes, TM = yo.ERR_INVALID_ARG_TYPE, kM = yo.ERR_STREAM_PUSH_AFTER_EOF, LM = yo.ERR_METHOD_NOT_IMPLEMENTED, NM = yo.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, rf, ah, oh;
    Ie()(Ce, ra);
    var ta = dh.errorOrDestroy, sh = ["error", "close", "destroy", "pause", "resume"];
    function DM(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function Hc(t, e, r) {
      tf = tf || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof tf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = IM(this, t, "readableHighWaterMark", r), this.buffer = new BM, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (rf || (rf = (Qf(), ur(Jf)).StringDecoder), this.decoder = new rf(t.encoding), this.encoding = t.encoding);
    }
    function Ce(t) {
      if (tf = tf || hn(), !(this instanceof Ce))
        return new Ce(t);
      var e = this instanceof tf;
      this._readableState = new Hc(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), ra.call(this);
    }
    Object.defineProperty(Ce.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Ce.prototype.destroy = dh.destroy;
    Ce.prototype._undestroy = dh.undestroy;
    Ce.prototype._destroy = function(t, e) {
      e(t);
    };
    Ce.prototype.push = function(t, e) {
      var r = this._readableState, o;
      return r.objectMode ? o = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = go.from(t, e), e = ""), o = true), Wc(this, t, e, false, o);
    };
    Ce.prototype.unshift = function(t) {
      return Wc(this, t, null, true, false);
    };
    function Wc(t, e, r, o, f) {
      Ne("readableAddChunk", e);
      var p = t._readableState;
      if (e === null)
        p.reading = false, OM(t, p);
      else {
        var m;
        if (f || (m = PM(p, e)), m)
          ta(t, m);
        else if (p.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p.objectMode && Object.getPrototypeOf(e) !== go.prototype && (e = AM(e)), o)
            p.endEmitted ? ta(t, new NM) : hh(t, p, e, true);
          else if (p.ended)
            ta(t, new kM);
          else {
            if (p.destroyed)
              return false;
            p.reading = false, p.decoder && !r ? (e = p.decoder.write(e), p.objectMode || e.length !== 0 ? hh(t, p, e, false) : lh(t, p)) : hh(t, p, e, false);
          }
        else
          o || (p.reading = false, lh(t, p));
      }
      return !p.ended && (p.length < p.highWaterMark || p.length === 0);
    }
    function hh(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && wo(t)), lh(t, e);
    }
    function PM(t, e) {
      var r;
      return !RM(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new TM("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Ce.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Ce.prototype.setEncoding = function(t) {
      rf || (rf = (Qf(), ur(Jf)).StringDecoder);
      var e = new rf(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o = "";r !== null; )
        o += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o !== "" && this._readableState.buffer.push(o), this._readableState.length = o.length, this;
    };
    var Fc = 1073741824;
    function CM(t) {
      return t >= Fc ? t = Fc : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Uc(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = CM(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Ce.prototype.read = function(t) {
      Ne("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Ne("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? uh(this) : wo(this), null;
      if (t = Uc(t, e), t === 0 && e.ended)
        return e.length === 0 && uh(this), null;
      var o = e.needReadable;
      Ne("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, Ne("length less than watermark", o)), e.ended || e.reading ? (o = false, Ne("reading or ended", o)) : o && (Ne("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Uc(r, e)));
      var f;
      return t > 0 ? f = Zc(t, e) : f = null, f === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && uh(this)), f !== null && this.emit("data", f), f;
    };
    function OM(t, e) {
      if (Ne("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? wo(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, Kc(t)));
      }
    }
    function wo(t) {
      var e = t._readableState;
      Ne("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Ne("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(Kc, t));
    }
    function Kc(t) {
      var e = t._readableState;
      Ne("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ch(t);
    }
    function lh(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(FM, t, e));
    }
    function FM(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (Ne("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Ce.prototype._read = function(t) {
      ta(this, new LM("_read()"));
    };
    Ce.prototype.pipe = function(t, e) {
      var r = this, o = this._readableState;
      switch (o.pipesCount) {
        case 0:
          o.pipes = t;
          break;
        case 1:
          o.pipes = [o.pipes, t];
          break;
        default:
          o.pipes.push(t);
          break;
      }
      o.pipesCount += 1, Ne("pipe count=%d opts=%j", o.pipesCount, e);
      var f = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p = f ? y : ge;
      o.endEmitted ? process.nextTick(p) : r.once("end", p), t.on("unpipe", m);
      function m(_e, N) {
        Ne("onunpipe"), _e === r && N && N.hasUnpiped === false && (N.hasUnpiped = true, S2());
      }
      function y() {
        Ne("onend"), t.end();
      }
      var M = UM(r);
      t.on("drain", M);
      var x = false;
      function S2() {
        Ne("cleanup"), t.removeListener("close", q), t.removeListener("finish", L), t.removeListener("drain", M), t.removeListener("error", B), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", ge), r.removeListener("data", E), x = true, o.awaitDrain && (!t._writableState || t._writableState.needDrain) && M();
      }
      r.on("data", E);
      function E(_e) {
        Ne("ondata");
        var N = t.write(_e);
        Ne("dest.write", N), N === false && ((o.pipesCount === 1 && o.pipes === t || o.pipesCount > 1 && Vc(o.pipes, t) !== -1) && !x && (Ne("false write response, pause", o.awaitDrain), o.awaitDrain++), r.pause());
      }
      function B(_e) {
        Ne("onerror", _e), ge(), t.removeListener("error", B), zc(t, "error") === 0 && ta(t, _e);
      }
      DM(t, "error", B);
      function q() {
        t.removeListener("finish", L), ge();
      }
      t.once("close", q);
      function L() {
        Ne("onfinish"), t.removeListener("close", q), ge();
      }
      t.once("finish", L);
      function ge() {
        Ne("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o.flowing || (Ne("pipe resume"), r.resume()), t;
    };
    function UM(t) {
      return function() {
        var r = t._readableState;
        Ne("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && zc(t, "data") && (r.flowing = true, ch(t));
      };
    }
    Ce.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o, pipesCount: f } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p = 0;p < f; p++)
          o[p].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m = Vc(e.pipes, t);
      return m === -1 ? this : (e.pipes.splice(m, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Ce.prototype.on = function(t, e) {
      var r = ra.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, Ne("on readable", o.length, o.reading), o.length ? wo(this) : o.reading || process.nextTick(zM, this)), r;
    };
    Ce.prototype.addListener = Ce.prototype.on;
    Ce.prototype.removeListener = function(t, e) {
      var r = ra.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(jc, this), r;
    };
    Ce.prototype.removeAllListeners = function(t) {
      var e = ra.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(jc, this), e;
    };
    function jc(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function zM(t) {
      Ne("readable nexttick read 0"), t.read(0);
    }
    Ce.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (Ne("resume"), t.flowing = !t.readableListening, HM(this, t)), t.paused = false, this;
    };
    function HM(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(WM, t, e));
    }
    function WM(t, e) {
      Ne("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ch(t), e.flowing && !e.reading && t.read(0);
    }
    Ce.prototype.pause = function() {
      return Ne("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Ne("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ch(t) {
      var e = t._readableState;
      for (Ne("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Ce.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o = false;
      t.on("end", function() {
        if (Ne("wrapped end"), r.decoder && !r.ended) {
          var m = r.decoder.end();
          m && m.length && e.push(m);
        }
        e.push(null);
      }), t.on("data", function(m) {
        if (Ne("wrapped data"), r.decoder && (m = r.decoder.write(m)), !(r.objectMode && m == null) && !(!r.objectMode && (!m || !m.length))) {
          var y = e.push(m);
          y || (o = true, t.pause());
        }
      });
      for (var f in t)
        this[f] === undefined && typeof t[f] == "function" && (this[f] = function(y) {
          return function() {
            return t[y].apply(t, arguments);
          };
        }(f));
      for (var p = 0;p < sh.length; p++)
        t.on(sh[p], this.emit.bind(this, sh[p]));
      return this._read = function(m) {
        Ne("wrapped _read", m), o && (o = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Ce.prototype[Symbol.asyncIterator] = function() {
      return ah === undefined && (ah = Pc()), ah(this);
    });
    Object.defineProperty(Ce.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Ce.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Ce.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Ce._fromList = Zc;
    Object.defineProperty(Ce.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Zc(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function uh(t) {
      var e = t._readableState;
      Ne("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(KM, e, t));
    }
    function KM(t, e) {
      if (Ne("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Ce.from = function(t, e) {
      return oh === undefined && (oh = Oc()), oh(Ce, t, e);
    });
    function Vc(t, e) {
      for (var r = 0, o = t.length;r < o; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  ph = T((pI, Yc) => {
    Yc.exports = di;
    var Mo = sn().codes, jM = Mo.ERR_METHOD_NOT_IMPLEMENTED, ZM = Mo.ERR_MULTIPLE_CALLBACK, VM = Mo.ERR_TRANSFORM_ALREADY_TRANSFORMING, $M = Mo.ERR_TRANSFORM_WITH_LENGTH_0, _o = hn();
    Ie()(di, _o);
    function GM(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o = r.writecb;
      if (o === null)
        return this.emit("error", new ZM);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o(t);
      var f = this._readableState;
      f.reading = false, (f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
    }
    function di(t) {
      if (!(this instanceof di))
        return new di(t);
      _o.call(this, t), this._transformState = { afterTransform: GM.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", YM);
    }
    function YM() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        Gc(t, e, r);
      }) : Gc(this, null, null);
    }
    di.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, _o.prototype.push.call(this, t, e);
    };
    di.prototype._transform = function(t, e, r) {
      r(new jM("_transform()"));
    };
    di.prototype._write = function(t, e, r) {
      var o = this._transformState;
      if (o.writecb = r, o.writechunk = t, o.writeencoding = e, !o.transforming) {
        var f = this._readableState;
        (o.needTransform || f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
      }
    };
    di.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    di.prototype._destroy = function(t, e) {
      _o.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function Gc(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new $M;
      if (t._transformState.transforming)
        throw new VM;
      return t.push(null);
    }
  });
  Qc = T((vI, Jc) => {
    Jc.exports = ia;
    var Xc = ph();
    Ie()(ia, Xc);
    function ia(t) {
      if (!(this instanceof ia))
        return new ia(t);
      Xc.call(this, t);
    }
    ia.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  np = T((bI, ip) => {
    var vh;
    function XM(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var rp = sn().codes, JM = rp.ERR_MISSING_ARGS, QM = rp.ERR_STREAM_DESTROYED;
    function ep(t) {
      if (t)
        throw t;
    }
    function e4(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function t4(t, e, r, o) {
      o = XM(o);
      var f = false;
      t.on("close", function() {
        f = true;
      }), vh === undefined && (vh = vo()), vh(t, { readable: e, writable: r }, function(m) {
        if (m)
          return o(m);
        f = true, o();
      });
      var p = false;
      return function(m) {
        if (!f && !p) {
          if (p = true, e4(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o(m || new QM("pipe"));
        }
      };
    }
    function tp(t) {
      t();
    }
    function r4(t, e) {
      return t.pipe(e);
    }
    function i4(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? ep : t.pop();
    }
    function n4() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o = i4(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new JM("streams");
      var f, p = e.map(function(m, y) {
        var M = y < e.length - 1, x = y > 0;
        return t4(m, M, x, function(S2) {
          f || (f = S2), S2 && p.forEach(tp), !M && (p.forEach(tp), o(f));
        });
      });
      return e.reduce(r4);
    }
    ip.exports = n4;
  });
  ap = T((cr, fp) => {
    cr = fp.exports = th();
    cr.Stream = cr;
    cr.Readable = cr;
    cr.Writable = J0();
    cr.Duplex = hn();
    cr.Transform = ph();
    cr.PassThrough = Qc();
    cr.finished = vo();
    cr.pipeline = np();
  });
  bh = T((mI, sp) => {
    var xo = Te().Buffer, op = ap().Transform, f4 = Ie();
    function a4(t, e) {
      if (!xo.isBuffer(t) && typeof t != "string")
        throw new TypeError(e + " must be a string or a buffer");
    }
    function Ci(t) {
      op.call(this), this._block = xo.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
    }
    f4(Ci, op);
    Ci.prototype._transform = function(t, e, r) {
      var o = null;
      try {
        this.update(t, e);
      } catch (f) {
        o = f;
      }
      r(o);
    };
    Ci.prototype._flush = function(t) {
      var e = null;
      try {
        this.push(this.digest());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    Ci.prototype.update = function(t, e) {
      if (a4(t, "Data"), this._finalized)
        throw new Error("Digest already called");
      xo.isBuffer(t) || (t = xo.from(t, e));
      for (var r = this._block, o = 0;this._blockOffset + t.length - o >= this._blockSize; ) {
        for (var f = this._blockOffset;f < this._blockSize; )
          r[f++] = t[o++];
        this._update(), this._blockOffset = 0;
      }
      for (;o < t.length; )
        r[this._blockOffset++] = t[o++];
      for (var p = 0, m = t.length * 8;m > 0; ++p)
        this._length[p] += m, m = this._length[p] / 4294967296 | 0, m > 0 && (this._length[p] -= 4294967296 * m);
      return this;
    };
    Ci.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    Ci.prototype.digest = function(t) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var e = this._digest();
      t !== undefined && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
      for (var r = 0;r < 4; ++r)
        this._length[r] = 0;
      return e;
    };
    Ci.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    sp.exports = Ci;
  });
  Ao = T((gI, up) => {
    var o4 = Ie(), hp = bh(), s4 = Te().Buffer, h4 = new Array(16);
    function So() {
      hp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    o4(So, hp);
    So.prototype._update = function() {
      for (var t = h4, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      var r = this._a, o = this._b, f = this._c, p = this._d;
      r = jt(r, o, f, p, t[0], 3614090360, 7), p = jt(p, r, o, f, t[1], 3905402710, 12), f = jt(f, p, r, o, t[2], 606105819, 17), o = jt(o, f, p, r, t[3], 3250441966, 22), r = jt(r, o, f, p, t[4], 4118548399, 7), p = jt(p, r, o, f, t[5], 1200080426, 12), f = jt(f, p, r, o, t[6], 2821735955, 17), o = jt(o, f, p, r, t[7], 4249261313, 22), r = jt(r, o, f, p, t[8], 1770035416, 7), p = jt(p, r, o, f, t[9], 2336552879, 12), f = jt(f, p, r, o, t[10], 4294925233, 17), o = jt(o, f, p, r, t[11], 2304563134, 22), r = jt(r, o, f, p, t[12], 1804603682, 7), p = jt(p, r, o, f, t[13], 4254626195, 12), f = jt(f, p, r, o, t[14], 2792965006, 17), o = jt(o, f, p, r, t[15], 1236535329, 22), r = Zt(r, o, f, p, t[1], 4129170786, 5), p = Zt(p, r, o, f, t[6], 3225465664, 9), f = Zt(f, p, r, o, t[11], 643717713, 14), o = Zt(o, f, p, r, t[0], 3921069994, 20), r = Zt(r, o, f, p, t[5], 3593408605, 5), p = Zt(p, r, o, f, t[10], 38016083, 9), f = Zt(f, p, r, o, t[15], 3634488961, 14), o = Zt(o, f, p, r, t[4], 3889429448, 20), r = Zt(r, o, f, p, t[9], 568446438, 5), p = Zt(p, r, o, f, t[14], 3275163606, 9), f = Zt(f, p, r, o, t[3], 4107603335, 14), o = Zt(o, f, p, r, t[8], 1163531501, 20), r = Zt(r, o, f, p, t[13], 2850285829, 5), p = Zt(p, r, o, f, t[2], 4243563512, 9), f = Zt(f, p, r, o, t[7], 1735328473, 14), o = Zt(o, f, p, r, t[12], 2368359562, 20), r = Vt(r, o, f, p, t[5], 4294588738, 4), p = Vt(p, r, o, f, t[8], 2272392833, 11), f = Vt(f, p, r, o, t[11], 1839030562, 16), o = Vt(o, f, p, r, t[14], 4259657740, 23), r = Vt(r, o, f, p, t[1], 2763975236, 4), p = Vt(p, r, o, f, t[4], 1272893353, 11), f = Vt(f, p, r, o, t[7], 4139469664, 16), o = Vt(o, f, p, r, t[10], 3200236656, 23), r = Vt(r, o, f, p, t[13], 681279174, 4), p = Vt(p, r, o, f, t[0], 3936430074, 11), f = Vt(f, p, r, o, t[3], 3572445317, 16), o = Vt(o, f, p, r, t[6], 76029189, 23), r = Vt(r, o, f, p, t[9], 3654602809, 4), p = Vt(p, r, o, f, t[12], 3873151461, 11), f = Vt(f, p, r, o, t[15], 530742520, 16), o = Vt(o, f, p, r, t[2], 3299628645, 23), r = $t(r, o, f, p, t[0], 4096336452, 6), p = $t(p, r, o, f, t[7], 1126891415, 10), f = $t(f, p, r, o, t[14], 2878612391, 15), o = $t(o, f, p, r, t[5], 4237533241, 21), r = $t(r, o, f, p, t[12], 1700485571, 6), p = $t(p, r, o, f, t[3], 2399980690, 10), f = $t(f, p, r, o, t[10], 4293915773, 15), o = $t(o, f, p, r, t[1], 2240044497, 21), r = $t(r, o, f, p, t[8], 1873313359, 6), p = $t(p, r, o, f, t[15], 4264355552, 10), f = $t(f, p, r, o, t[6], 2734768916, 15), o = $t(o, f, p, r, t[13], 1309151649, 21), r = $t(r, o, f, p, t[4], 4149444226, 6), p = $t(p, r, o, f, t[11], 3174756917, 10), f = $t(f, p, r, o, t[2], 718787259, 15), o = $t(o, f, p, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + o | 0, this._c = this._c + f | 0, this._d = this._d + p | 0;
    };
    So.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = s4.allocUnsafe(16);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
    };
    function Eo(t, e) {
      return t << e | t >>> 32 - e;
    }
    function jt(t, e, r, o, f, p, m) {
      return Eo(t + (e & r | ~e & o) + f + p | 0, m) + e | 0;
    }
    function Zt(t, e, r, o, f, p, m) {
      return Eo(t + (e & o | r & ~o) + f + p | 0, m) + e | 0;
    }
    function Vt(t, e, r, o, f, p, m) {
      return Eo(t + (e ^ r ^ o) + f + p | 0, m) + e | 0;
    }
    function $t(t, e, r, o, f, p, m) {
      return Eo(t + (r ^ (e | ~o)) + f + p | 0, m) + e | 0;
    }
    up.exports = So;
  });
  Bo = T((yI, mp) => {
    var mh = Ut().Buffer, u4 = Ie(), bp = bh(), l4 = new Array(16), na = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], fa = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], aa = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], oa = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], sa = [0, 1518500249, 1859775393, 2400959708, 2840853838], ha = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function Ro() {
      bp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
    }
    u4(Ro, bp);
    Ro.prototype._update = function() {
      for (var t = l4, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      for (var r = this._a | 0, o = this._b | 0, f = this._c | 0, p = this._d | 0, m = this._e | 0, y = this._a | 0, M = this._b | 0, x = this._c | 0, S2 = this._d | 0, E = this._e | 0, B = 0;B < 80; B += 1) {
        var q, L;
        B < 16 ? (q = lp(r, o, f, p, m, t[na[B]], sa[0], aa[B]), L = vp(y, M, x, S2, E, t[fa[B]], ha[0], oa[B])) : B < 32 ? (q = dp(r, o, f, p, m, t[na[B]], sa[1], aa[B]), L = pp(y, M, x, S2, E, t[fa[B]], ha[1], oa[B])) : B < 48 ? (q = cp(r, o, f, p, m, t[na[B]], sa[2], aa[B]), L = cp(y, M, x, S2, E, t[fa[B]], ha[2], oa[B])) : B < 64 ? (q = pp(r, o, f, p, m, t[na[B]], sa[3], aa[B]), L = dp(y, M, x, S2, E, t[fa[B]], ha[3], oa[B])) : (q = vp(r, o, f, p, m, t[na[B]], sa[4], aa[B]), L = lp(y, M, x, S2, E, t[fa[B]], ha[4], oa[B])), r = m, m = p, p = cn(f, 10), f = o, o = q, y = E, E = S2, S2 = cn(x, 10), x = M, M = L;
      }
      var ge = this._b + f + S2 | 0;
      this._b = this._c + p + E | 0, this._c = this._d + m + y | 0, this._d = this._e + r + M | 0, this._e = this._a + o + x | 0, this._a = ge;
    };
    Ro.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = mh.alloc ? mh.alloc(20) : new mh(20);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
    };
    function cn(t, e) {
      return t << e | t >>> 32 - e;
    }
    function lp(t, e, r, o, f, p, m, y) {
      return cn(t + (e ^ r ^ o) + p + m | 0, y) + f | 0;
    }
    function dp(t, e, r, o, f, p, m, y) {
      return cn(t + (e & r | ~e & o) + p + m | 0, y) + f | 0;
    }
    function cp(t, e, r, o, f, p, m, y) {
      return cn(t + ((e | ~r) ^ o) + p + m | 0, y) + f | 0;
    }
    function pp(t, e, r, o, f, p, m, y) {
      return cn(t + (e & o | r & ~o) + p + m | 0, y) + f | 0;
    }
    function vp(t, e, r, o, f, p, m, y) {
      return cn(t + (e ^ (r | ~o)) + p + m | 0, y) + f | 0;
    }
    mp.exports = Ro;
  });
  pn = T((wI, yp) => {
    var gp = Te().Buffer;
    function qo(t, e) {
      this._block = gp.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
    }
    qo.prototype.update = function(t, e) {
      typeof t == "string" && (e = e || "utf8", t = gp.from(t, e));
      for (var r = this._block, o = this._blockSize, f = t.length, p = this._len, m = 0;m < f; ) {
        for (var y = p % o, M = Math.min(f - m, o - y), x = 0;x < M; x++)
          r[y + x] = t[m + x];
        p += M, m += M, p % o === 0 && this._update(r);
      }
      return this._len += f, this;
    };
    qo.prototype.digest = function(t) {
      var e = this._len % this._blockSize;
      this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
      var r = this._len * 8;
      if (r <= 4294967295)
        this._block.writeUInt32BE(r, this._blockSize - 4);
      else {
        var o = (r & 4294967295) >>> 0, f = (r - o) / 4294967296;
        this._block.writeUInt32BE(f, this._blockSize - 8), this._block.writeUInt32BE(o, this._blockSize - 4);
      }
      this._update(this._block);
      var p = this._hash();
      return t ? p.toString(t) : p;
    };
    qo.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    yp.exports = qo;
  });
  _p = T((MI, Mp) => {
    var d4 = Ie(), wp = pn(), c4 = Te().Buffer, p4 = [1518500249, 1859775393, -1894007588, -899497514], v4 = new Array(80);
    function ua() {
      this.init(), this._w = v4, wp.call(this, 64, 56);
    }
    d4(ua, wp);
    ua.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function b4(t) {
      return t << 5 | t >>> 27;
    }
    function m4(t) {
      return t << 30 | t >>> 2;
    }
    function g4(t, e, r, o) {
      return t === 0 ? e & r | ~e & o : t === 2 ? e & r | e & o | r & o : e ^ r ^ o;
    }
    ua.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f = this._c | 0, p = this._d | 0, m = this._e | 0, y = 0;y < 16; ++y)
        e[y] = t.readInt32BE(y * 4);
      for (;y < 80; ++y)
        e[y] = e[y - 3] ^ e[y - 8] ^ e[y - 14] ^ e[y - 16];
      for (var M = 0;M < 80; ++M) {
        var x = ~~(M / 20), S2 = b4(r) + g4(x, o, f, p) + m + e[M] + p4[x] | 0;
        m = p, p = f, f = m4(o), o = r, r = S2;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f + this._c | 0, this._d = p + this._d | 0, this._e = m + this._e | 0;
    };
    ua.prototype._hash = function() {
      var t = c4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Mp.exports = ua;
  });
  Ep = T((_I, Sp) => {
    var y4 = Ie(), xp = pn(), w4 = Te().Buffer, M4 = [1518500249, 1859775393, -1894007588, -899497514], _4 = new Array(80);
    function la() {
      this.init(), this._w = _4, xp.call(this, 64, 56);
    }
    y4(la, xp);
    la.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function x4(t) {
      return t << 1 | t >>> 31;
    }
    function S4(t) {
      return t << 5 | t >>> 27;
    }
    function E4(t) {
      return t << 30 | t >>> 2;
    }
    function A4(t, e, r, o) {
      return t === 0 ? e & r | ~e & o : t === 2 ? e & r | e & o | r & o : e ^ r ^ o;
    }
    la.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f = this._c | 0, p = this._d | 0, m = this._e | 0, y = 0;y < 16; ++y)
        e[y] = t.readInt32BE(y * 4);
      for (;y < 80; ++y)
        e[y] = x4(e[y - 3] ^ e[y - 8] ^ e[y - 14] ^ e[y - 16]);
      for (var M = 0;M < 80; ++M) {
        var x = ~~(M / 20), S2 = S4(r) + A4(x, o, f, p) + m + e[M] + M4[x] | 0;
        m = p, p = f, f = E4(o), o = r, r = S2;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f + this._c | 0, this._d = p + this._d | 0, this._e = m + this._e | 0;
    };
    la.prototype._hash = function() {
      var t = w4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Sp.exports = la;
  });
  gh = T((xI, Rp) => {
    var R4 = Ie(), Ap = pn(), B4 = Te().Buffer, q4 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], I4 = new Array(64);
    function da() {
      this.init(), this._w = I4, Ap.call(this, 64, 56);
    }
    R4(da, Ap);
    da.prototype.init = function() {
      return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
    };
    function T4(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function k4(t, e, r) {
      return t & e | r & (t | e);
    }
    function L4(t) {
      return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
    }
    function N4(t) {
      return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
    }
    function D4(t) {
      return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
    }
    function P4(t) {
      return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
    }
    da.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f = this._c | 0, p = this._d | 0, m = this._e | 0, y = this._f | 0, M = this._g | 0, x = this._h | 0, S2 = 0;S2 < 16; ++S2)
        e[S2] = t.readInt32BE(S2 * 4);
      for (;S2 < 64; ++S2)
        e[S2] = P4(e[S2 - 2]) + e[S2 - 7] + D4(e[S2 - 15]) + e[S2 - 16] | 0;
      for (var E = 0;E < 64; ++E) {
        var B = x + N4(m) + T4(m, y, M) + q4[E] + e[E] | 0, q = L4(r) + k4(r, o, f) | 0;
        x = M, M = y, y = m, m = p + B | 0, p = f, f = o, o = r, r = B + q | 0;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f + this._c | 0, this._d = p + this._d | 0, this._e = m + this._e | 0, this._f = y + this._f | 0, this._g = M + this._g | 0, this._h = x + this._h | 0;
    };
    da.prototype._hash = function() {
      var t = B4.allocUnsafe(32);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
    };
    Rp.exports = da;
  });
  qp = T((SI, Bp) => {
    var C4 = Ie(), O4 = gh(), F4 = pn(), U4 = Te().Buffer, z4 = new Array(64);
    function Io() {
      this.init(), this._w = z4, F4.call(this, 64, 56);
    }
    C4(Io, O4);
    Io.prototype.init = function() {
      return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
    };
    Io.prototype._hash = function() {
      var t = U4.allocUnsafe(28);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
    };
    Bp.exports = Io;
  });
  yh = T((EI, Pp) => {
    var H4 = Ie(), Dp = pn(), W4 = Te().Buffer, Ip = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], K4 = new Array(160);
    function ca() {
      this.init(), this._w = K4, Dp.call(this, 128, 112);
    }
    H4(ca, Dp);
    ca.prototype.init = function() {
      return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
    };
    function Tp(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function kp(t, e, r) {
      return t & e | r & (t | e);
    }
    function Lp(t, e) {
      return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
    }
    function Np(t, e) {
      return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
    }
    function j4(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
    }
    function Z4(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
    }
    function V4(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
    }
    function $4(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
    }
    function Pt(t, e) {
      return t >>> 0 < e >>> 0 ? 1 : 0;
    }
    ca.prototype._update = function(t) {
      for (var e = this._w, r = this._ah | 0, o = this._bh | 0, f = this._ch | 0, p = this._dh | 0, m = this._eh | 0, y = this._fh | 0, M = this._gh | 0, x = this._hh | 0, S2 = this._al | 0, E = this._bl | 0, B = this._cl | 0, q = this._dl | 0, L = this._el | 0, ge = this._fl | 0, _e = this._gl | 0, N = this._hl | 0, we = 0;we < 32; we += 2)
        e[we] = t.readInt32BE(we * 4), e[we + 1] = t.readInt32BE(we * 4 + 4);
      for (;we < 160; we += 2) {
        var ye = e[we - 30], xe = e[we - 15 * 2 + 1], Re = j4(ye, xe), Ee = Z4(xe, ye);
        ye = e[we - 2 * 2], xe = e[we - 2 * 2 + 1];
        var Ae = V4(ye, xe), P = $4(xe, ye), Se = e[we - 7 * 2], v2 = e[we - 7 * 2 + 1], i = e[we - 16 * 2], a = e[we - 16 * 2 + 1], h = Ee + v2 | 0, s = Re + Se + Pt(h, Ee) | 0;
        h = h + P | 0, s = s + Ae + Pt(h, P) | 0, h = h + a | 0, s = s + i + Pt(h, a) | 0, e[we] = s, e[we + 1] = h;
      }
      for (var u = 0;u < 160; u += 2) {
        s = e[u], h = e[u + 1];
        var c = kp(r, o, f), b2 = kp(S2, E, B), l = Lp(r, S2), n = Lp(S2, r), d = Np(m, L), w = Np(L, m), g = Ip[u], _2 = Ip[u + 1], A = Tp(m, y, M), R = Tp(L, ge, _e), I = N + w | 0, Me = x + d + Pt(I, N) | 0;
        I = I + R | 0, Me = Me + A + Pt(I, R) | 0, I = I + _2 | 0, Me = Me + g + Pt(I, _2) | 0, I = I + h | 0, Me = Me + s + Pt(I, h) | 0;
        var k = n + b2 | 0, D2 = l + c + Pt(k, n) | 0;
        x = M, N = _e, M = y, _e = ge, y = m, ge = L, L = q + I | 0, m = p + Me + Pt(L, q) | 0, p = f, q = B, f = o, B = E, o = r, E = S2, S2 = I + k | 0, r = Me + D2 + Pt(S2, I) | 0;
      }
      this._al = this._al + S2 | 0, this._bl = this._bl + E | 0, this._cl = this._cl + B | 0, this._dl = this._dl + q | 0, this._el = this._el + L | 0, this._fl = this._fl + ge | 0, this._gl = this._gl + _e | 0, this._hl = this._hl + N | 0, this._ah = this._ah + r + Pt(this._al, S2) | 0, this._bh = this._bh + o + Pt(this._bl, E) | 0, this._ch = this._ch + f + Pt(this._cl, B) | 0, this._dh = this._dh + p + Pt(this._dl, q) | 0, this._eh = this._eh + m + Pt(this._el, L) | 0, this._fh = this._fh + y + Pt(this._fl, ge) | 0, this._gh = this._gh + M + Pt(this._gl, _e) | 0, this._hh = this._hh + x + Pt(this._hl, N) | 0;
    };
    ca.prototype._hash = function() {
      var t = W4.allocUnsafe(64);
      function e(r, o, f) {
        t.writeInt32BE(r, f), t.writeInt32BE(o, f + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
    };
    Pp.exports = ca;
  });
  Op = T((AI, Cp) => {
    var G4 = Ie(), Y4 = yh(), X4 = pn(), J4 = Te().Buffer, Q4 = new Array(160);
    function To() {
      this.init(), this._w = Q4, X4.call(this, 128, 112);
    }
    G4(To, Y4);
    To.prototype.init = function() {
      return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
    };
    To.prototype._hash = function() {
      var t = J4.allocUnsafe(48);
      function e(r, o, f) {
        t.writeInt32BE(r, f), t.writeInt32BE(o, f + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
    };
    Cp.exports = To;
  });
  ko = T((ci, Fp) => {
    var ci = Fp.exports = function(e) {
      e = e.toLowerCase();
      var r = ci[e];
      if (!r)
        throw new Error(e + " is not supported (we accept pull requests)");
      return new r;
    };
    ci.sha = _p();
    ci.sha1 = Ep();
    ci.sha224 = qp();
    ci.sha256 = gh();
    ci.sha384 = Op();
    ci.sha512 = yh();
  });
  Tt = T((RI, Up) => {
    Up.exports = { ArrayIsArray(t) {
      return Array.isArray(t);
    }, ArrayPrototypeIncludes(t, e) {
      return t.includes(e);
    }, ArrayPrototypeIndexOf(t, e) {
      return t.indexOf(e);
    }, ArrayPrototypeJoin(t, e) {
      return t.join(e);
    }, ArrayPrototypeMap(t, e) {
      return t.map(e);
    }, ArrayPrototypePop(t, e) {
      return t.pop(e);
    }, ArrayPrototypePush(t, e) {
      return t.push(e);
    }, ArrayPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, Error, FunctionPrototypeCall(t, e, ...r) {
      return t.call(e, ...r);
    }, FunctionPrototypeSymbolHasInstance(t, e) {
      return Function.prototype[Symbol.hasInstance].call(t, e);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(t, e) {
      return Object.defineProperties(t, e);
    }, ObjectDefineProperty(t, e, r) {
      return Object.defineProperty(t, e, r);
    }, ObjectGetOwnPropertyDescriptor(t, e) {
      return Object.getOwnPropertyDescriptor(t, e);
    }, ObjectKeys(t) {
      return Object.keys(t);
    }, ObjectSetPrototypeOf(t, e) {
      return Object.setPrototypeOf(t, e);
    }, Promise, PromisePrototypeCatch(t, e) {
      return t.catch(e);
    }, PromisePrototypeThen(t, e, r) {
      return t.then(e, r);
    }, PromiseReject(t) {
      return Promise.reject(t);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(t, e) {
      return t.test(e);
    }, SafeSet: Set, String, StringPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, StringPrototypeToLowerCase(t) {
      return t.toLowerCase();
    }, StringPrototypeToUpperCase(t) {
      return t.toUpperCase();
    }, StringPrototypeTrim(t) {
      return t.trim();
    }, Symbol, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(t, e, r) {
      return t.set(e, r);
    }, Uint8Array };
  });
  Gr = T((BI, Mh) => {
    var e_ = Ut(), t_ = Object.getPrototypeOf(async function() {
    }).constructor, zp = globalThis.Blob || e_.Blob, r_ = typeof zp < "u" ? function(e) {
      return e instanceof zp;
    } : function(e) {
      return false;
    }, wh = class extends Error {
      constructor(e) {
        if (!Array.isArray(e))
          throw new TypeError(`Expected input to be an Array, got ${typeof e}`);
        let r = "";
        for (let o = 0;o < e.length; o++)
          r += `    ${e[o].stack}
`;
        super(r), this.name = "AggregateError", this.errors = e;
      }
    };
    Mh.exports = { AggregateError: wh, kEmptyObject: Object.freeze({}), once(t) {
      let e = false;
      return function(...r) {
        e || (e = true, t.apply(this, r));
      };
    }, createDeferredPromise: function() {
      let t, e;
      return { promise: new Promise((o, f) => {
        t = o, e = f;
      }), resolve: t, reject: e };
    }, promisify(t) {
      return new Promise((e, r) => {
        t((o, ...f) => o ? r(o) : e(...f));
      });
    }, debuglog() {
      return function() {
      };
    }, format(t, ...e) {
      return t.replace(/%([sdifj])/g, function(...[r, o]) {
        let f = e.shift();
        return o === "f" ? f.toFixed(6) : o === "j" ? JSON.stringify(f) : o === "s" && typeof f == "object" ? `${f.constructor !== Object ? f.constructor.name : ""} {}`.trim() : f.toString();
      });
    }, inspect(t) {
      switch (typeof t) {
        case "string":
          if (t.includes("'"))
            if (t.includes('"')) {
              if (!t.includes("`") && !t.includes("${"))
                return `\`${t}\``;
            } else
              return `"${t}"`;
          return `'${t}'`;
        case "number":
          return isNaN(t) ? "NaN" : Object.is(t, -0) ? String(t) : t;
        case "bigint":
          return `${String(t)}n`;
        case "boolean":
        case "undefined":
          return String(t);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction(t) {
      return t instanceof t_;
    }, isArrayBufferView(t) {
      return ArrayBuffer.isView(t);
    } }, isBlob: r_ };
    Mh.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  No = T((qI, Lo) => {
    var { AbortController: Hp, AbortSignal: i_ } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
    Lo.exports = Hp;
    Lo.exports.AbortSignal = i_;
    Lo.exports.default = Hp;
  });
  Jt = T((II, jp) => {
    var { format: n_, inspect: Do, AggregateError: f_ } = Gr(), a_ = globalThis.AggregateError || f_, o_ = Symbol("kIsNodeError"), s_ = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], h_ = /^([A-Z][a-z0-9]*)+$/, u_ = "__node_internal_", Po = {};
    function vn(t, e) {
      if (!t)
        throw new Po.ERR_INTERNAL_ASSERTION(e);
    }
    function Wp(t) {
      let e = "", r = t.length, o = t[0] === "-" ? 1 : 0;
      for (;r >= o + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function l_(t, e, r) {
      if (typeof e == "function")
        return vn(e.length <= r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${e.length}).`), e(...r);
      let o = (e.match(/%[dfijoOs]/g) || []).length;
      return vn(o === r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${o}).`), r.length === 0 ? e : n_(e, ...r);
    }
    function zt(t, e, r) {
      r || (r = Error);

      class o extends r {
        constructor(...p) {
          super(l_(t, e, p));
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      }
      Object.defineProperties(o.prototype, { name: { value: r.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${t}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), o.prototype.code = t, o.prototype[o_] = true, Po[t] = o;
    }
    function Kp(t) {
      let e = u_ + t.name;
      return Object.defineProperty(t, "name", { value: e }), t;
    }
    function d_(t, e) {
      if (t && e && t !== e) {
        if (Array.isArray(e.errors))
          return e.errors.push(t), e;
        let r = new a_([e, t], e.message);
        return r.code = e.code, r;
      }
      return t || e;
    }
    var _h = class extends Error {
      constructor(e = "The operation was aborted", r = undefined) {
        if (r !== undefined && typeof r != "object")
          throw new Po.ERR_INVALID_ARG_TYPE("options", "Object", r);
        super(e, r), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    zt("ERR_ASSERTION", "%s", Error);
    zt("ERR_INVALID_ARG_TYPE", (t, e, r) => {
      vn(typeof t == "string", "'name' must be a string"), Array.isArray(e) || (e = [e]);
      let o = "The ";
      t.endsWith(" argument") ? o += `${t} ` : o += `"${t}" ${t.includes(".") ? "property" : "argument"} `, o += "must be ";
      let f = [], p = [], m = [];
      for (let M of e)
        vn(typeof M == "string", "All expected entries have to be of type string"), s_.includes(M) ? f.push(M.toLowerCase()) : h_.test(M) ? p.push(M) : (vn(M !== "object", 'The value "object" should be written as "Object"'), m.push(M));
      if (p.length > 0) {
        let M = f.indexOf("object");
        M !== -1 && (f.splice(f, M, 1), p.push("Object"));
      }
      if (f.length > 0) {
        switch (f.length) {
          case 1:
            o += `of type ${f[0]}`;
            break;
          case 2:
            o += `one of type ${f[0]} or ${f[1]}`;
            break;
          default: {
            let M = f.pop();
            o += `one of type ${f.join(", ")}, or ${M}`;
          }
        }
        (p.length > 0 || m.length > 0) && (o += " or ");
      }
      if (p.length > 0) {
        switch (p.length) {
          case 1:
            o += `an instance of ${p[0]}`;
            break;
          case 2:
            o += `an instance of ${p[0]} or ${p[1]}`;
            break;
          default: {
            let M = p.pop();
            o += `an instance of ${p.join(", ")}, or ${M}`;
          }
        }
        m.length > 0 && (o += " or ");
      }
      switch (m.length) {
        case 0:
          break;
        case 1:
          m[0].toLowerCase() !== m[0] && (o += "an "), o += `${m[0]}`;
          break;
        case 2:
          o += `one of ${m[0]} or ${m[1]}`;
          break;
        default: {
          let M = m.pop();
          o += `one of ${m.join(", ")}, or ${M}`;
        }
      }
      if (r == null)
        o += `. Received ${r}`;
      else if (typeof r == "function" && r.name)
        o += `. Received function ${r.name}`;
      else if (typeof r == "object") {
        var y;
        (y = r.constructor) !== null && y !== undefined && y.name ? o += `. Received an instance of ${r.constructor.name}` : o += `. Received ${Do(r, { depth: -1 })}`;
      } else {
        let M = Do(r, { colors: false });
        M.length > 25 && (M = `${M.slice(0, 25)}...`), o += `. Received type ${typeof r} (${M})`;
      }
      return o;
    }, TypeError);
    zt("ERR_INVALID_ARG_VALUE", (t, e, r = "is invalid") => {
      let o = Do(e);
      return o.length > 128 && (o = o.slice(0, 128) + "..."), `The ${t.includes(".") ? "property" : "argument"} '${t}' ${r}. Received ${o}`;
    }, TypeError);
    zt("ERR_INVALID_RETURN_VALUE", (t, e, r) => {
      var o;
      let f = r != null && (o = r.constructor) !== null && o !== undefined && o.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
      return `Expected ${t} to be returned from the "${e}" function but got ${f}.`;
    }, TypeError);
    zt("ERR_MISSING_ARGS", (...t) => {
      vn(t.length > 0, "At least one arg needs to be specified");
      let e, r = t.length;
      switch (t = (Array.isArray(t) ? t : [t]).map((o) => `"${o}"`).join(" or "), r) {
        case 1:
          e += `The ${t[0]} argument`;
          break;
        case 2:
          e += `The ${t[0]} and ${t[1]} arguments`;
          break;
        default:
          {
            let o = t.pop();
            e += `The ${t.join(", ")}, and ${o} arguments`;
          }
          break;
      }
      return `${e} must be specified`;
    }, TypeError);
    zt("ERR_OUT_OF_RANGE", (t, e, r) => {
      vn(e, 'Missing "range" argument');
      let o;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o = Wp(String(r)) : typeof r == "bigint" ? (o = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (o = Wp(o)), o += "n") : o = Do(r), `The value of "${t}" is out of range. It must be ${e}. Received ${o}`;
    }, RangeError);
    zt("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    zt("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    zt("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    zt("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    zt("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    zt("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    zt("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    zt("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    zt("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    zt("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    zt("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    jp.exports = { AbortError: _h, aggregateTwoErrors: Kp(d_), hideStackFrames: Kp, codes: Po };
  });
  pa = T((TI, Qp) => {
    var { ArrayIsArray: $p, ArrayPrototypeIncludes: Gp, ArrayPrototypeJoin: Yp, ArrayPrototypeMap: c_, NumberIsInteger: Sh, NumberIsNaN: p_, NumberMAX_SAFE_INTEGER: v_, NumberMIN_SAFE_INTEGER: b_, NumberParseInt: m_, ObjectPrototypeHasOwnProperty: g_, RegExpPrototypeExec: y_, String: w_, StringPrototypeToUpperCase: M_, StringPrototypeTrim: __ } = Tt(), { hideStackFrames: Ir2, codes: { ERR_SOCKET_BAD_PORT: x_, ERR_INVALID_ARG_TYPE: tr, ERR_INVALID_ARG_VALUE: Co, ERR_OUT_OF_RANGE: bn, ERR_UNKNOWN_SIGNAL: Zp } } = Jt(), { normalizeEncoding: S_ } = Gr(), { isAsyncFunction: E_, isArrayBufferView: A_ } = Gr().types, Vp = {};
    function R_(t) {
      return t === (t | 0);
    }
    function B_(t) {
      return t === t >>> 0;
    }
    var q_ = /^[0-7]+$/, I_ = "must be a 32-bit unsigned integer or an octal string";
    function T_(t, e, r) {
      if (typeof t > "u" && (t = r), typeof t == "string") {
        if (y_(q_, t) === null)
          throw new Co(e, t, I_);
        t = m_(t, 8);
      }
      return Xp(t, e), t;
    }
    var k_ = Ir2((t, e, r = b_, o = v_) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      if (t < r || t > o)
        throw new bn(e, `>= ${r} && <= ${o}`, t);
    }), L_ = Ir2((t, e, r = -2147483648, o = 2147483647) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      if (t < r || t > o)
        throw new bn(e, `>= ${r} && <= ${o}`, t);
    }), Xp = Ir2((t, e, r = false) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      let o = r ? 1 : 0, f = 4294967295;
      if (t < o || t > f)
        throw new bn(e, `>= ${o} && <= ${f}`, t);
    });
    function Jp(t, e) {
      if (typeof t != "string")
        throw new tr(e, "string", t);
    }
    function N_(t, e, r = undefined, o) {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (r != null && t < r || o != null && t > o || (r != null || o != null) && p_(t))
        throw new bn(e, `${r != null ? `>= ${r}` : ""}${r != null && o != null ? " && " : ""}${o != null ? `<= ${o}` : ""}`, t);
    }
    var D_ = Ir2((t, e, r) => {
      if (!Gp(r, t)) {
        let o = Yp(c_(r, (p) => typeof p == "string" ? `'${p}'` : w_(p)), ", "), f = "must be one of: " + o;
        throw new Co(e, t, f);
      }
    });
    function P_(t, e) {
      if (typeof t != "boolean")
        throw new tr(e, "boolean", t);
    }
    function xh(t, e, r) {
      return t == null || !g_(t, e) ? r : t[e];
    }
    var C_ = Ir2((t, e, r = null) => {
      let o = xh(r, "allowArray", false), f = xh(r, "allowFunction", false);
      if (!xh(r, "nullable", false) && t === null || !o && $p(t) || typeof t != "object" && (!f || typeof t != "function"))
        throw new tr(e, "Object", t);
    }), O_ = Ir2((t, e, r = 0) => {
      if (!$p(t))
        throw new tr(e, "Array", t);
      if (t.length < r) {
        let o = `must be longer than ${r}`;
        throw new Co(e, t, o);
      }
    });
    function F_(t, e = "signal") {
      if (Jp(t, e), Vp[t] === undefined)
        throw Vp[M_(t)] !== undefined ? new Zp(t + " (signals must use all capital letters)") : new Zp(t);
    }
    var U_ = Ir2((t, e = "buffer") => {
      if (!A_(t))
        throw new tr(e, ["Buffer", "TypedArray", "DataView"], t);
    });
    function z_(t, e) {
      let r = S_(e), o = t.length;
      if (r === "hex" && o % 2 !== 0)
        throw new Co("encoding", e, `is invalid for data of length ${o}`);
    }
    function H_(t, e = "Port", r = true) {
      if (typeof t != "number" && typeof t != "string" || typeof t == "string" && __(t).length === 0 || +t !== +t >>> 0 || t > 65535 || t === 0 && !r)
        throw new x_(e, t, r);
      return t | 0;
    }
    var W_ = Ir2((t, e) => {
      if (t !== undefined && (t === null || typeof t != "object" || !("aborted" in t)))
        throw new tr(e, "AbortSignal", t);
    }), K_ = Ir2((t, e) => {
      if (typeof t != "function")
        throw new tr(e, "Function", t);
    }), j_ = Ir2((t, e) => {
      if (typeof t != "function" || E_(t))
        throw new tr(e, "Function", t);
    }), Z_ = Ir2((t, e) => {
      if (t !== undefined)
        throw new tr(e, "undefined", t);
    });
    function V_(t, e, r) {
      if (!Gp(r, t))
        throw new tr(e, `('${Yp(r, "|")}')`, t);
    }
    Qp.exports = { isInt32: R_, isUint32: B_, parseFileMode: T_, validateArray: O_, validateBoolean: P_, validateBuffer: U_, validateEncoding: z_, validateFunction: K_, validateInt32: L_, validateInteger: k_, validateNumber: N_, validateObject: C_, validateOneOf: D_, validatePlainFunction: j_, validatePort: H_, validateSignalName: F_, validateString: Jp, validateUint32: Xp, validateUndefined: Z_, validateUnion: V_, validateAbortSignal: W_ };
  });
  Rh = T((kI, i1) => {
    var dt = i1.exports = {}, Yr, Xr;
    function Eh() {
      throw new Error("setTimeout has not been defined");
    }
    function Ah() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? Yr = setTimeout : Yr = Eh;
      } catch {
        Yr = Eh;
      }
      try {
        typeof clearTimeout == "function" ? Xr = clearTimeout : Xr = Ah;
      } catch {
        Xr = Ah;
      }
    })();
    function e1(t) {
      if (Yr === setTimeout)
        return setTimeout(t, 0);
      if ((Yr === Eh || !Yr) && setTimeout)
        return Yr = setTimeout, setTimeout(t, 0);
      try {
        return Yr(t, 0);
      } catch {
        try {
          return Yr.call(null, t, 0);
        } catch {
          return Yr.call(this, t, 0);
        }
      }
    }
    function $_(t) {
      if (Xr === clearTimeout)
        return clearTimeout(t);
      if ((Xr === Ah || !Xr) && clearTimeout)
        return Xr = clearTimeout, clearTimeout(t);
      try {
        return Xr(t);
      } catch {
        try {
          return Xr.call(null, t);
        } catch {
          return Xr.call(this, t);
        }
      }
    }
    var pi = [], nf = false, mn, Oo = -1;
    function G_() {
      !nf || !mn || (nf = false, mn.length ? pi = mn.concat(pi) : Oo = -1, pi.length && t1());
    }
    function t1() {
      if (!nf) {
        var t = e1(G_);
        nf = true;
        for (var e = pi.length;e; ) {
          for (mn = pi, pi = [];++Oo < e; )
            mn && mn[Oo].run();
          Oo = -1, e = pi.length;
        }
        mn = null, nf = false, $_(t);
      }
    }
    dt.nextTick = function(t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r = 1;r < arguments.length; r++)
          e[r - 1] = arguments[r];
      pi.push(new r1(t, e)), pi.length === 1 && !nf && e1(t1);
    };
    function r1(t, e) {
      this.fun = t, this.array = e;
    }
    r1.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    dt.title = "browser";
    dt.browser = true;
    dt.env = {};
    dt.argv = [];
    dt.version = "";
    dt.versions = {};
    function vi() {
    }
    dt.on = vi;
    dt.addListener = vi;
    dt.once = vi;
    dt.off = vi;
    dt.removeListener = vi;
    dt.removeAllListeners = vi;
    dt.emit = vi;
    dt.prependListener = vi;
    dt.prependOnceListener = vi;
    dt.listeners = function(t) {
      return [];
    };
    dt.binding = function(t) {
      throw new Error("process.binding is not supported");
    };
    dt.cwd = function() {
      return "/";
    };
    dt.chdir = function(t) {
      throw new Error("process.chdir is not supported");
    };
    dt.umask = function() {
      return 0;
    };
  });
  pr = {};
  Ja(pr, { default: () => Y_ });
  Oi = R0(() => {
    ot(pr, rn(Rh()));
    Y_ = rn(Rh());
  });
  Fi = T((NI, v1) => {
    var { Symbol: Fo, SymbolAsyncIterator: n1, SymbolIterator: f1 } = Tt(), a1 = Fo("kDestroyed"), o1 = Fo("kIsErrored"), Bh = Fo("kIsReadable"), s1 = Fo("kIsDisturbed");
    function Uo(t, e = false) {
      var r;
      return !!(t && typeof t.pipe == "function" && typeof t.on == "function" && (!e || typeof t.pause == "function" && typeof t.resume == "function") && (!t._writableState || ((r = t._readableState) === null || r === undefined ? undefined : r.readable) !== false) && (!t._writableState || t._readableState));
    }
    function zo(t) {
      var e;
      return !!(t && typeof t.write == "function" && typeof t.on == "function" && (!t._readableState || ((e = t._writableState) === null || e === undefined ? undefined : e.writable) !== false));
    }
    function X_(t) {
      return !!(t && typeof t.pipe == "function" && t._readableState && typeof t.on == "function" && typeof t.write == "function");
    }
    function gn(t) {
      return t && (t._readableState || t._writableState || typeof t.write == "function" && typeof t.on == "function" || typeof t.pipe == "function" && typeof t.on == "function");
    }
    function J_(t, e) {
      return t == null ? false : e === true ? typeof t[n1] == "function" : e === false ? typeof t[f1] == "function" : typeof t[n1] == "function" || typeof t[f1] == "function";
    }
    function Ho(t) {
      if (!gn(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o = e || r;
      return !!(t.destroyed || t[a1] || o != null && o.destroyed);
    }
    function h1(t) {
      if (!zo(t))
        return null;
      if (t.writableEnded === true)
        return true;
      let e = t._writableState;
      return e != null && e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function Q_(t, e) {
      if (!zo(t))
        return null;
      if (t.writableFinished === true)
        return true;
      let r = t._writableState;
      return r != null && r.errored ? false : typeof r?.finished != "boolean" ? null : !!(r.finished || e === false && r.ended === true && r.length === 0);
    }
    function e8(t) {
      if (!Uo(t))
        return null;
      if (t.readableEnded === true)
        return true;
      let e = t._readableState;
      return !e || e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function u1(t, e) {
      if (!Uo(t))
        return null;
      let r = t._readableState;
      return r != null && r.errored ? false : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || e === false && r.ended === true && r.length === 0);
    }
    function l1(t) {
      return t && t[Bh] != null ? t[Bh] : typeof t?.readable != "boolean" ? null : Ho(t) ? false : Uo(t) && t.readable && !u1(t);
    }
    function d1(t) {
      return typeof t?.writable != "boolean" ? null : Ho(t) ? false : zo(t) && t.writable && !h1(t);
    }
    function t8(t, e) {
      return gn(t) ? Ho(t) ? true : !(e?.readable !== false && l1(t) || e?.writable !== false && d1(t)) : null;
    }
    function r8(t) {
      var e, r;
      return gn(t) ? t.writableErrored ? t.writableErrored : (e = (r = t._writableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function i8(t) {
      var e, r;
      return gn(t) ? t.readableErrored ? t.readableErrored : (e = (r = t._readableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function n8(t) {
      if (!gn(t))
        return null;
      if (typeof t.closed == "boolean")
        return t.closed;
      let { _writableState: e, _readableState: r } = t;
      return typeof e?.closed == "boolean" || typeof r?.closed == "boolean" ? e?.closed || r?.closed : typeof t._closed == "boolean" && c1(t) ? t._closed : null;
    }
    function c1(t) {
      return typeof t._closed == "boolean" && typeof t._defaultKeepAlive == "boolean" && typeof t._removedConnection == "boolean" && typeof t._removedContLen == "boolean";
    }
    function p1(t) {
      return typeof t._sent100 == "boolean" && c1(t);
    }
    function f8(t) {
      var e;
      return typeof t._consuming == "boolean" && typeof t._dumped == "boolean" && ((e = t.req) === null || e === undefined ? undefined : e.upgradeOrConnect) === undefined;
    }
    function a8(t) {
      if (!gn(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o = e || r;
      return !o && p1(t) || !!(o && o.autoDestroy && o.emitClose && o.closed === false);
    }
    function o8(t) {
      var e;
      return !!(t && ((e = t[s1]) !== null && e !== undefined ? e : t.readableDidRead || t.readableAborted));
    }
    function s8(t) {
      var e, r, o, f, p, m, y, M, x, S2;
      return !!(t && ((e = (r = (o = (f = (p = (m = t[o1]) !== null && m !== undefined ? m : t.readableErrored) !== null && p !== undefined ? p : t.writableErrored) !== null && f !== undefined ? f : (y = t._readableState) === null || y === undefined ? undefined : y.errorEmitted) !== null && o !== undefined ? o : (M = t._writableState) === null || M === undefined ? undefined : M.errorEmitted) !== null && r !== undefined ? r : (x = t._readableState) === null || x === undefined ? undefined : x.errored) !== null && e !== undefined ? e : (S2 = t._writableState) === null || S2 === undefined ? undefined : S2.errored));
    }
    v1.exports = { kDestroyed: a1, isDisturbed: o8, kIsDisturbed: s1, isErrored: s8, kIsErrored: o1, isReadable: l1, kIsReadable: Bh, isClosed: n8, isDestroyed: Ho, isDuplexNodeStream: X_, isFinished: t8, isIterable: J_, isReadableNodeStream: Uo, isReadableEnded: e8, isReadableFinished: u1, isReadableErrored: i8, isNodeStream: gn, isWritable: d1, isWritableNodeStream: zo, isWritableEnded: h1, isWritableFinished: Q_, isWritableErrored: r8, isServerRequest: f8, isServerResponse: p1, willEmitClose: a8 };
  });
  Ui = T((DI, Ih) => {
    var ff = (Oi(), ur(pr)), { AbortError: h8, codes: u8 } = Jt(), { ERR_INVALID_ARG_TYPE: l8, ERR_STREAM_PREMATURE_CLOSE: b1 } = u8, { kEmptyObject: m1, once: g1 } = Gr(), { validateAbortSignal: d8, validateFunction: c8, validateObject: p8 } = pa(), { Promise: v8 } = Tt(), { isClosed: b8, isReadable: y1, isReadableNodeStream: qh, isReadableFinished: w1, isReadableErrored: m8, isWritable: M1, isWritableNodeStream: _1, isWritableFinished: x1, isWritableErrored: g8, isNodeStream: y8, willEmitClose: w8 } = Fi();
    function M8(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    var _8 = () => {
    };
    function S1(t, e, r) {
      var o, f;
      arguments.length === 2 ? (r = e, e = m1) : e == null ? e = m1 : p8(e, "options"), c8(r, "callback"), d8(e.signal, "options.signal"), r = g1(r);
      let p = (o = e.readable) !== null && o !== undefined ? o : qh(t), m = (f = e.writable) !== null && f !== undefined ? f : _1(t);
      if (!y8(t))
        throw new l8("stream", "Stream", t);
      let { _writableState: y, _readableState: M } = t, x = () => {
        t.writable || B();
      }, S2 = w8(t) && qh(t) === p && _1(t) === m, E = x1(t, false), B = () => {
        E = true, t.destroyed && (S2 = false), !(S2 && (!t.readable || p)) && (!p || q) && r.call(t);
      }, q = w1(t, false), L = () => {
        q = true, t.destroyed && (S2 = false), !(S2 && (!t.writable || m)) && (!m || E) && r.call(t);
      }, ge = (xe) => {
        r.call(t, xe);
      }, _e = b8(t), N = () => {
        _e = true;
        let xe = g8(t) || m8(t);
        if (xe && typeof xe != "boolean")
          return r.call(t, xe);
        if (p && !q && qh(t, true) && !w1(t, false))
          return r.call(t, new b1);
        if (m && !E && !x1(t, false))
          return r.call(t, new b1);
        r.call(t);
      }, we = () => {
        t.req.on("finish", B);
      };
      M8(t) ? (t.on("complete", B), S2 || t.on("abort", N), t.req ? we() : t.on("request", we)) : m && !y && (t.on("end", x), t.on("close", x)), !S2 && typeof t.aborted == "boolean" && t.on("aborted", N), t.on("end", L), t.on("finish", B), e.error !== false && t.on("error", ge), t.on("close", N), _e ? ff.nextTick(N) : y != null && y.errorEmitted || M != null && M.errorEmitted ? S2 || ff.nextTick(N) : (!p && (!S2 || y1(t)) && (E || M1(t) === false) || !m && (!S2 || M1(t)) && (q || y1(t) === false) || M && t.req && t.aborted) && ff.nextTick(N);
      let ye = () => {
        r = _8, t.removeListener("aborted", N), t.removeListener("complete", B), t.removeListener("abort", N), t.removeListener("request", we), t.req && t.req.removeListener("finish", B), t.removeListener("end", x), t.removeListener("close", x), t.removeListener("finish", B), t.removeListener("end", L), t.removeListener("error", ge), t.removeListener("close", N);
      };
      if (e.signal && !_e) {
        let xe = () => {
          let Re = r;
          ye(), Re.call(t, new h8(undefined, { cause: e.signal.reason }));
        };
        if (e.signal.aborted)
          ff.nextTick(xe);
        else {
          let Re = r;
          r = g1((...Ee) => {
            e.signal.removeEventListener("abort", xe), Re.apply(t, Ee);
          }), e.signal.addEventListener("abort", xe);
        }
      }
      return ye;
    }
    function x8(t, e) {
      return new v8((r, o) => {
        S1(t, e, (f) => {
          f ? o(f) : r();
        });
      });
    }
    Ih.exports = S1;
    Ih.exports.finished = x8;
  });
  k1 = T((PI, Lh) => {
    var B1 = globalThis.AbortController || No().AbortController, { codes: { ERR_INVALID_ARG_TYPE: va, ERR_MISSING_ARGS: S8, ERR_OUT_OF_RANGE: E8 }, AbortError: Jr } = Jt(), { validateAbortSignal: af, validateInteger: A8, validateObject: of } = pa(), R8 = Tt().Symbol("kWeak"), { finished: B8 } = Ui(), { ArrayPrototypePush: q8, MathFloor: I8, Number: T8, NumberIsNaN: k8, Promise: E1, PromiseReject: A1, PromisePrototypeThen: L8, Symbol: q1 } = Tt(), Wo = q1("kEmpty"), R1 = q1("kEof");
    function Ko(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal");
      let r = 1;
      return e?.concurrency != null && (r = I8(e.concurrency)), A8(r, "concurrency", 1), async function* () {
        var f, p;
        let m = new B1, y = this, M = [], x = m.signal, S2 = { signal: x }, E = () => m.abort();
        e != null && (f = e.signal) !== null && f !== undefined && f.aborted && E(), e == null || (p = e.signal) === null || p === undefined || p.addEventListener("abort", E);
        let B, q, L = false;
        function ge() {
          L = true;
        }
        async function _e() {
          try {
            for await (let ye of y) {
              var N;
              if (L)
                return;
              if (x.aborted)
                throw new Jr;
              try {
                ye = t(ye, S2);
              } catch (xe) {
                ye = A1(xe);
              }
              ye !== Wo && (typeof ((N = ye) === null || N === undefined ? undefined : N.catch) == "function" && ye.catch(ge), M.push(ye), B && (B(), B = null), !L && M.length && M.length >= r && await new E1((xe) => {
                q = xe;
              }));
            }
            M.push(R1);
          } catch (ye) {
            let xe = A1(ye);
            L8(xe, undefined, ge), M.push(xe);
          } finally {
            var we;
            L = true, B && (B(), B = null), e == null || (we = e.signal) === null || we === undefined || we.removeEventListener("abort", E);
          }
        }
        _e();
        try {
          for (;; ) {
            for (;M.length > 0; ) {
              let N = await M[0];
              if (N === R1)
                return;
              if (x.aborted)
                throw new Jr;
              N !== Wo && (yield N), M.shift(), q && (q(), q = null);
            }
            await new E1((N) => {
              B = N;
            });
          }
        } finally {
          m.abort(), L = true, q && (q(), q = null);
        }
      }.call(this);
    }
    function N8(t = undefined) {
      return t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal"), async function* () {
        let r = 0;
        for await (let f of this) {
          var o;
          if (t != null && (o = t.signal) !== null && o !== undefined && o.aborted)
            throw new Jr({ cause: t.signal.reason });
          yield [r++, f];
        }
      }.call(this);
    }
    async function I1(t, e = undefined) {
      for await (let r of kh.call(this, t, e))
        return true;
      return false;
    }
    async function D8(t, e = undefined) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      return !await I1.call(this, async (...r) => !await t(...r), e);
    }
    async function P8(t, e) {
      for await (let r of kh.call(this, t, e))
        return r;
    }
    async function C8(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      async function r(o, f) {
        return await t(o, f), Wo;
      }
      for await (let o of Ko.call(this, r, e))
        ;
    }
    function kh(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      async function r(o, f) {
        return await t(o, f) ? o : Wo;
      }
      return Ko.call(this, r, e);
    }
    var Th = class extends S8 {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function O8(t, e, r) {
      var o;
      if (typeof t != "function")
        throw new va("reducer", ["Function", "AsyncFunction"], t);
      r != null && of(r, "options"), r?.signal != null && af(r.signal, "options.signal");
      let f = arguments.length > 1;
      if (r != null && (o = r.signal) !== null && o !== undefined && o.aborted) {
        let x = new Jr(undefined, { cause: r.signal.reason });
        throw this.once("error", () => {
        }), await B8(this.destroy(x)), x;
      }
      let p = new B1, m = p.signal;
      if (r != null && r.signal) {
        let x = { once: true, [R8]: this };
        r.signal.addEventListener("abort", () => p.abort(), x);
      }
      let y = false;
      try {
        for await (let x of this) {
          var M;
          if (y = true, r != null && (M = r.signal) !== null && M !== undefined && M.aborted)
            throw new Jr;
          f ? e = await t(e, x, { signal: m }) : (e = x, f = true);
        }
        if (!y && !f)
          throw new Th;
      } finally {
        p.abort();
      }
      return e;
    }
    async function F8(t) {
      t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal");
      let e = [];
      for await (let o of this) {
        var r;
        if (t != null && (r = t.signal) !== null && r !== undefined && r.aborted)
          throw new Jr(undefined, { cause: t.signal.reason });
        q8(e, o);
      }
      return e;
    }
    function U8(t, e) {
      let r = Ko.call(this, t, e);
      return async function* () {
        for await (let f of r)
          yield* f;
      }.call(this);
    }
    function T1(t) {
      if (t = T8(t), k8(t))
        return 0;
      if (t < 0)
        throw new E8("number", ">= 0", t);
      return t;
    }
    function z8(t, e = undefined) {
      return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
        var o;
        if (e != null && (o = e.signal) !== null && o !== undefined && o.aborted)
          throw new Jr;
        for await (let p of this) {
          var f;
          if (e != null && (f = e.signal) !== null && f !== undefined && f.aborted)
            throw new Jr;
          t-- <= 0 && (yield p);
        }
      }.call(this);
    }
    function H8(t, e = undefined) {
      return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
        var o;
        if (e != null && (o = e.signal) !== null && o !== undefined && o.aborted)
          throw new Jr;
        for await (let p of this) {
          var f;
          if (e != null && (f = e.signal) !== null && f !== undefined && f.aborted)
            throw new Jr;
          if (t-- > 0)
            yield p;
          else
            return;
        }
      }.call(this);
    }
    Lh.exports.streamReturningOperators = { asIndexedPairs: N8, drop: z8, filter: kh, flatMap: U8, map: Ko, take: H8 };
    Lh.exports.promiseReturningOperators = { every: D8, forEach: C8, reduce: O8, toArray: F8, some: I1, find: P8 };
  });
  yn = T((CI, U1) => {
    var zi = (Oi(), ur(pr)), { aggregateTwoErrors: W8, codes: { ERR_MULTIPLE_CALLBACK: K8 }, AbortError: j8 } = Jt(), { Symbol: D1 } = Tt(), { kDestroyed: Z8, isDestroyed: V8, isFinished: $8, isServerRequest: G8 } = Fi(), P1 = D1("kDestroy"), Nh = D1("kConstruct");
    function C1(t, e, r) {
      t && (t.stack, e && !e.errored && (e.errored = t), r && !r.errored && (r.errored = t));
    }
    function Y8(t, e) {
      let r = this._readableState, o = this._writableState, f = o || r;
      return o && o.destroyed || r && r.destroyed ? (typeof e == "function" && e(), this) : (C1(t, o, r), o && (o.destroyed = true), r && (r.destroyed = true), f.constructed ? L1(this, t, e) : this.once(P1, function(p) {
        L1(this, W8(p, t), e);
      }), this);
    }
    function L1(t, e, r) {
      let o = false;
      function f(p) {
        if (o)
          return;
        o = true;
        let { _readableState: m, _writableState: y } = t;
        C1(p, y, m), y && (y.closed = true), m && (m.closed = true), typeof r == "function" && r(p), p ? zi.nextTick(X8, t, p) : zi.nextTick(O1, t);
      }
      try {
        t._destroy(e || null, f);
      } catch (p) {
        f(p);
      }
    }
    function X8(t, e) {
      Dh(t, e), O1(t);
    }
    function O1(t) {
      let { _readableState: e, _writableState: r } = t;
      r && (r.closeEmitted = true), e && (e.closeEmitted = true), (r && r.emitClose || e && e.emitClose) && t.emit("close");
    }
    function Dh(t, e) {
      let { _readableState: r, _writableState: o } = t;
      o && o.errorEmitted || r && r.errorEmitted || (o && (o.errorEmitted = true), r && (r.errorEmitted = true), t.emit("error", e));
    }
    function J8() {
      let t = this._readableState, e = this._writableState;
      t && (t.constructed = true, t.closed = false, t.closeEmitted = false, t.destroyed = false, t.errored = null, t.errorEmitted = false, t.reading = false, t.ended = t.readable === false, t.endEmitted = t.readable === false), e && (e.constructed = true, e.destroyed = false, e.closed = false, e.closeEmitted = false, e.errored = null, e.errorEmitted = false, e.finalCalled = false, e.prefinished = false, e.ended = e.writable === false, e.ending = e.writable === false, e.finished = e.writable === false);
    }
    function Ph(t, e, r) {
      let { _readableState: o, _writableState: f } = t;
      if (f && f.destroyed || o && o.destroyed)
        return this;
      o && o.autoDestroy || f && f.autoDestroy ? t.destroy(e) : e && (e.stack, f && !f.errored && (f.errored = e), o && !o.errored && (o.errored = e), r ? zi.nextTick(Dh, t, e) : Dh(t, e));
    }
    function Q8(t, e) {
      if (typeof t._construct != "function")
        return;
      let { _readableState: r, _writableState: o } = t;
      r && (r.constructed = false), o && (o.constructed = false), t.once(Nh, e), !(t.listenerCount(Nh) > 1) && zi.nextTick(e5, t);
    }
    function e5(t) {
      let e = false;
      function r(o) {
        if (e) {
          Ph(t, o ?? new K8);
          return;
        }
        e = true;
        let { _readableState: f, _writableState: p } = t, m = p || f;
        f && (f.constructed = true), p && (p.constructed = true), m.destroyed ? t.emit(P1, o) : o ? Ph(t, o, true) : zi.nextTick(t5, t);
      }
      try {
        t._construct(r);
      } catch (o) {
        r(o);
      }
    }
    function t5(t) {
      t.emit(Nh);
    }
    function N1(t) {
      return t && t.setHeader && typeof t.abort == "function";
    }
    function F1(t) {
      t.emit("close");
    }
    function r5(t, e) {
      t.emit("error", e), zi.nextTick(F1, t);
    }
    function i5(t, e) {
      !t || V8(t) || (!e && !$8(t) && (e = new j8), G8(t) ? (t.socket = null, t.destroy(e)) : N1(t) ? t.abort() : N1(t.req) ? t.req.abort() : typeof t.destroy == "function" ? t.destroy(e) : typeof t.close == "function" ? t.close() : e ? zi.nextTick(r5, t, e) : zi.nextTick(F1, t), t.destroyed || (t[Z8] = true));
    }
    U1.exports = { construct: Q8, destroyer: i5, destroy: Y8, undestroy: J8, errorOrDestroy: Ph };
  });
  Vo = T((OI, H1) => {
    var { ArrayIsArray: n5, ObjectSetPrototypeOf: z1 } = Tt(), { EventEmitter: jo } = ki();
    function Zo(t) {
      jo.call(this, t);
    }
    z1(Zo.prototype, jo.prototype);
    z1(Zo, jo);
    Zo.prototype.pipe = function(t, e) {
      let r = this;
      function o(S2) {
        t.writable && t.write(S2) === false && r.pause && r.pause();
      }
      r.on("data", o);
      function f() {
        r.readable && r.resume && r.resume();
      }
      t.on("drain", f), !t._isStdio && (!e || e.end !== false) && (r.on("end", m), r.on("close", y));
      let p = false;
      function m() {
        p || (p = true, t.end());
      }
      function y() {
        p || (p = true, typeof t.destroy == "function" && t.destroy());
      }
      function M(S2) {
        x(), jo.listenerCount(this, "error") === 0 && this.emit("error", S2);
      }
      Ch(r, "error", M), Ch(t, "error", M);
      function x() {
        r.removeListener("data", o), t.removeListener("drain", f), r.removeListener("end", m), r.removeListener("close", y), r.removeListener("error", M), t.removeListener("error", M), r.removeListener("end", x), r.removeListener("close", x), t.removeListener("close", x);
      }
      return r.on("end", x), r.on("close", x), t.on("close", x), t.emit("pipe", r), t;
    };
    function Ch(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : n5(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    H1.exports = { Stream: Zo, prependListener: Ch };
  });
  Go = T((FI, $o) => {
    var { AbortError: f5, codes: a5 } = Jt(), o5 = Ui(), { ERR_INVALID_ARG_TYPE: W1 } = a5, s5 = (t, e) => {
      if (typeof t != "object" || !("aborted" in t))
        throw new W1(e, "AbortSignal", t);
    };
    function h5(t) {
      return !!(t && typeof t.pipe == "function");
    }
    $o.exports.addAbortSignal = function(e, r) {
      if (s5(e, "signal"), !h5(r))
        throw new W1("stream", "stream.Stream", r);
      return $o.exports.addAbortSignalNoValidate(e, r);
    };
    $o.exports.addAbortSignalNoValidate = function(t, e) {
      if (typeof t != "object" || !("aborted" in t))
        return e;
      let r = () => {
        e.destroy(new f5(undefined, { cause: t.reason }));
      };
      return t.aborted ? r() : (t.addEventListener("abort", r), o5(e, () => t.removeEventListener("abort", r))), e;
    };
  });
  Z1 = T((zI, j1) => {
    var { StringPrototypeSlice: K1, SymbolIterator: u5, TypedArrayPrototypeSet: Yo, Uint8Array: l5 } = Tt(), { Buffer: Oh } = Ut(), { inspect: d5 } = Gr();
    j1.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(e) {
        let r = { data: e, next: null };
        this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
      }
      unshift(e) {
        let r = { data: e, next: this.head };
        this.length === 0 && (this.tail = r), this.head = r, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let e = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(e) {
        if (this.length === 0)
          return "";
        let r = this.head, o = "" + r.data;
        for (;(r = r.next) !== null; )
          o += e + r.data;
        return o;
      }
      concat(e) {
        if (this.length === 0)
          return Oh.alloc(0);
        let r = Oh.allocUnsafe(e >>> 0), o = this.head, f = 0;
        for (;o; )
          Yo(r, o.data, f), f += o.data.length, o = o.next;
        return r;
      }
      consume(e, r) {
        let o = this.head.data;
        if (e < o.length) {
          let f = o.slice(0, e);
          return this.head.data = o.slice(e), f;
        }
        return e === o.length ? this.shift() : r ? this._getString(e) : this._getBuffer(e);
      }
      first() {
        return this.head.data;
      }
      *[u5]() {
        for (let e = this.head;e; e = e.next)
          yield e.data;
      }
      _getString(e) {
        let r = "", o = this.head, f = 0;
        do {
          let p = o.data;
          if (e > p.length)
            r += p, e -= p.length;
          else {
            e === p.length ? (r += p, ++f, o.next ? this.head = o.next : this.head = this.tail = null) : (r += K1(p, 0, e), this.head = o, o.data = K1(p, e));
            break;
          }
          ++f;
        } while ((o = o.next) !== null);
        return this.length -= f, r;
      }
      _getBuffer(e) {
        let r = Oh.allocUnsafe(e), o = e, f = this.head, p = 0;
        do {
          let m = f.data;
          if (e > m.length)
            Yo(r, m, o - e), e -= m.length;
          else {
            e === m.length ? (Yo(r, m, o - e), ++p, f.next ? this.head = f.next : this.head = this.tail = null) : (Yo(r, new l5(m.buffer, m.byteOffset, e), o - e), this.head = f, f.data = m.slice(e));
            break;
          }
          ++p;
        } while ((f = f.next) !== null);
        return this.length -= p, r;
      }
      [Symbol.for("nodejs.util.inspect.custom")](e, r) {
        return d5(this, { ...r, depth: 0, customInspect: false });
      }
    };
  });
  Xo = T((HI, $1) => {
    var { MathFloor: c5, NumberIsInteger: p5 } = Tt(), { ERR_INVALID_ARG_VALUE: v5 } = Jt().codes;
    function b5(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function V1(t) {
      return t ? 16 : 16 * 1024;
    }
    function m5(t, e, r, o) {
      let f = b5(e, o, r);
      if (f != null) {
        if (!p5(f) || f < 0) {
          let p = o ? `options.${r}` : "options.highWaterMark";
          throw new v5(p, f);
        }
        return c5(f);
      }
      return V1(t.objectMode);
    }
    $1.exports = { getHighWaterMark: m5, getDefaultHighWaterMark: V1 };
  });
  Fh = T((WI, J1) => {
    var G1 = (Oi(), ur(pr)), { PromisePrototypeThen: g5, SymbolAsyncIterator: Y1, SymbolIterator: X1 } = Tt(), { Buffer: y5 } = Ut(), { ERR_INVALID_ARG_TYPE: w5, ERR_STREAM_NULL_VALUES: M5 } = Jt().codes;
    function _5(t, e, r) {
      let o;
      if (typeof e == "string" || e instanceof y5)
        return new t({ objectMode: true, ...r, read() {
          this.push(e), this.push(null);
        } });
      let f;
      if (e && e[Y1])
        f = true, o = e[Y1]();
      else if (e && e[X1])
        f = false, o = e[X1]();
      else
        throw new w5("iterable", ["Iterable"], e);
      let p = new t({ objectMode: true, highWaterMark: 1, ...r }), m = false;
      p._read = function() {
        m || (m = true, M());
      }, p._destroy = function(x, S2) {
        g5(y(x), () => G1.nextTick(S2, x), (E) => G1.nextTick(S2, E || x));
      };
      async function y(x) {
        let S2 = x != null, E = typeof o.throw == "function";
        if (S2 && E) {
          let { value: B, done: q } = await o.throw(x);
          if (await B, q)
            return;
        }
        if (typeof o.return == "function") {
          let { value: B } = await o.return();
          await B;
        }
      }
      async function M() {
        for (;; ) {
          try {
            let { value: x, done: S2 } = f ? await o.next() : o.next();
            if (S2)
              p.push(null);
            else {
              let E = x && typeof x.then == "function" ? await x : x;
              if (E === null)
                throw m = false, new M5;
              if (p.push(E))
                continue;
              m = false;
            }
          } catch (x) {
            p.destroy(x);
          }
          break;
        }
      }
      return p;
    }
    J1.exports = _5;
  });
  ba = T((KI, lv) => {
    var Tr = (Oi(), ur(pr)), { ArrayPrototypeIndexOf: x5, NumberIsInteger: S5, NumberIsNaN: E5, NumberParseInt: A5, ObjectDefineProperties: tv, ObjectKeys: R5, ObjectSetPrototypeOf: rv, Promise: B5, SafeSet: q5, SymbolAsyncIterator: I5, Symbol: T5 } = Tt();
    lv.exports = Le;
    Le.ReadableState = jh;
    var { EventEmitter: k5 } = ki(), { Stream: Hi, prependListener: L5 } = Vo(), { Buffer: Uh } = Ut(), { addAbortSignal: N5 } = Go(), D5 = Ui(), Pe = Gr().debuglog("stream", (t) => {
      Pe = t;
    }), P5 = Z1(), hf = yn(), { getHighWaterMark: C5, getDefaultHighWaterMark: O5 } = Xo(), { aggregateTwoErrors: Q1, codes: { ERR_INVALID_ARG_TYPE: F5, ERR_METHOD_NOT_IMPLEMENTED: U5, ERR_OUT_OF_RANGE: z5, ERR_STREAM_PUSH_AFTER_EOF: H5, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: W5 } } = Jt(), { validateObject: K5 } = pa(), wn = T5("kPaused"), { StringDecoder: iv } = co(), j5 = Fh();
    rv(Le.prototype, Hi.prototype);
    rv(Le, Hi);
    var zh = () => {
    }, { errorOrDestroy: sf } = hf;
    function jh(t, e, r) {
      typeof r != "boolean" && (r = e instanceof Qr()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.readableObjectMode)), this.highWaterMark = t ? C5(this, t, "readableHighWaterMark", r) : O5(false), this.buffer = new P5, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[wn] = null, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, t && t.encoding && (this.decoder = new iv(t.encoding), this.encoding = t.encoding);
    }
    function Le(t) {
      if (!(this instanceof Le))
        return new Le(t);
      let e = this instanceof Qr();
      this._readableState = new jh(t, this, e), t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.construct == "function" && (this._construct = t.construct), t.signal && !e && N5(t.signal, this)), Hi.call(this, t), hf.construct(this, () => {
        this._readableState.needReadable && Jo(this, this._readableState);
      });
    }
    Le.prototype.destroy = hf.destroy;
    Le.prototype._undestroy = hf.undestroy;
    Le.prototype._destroy = function(t, e) {
      e(t);
    };
    Le.prototype[k5.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    Le.prototype.push = function(t, e) {
      return nv(this, t, e, false);
    };
    Le.prototype.unshift = function(t, e) {
      return nv(this, t, e, true);
    };
    function nv(t, e, r, o) {
      Pe("readableAddChunk", e);
      let f = t._readableState, p;
      if (f.objectMode || (typeof e == "string" ? (r = r || f.defaultEncoding, f.encoding !== r && (o && f.encoding ? e = Uh.from(e, r).toString(f.encoding) : (e = Uh.from(e, r), r = ""))) : e instanceof Uh ? r = "" : Hi._isUint8Array(e) ? (e = Hi._uint8ArrayToBuffer(e), r = "") : e != null && (p = new F5("chunk", ["string", "Buffer", "Uint8Array"], e))), p)
        sf(t, p);
      else if (e === null)
        f.reading = false, $5(t, f);
      else if (f.objectMode || e && e.length > 0)
        if (o)
          if (f.endEmitted)
            sf(t, new W5);
          else {
            if (f.destroyed || f.errored)
              return false;
            Hh(t, f, e, true);
          }
        else if (f.ended)
          sf(t, new H5);
        else {
          if (f.destroyed || f.errored)
            return false;
          f.reading = false, f.decoder && !r ? (e = f.decoder.write(e), f.objectMode || e.length !== 0 ? Hh(t, f, e, false) : Jo(t, f)) : Hh(t, f, e, false);
        }
      else
        o || (f.reading = false, Jo(t, f));
      return !f.ended && (f.length < f.highWaterMark || f.length === 0);
    }
    function Hh(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync && t.listenerCount("data") > 0 ? (e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null, e.dataEmitted = true, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Qo(t)), Jo(t, e);
    }
    Le.prototype.isPaused = function() {
      let t = this._readableState;
      return t[wn] === true || t.flowing === false;
    };
    Le.prototype.setEncoding = function(t) {
      let e = new iv(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      let r = this._readableState.buffer, o = "";
      for (let f of r)
        o += e.write(f);
      return r.clear(), o !== "" && r.push(o), this._readableState.length = o.length, this;
    };
    var Z5 = 1073741824;
    function V5(t) {
      if (t > Z5)
        throw new z5("size", "<= 1GiB", t);
      return t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++, t;
    }
    function ev(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : E5(t) ? e.flowing && e.length ? e.buffer.first().length : e.length : t <= e.length ? t : e.ended ? e.length : 0;
    }
    Le.prototype.read = function(t) {
      Pe("read", t), t === undefined ? t = NaN : S5(t) || (t = A5(t, 10));
      let e = this._readableState, r = t;
      if (t > e.highWaterMark && (e.highWaterMark = V5(t)), t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Pe("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Wh(this) : Qo(this), null;
      if (t = ev(t, e), t === 0 && e.ended)
        return e.length === 0 && Wh(this), null;
      let o = e.needReadable;
      if (Pe("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, Pe("length less than watermark", o)), e.ended || e.reading || e.destroyed || e.errored || !e.constructed)
        o = false, Pe("reading, ended or constructing", o);
      else if (o) {
        Pe("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true);
        try {
          this._read(e.highWaterMark);
        } catch (p) {
          sf(this, p);
        }
        e.sync = false, e.reading || (t = ev(r, e));
      }
      let f;
      return t > 0 ? f = hv(t, e) : f = null, f === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Wh(this)), f !== null && !e.errorEmitted && !e.closeEmitted && (e.dataEmitted = true, this.emit("data", f)), f;
    };
    function $5(t, e) {
      if (Pe("onEofChunk"), !e.ended) {
        if (e.decoder) {
          let r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? Qo(t) : (e.needReadable = false, e.emittedReadable = true, fv(t));
      }
    }
    function Qo(t) {
      let e = t._readableState;
      Pe("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Pe("emitReadable", e.flowing), e.emittedReadable = true, Tr.nextTick(fv, t));
    }
    function fv(t) {
      let e = t._readableState;
      Pe("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && !e.errored && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ov(t);
    }
    function Jo(t, e) {
      !e.readingMore && e.constructed && (e.readingMore = true, Tr.nextTick(G5, t, e));
    }
    function G5(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        let r = e.length;
        if (Pe("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Le.prototype._read = function(t) {
      throw new U5("_read()");
    };
    Le.prototype.pipe = function(t, e) {
      let r = this, o = this._readableState;
      o.pipes.length === 1 && (o.multiAwaitDrain || (o.multiAwaitDrain = true, o.awaitDrainWriters = new q5(o.awaitDrainWriters ? [o.awaitDrainWriters] : []))), o.pipes.push(t), Pe("pipe count=%d opts=%j", o.pipes.length, e);
      let p = (!e || e.end !== false) && t !== Tr.stdout && t !== Tr.stderr ? y : _e;
      o.endEmitted ? Tr.nextTick(p) : r.once("end", p), t.on("unpipe", m);
      function m(N, we) {
        Pe("onunpipe"), N === r && we && we.hasUnpiped === false && (we.hasUnpiped = true, S2());
      }
      function y() {
        Pe("onend"), t.end();
      }
      let M, x = false;
      function S2() {
        Pe("cleanup"), t.removeListener("close", L), t.removeListener("finish", ge), M && t.removeListener("drain", M), t.removeListener("error", q), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", _e), r.removeListener("data", B), x = true, M && o.awaitDrainWriters && (!t._writableState || t._writableState.needDrain) && M();
      }
      function E() {
        x || (o.pipes.length === 1 && o.pipes[0] === t ? (Pe("false write response, pause", 0), o.awaitDrainWriters = t, o.multiAwaitDrain = false) : o.pipes.length > 1 && o.pipes.includes(t) && (Pe("false write response, pause", o.awaitDrainWriters.size), o.awaitDrainWriters.add(t)), r.pause()), M || (M = Y5(r, t), t.on("drain", M));
      }
      r.on("data", B);
      function B(N) {
        Pe("ondata");
        let we = t.write(N);
        Pe("dest.write", we), we === false && E();
      }
      function q(N) {
        if (Pe("onerror", N), _e(), t.removeListener("error", q), t.listenerCount("error") === 0) {
          let we = t._writableState || t._readableState;
          we && !we.errorEmitted ? sf(t, N) : t.emit("error", N);
        }
      }
      L5(t, "error", q);
      function L() {
        t.removeListener("finish", ge), _e();
      }
      t.once("close", L);
      function ge() {
        Pe("onfinish"), t.removeListener("close", L), _e();
      }
      t.once("finish", ge);
      function _e() {
        Pe("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), t.writableNeedDrain === true ? o.flowing && E() : o.flowing || (Pe("pipe resume"), r.resume()), t;
    };
    function Y5(t, e) {
      return function() {
        let o = t._readableState;
        o.awaitDrainWriters === e ? (Pe("pipeOnDrain", 1), o.awaitDrainWriters = null) : o.multiAwaitDrain && (Pe("pipeOnDrain", o.awaitDrainWriters.size), o.awaitDrainWriters.delete(e)), (!o.awaitDrainWriters || o.awaitDrainWriters.size === 0) && t.listenerCount("data") && t.resume();
      };
    }
    Le.prototype.unpipe = function(t) {
      let e = this._readableState, r = { hasUnpiped: false };
      if (e.pipes.length === 0)
        return this;
      if (!t) {
        let f = e.pipes;
        e.pipes = [], this.pause();
        for (let p = 0;p < f.length; p++)
          f[p].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let o = x5(e.pipes, t);
      return o === -1 ? this : (e.pipes.splice(o, 1), e.pipes.length === 0 && this.pause(), t.emit("unpipe", this, r), this);
    };
    Le.prototype.on = function(t, e) {
      let r = Hi.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, Pe("on readable", o.length, o.reading), o.length ? Qo(this) : o.reading || Tr.nextTick(X5, this)), r;
    };
    Le.prototype.addListener = Le.prototype.on;
    Le.prototype.removeListener = function(t, e) {
      let r = Hi.prototype.removeListener.call(this, t, e);
      return t === "readable" && Tr.nextTick(av, this), r;
    };
    Le.prototype.off = Le.prototype.removeListener;
    Le.prototype.removeAllListeners = function(t) {
      let e = Hi.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && Tr.nextTick(av, this), e;
    };
    function av(t) {
      let e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && e[wn] === false ? e.flowing = true : t.listenerCount("data") > 0 ? t.resume() : e.readableListening || (e.flowing = null);
    }
    function X5(t) {
      Pe("readable nexttick read 0"), t.read(0);
    }
    Le.prototype.resume = function() {
      let t = this._readableState;
      return t.flowing || (Pe("resume"), t.flowing = !t.readableListening, J5(this, t)), t[wn] = false, this;
    };
    function J5(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, Tr.nextTick(Q5, t, e));
    }
    function Q5(t, e) {
      Pe("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ov(t), e.flowing && !e.reading && t.read(0);
    }
    Le.prototype.pause = function() {
      return Pe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Pe("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[wn] = true, this;
    };
    function ov(t) {
      let e = t._readableState;
      for (Pe("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Le.prototype.wrap = function(t) {
      let e = false;
      t.on("data", (o) => {
        !this.push(o) && t.pause && (e = true, t.pause());
      }), t.on("end", () => {
        this.push(null);
      }), t.on("error", (o) => {
        sf(this, o);
      }), t.on("close", () => {
        this.destroy();
      }), t.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        e && t.resume && (e = false, t.resume());
      };
      let r = R5(t);
      for (let o = 1;o < r.length; o++) {
        let f = r[o];
        this[f] === undefined && typeof t[f] == "function" && (this[f] = t[f].bind(t));
      }
      return this;
    };
    Le.prototype[I5] = function() {
      return sv(this);
    };
    Le.prototype.iterator = function(t) {
      return t !== undefined && K5(t, "options"), sv(this, t);
    };
    function sv(t, e) {
      typeof t.read != "function" && (t = Le.wrap(t, { objectMode: true }));
      let r = ex(t, e);
      return r.stream = t, r;
    }
    async function* ex(t, e) {
      let r = zh;
      function o(m) {
        this === t ? (r(), r = zh) : r = m;
      }
      t.on("readable", o);
      let f, p = D5(t, { writable: false }, (m) => {
        f = m ? Q1(f, m) : null, r(), r = zh;
      });
      try {
        for (;; ) {
          let m = t.destroyed ? null : t.read();
          if (m !== null)
            yield m;
          else {
            if (f)
              throw f;
            if (f === null)
              return;
            await new B5(o);
          }
        }
      } catch (m) {
        throw f = Q1(f, m), f;
      } finally {
        (f || e?.destroyOnReturn !== false) && (f === undefined || t._readableState.autoDestroy) ? hf.destroyer(t, null) : (t.off("readable", o), p());
      }
    }
    tv(Le.prototype, { readable: { __proto__: null, get() {
      let t = this._readableState;
      return !!t && t.readable !== false && !t.destroyed && !t.errorEmitted && !t.endEmitted;
    }, set(t) {
      this._readableState && (this._readableState.readable = !!t);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    tv(jh.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[wn] !== false;
    }, set(t) {
      this[wn] = !!t;
    } } });
    Le._fromList = hv;
    function hv(t, e) {
      if (e.length === 0)
        return null;
      let r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Wh(t) {
      let e = t._readableState;
      Pe("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, Tr.nextTick(tx, e, t));
    }
    function tx(t, e) {
      if (Pe("endReadableNT", t.endEmitted, t.length), !t.errored && !t.closeEmitted && !t.endEmitted && t.length === 0) {
        if (t.endEmitted = true, e.emit("end"), e.writable && e.allowHalfOpen === false)
          Tr.nextTick(rx, e);
        else if (t.autoDestroy) {
          let r = e._writableState;
          (!r || r.autoDestroy && (r.finished || r.writable === false)) && e.destroy();
        }
      }
    }
    function rx(t) {
      t.writable && !t.writableEnded && !t.destroyed && t.end();
    }
    Le.from = function(t, e) {
      return j5(Le, t, e);
    };
    var Kh;
    function uv() {
      return Kh === undefined && (Kh = {}), Kh;
    }
    Le.fromWeb = function(t, e) {
      return uv().newStreamReadableFromReadableStream(t, e);
    };
    Le.toWeb = function(t, e) {
      return uv().newReadableStreamFromStreamReadable(t, e);
    };
    Le.wrap = function(t, e) {
      var r, o;
      return new Le({ objectMode: (r = (o = t.readableObjectMode) !== null && o !== undefined ? o : t.objectMode) !== null && r !== undefined ? r : true, ...e, destroy(f, p) {
        hf.destroyer(t, f), p(f);
      } }).wrap(t);
    };
  });
  Jh = T((jI, xv) => {
    var Mn = (Oi(), ur(pr)), { ArrayPrototypeSlice: pv, Error: ix, FunctionPrototypeSymbolHasInstance: vv, ObjectDefineProperty: bv, ObjectDefineProperties: nx, ObjectSetPrototypeOf: mv, StringPrototypeToLowerCase: fx, Symbol: ax, SymbolHasInstance: ox } = Tt();
    xv.exports = st;
    st.WritableState = ya;
    var { EventEmitter: sx } = ki(), ma = Vo().Stream, { Buffer: es } = Ut(), is = yn(), { addAbortSignal: hx } = Go(), { getHighWaterMark: ux, getDefaultHighWaterMark: lx } = Xo(), { ERR_INVALID_ARG_TYPE: dx, ERR_METHOD_NOT_IMPLEMENTED: cx, ERR_MULTIPLE_CALLBACK: gv, ERR_STREAM_CANNOT_PIPE: px, ERR_STREAM_DESTROYED: ga, ERR_STREAM_ALREADY_FINISHED: vx, ERR_STREAM_NULL_VALUES: bx, ERR_STREAM_WRITE_AFTER_END: mx, ERR_UNKNOWN_ENCODING: yv } = Jt().codes, { errorOrDestroy: uf } = is;
    mv(st.prototype, ma.prototype);
    mv(st, ma);
    function $h() {
    }
    var lf = ax("kOnFinished");
    function ya(t, e, r) {
      typeof r != "boolean" && (r = e instanceof Qr()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.writableObjectMode)), this.highWaterMark = t ? ux(this, t, "writableHighWaterMark", r) : lx(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let o = !!(t && t.decodeStrings === false);
      this.decodeStrings = !o, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = yx.bind(undefined, e), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, rs(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[lf] = [];
    }
    function rs(t) {
      t.buffered = [], t.bufferedIndex = 0, t.allBuffers = true, t.allNoop = true;
    }
    ya.prototype.getBuffer = function() {
      return pv(this.buffered, this.bufferedIndex);
    };
    bv(ya.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function st(t) {
      let e = this instanceof Qr();
      if (!e && !vv(st, this))
        return new st(t);
      this._writableState = new ya(t, this, e), t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final), typeof t.construct == "function" && (this._construct = t.construct), t.signal && hx(t.signal, this)), ma.call(this, t), is.construct(this, () => {
        let r = this._writableState;
        r.writing || Yh(this, r), Xh(this, r);
      });
    }
    bv(st, ox, { __proto__: null, value: function(t) {
      return vv(this, t) ? true : this !== st ? false : t && t._writableState instanceof ya;
    } });
    st.prototype.pipe = function() {
      uf(this, new px);
    };
    function wv(t, e, r, o) {
      let f = t._writableState;
      if (typeof r == "function")
        o = r, r = f.defaultEncoding;
      else {
        if (!r)
          r = f.defaultEncoding;
        else if (r !== "buffer" && !es.isEncoding(r))
          throw new yv(r);
        typeof o != "function" && (o = $h);
      }
      if (e === null)
        throw new bx;
      if (!f.objectMode)
        if (typeof e == "string")
          f.decodeStrings !== false && (e = es.from(e, r), r = "buffer");
        else if (e instanceof es)
          r = "buffer";
        else if (ma._isUint8Array(e))
          e = ma._uint8ArrayToBuffer(e), r = "buffer";
        else
          throw new dx("chunk", ["string", "Buffer", "Uint8Array"], e);
      let p;
      return f.ending ? p = new mx : f.destroyed && (p = new ga("write")), p ? (Mn.nextTick(o, p), uf(t, p, true), p) : (f.pendingcb++, gx(t, f, e, r, o));
    }
    st.prototype.write = function(t, e, r) {
      return wv(this, t, e, r) === true;
    };
    st.prototype.cork = function() {
      this._writableState.corked++;
    };
    st.prototype.uncork = function() {
      let t = this._writableState;
      t.corked && (t.corked--, t.writing || Yh(this, t));
    };
    st.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = fx(e)), !es.isEncoding(e))
        throw new yv(e);
      return this._writableState.defaultEncoding = e, this;
    };
    function gx(t, e, r, o, f) {
      let p = e.objectMode ? 1 : r.length;
      e.length += p;
      let m = e.length < e.highWaterMark;
      return m || (e.needDrain = true), e.writing || e.corked || e.errored || !e.constructed ? (e.buffered.push({ chunk: r, encoding: o, callback: f }), e.allBuffers && o !== "buffer" && (e.allBuffers = false), e.allNoop && f !== $h && (e.allNoop = false)) : (e.writelen = p, e.writecb = f, e.writing = true, e.sync = true, t._write(r, o, e.onwrite), e.sync = false), m && !e.errored && !e.destroyed;
    }
    function dv(t, e, r, o, f, p, m) {
      e.writelen = o, e.writecb = m, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new ga("write")) : r ? t._writev(f, e.onwrite) : t._write(f, p, e.onwrite), e.sync = false;
    }
    function cv(t, e, r, o) {
      --e.pendingcb, o(r), Gh(e), uf(t, r);
    }
    function yx(t, e) {
      let r = t._writableState, o = r.sync, f = r.writecb;
      if (typeof f != "function") {
        uf(t, new gv);
        return;
      }
      r.writing = false, r.writecb = null, r.length -= r.writelen, r.writelen = 0, e ? (e.stack, r.errored || (r.errored = e), t._readableState && !t._readableState.errored && (t._readableState.errored = e), o ? Mn.nextTick(cv, t, r, e, f) : cv(t, r, e, f)) : (r.buffered.length > r.bufferedIndex && Yh(t, r), o ? r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === f ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = { count: 1, cb: f, stream: t, state: r }, Mn.nextTick(wx, r.afterWriteTickInfo)) : Mv(t, r, 1, f));
    }
    function wx({ stream: t, state: e, count: r, cb: o }) {
      return e.afterWriteTickInfo = null, Mv(t, e, r, o);
    }
    function Mv(t, e, r, o) {
      for (!e.ending && !t.destroyed && e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));r-- > 0; )
        e.pendingcb--, o();
      e.destroyed && Gh(e), Xh(t, e);
    }
    function Gh(t) {
      if (t.writing)
        return;
      for (let f = t.bufferedIndex;f < t.buffered.length; ++f) {
        var e;
        let { chunk: p, callback: m } = t.buffered[f], y = t.objectMode ? 1 : p.length;
        t.length -= y, m((e = t.errored) !== null && e !== undefined ? e : new ga("write"));
      }
      let r = t[lf].splice(0);
      for (let f = 0;f < r.length; f++) {
        var o;
        r[f]((o = t.errored) !== null && o !== undefined ? o : new ga("end"));
      }
      rs(t);
    }
    function Yh(t, e) {
      if (e.corked || e.bufferProcessing || e.destroyed || !e.constructed)
        return;
      let { buffered: r, bufferedIndex: o, objectMode: f } = e, p = r.length - o;
      if (!p)
        return;
      let m = o;
      if (e.bufferProcessing = true, p > 1 && t._writev) {
        e.pendingcb -= p - 1;
        let y = e.allNoop ? $h : (x) => {
          for (let S2 = m;S2 < r.length; ++S2)
            r[S2].callback(x);
        }, M = e.allNoop && m === 0 ? r : pv(r, m);
        M.allBuffers = e.allBuffers, dv(t, e, true, e.length, M, "", y), rs(e);
      } else {
        do {
          let { chunk: y, encoding: M, callback: x } = r[m];
          r[m++] = null;
          let S2 = f ? 1 : y.length;
          dv(t, e, false, S2, y, M, x);
        } while (m < r.length && !e.writing);
        m === r.length ? rs(e) : m > 256 ? (r.splice(0, m), e.bufferedIndex = 0) : e.bufferedIndex = m;
      }
      e.bufferProcessing = false;
    }
    st.prototype._write = function(t, e, r) {
      if (this._writev)
        this._writev([{ chunk: t, encoding: e }], r);
      else
        throw new cx("_write()");
    };
    st.prototype._writev = null;
    st.prototype.end = function(t, e, r) {
      let o = this._writableState;
      typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null);
      let f;
      if (t != null) {
        let p = wv(this, t, e);
        p instanceof ix && (f = p);
      }
      return o.corked && (o.corked = 1, this.uncork()), f || (!o.errored && !o.ending ? (o.ending = true, Xh(this, o, true), o.ended = true) : o.finished ? f = new vx("end") : o.destroyed && (f = new ga("end"))), typeof r == "function" && (f || o.finished ? Mn.nextTick(r, f) : o[lf].push(r)), this;
    };
    function ts(t) {
      return t.ending && !t.destroyed && t.constructed && t.length === 0 && !t.errored && t.buffered.length === 0 && !t.finished && !t.writing && !t.errorEmitted && !t.closeEmitted;
    }
    function Mx(t, e) {
      let r = false;
      function o(f) {
        if (r) {
          uf(t, f ?? gv());
          return;
        }
        if (r = true, e.pendingcb--, f) {
          let p = e[lf].splice(0);
          for (let m = 0;m < p.length; m++)
            p[m](f);
          uf(t, f, e.sync);
        } else
          ts(e) && (e.prefinished = true, t.emit("prefinish"), e.pendingcb++, Mn.nextTick(Vh, t, e));
      }
      e.sync = true, e.pendingcb++;
      try {
        t._final(o);
      } catch (f) {
        o(f);
      }
      e.sync = false;
    }
    function _x(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.finalCalled = true, Mx(t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Xh(t, e, r) {
      ts(e) && (_x(t, e), e.pendingcb === 0 && (r ? (e.pendingcb++, Mn.nextTick((o, f) => {
        ts(f) ? Vh(o, f) : f.pendingcb--;
      }, t, e)) : ts(e) && (e.pendingcb++, Vh(t, e))));
    }
    function Vh(t, e) {
      e.pendingcb--, e.finished = true;
      let r = e[lf].splice(0);
      for (let o = 0;o < r.length; o++)
        r[o]();
      if (t.emit("finish"), e.autoDestroy) {
        let o = t._readableState;
        (!o || o.autoDestroy && (o.endEmitted || o.readable === false)) && t.destroy();
      }
    }
    nx(st.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(t) {
      this._writableState && (this._writableState.destroyed = t);
    } }, writable: { __proto__: null, get() {
      let t = this._writableState;
      return !!t && t.writable !== false && !t.destroyed && !t.errored && !t.ending && !t.ended;
    }, set(t) {
      this._writableState && (this._writableState.writable = !!t);
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let t = this._writableState;
      return t ? !t.destroyed && !t.ending && t.needDrain : false;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var xx = is.destroy;
    st.prototype.destroy = function(t, e) {
      let r = this._writableState;
      return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[lf].length) && Mn.nextTick(Gh, r), xx.call(this, t, e), this;
    };
    st.prototype._undestroy = is.undestroy;
    st.prototype._destroy = function(t, e) {
      e(t);
    };
    st.prototype[sx.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    var Zh;
    function _v() {
      return Zh === undefined && (Zh = {}), Zh;
    }
    st.fromWeb = function(t, e) {
      return _v().newStreamWritableFromWritableStream(t, e);
    };
    st.toWeb = function(t) {
      return _v().newWritableStreamFromStreamWritable(t);
    };
  });
  Dv = T((ZI, Nv) => {
    var Qh = (Oi(), ur(pr)), Sx = Ut(), { isReadable: Ex, isWritable: Ax, isIterable: Sv, isNodeStream: Rx, isReadableNodeStream: Ev, isWritableNodeStream: Av, isDuplexNodeStream: Bx } = Fi(), Rv = Ui(), { AbortError: Lv, codes: { ERR_INVALID_ARG_TYPE: qx, ERR_INVALID_RETURN_VALUE: Bv } } = Jt(), { destroyer: df } = yn(), Ix = Qr(), Tx = ba(), { createDeferredPromise: qv } = Gr(), Iv = Fh(), Tv = globalThis.Blob || Sx.Blob, kx = typeof Tv < "u" ? function(e) {
      return e instanceof Tv;
    } : function(e) {
      return false;
    }, Lx = globalThis.AbortController || No().AbortController, { FunctionPrototypeCall: kv } = Tt(), _n = class extends Ix {
      constructor(e) {
        super(e), e?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    };
    Nv.exports = function t(e, r) {
      if (Bx(e))
        return e;
      if (Ev(e))
        return ns({ readable: e });
      if (Av(e))
        return ns({ writable: e });
      if (Rx(e))
        return ns({ writable: false, readable: false });
      if (typeof e == "function") {
        let { value: f, write: p, final: m, destroy: y } = Nx(e);
        if (Sv(f))
          return Iv(_n, f, { objectMode: true, write: p, final: m, destroy: y });
        let M = f?.then;
        if (typeof M == "function") {
          let x, S2 = kv(M, f, (E) => {
            if (E != null)
              throw new Bv("nully", "body", E);
          }, (E) => {
            df(x, E);
          });
          return x = new _n({ objectMode: true, readable: false, write: p, final(E) {
            m(async () => {
              try {
                await S2, Qh.nextTick(E, null);
              } catch (B) {
                Qh.nextTick(E, B);
              }
            });
          }, destroy: y });
        }
        throw new Bv("Iterable, AsyncIterable or AsyncFunction", r, f);
      }
      if (kx(e))
        return t(e.arrayBuffer());
      if (Sv(e))
        return Iv(_n, e, { objectMode: true, writable: false });
      if (typeof e?.writable == "object" || typeof e?.readable == "object") {
        let f = e != null && e.readable ? Ev(e?.readable) ? e?.readable : t(e.readable) : undefined, p = e != null && e.writable ? Av(e?.writable) ? e?.writable : t(e.writable) : undefined;
        return ns({ readable: f, writable: p });
      }
      let o = e?.then;
      if (typeof o == "function") {
        let f;
        return kv(o, e, (p) => {
          p != null && f.push(p), f.push(null);
        }, (p) => {
          df(f, p);
        }), f = new _n({ objectMode: true, writable: false, read() {
        } });
      }
      throw new qx(r, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], e);
    };
    function Nx(t) {
      let { promise: e, resolve: r } = qv(), o = new Lx, f = o.signal;
      return { value: t(async function* () {
        for (;; ) {
          let m = e;
          e = null;
          let { chunk: y, done: M, cb: x } = await m;
          if (Qh.nextTick(x), M)
            return;
          if (f.aborted)
            throw new Lv(undefined, { cause: f.reason });
          ({ promise: e, resolve: r } = qv()), yield y;
        }
      }(), { signal: f }), write(m, y, M) {
        let x = r;
        r = null, x({ chunk: m, done: false, cb: M });
      }, final(m) {
        let y = r;
        r = null, y({ done: true, cb: m });
      }, destroy(m, y) {
        o.abort(), y(m);
      } };
    }
    function ns(t) {
      let e = t.readable && typeof t.readable.read != "function" ? Tx.wrap(t.readable) : t.readable, r = t.writable, o = !!Ex(e), f = !!Ax(r), p, m, y, M, x;
      function S2(E) {
        let B = M;
        M = null, B ? B(E) : E ? x.destroy(E) : !o && !f && x.destroy();
      }
      return x = new _n({ readableObjectMode: !!(e != null && e.readableObjectMode), writableObjectMode: !!(r != null && r.writableObjectMode), readable: o, writable: f }), f && (Rv(r, (E) => {
        f = false, E && df(e, E), S2(E);
      }), x._write = function(E, B, q) {
        r.write(E, B) ? q() : p = q;
      }, x._final = function(E) {
        r.end(), m = E;
      }, r.on("drain", function() {
        if (p) {
          let E = p;
          p = null, E();
        }
      }), r.on("finish", function() {
        if (m) {
          let E = m;
          m = null, E();
        }
      })), o && (Rv(e, (E) => {
        o = false, E && df(e, E), S2(E);
      }), e.on("readable", function() {
        if (y) {
          let E = y;
          y = null, E();
        }
      }), e.on("end", function() {
        x.push(null);
      }), x._read = function() {
        for (;; ) {
          let E = e.read();
          if (E === null) {
            y = x._read;
            return;
          }
          if (!x.push(E))
            return;
        }
      }), x._destroy = function(E, B) {
        !E && M !== null && (E = new Lv), y = null, p = null, m = null, M === null ? B(E) : (M = B, df(r, E), df(e, E));
      }, x;
    }
  });
  Qr = T((VI, Ov) => {
    var { ObjectDefineProperties: Dx, ObjectGetOwnPropertyDescriptor: bi, ObjectKeys: Px, ObjectSetPrototypeOf: Pv } = Tt();
    Ov.exports = kr;
    var ru = ba(), vr = Jh();
    Pv(kr.prototype, ru.prototype);
    Pv(kr, ru);
    {
      let t = Px(vr.prototype);
      for (let e = 0;e < t.length; e++) {
        let r = t[e];
        kr.prototype[r] || (kr.prototype[r] = vr.prototype[r]);
      }
    }
    function kr(t) {
      if (!(this instanceof kr))
        return new kr(t);
      ru.call(this, t), vr.call(this, t), t ? (this.allowHalfOpen = t.allowHalfOpen !== false, t.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    Dx(kr.prototype, { writable: { __proto__: null, ...bi(vr.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...bi(vr.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...bi(vr.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...bi(vr.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...bi(vr.prototype, "writableLength") }, writableFinished: { __proto__: null, ...bi(vr.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...bi(vr.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...bi(vr.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...bi(vr.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set(t) {
      this._readableState && this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } } });
    var eu;
    function Cv() {
      return eu === undefined && (eu = {}), eu;
    }
    kr.fromWeb = function(t, e) {
      return Cv().newStreamDuplexFromReadableWritablePair(t, e);
    };
    kr.toWeb = function(t) {
      return Cv().newReadableWritablePairFromDuplex(t);
    };
    var tu;
    kr.from = function(t) {
      return tu || (tu = Dv()), tu(t, "body");
    };
  });
  fu = T(($I, Uv) => {
    var { ObjectSetPrototypeOf: Fv, Symbol: Cx } = Tt();
    Uv.exports = mi;
    var { ERR_METHOD_NOT_IMPLEMENTED: Ox } = Jt().codes, nu = Qr(), { getHighWaterMark: Fx } = Xo();
    Fv(mi.prototype, nu.prototype);
    Fv(mi, nu);
    var wa = Cx("kCallback");
    function mi(t) {
      if (!(this instanceof mi))
        return new mi(t);
      let e = t ? Fx(this, t, "readableHighWaterMark", true) : null;
      e === 0 && (t = { ...t, highWaterMark: null, readableHighWaterMark: e, writableHighWaterMark: t.writableHighWaterMark || 0 }), nu.call(this, t), this._readableState.sync = false, this[wa] = null, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", Ux);
    }
    function iu(t) {
      typeof this._flush == "function" && !this.destroyed ? this._flush((e, r) => {
        if (e) {
          t ? t(e) : this.destroy(e);
          return;
        }
        r != null && this.push(r), this.push(null), t && t();
      }) : (this.push(null), t && t());
    }
    function Ux() {
      this._final !== iu && iu.call(this);
    }
    mi.prototype._final = iu;
    mi.prototype._transform = function(t, e, r) {
      throw new Ox("_transform()");
    };
    mi.prototype._write = function(t, e, r) {
      let o = this._readableState, f = this._writableState, p = o.length;
      this._transform(t, e, (m, y) => {
        if (m) {
          r(m);
          return;
        }
        y != null && this.push(y), f.ended || p === o.length || o.length < o.highWaterMark ? r() : this[wa] = r;
      });
    };
    mi.prototype._read = function() {
      if (this[wa]) {
        let t = this[wa];
        this[wa] = null, t();
      }
    };
  });
  ou = T((GI, Hv) => {
    var { ObjectSetPrototypeOf: zv } = Tt();
    Hv.exports = cf;
    var au = fu();
    zv(cf.prototype, au.prototype);
    zv(cf, au);
    function cf(t) {
      if (!(this instanceof cf))
        return new cf(t);
      au.call(this, t);
    }
    cf.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  os = T((YI, Gv) => {
    var fs = (Oi(), ur(pr)), { ArrayIsArray: zx, Promise: Hx, SymbolAsyncIterator: Wx } = Tt(), as = Ui(), { once: Kx } = Gr(), jx = yn(), Wv = Qr(), { aggregateTwoErrors: Zx, codes: { ERR_INVALID_ARG_TYPE: Vv, ERR_INVALID_RETURN_VALUE: su, ERR_MISSING_ARGS: Vx, ERR_STREAM_DESTROYED: $x, ERR_STREAM_PREMATURE_CLOSE: Gx }, AbortError: Yx } = Jt(), { validateFunction: Xx, validateAbortSignal: Jx } = pa(), { isIterable: pf, isReadable: hu, isReadableNodeStream: du, isNodeStream: Kv } = Fi(), Qx = globalThis.AbortController || No().AbortController, uu, lu;
    function jv(t, e, r) {
      let o = false;
      t.on("close", () => {
        o = true;
      });
      let f = as(t, { readable: e, writable: r }, (p) => {
        o = !p;
      });
      return { destroy: (p) => {
        o || (o = true, jx.destroyer(t, p || new $x("pipe")));
      }, cleanup: f };
    }
    function e7(t) {
      return Xx(t[t.length - 1], "streams[stream.length - 1]"), t.pop();
    }
    function t7(t) {
      if (pf(t))
        return t;
      if (du(t))
        return r7(t);
      throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], t);
    }
    async function* r7(t) {
      lu || (lu = ba()), yield* lu.prototype[Wx].call(t);
    }
    async function Zv(t, e, r, { end: o }) {
      let f, p = null, m = (x) => {
        if (x && (f = x), p) {
          let S2 = p;
          p = null, S2();
        }
      }, y = () => new Hx((x, S2) => {
        f ? S2(f) : p = () => {
          f ? S2(f) : x();
        };
      });
      e.on("drain", m);
      let M = as(e, { readable: false }, m);
      try {
        e.writableNeedDrain && await y();
        for await (let x of t)
          e.write(x) || await y();
        o && e.end(), await y(), r();
      } catch (x) {
        r(f !== x ? Zx(f, x) : x);
      } finally {
        M(), e.off("drain", m);
      }
    }
    function i7(...t) {
      return $v(t, Kx(e7(t)));
    }
    function $v(t, e, r) {
      if (t.length === 1 && zx(t[0]) && (t = t[0]), t.length < 2)
        throw new Vx("streams");
      let o = new Qx, f = o.signal, p = r?.signal, m = [];
      Jx(p, "options.signal");
      function y() {
        q(new Yx);
      }
      p?.addEventListener("abort", y);
      let M, x, S2 = [], E = 0;
      function B(N) {
        q(N, --E === 0);
      }
      function q(N, we) {
        if (N && (!M || M.code === "ERR_STREAM_PREMATURE_CLOSE") && (M = N), !(!M && !we)) {
          for (;S2.length; )
            S2.shift()(M);
          p?.removeEventListener("abort", y), o.abort(), we && (M || m.forEach((ye) => ye()), fs.nextTick(e, M, x));
        }
      }
      let L;
      for (let N = 0;N < t.length; N++) {
        let we = t[N], ye = N < t.length - 1, xe = N > 0, Re = ye || r?.end !== false, Ee = N === t.length - 1;
        if (Kv(we)) {
          let Ae = function(P) {
            P && P.name !== "AbortError" && P.code !== "ERR_STREAM_PREMATURE_CLOSE" && B(P);
          };
          var _e = Ae;
          if (Re) {
            let { destroy: P, cleanup: Se } = jv(we, ye, xe);
            S2.push(P), hu(we) && Ee && m.push(Se);
          }
          we.on("error", Ae), hu(we) && Ee && m.push(() => {
            we.removeListener("error", Ae);
          });
        }
        if (N === 0)
          if (typeof we == "function") {
            if (L = we({ signal: f }), !pf(L))
              throw new su("Iterable, AsyncIterable or Stream", "source", L);
          } else
            pf(we) || du(we) ? L = we : L = Wv.from(we);
        else if (typeof we == "function")
          if (L = t7(L), L = we(L, { signal: f }), ye) {
            if (!pf(L, true))
              throw new su("AsyncIterable", `transform[${N - 1}]`, L);
          } else {
            var ge;
            uu || (uu = ou());
            let Ae = new uu({ objectMode: true }), P = (ge = L) === null || ge === undefined ? undefined : ge.then;
            if (typeof P == "function")
              E++, P.call(L, (i) => {
                x = i, i != null && Ae.write(i), Re && Ae.end(), fs.nextTick(B);
              }, (i) => {
                Ae.destroy(i), fs.nextTick(B, i);
              });
            else if (pf(L, true))
              E++, Zv(L, Ae, B, { end: Re });
            else
              throw new su("AsyncIterable or Promise", "destination", L);
            L = Ae;
            let { destroy: Se, cleanup: v2 } = jv(L, false, true);
            S2.push(Se), Ee && m.push(v2);
          }
        else if (Kv(we)) {
          if (du(L)) {
            E += 2;
            let Ae = n7(L, we, B, { end: Re });
            hu(we) && Ee && m.push(Ae);
          } else if (pf(L))
            E++, Zv(L, we, B, { end: Re });
          else
            throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], L);
          L = we;
        } else
          L = Wv.from(we);
      }
      return (f != null && f.aborted || p != null && p.aborted) && fs.nextTick(y), L;
    }
    function n7(t, e, r, { end: o }) {
      let f = false;
      return e.on("close", () => {
        f || r(new Gx);
      }), t.pipe(e, { end: o }), o ? t.once("end", () => {
        f = true, e.end();
      }) : r(), as(t, { readable: true, writable: false }, (p) => {
        let m = t._readableState;
        p && p.code === "ERR_STREAM_PREMATURE_CLOSE" && m && m.ended && !m.errored && !m.errorEmitted ? t.once("end", r).once("error", r) : r(p);
      }), as(e, { readable: false, writable: true }, r);
    }
    Gv.exports = { pipelineImpl: $v, pipeline: i7 };
  });
  eb = T((XI, Qv) => {
    var { pipeline: f7 } = os(), ss = Qr(), { destroyer: a7 } = yn(), { isNodeStream: o7, isReadable: Yv, isWritable: Xv } = Fi(), { AbortError: s7, codes: { ERR_INVALID_ARG_VALUE: Jv, ERR_MISSING_ARGS: h7 } } = Jt();
    Qv.exports = function(...e) {
      if (e.length === 0)
        throw new h7("streams");
      if (e.length === 1)
        return ss.from(e[0]);
      let r = [...e];
      if (typeof e[0] == "function" && (e[0] = ss.from(e[0])), typeof e[e.length - 1] == "function") {
        let q = e.length - 1;
        e[q] = ss.from(e[q]);
      }
      for (let q = 0;q < e.length; ++q)
        if (!!o7(e[q])) {
          if (q < e.length - 1 && !Yv(e[q]))
            throw new Jv(`streams[${q}]`, r[q], "must be readable");
          if (q > 0 && !Xv(e[q]))
            throw new Jv(`streams[${q}]`, r[q], "must be writable");
        }
      let o, f, p, m, y;
      function M(q) {
        let L = m;
        m = null, L ? L(q) : q ? y.destroy(q) : !B && !E && y.destroy();
      }
      let x = e[0], S2 = f7(e, M), E = !!Xv(x), B = !!Yv(S2);
      return y = new ss({ writableObjectMode: !!(x != null && x.writableObjectMode), readableObjectMode: !!(S2 != null && S2.writableObjectMode), writable: E, readable: B }), E && (y._write = function(q, L, ge) {
        x.write(q, L) ? ge() : o = ge;
      }, y._final = function(q) {
        x.end(), f = q;
      }, x.on("drain", function() {
        if (o) {
          let q = o;
          o = null, q();
        }
      }), S2.on("finish", function() {
        if (f) {
          let q = f;
          f = null, q();
        }
      })), B && (S2.on("readable", function() {
        if (p) {
          let q = p;
          p = null, q();
        }
      }), S2.on("end", function() {
        y.push(null);
      }), y._read = function() {
        for (;; ) {
          let q = S2.read();
          if (q === null) {
            p = y._read;
            return;
          }
          if (!y.push(q))
            return;
        }
      }), y._destroy = function(q, L) {
        !q && m !== null && (q = new s7), p = null, o = null, f = null, m === null ? L(q) : (m = L, a7(S2, q));
      }, y;
    };
  });
  cu = T((JI, tb) => {
    var { ArrayPrototypePop: u7, Promise: l7 } = Tt(), { isIterable: d7, isNodeStream: c7 } = Fi(), { pipelineImpl: p7 } = os(), { finished: v7 } = Ui();
    function b7(...t) {
      return new l7((e, r) => {
        let o, f, p = t[t.length - 1];
        if (p && typeof p == "object" && !c7(p) && !d7(p)) {
          let m = u7(t);
          o = m.signal, f = m.end;
        }
        p7(t, (m, y) => {
          m ? r(m) : e(y);
        }, { signal: o, end: f });
      });
    }
    tb.exports = { finished: v7, pipeline: b7 };
  });
  lb = T((QI, ub) => {
    var { Buffer: m7 } = Ut(), { ObjectDefineProperty: gi, ObjectKeys: nb, ReflectApply: fb } = Tt(), { promisify: { custom: ab } } = Gr(), { streamReturningOperators: rb, promiseReturningOperators: ib } = k1(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: ob } } = Jt(), g7 = eb(), { pipeline: sb } = os(), { destroyer: y7 } = yn(), hb = Ui(), pu = cu(), vu = Fi(), ct = ub.exports = Vo().Stream;
    ct.isDisturbed = vu.isDisturbed;
    ct.isErrored = vu.isErrored;
    ct.isReadable = vu.isReadable;
    ct.Readable = ba();
    for (let t of nb(rb)) {
      let r = function(...o) {
        if (new.target)
          throw ob();
        return ct.Readable.from(fb(e, this, o));
      };
      M7 = r;
      let e = rb[t];
      gi(r, "name", { __proto__: null, value: e.name }), gi(r, "length", { __proto__: null, value: e.length }), gi(ct.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    for (let t of nb(ib)) {
      let r = function(...f) {
        if (new.target)
          throw ob();
        return fb(e, this, f);
      };
      M7 = r;
      let e = ib[t];
      gi(r, "name", { __proto__: null, value: e.name }), gi(r, "length", { __proto__: null, value: e.length }), gi(ct.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    ct.Writable = Jh();
    ct.Duplex = Qr();
    ct.Transform = fu();
    ct.PassThrough = ou();
    ct.pipeline = sb;
    var { addAbortSignal: w7 } = Go();
    ct.addAbortSignal = w7;
    ct.finished = hb;
    ct.destroy = y7;
    ct.compose = g7;
    gi(ct, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return pu;
    } });
    gi(sb, ab, { __proto__: null, enumerable: true, get() {
      return pu.pipeline;
    } });
    gi(hb, ab, { __proto__: null, enumerable: true, get() {
      return pu.finished;
    } });
    ct.Stream = ct;
    ct._isUint8Array = function(e) {
      return e instanceof Uint8Array;
    };
    ct._uint8ArrayToBuffer = function(e) {
      return m7.from(e.buffer, e.byteOffset, e.byteLength);
    };
  });
  bu = T((eT, pt) => {
    var Lt = lb(), _7 = cu(), x7 = Lt.Readable.destroy;
    pt.exports = Lt.Readable;
    pt.exports._uint8ArrayToBuffer = Lt._uint8ArrayToBuffer;
    pt.exports._isUint8Array = Lt._isUint8Array;
    pt.exports.isDisturbed = Lt.isDisturbed;
    pt.exports.isErrored = Lt.isErrored;
    pt.exports.isReadable = Lt.isReadable;
    pt.exports.Readable = Lt.Readable;
    pt.exports.Writable = Lt.Writable;
    pt.exports.Duplex = Lt.Duplex;
    pt.exports.Transform = Lt.Transform;
    pt.exports.PassThrough = Lt.PassThrough;
    pt.exports.addAbortSignal = Lt.addAbortSignal;
    pt.exports.finished = Lt.finished;
    pt.exports.destroy = Lt.destroy;
    pt.exports.destroy = x7;
    pt.exports.pipeline = Lt.pipeline;
    pt.exports.compose = Lt.compose;
    Object.defineProperty(Lt, "promises", { configurable: true, enumerable: true, get() {
      return _7;
    } });
    pt.exports.Stream = Lt.Stream;
    pt.exports.default = pt.exports;
  });
  vf = {};
  Ja(vf, { default: () => S7 });
  db = R0(() => {
    ot(vf, rn(bu()));
    S7 = rn(bu());
  });
  yi = T((rT, vb) => {
    var cb = Te().Buffer, pb = (db(), ur(vf)).Transform, E7 = co().StringDecoder, A7 = Ie();
    function Lr(t) {
      pb.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
    }
    A7(Lr, pb);
    Lr.prototype.update = function(t, e, r) {
      typeof t == "string" && (t = cb.from(t, e));
      var o = this._update(t);
      return this.hashMode ? this : (r && (o = this._toString(o, r)), o);
    };
    Lr.prototype.setAutoPadding = function() {
    };
    Lr.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    Lr.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    Lr.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    Lr.prototype._transform = function(t, e, r) {
      var o;
      try {
        this.hashMode ? this._update(t) : this.push(this._update(t));
      } catch (f) {
        o = f;
      } finally {
        r(o);
      }
    };
    Lr.prototype._flush = function(t) {
      var e;
      try {
        this.push(this.__final());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    Lr.prototype._finalOrDigest = function(t) {
      var e = this.__final() || cb.alloc(0);
      return t && (e = this._toString(e, t, true)), e;
    };
    Lr.prototype._toString = function(t, e, r) {
      if (this._decoder || (this._decoder = new E7(e), this._encoding = e), this._encoding !== e)
        throw new Error("can't switch encodings");
      var o = this._decoder.write(t);
      return r && (o += this._decoder.end()), o;
    };
    vb.exports = Lr;
  });
  bf = T((iT, mb) => {
    var R7 = Ie(), B7 = Ao(), q7 = Bo(), I7 = ko(), bb = yi();
    function hs(t) {
      bb.call(this, "digest"), this._hash = t;
    }
    R7(hs, bb);
    hs.prototype._update = function(t) {
      this._hash.update(t);
    };
    hs.prototype._final = function() {
      return this._hash.digest();
    };
    mb.exports = function(e) {
      return e = e.toLowerCase(), e === "md5" ? new B7 : e === "rmd160" || e === "ripemd160" ? new q7 : new hs(I7(e));
    };
  });
  wb = T((nT, yb) => {
    var T7 = Ie(), xn = Te().Buffer, gb = yi(), k7 = xn.alloc(128), mf = 64;
    function us(t, e) {
      gb.call(this, "digest"), typeof e == "string" && (e = xn.from(e)), this._alg = t, this._key = e, e.length > mf ? e = t(e) : e.length < mf && (e = xn.concat([e, k7], mf));
      for (var r = this._ipad = xn.allocUnsafe(mf), o = this._opad = xn.allocUnsafe(mf), f = 0;f < mf; f++)
        r[f] = e[f] ^ 54, o[f] = e[f] ^ 92;
      this._hash = [r];
    }
    T7(us, gb);
    us.prototype._update = function(t) {
      this._hash.push(t);
    };
    us.prototype._final = function() {
      var t = this._alg(xn.concat(this._hash));
      return this._alg(xn.concat([this._opad, t]));
    };
    yb.exports = us;
  });
  mu = T((fT, Mb) => {
    var L7 = Ao();
    Mb.exports = function(t) {
      return new L7().update(t).digest();
    };
  });
  wu = T((aT, xb) => {
    var N7 = Ie(), D7 = wb(), _b = yi(), Ma = Te().Buffer, P7 = mu(), gu = Bo(), yu = ko(), C7 = Ma.alloc(128);
    function _a(t, e) {
      _b.call(this, "digest"), typeof e == "string" && (e = Ma.from(e));
      var r = t === "sha512" || t === "sha384" ? 128 : 64;
      if (this._alg = t, this._key = e, e.length > r) {
        var o = t === "rmd160" ? new gu : yu(t);
        e = o.update(e).digest();
      } else
        e.length < r && (e = Ma.concat([e, C7], r));
      for (var f = this._ipad = Ma.allocUnsafe(r), p = this._opad = Ma.allocUnsafe(r), m = 0;m < r; m++)
        f[m] = e[m] ^ 54, p[m] = e[m] ^ 92;
      this._hash = t === "rmd160" ? new gu : yu(t), this._hash.update(f);
    }
    N7(_a, _b);
    _a.prototype._update = function(t) {
      this._hash.update(t);
    };
    _a.prototype._final = function() {
      var t = this._hash.digest(), e = this._alg === "rmd160" ? new gu : yu(this._alg);
      return e.update(this._opad).update(t).digest();
    };
    xb.exports = function(e, r) {
      return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new _a("rmd160", r) : e === "md5" ? new D7(P7, r) : new _a(e, r);
    };
  });
  Mu = T((oT, O7) => {
    O7.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
  });
  Eb = T((sT, Sb) => {
    Sb.exports = Mu();
  });
  _u = T((hT, Ab) => {
    var F7 = Math.pow(2, 30) - 1;
    Ab.exports = function(t, e) {
      if (typeof t != "number")
        throw new TypeError("Iterations not a number");
      if (t < 0)
        throw new TypeError("Bad iterations");
      if (typeof e != "number")
        throw new TypeError("Key length not a number");
      if (e < 0 || e > F7 || e !== e)
        throw new TypeError("Bad key length");
    };
  });
  xu = T((uT, Bb) => {
    var ls;
    global.process && global.process.browser ? ls = "utf-8" : global.process && global.process.version ? (Rb = parseInt(process.version.split(".")[0].slice(1), 10), ls = Rb >= 6 ? "utf-8" : "binary") : ls = "utf-8";
    var Rb;
    Bb.exports = ls;
  });
  Eu = T((lT, qb) => {
    var Su = Te().Buffer;
    qb.exports = function(t, e, r) {
      if (Su.isBuffer(t))
        return t;
      if (typeof t == "string")
        return Su.from(t, e);
      if (ArrayBuffer.isView(t))
        return Su.from(t.buffer);
      throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
    };
  });
  Au = T((dT, Lb) => {
    var U7 = mu(), z7 = Bo(), H7 = ko(), Sn = Te().Buffer, W7 = _u(), Ib = xu(), Tb = Eu(), K7 = Sn.alloc(128), ds = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
    function kb(t, e, r) {
      var o = j7(t), f = t === "sha512" || t === "sha384" ? 128 : 64;
      e.length > f ? e = o(e) : e.length < f && (e = Sn.concat([e, K7], f));
      for (var p = Sn.allocUnsafe(f + ds[t]), m = Sn.allocUnsafe(f + ds[t]), y = 0;y < f; y++)
        p[y] = e[y] ^ 54, m[y] = e[y] ^ 92;
      var M = Sn.allocUnsafe(f + r + 4);
      p.copy(M, 0, 0, f), this.ipad1 = M, this.ipad2 = p, this.opad = m, this.alg = t, this.blocksize = f, this.hash = o, this.size = ds[t];
    }
    kb.prototype.run = function(t, e) {
      t.copy(e, this.blocksize);
      var r = this.hash(e);
      return r.copy(this.opad, this.blocksize), this.hash(this.opad);
    };
    function j7(t) {
      function e(o) {
        return H7(t).update(o).digest();
      }
      function r(o) {
        return new z7().update(o).digest();
      }
      return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? U7 : e;
    }
    function Z7(t, e, r, o, f) {
      W7(r, o), t = Tb(t, Ib, "Password"), e = Tb(e, Ib, "Salt"), f = f || "sha1";
      var p = new kb(f, t, e.length), m = Sn.allocUnsafe(o), y = Sn.allocUnsafe(e.length + 4);
      e.copy(y, 0, 0, e.length);
      for (var M = 0, x = ds[f], S2 = Math.ceil(o / x), E = 1;E <= S2; E++) {
        y.writeUInt32BE(E, e.length);
        for (var B = p.run(y, p.ipad1), q = B, L = 1;L < r; L++) {
          q = p.run(q, p.ipad2);
          for (var ge = 0;ge < x; ge++)
            B[ge] ^= q[ge];
        }
        B.copy(m, M), M += x;
      }
      return m;
    }
    Lb.exports = Z7;
  });
  Ub = T((cT, Fb) => {
    var Cb = Te().Buffer, V7 = _u(), Nb = xu(), Db = Au(), Pb = Eu(), cs, xa = global.crypto && global.crypto.subtle, $7 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, Ru = [];
    function G7(t) {
      if (global.process && !global.process.browser || !xa || !xa.importKey || !xa.deriveBits)
        return Promise.resolve(false);
      if (Ru[t] !== undefined)
        return Ru[t];
      cs = cs || Cb.alloc(8);
      var e = Ob(cs, cs, 10, 128, t).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      return Ru[t] = e, e;
    }
    var En;
    function Bu() {
      return En || (global.process && global.process.nextTick ? En = global.process.nextTick : global.queueMicrotask ? En = global.queueMicrotask : global.setImmediate ? En = global.setImmediate : En = global.setTimeout, En);
    }
    function Ob(t, e, r, o, f) {
      return xa.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(p) {
        return xa.deriveBits({ name: "PBKDF2", salt: e, iterations: r, hash: { name: f } }, p, o << 3);
      }).then(function(p) {
        return Cb.from(p);
      });
    }
    function Y7(t, e) {
      t.then(function(r) {
        Bu()(function() {
          e(null, r);
        });
      }, function(r) {
        Bu()(function() {
          e(r);
        });
      });
    }
    Fb.exports = function(t, e, r, o, f, p) {
      typeof f == "function" && (p = f, f = undefined), f = f || "sha1";
      var m = $7[f.toLowerCase()];
      if (!m || typeof global.Promise != "function") {
        Bu()(function() {
          var y;
          try {
            y = Db(t, e, r, o, f);
          } catch (M) {
            return p(M);
          }
          p(null, y);
        });
        return;
      }
      if (V7(r, o), t = Pb(t, Nb, "Password"), e = Pb(e, Nb, "Salt"), typeof p != "function")
        throw new Error("No callback provided to pbkdf2");
      Y7(G7(m).then(function(y) {
        return y ? Ob(t, e, r, o, m) : Db(t, e, r, o, f);
      }), p);
    };
  });
  Iu = T((qu) => {
    qu.pbkdf2 = Ub();
    qu.pbkdf2Sync = Au();
  });
  Tu = T((br) => {
    br.readUInt32BE = function(e, r) {
      var o = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
      return o >>> 0;
    };
    br.writeUInt32BE = function(e, r, o) {
      e[0 + o] = r >>> 24, e[1 + o] = r >>> 16 & 255, e[2 + o] = r >>> 8 & 255, e[3 + o] = r & 255;
    };
    br.ip = function(e, r, o, f) {
      for (var p = 0, m = 0, y = 6;y >= 0; y -= 2) {
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= r >>> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= e >>> M + y & 1;
      }
      for (var y = 6;y >= 0; y -= 2) {
        for (var M = 1;M <= 25; M += 8)
          m <<= 1, m |= r >>> M + y & 1;
        for (var M = 1;M <= 25; M += 8)
          m <<= 1, m |= e >>> M + y & 1;
      }
      o[f + 0] = p >>> 0, o[f + 1] = m >>> 0;
    };
    br.rip = function(e, r, o, f) {
      for (var p = 0, m = 0, y = 0;y < 4; y++)
        for (var M = 24;M >= 0; M -= 8)
          p <<= 1, p |= r >>> M + y & 1, p <<= 1, p |= e >>> M + y & 1;
      for (var y = 4;y < 8; y++)
        for (var M = 24;M >= 0; M -= 8)
          m <<= 1, m |= r >>> M + y & 1, m <<= 1, m |= e >>> M + y & 1;
      o[f + 0] = p >>> 0, o[f + 1] = m >>> 0;
    };
    br.pc1 = function(e, r, o, f) {
      for (var p = 0, m = 0, y = 7;y >= 5; y--) {
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= r >> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          p <<= 1, p |= e >> M + y & 1;
      }
      for (var M = 0;M <= 24; M += 8)
        p <<= 1, p |= r >> M + y & 1;
      for (var y = 1;y <= 3; y++) {
        for (var M = 0;M <= 24; M += 8)
          m <<= 1, m |= r >> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          m <<= 1, m |= e >> M + y & 1;
      }
      for (var M = 0;M <= 24; M += 8)
        m <<= 1, m |= e >> M + y & 1;
      o[f + 0] = p >>> 0, o[f + 1] = m >>> 0;
    };
    br.r28shl = function(e, r) {
      return e << r & 268435455 | e >>> 28 - r;
    };
    var ps = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
    br.pc2 = function(e, r, o, f) {
      for (var p = 0, m = 0, y = ps.length >>> 1, M = 0;M < y; M++)
        p <<= 1, p |= e >>> ps[M] & 1;
      for (var M = y;M < ps.length; M++)
        m <<= 1, m |= r >>> ps[M] & 1;
      o[f + 0] = p >>> 0, o[f + 1] = m >>> 0;
    };
    br.expand = function(e, r, o) {
      var f = 0, p = 0;
      f = (e & 1) << 5 | e >>> 27;
      for (var m = 23;m >= 15; m -= 4)
        f <<= 6, f |= e >>> m & 63;
      for (var m = 11;m >= 3; m -= 4)
        p |= e >>> m & 63, p <<= 6;
      p |= (e & 31) << 1 | e >>> 31, r[o + 0] = f >>> 0, r[o + 1] = p >>> 0;
    };
    var zb = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
    br.substitute = function(e, r) {
      for (var o = 0, f = 0;f < 4; f++) {
        var p = e >>> 18 - f * 6 & 63, m = zb[f * 64 + p];
        o <<= 4, o |= m;
      }
      for (var f = 0;f < 4; f++) {
        var p = r >>> 18 - f * 6 & 63, m = zb[4 * 64 + f * 64 + p];
        o <<= 4, o |= m;
      }
      return o >>> 0;
    };
    var Hb = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
    br.permute = function(e) {
      for (var r = 0, o = 0;o < Hb.length; o++)
        r <<= 1, r |= e >>> Hb[o] & 1;
      return r >>> 0;
    };
    br.padSplit = function(e, r, o) {
      for (var f = e.toString(2);f.length < r; )
        f = "0" + f;
      for (var p = [], m = 0;m < r; m += o)
        p.push(f.slice(m, m + o));
      return p.join(" ");
    };
  });
  ar = T((bT, Kb) => {
    Kb.exports = Wb;
    function Wb(t, e) {
      if (!t)
        throw new Error(e || "Assertion failed");
    }
    Wb.equal = function(e, r, o) {
      if (e != r)
        throw new Error(o || "Assertion failed: " + e + " != " + r);
    };
  });
  vs = T((mT, jb) => {
    var X7 = ar();
    function mr2(t) {
      this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
    }
    jb.exports = mr2;
    mr2.prototype._init = function() {
    };
    mr2.prototype.update = function(e) {
      return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
    };
    mr2.prototype._buffer = function(e, r) {
      for (var o = Math.min(this.buffer.length - this.bufferOff, e.length - r), f = 0;f < o; f++)
        this.buffer[this.bufferOff + f] = e[r + f];
      return this.bufferOff += o, o;
    };
    mr2.prototype._flushBuffer = function(e, r) {
      return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize;
    };
    mr2.prototype._updateEncrypt = function(e) {
      var r = 0, o = 0, f = (this.bufferOff + e.length) / this.blockSize | 0, p = new Array(f * this.blockSize);
      this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (o += this._flushBuffer(p, o)));
      for (var m = e.length - (e.length - r) % this.blockSize;r < m; r += this.blockSize)
        this._update(e, r, p, o), o += this.blockSize;
      for (;r < e.length; r++, this.bufferOff++)
        this.buffer[this.bufferOff] = e[r];
      return p;
    };
    mr2.prototype._updateDecrypt = function(e) {
      for (var r = 0, o = 0, f = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, p = new Array(f * this.blockSize);f > 0; f--)
        r += this._buffer(e, r), o += this._flushBuffer(p, o);
      return r += this._buffer(e, r), p;
    };
    mr2.prototype.final = function(e) {
      var r;
      e && (r = this.update(e));
      var o;
      return this.type === "encrypt" ? o = this._finalEncrypt() : o = this._finalDecrypt(), r ? r.concat(o) : o;
    };
    mr2.prototype._pad = function(e, r) {
      if (r === 0)
        return false;
      for (;r < e.length; )
        e[r++] = 0;
      return true;
    };
    mr2.prototype._finalEncrypt = function() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var e = new Array(this.blockSize);
      return this._update(this.buffer, 0, e, 0), e;
    };
    mr2.prototype._unpad = function(e) {
      return e;
    };
    mr2.prototype._finalDecrypt = function() {
      X7.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var e = new Array(this.blockSize);
      return this._flushBuffer(e, 0), this._unpad(e);
    };
  });
  ku = T((gT, $b) => {
    var Zb = ar(), J7 = Ie(), Nt = Tu(), Vb = vs();
    function Q7() {
      this.tmp = new Array(2), this.keys = null;
    }
    function ei(t) {
      Vb.call(this, t);
      var e = new Q7;
      this._desState = e, this.deriveKeys(e, t.key);
    }
    J7(ei, Vb);
    $b.exports = ei;
    ei.create = function(e) {
      return new ei(e);
    };
    var e9 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
    ei.prototype.deriveKeys = function(e, r) {
      e.keys = new Array(16 * 2), Zb.equal(r.length, this.blockSize, "Invalid key length");
      var o = Nt.readUInt32BE(r, 0), f = Nt.readUInt32BE(r, 4);
      Nt.pc1(o, f, e.tmp, 0), o = e.tmp[0], f = e.tmp[1];
      for (var p = 0;p < e.keys.length; p += 2) {
        var m = e9[p >>> 1];
        o = Nt.r28shl(o, m), f = Nt.r28shl(f, m), Nt.pc2(o, f, e.keys, p);
      }
    };
    ei.prototype._update = function(e, r, o, f) {
      var p = this._desState, m = Nt.readUInt32BE(e, r), y = Nt.readUInt32BE(e, r + 4);
      Nt.ip(m, y, p.tmp, 0), m = p.tmp[0], y = p.tmp[1], this.type === "encrypt" ? this._encrypt(p, m, y, p.tmp, 0) : this._decrypt(p, m, y, p.tmp, 0), m = p.tmp[0], y = p.tmp[1], Nt.writeUInt32BE(o, m, f), Nt.writeUInt32BE(o, y, f + 4);
    };
    ei.prototype._pad = function(e, r) {
      for (var o = e.length - r, f = r;f < e.length; f++)
        e[f] = o;
      return true;
    };
    ei.prototype._unpad = function(e) {
      for (var r = e[e.length - 1], o = e.length - r;o < e.length; o++)
        Zb.equal(e[o], r);
      return e.slice(0, e.length - r);
    };
    ei.prototype._encrypt = function(e, r, o, f, p) {
      for (var m = r, y = o, M = 0;M < e.keys.length; M += 2) {
        var x = e.keys[M], S2 = e.keys[M + 1];
        Nt.expand(y, e.tmp, 0), x ^= e.tmp[0], S2 ^= e.tmp[1];
        var E = Nt.substitute(x, S2), B = Nt.permute(E), q = y;
        y = (m ^ B) >>> 0, m = q;
      }
      Nt.rip(y, m, f, p);
    };
    ei.prototype._decrypt = function(e, r, o, f, p) {
      for (var m = o, y = r, M = e.keys.length - 2;M >= 0; M -= 2) {
        var x = e.keys[M], S2 = e.keys[M + 1];
        Nt.expand(m, e.tmp, 0), x ^= e.tmp[0], S2 ^= e.tmp[1];
        var E = Nt.substitute(x, S2), B = Nt.permute(E), q = m;
        m = (y ^ B) >>> 0, y = q;
      }
      Nt.rip(m, y, f, p);
    };
  });
  Yb = T((Gb) => {
    var t9 = ar(), r9 = Ie(), bs = {};
    function i9(t) {
      t9.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
      for (var e = 0;e < this.iv.length; e++)
        this.iv[e] = t[e];
    }
    function n9(t) {
      function e(p) {
        t.call(this, p), this._cbcInit();
      }
      r9(e, t);
      for (var r = Object.keys(bs), o = 0;o < r.length; o++) {
        var f = r[o];
        e.prototype[f] = bs[f];
      }
      return e.create = function(m) {
        return new e(m);
      }, e;
    }
    Gb.instantiate = n9;
    bs._cbcInit = function() {
      var e = new i9(this.options.iv);
      this._cbcState = e;
    };
    bs._update = function(e, r, o, f) {
      var p = this._cbcState, m = this.constructor.super_.prototype, y = p.iv;
      if (this.type === "encrypt") {
        for (var M = 0;M < this.blockSize; M++)
          y[M] ^= e[r + M];
        m._update.call(this, y, 0, o, f);
        for (var M = 0;M < this.blockSize; M++)
          y[M] = o[f + M];
      } else {
        m._update.call(this, e, r, o, f);
        for (var M = 0;M < this.blockSize; M++)
          o[f + M] ^= y[M];
        for (var M = 0;M < this.blockSize; M++)
          y[M] = e[r + M];
      }
    };
  });
  Qb = T((wT, Jb) => {
    var f9 = ar(), a9 = Ie(), Xb = vs(), Wi = ku();
    function o9(t, e) {
      f9.equal(e.length, 24, "Invalid key length");
      var r = e.slice(0, 8), o = e.slice(8, 16), f = e.slice(16, 24);
      t === "encrypt" ? this.ciphers = [Wi.create({ type: "encrypt", key: r }), Wi.create({ type: "decrypt", key: o }), Wi.create({ type: "encrypt", key: f })] : this.ciphers = [Wi.create({ type: "decrypt", key: f }), Wi.create({ type: "encrypt", key: o }), Wi.create({ type: "decrypt", key: r })];
    }
    function An(t) {
      Xb.call(this, t);
      var e = new o9(this.type, this.options.key);
      this._edeState = e;
    }
    a9(An, Xb);
    Jb.exports = An;
    An.create = function(e) {
      return new An(e);
    };
    An.prototype._update = function(e, r, o, f) {
      var p = this._edeState;
      p.ciphers[0]._update(e, r, o, f), p.ciphers[1]._update(o, f, o, f), p.ciphers[2]._update(o, f, o, f);
    };
    An.prototype._pad = Wi.prototype._pad;
    An.prototype._unpad = Wi.prototype._unpad;
  });
  em = T((gf) => {
    gf.utils = Tu();
    gf.Cipher = vs();
    gf.DES = ku();
    gf.CBC = Yb();
    gf.EDE = Qb();
  });
  im = T((_T, rm) => {
    var tm = yi(), wi = em(), s9 = Ie(), Rn = Te().Buffer, Sa = { "des-ede3-cbc": wi.CBC.instantiate(wi.EDE), "des-ede3": wi.EDE, "des-ede-cbc": wi.CBC.instantiate(wi.EDE), "des-ede": wi.EDE, "des-cbc": wi.CBC.instantiate(wi.DES), "des-ecb": wi.DES };
    Sa.des = Sa["des-cbc"];
    Sa.des3 = Sa["des-ede3-cbc"];
    rm.exports = ms;
    s9(ms, tm);
    function ms(t) {
      tm.call(this);
      var e = t.mode.toLowerCase(), r = Sa[e], o;
      t.decrypt ? o = "decrypt" : o = "encrypt";
      var f = t.key;
      Rn.isBuffer(f) || (f = Rn.from(f)), (e === "des-ede" || e === "des-ede-cbc") && (f = Rn.concat([f, f.slice(0, 8)]));
      var p = t.iv;
      Rn.isBuffer(p) || (p = Rn.from(p)), this._des = r.create({ key: f, iv: p, type: o });
    }
    ms.prototype._update = function(t) {
      return Rn.from(this._des.update(t));
    };
    ms.prototype._final = function() {
      return Rn.from(this._des.final());
    };
  });
  nm = T((Lu) => {
    Lu.encrypt = function(t, e) {
      return t._cipher.encryptBlock(e);
    };
    Lu.decrypt = function(t, e) {
      return t._cipher.decryptBlock(e);
    };
  });
  yf = T((ST, fm) => {
    fm.exports = function(e, r) {
      for (var o = Math.min(e.length, r.length), f = new Buffer(o), p = 0;p < o; ++p)
        f[p] = e[p] ^ r[p];
      return f;
    };
  });
  om = T((Nu) => {
    var am = yf();
    Nu.encrypt = function(t, e) {
      var r = am(e, t._prev);
      return t._prev = t._cipher.encryptBlock(r), t._prev;
    };
    Nu.decrypt = function(t, e) {
      var r = t._prev;
      t._prev = e;
      var o = t._cipher.decryptBlock(e);
      return am(o, r);
    };
  });
  um = T((hm) => {
    var Ea = Te().Buffer, h9 = yf();
    function sm(t, e, r) {
      var o = e.length, f = h9(e, t._cache);
      return t._cache = t._cache.slice(o), t._prev = Ea.concat([t._prev, r ? e : f]), f;
    }
    hm.encrypt = function(t, e, r) {
      for (var o = Ea.allocUnsafe(0), f;e.length; )
        if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = Ea.allocUnsafe(0)), t._cache.length <= e.length)
          f = t._cache.length, o = Ea.concat([o, sm(t, e.slice(0, f), r)]), e = e.slice(f);
        else {
          o = Ea.concat([o, sm(t, e, r)]);
          break;
        }
      return o;
    };
  });
  dm = T((lm) => {
    var Du = Te().Buffer;
    function u9(t, e, r) {
      var o = t._cipher.encryptBlock(t._prev), f = o[0] ^ e;
      return t._prev = Du.concat([t._prev.slice(1), Du.from([r ? e : f])]), f;
    }
    lm.encrypt = function(t, e, r) {
      for (var o = e.length, f = Du.allocUnsafe(o), p = -1;++p < o; )
        f[p] = u9(t, e[p], r);
      return f;
    };
  });
  pm = T((cm) => {
    var gs = Te().Buffer;
    function l9(t, e, r) {
      for (var o, f = -1, p = 8, m = 0, y, M;++f < p; )
        o = t._cipher.encryptBlock(t._prev), y = e & 1 << 7 - f ? 128 : 0, M = o[0] ^ y, m += (M & 128) >> f % 8, t._prev = d9(t._prev, r ? y : M);
      return m;
    }
    function d9(t, e) {
      var r = t.length, o = -1, f = gs.allocUnsafe(t.length);
      for (t = gs.concat([t, gs.from([e])]);++o < r; )
        f[o] = t[o] << 1 | t[o + 1] >> 7;
      return f;
    }
    cm.encrypt = function(t, e, r) {
      for (var o = e.length, f = gs.allocUnsafe(o), p = -1;++p < o; )
        f[p] = l9(t, e[p], r);
      return f;
    };
  });
  bm = T((vm) => {
    var c9 = yf();
    function p9(t) {
      return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
    }
    vm.encrypt = function(t, e) {
      for (;t._cache.length < e.length; )
        t._cache = Buffer.concat([t._cache, p9(t)]);
      var r = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), c9(e, r);
    };
  });
  Pu = T((IT, mm) => {
    function v9(t) {
      for (var e = t.length, r;e--; )
        if (r = t.readUInt8(e), r === 255)
          t.writeUInt8(0, e);
        else {
          r++, t.writeUInt8(r, e);
          break;
        }
    }
    mm.exports = v9;
  });
  Ou = T((ym) => {
    var b9 = yf(), gm = Te().Buffer, m9 = Pu();
    function g9(t) {
      var e = t._cipher.encryptBlockRaw(t._prev);
      return m9(t._prev), e;
    }
    var Cu = 16;
    ym.encrypt = function(t, e) {
      var r = Math.ceil(e.length / Cu), o = t._cache.length;
      t._cache = gm.concat([t._cache, gm.allocUnsafe(r * Cu)]);
      for (var f = 0;f < r; f++) {
        var p = g9(t), m = o + f * Cu;
        t._cache.writeUInt32BE(p[0], m + 0), t._cache.writeUInt32BE(p[1], m + 4), t._cache.writeUInt32BE(p[2], m + 8), t._cache.writeUInt32BE(p[3], m + 12);
      }
      var y = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), b9(e, y);
    };
  });
  Fu = T((kT, y9) => {
    y9.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
  });
  ws = T((LT, wm) => {
    var w9 = { ECB: nm(), CBC: om(), CFB: um(), CFB8: dm(), CFB1: pm(), OFB: bm(), CTR: Ou(), GCM: Ou() }, ys = Fu();
    for (Uu in ys)
      ys[Uu].module = w9[ys[Uu].mode];
    var Uu;
    wm.exports = ys;
  });
  Aa = T((NT, _m) => {
    var Ms = Te().Buffer;
    function Hu(t) {
      Ms.isBuffer(t) || (t = Ms.from(t));
      for (var e = t.length / 4 | 0, r = new Array(e), o = 0;o < e; o++)
        r[o] = t.readUInt32BE(o * 4);
      return r;
    }
    function zu(t) {
      for (var e = 0;e < t.length; t++)
        t[e] = 0;
    }
    function Mm(t, e, r, o, f) {
      for (var p = r[0], m = r[1], y = r[2], M = r[3], x = t[0] ^ e[0], S2 = t[1] ^ e[1], E = t[2] ^ e[2], B = t[3] ^ e[3], q, L, ge, _e, N = 4, we = 1;we < f; we++)
        q = p[x >>> 24] ^ m[S2 >>> 16 & 255] ^ y[E >>> 8 & 255] ^ M[B & 255] ^ e[N++], L = p[S2 >>> 24] ^ m[E >>> 16 & 255] ^ y[B >>> 8 & 255] ^ M[x & 255] ^ e[N++], ge = p[E >>> 24] ^ m[B >>> 16 & 255] ^ y[x >>> 8 & 255] ^ M[S2 & 255] ^ e[N++], _e = p[B >>> 24] ^ m[x >>> 16 & 255] ^ y[S2 >>> 8 & 255] ^ M[E & 255] ^ e[N++], x = q, S2 = L, E = ge, B = _e;
      return q = (o[x >>> 24] << 24 | o[S2 >>> 16 & 255] << 16 | o[E >>> 8 & 255] << 8 | o[B & 255]) ^ e[N++], L = (o[S2 >>> 24] << 24 | o[E >>> 16 & 255] << 16 | o[B >>> 8 & 255] << 8 | o[x & 255]) ^ e[N++], ge = (o[E >>> 24] << 24 | o[B >>> 16 & 255] << 16 | o[x >>> 8 & 255] << 8 | o[S2 & 255]) ^ e[N++], _e = (o[B >>> 24] << 24 | o[x >>> 16 & 255] << 16 | o[S2 >>> 8 & 255] << 8 | o[E & 255]) ^ e[N++], q = q >>> 0, L = L >>> 0, ge = ge >>> 0, _e = _e >>> 0, [q, L, ge, _e];
    }
    var M9 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], kt = function() {
      for (var t = new Array(256), e = 0;e < 256; e++)
        e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
      for (var r = [], o = [], f = [[], [], [], []], p = [[], [], [], []], m = 0, y = 0, M = 0;M < 256; ++M) {
        var x = y ^ y << 1 ^ y << 2 ^ y << 3 ^ y << 4;
        x = x >>> 8 ^ x & 255 ^ 99, r[m] = x, o[x] = m;
        var S2 = t[m], E = t[S2], B = t[E], q = t[x] * 257 ^ x * 16843008;
        f[0][m] = q << 24 | q >>> 8, f[1][m] = q << 16 | q >>> 16, f[2][m] = q << 8 | q >>> 24, f[3][m] = q, q = B * 16843009 ^ E * 65537 ^ S2 * 257 ^ m * 16843008, p[0][x] = q << 24 | q >>> 8, p[1][x] = q << 16 | q >>> 16, p[2][x] = q << 8 | q >>> 24, p[3][x] = q, m === 0 ? m = y = 1 : (m = S2 ^ t[t[t[B ^ S2]]], y ^= t[t[y]]);
      }
      return { SBOX: r, INV_SBOX: o, SUB_MIX: f, INV_SUB_MIX: p };
    }();
    function gr2(t) {
      this._key = Hu(t), this._reset();
    }
    gr2.blockSize = 4 * 4;
    gr2.keySize = 256 / 8;
    gr2.prototype.blockSize = gr2.blockSize;
    gr2.prototype.keySize = gr2.keySize;
    gr2.prototype._reset = function() {
      for (var t = this._key, e = t.length, r = e + 6, o = (r + 1) * 4, f = [], p = 0;p < e; p++)
        f[p] = t[p];
      for (p = e;p < o; p++) {
        var m = f[p - 1];
        p % e === 0 ? (m = m << 8 | m >>> 24, m = kt.SBOX[m >>> 24] << 24 | kt.SBOX[m >>> 16 & 255] << 16 | kt.SBOX[m >>> 8 & 255] << 8 | kt.SBOX[m & 255], m ^= M9[p / e | 0] << 24) : e > 6 && p % e === 4 && (m = kt.SBOX[m >>> 24] << 24 | kt.SBOX[m >>> 16 & 255] << 16 | kt.SBOX[m >>> 8 & 255] << 8 | kt.SBOX[m & 255]), f[p] = f[p - e] ^ m;
      }
      for (var y = [], M = 0;M < o; M++) {
        var x = o - M, S2 = f[x - (M % 4 ? 0 : 4)];
        M < 4 || x <= 4 ? y[M] = S2 : y[M] = kt.INV_SUB_MIX[0][kt.SBOX[S2 >>> 24]] ^ kt.INV_SUB_MIX[1][kt.SBOX[S2 >>> 16 & 255]] ^ kt.INV_SUB_MIX[2][kt.SBOX[S2 >>> 8 & 255]] ^ kt.INV_SUB_MIX[3][kt.SBOX[S2 & 255]];
      }
      this._nRounds = r, this._keySchedule = f, this._invKeySchedule = y;
    };
    gr2.prototype.encryptBlockRaw = function(t) {
      return t = Hu(t), Mm(t, this._keySchedule, kt.SUB_MIX, kt.SBOX, this._nRounds);
    };
    gr2.prototype.encryptBlock = function(t) {
      var e = this.encryptBlockRaw(t), r = Ms.allocUnsafe(16);
      return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r;
    };
    gr2.prototype.decryptBlock = function(t) {
      t = Hu(t);
      var e = t[1];
      t[1] = t[3], t[3] = e;
      var r = Mm(t, this._invKeySchedule, kt.INV_SUB_MIX, kt.INV_SBOX, this._nRounds), o = Ms.allocUnsafe(16);
      return o.writeUInt32BE(r[0], 0), o.writeUInt32BE(r[3], 4), o.writeUInt32BE(r[2], 8), o.writeUInt32BE(r[1], 12), o;
    };
    gr2.prototype.scrub = function() {
      zu(this._keySchedule), zu(this._invKeySchedule), zu(this._key);
    };
    _m.exports.AES = gr2;
  });
  Em = T((DT, Sm) => {
    var wf = Te().Buffer, _9 = wf.alloc(16, 0);
    function x9(t) {
      return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
    }
    function xm(t) {
      var e = wf.allocUnsafe(16);
      return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
    }
    function Ra(t) {
      this.h = t, this.state = wf.alloc(16, 0), this.cache = wf.allocUnsafe(0);
    }
    Ra.prototype.ghash = function(t) {
      for (var e = -1;++e < t.length; )
        this.state[e] ^= t[e];
      this._multiply();
    };
    Ra.prototype._multiply = function() {
      for (var t = x9(this.h), e = [0, 0, 0, 0], r, o, f, p = -1;++p < 128; ) {
        for (o = (this.state[~~(p / 8)] & 1 << 7 - p % 8) !== 0, o && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), f = (t[3] & 1) !== 0, r = 3;r > 0; r--)
          t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
        t[0] = t[0] >>> 1, f && (t[0] = t[0] ^ 225 << 24);
      }
      this.state = xm(e);
    };
    Ra.prototype.update = function(t) {
      this.cache = wf.concat([this.cache, t]);
      for (var e;this.cache.length >= 16; )
        e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
    };
    Ra.prototype.final = function(t, e) {
      return this.cache.length && this.ghash(wf.concat([this.cache, _9], 16)), this.ghash(xm([0, t, 0, e])), this.state;
    };
    Sm.exports = Ra;
  });
  Wu = T((PT, Bm) => {
    var S9 = Aa(), rr = Te().Buffer, Am = yi(), E9 = Ie(), Rm = Em(), A9 = yf(), R9 = Pu();
    function B9(t, e) {
      var r = 0;
      t.length !== e.length && r++;
      for (var o = Math.min(t.length, e.length), f = 0;f < o; ++f)
        r += t[f] ^ e[f];
      return r;
    }
    function q9(t, e, r) {
      if (e.length === 12)
        return t._finID = rr.concat([e, rr.from([0, 0, 0, 1])]), rr.concat([e, rr.from([0, 0, 0, 2])]);
      var o = new Rm(r), f = e.length, p = f % 16;
      o.update(e), p && (p = 16 - p, o.update(rr.alloc(p, 0))), o.update(rr.alloc(8, 0));
      var m = f * 8, y = rr.alloc(8);
      y.writeUIntBE(m, 0, 8), o.update(y), t._finID = o.state;
      var M = rr.from(t._finID);
      return R9(M), M;
    }
    function Bn(t, e, r, o) {
      Am.call(this);
      var f = rr.alloc(4, 0);
      this._cipher = new S9.AES(e);
      var p = this._cipher.encryptBlock(f);
      this._ghash = new Rm(p), r = q9(this, r, p), this._prev = rr.from(r), this._cache = rr.allocUnsafe(0), this._secCache = rr.allocUnsafe(0), this._decrypt = o, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
    }
    E9(Bn, Am);
    Bn.prototype._update = function(t) {
      if (!this._called && this._alen) {
        var e = 16 - this._alen % 16;
        e < 16 && (e = rr.alloc(e, 0), this._ghash.update(e));
      }
      this._called = true;
      var r = this._mode.encrypt(this, t);
      return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
    };
    Bn.prototype._final = function() {
      if (this._decrypt && !this._authTag)
        throw new Error("Unsupported state or unable to authenticate data");
      var t = A9(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt && B9(t, this._authTag))
        throw new Error("Unsupported state or unable to authenticate data");
      this._authTag = t, this._cipher.scrub();
    };
    Bn.prototype.getAuthTag = function() {
      if (this._decrypt || !rr.isBuffer(this._authTag))
        throw new Error("Attempting to get auth tag in unsupported state");
      return this._authTag;
    };
    Bn.prototype.setAuthTag = function(e) {
      if (!this._decrypt)
        throw new Error("Attempting to set auth tag in unsupported state");
      this._authTag = e;
    };
    Bn.prototype.setAAD = function(e) {
      if (this._called)
        throw new Error("Attempting to set AAD in unsupported state");
      this._ghash.update(e), this._alen += e.length;
    };
    Bm.exports = Bn;
  });
  ju = T((CT, Im) => {
    var I9 = Aa(), Ku = Te().Buffer, qm = yi(), T9 = Ie();
    function _s(t, e, r, o) {
      qm.call(this), this._cipher = new I9.AES(e), this._prev = Ku.from(r), this._cache = Ku.allocUnsafe(0), this._secCache = Ku.allocUnsafe(0), this._decrypt = o, this._mode = t;
    }
    T9(_s, qm);
    _s.prototype._update = function(t) {
      return this._mode.encrypt(this, t, this._decrypt);
    };
    _s.prototype._final = function() {
      this._cipher.scrub();
    };
    Im.exports = _s;
  });
  Ba = T((OT, Tm) => {
    var qn = Te().Buffer, k9 = Ao();
    function L9(t, e, r, o) {
      if (qn.isBuffer(t) || (t = qn.from(t, "binary")), e && (qn.isBuffer(e) || (e = qn.from(e, "binary")), e.length !== 8))
        throw new RangeError("salt should be Buffer with 8 byte length");
      for (var f = r / 8, p = qn.alloc(f), m = qn.alloc(o || 0), y = qn.alloc(0);f > 0 || o > 0; ) {
        var M = new k9;
        M.update(y), M.update(t), e && M.update(e), y = M.digest();
        var x = 0;
        if (f > 0) {
          var S2 = p.length - f;
          x = Math.min(f, y.length), y.copy(p, S2, 0, x), f -= x;
        }
        if (x < y.length && o > 0) {
          var E = m.length - o, B = Math.min(o, y.length - x);
          y.copy(m, E, x, x + B), o -= B;
        }
      }
      return y.fill(0), { key: p, iv: m };
    }
    Tm.exports = L9;
  });
  Dm = T((Zu) => {
    var km = ws(), N9 = Wu(), Mi = Te().Buffer, D9 = ju(), Lm = yi(), P9 = Aa(), C9 = Ba(), O9 = Ie();
    function qa(t, e, r) {
      Lm.call(this), this._cache = new xs, this._cipher = new P9.AES(e), this._prev = Mi.from(r), this._mode = t, this._autopadding = true;
    }
    O9(qa, Lm);
    qa.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o = [];e = this._cache.get(); )
        r = this._mode.encrypt(this, e), o.push(r);
      return Mi.concat(o);
    };
    var F9 = Mi.alloc(16, 16);
    qa.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
      if (!t.equals(F9))
        throw this._cipher.scrub(), new Error("data not multiple of block length");
    };
    qa.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function xs() {
      this.cache = Mi.allocUnsafe(0);
    }
    xs.prototype.add = function(t) {
      this.cache = Mi.concat([this.cache, t]);
    };
    xs.prototype.get = function() {
      if (this.cache.length > 15) {
        var t = this.cache.slice(0, 16);
        return this.cache = this.cache.slice(16), t;
      }
      return null;
    };
    xs.prototype.flush = function() {
      for (var t = 16 - this.cache.length, e = Mi.allocUnsafe(t), r = -1;++r < t; )
        e.writeUInt8(t, r);
      return Mi.concat([this.cache, e]);
    };
    function Nm(t, e, r) {
      var o = km[t.toLowerCase()];
      if (!o)
        throw new TypeError("invalid suite type");
      if (typeof e == "string" && (e = Mi.from(e)), e.length !== o.key / 8)
        throw new TypeError("invalid key length " + e.length);
      if (typeof r == "string" && (r = Mi.from(r)), o.mode !== "GCM" && r.length !== o.iv)
        throw new TypeError("invalid iv length " + r.length);
      return o.type === "stream" ? new D9(o.module, e, r) : o.type === "auth" ? new N9(o.module, e, r) : new qa(o.module, e, r);
    }
    function U9(t, e) {
      var r = km[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o = C9(e, false, r.key, r.iv);
      return Nm(t, o.key, o.iv);
    }
    Zu.createCipheriv = Nm;
    Zu.createCipher = U9;
  });
  Fm = T((Vu) => {
    var z9 = Wu(), Mf = Te().Buffer, Pm = ws(), H9 = ju(), Cm = yi(), W9 = Aa(), K9 = Ba(), j9 = Ie();
    function Ia(t, e, r) {
      Cm.call(this), this._cache = new Ss, this._last = undefined, this._cipher = new W9.AES(e), this._prev = Mf.from(r), this._mode = t, this._autopadding = true;
    }
    j9(Ia, Cm);
    Ia.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o = [];e = this._cache.get(this._autopadding); )
        r = this._mode.decrypt(this, e), o.push(r);
      return Mf.concat(o);
    };
    Ia.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return Z9(this._mode.decrypt(this, t));
      if (t)
        throw new Error("data not multiple of block length");
    };
    Ia.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function Ss() {
      this.cache = Mf.allocUnsafe(0);
    }
    Ss.prototype.add = function(t) {
      this.cache = Mf.concat([this.cache, t]);
    };
    Ss.prototype.get = function(t) {
      var e;
      if (t) {
        if (this.cache.length > 16)
          return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      } else if (this.cache.length >= 16)
        return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      return null;
    };
    Ss.prototype.flush = function() {
      if (this.cache.length)
        return this.cache;
    };
    function Z9(t) {
      var e = t[15];
      if (e < 1 || e > 16)
        throw new Error("unable to decrypt data");
      for (var r = -1;++r < e; )
        if (t[r + (16 - e)] !== e)
          throw new Error("unable to decrypt data");
      if (e !== 16)
        return t.slice(0, 16 - e);
    }
    function Om(t, e, r) {
      var o = Pm[t.toLowerCase()];
      if (!o)
        throw new TypeError("invalid suite type");
      if (typeof r == "string" && (r = Mf.from(r)), o.mode !== "GCM" && r.length !== o.iv)
        throw new TypeError("invalid iv length " + r.length);
      if (typeof e == "string" && (e = Mf.from(e)), e.length !== o.key / 8)
        throw new TypeError("invalid key length " + e.length);
      return o.type === "stream" ? new H9(o.module, e, r, true) : o.type === "auth" ? new z9(o.module, e, r, true) : new Ia(o.module, e, r);
    }
    function V9(t, e) {
      var r = Pm[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o = K9(e, false, r.key, r.iv);
      return Om(t, o.key, o.iv);
    }
    Vu.createDecipher = V9;
    Vu.createDecipheriv = Om;
  });
  Es = T((Nr) => {
    var Um = Dm(), zm = Fm(), $9 = Fu();
    function G9() {
      return Object.keys($9);
    }
    Nr.createCipher = Nr.Cipher = Um.createCipher;
    Nr.createCipheriv = Nr.Cipheriv = Um.createCipheriv;
    Nr.createDecipher = Nr.Decipher = zm.createDecipher;
    Nr.createDecipheriv = Nr.Decipheriv = zm.createDecipheriv;
    Nr.listCiphers = Nr.getCiphers = G9;
  });
  Hm = T((_i) => {
    _i["des-ecb"] = { key: 8, iv: 0 };
    _i["des-cbc"] = _i.des = { key: 8, iv: 8 };
    _i["des-ede3-cbc"] = _i.des3 = { key: 24, iv: 8 };
    _i["des-ede3"] = { key: 24, iv: 0 };
    _i["des-ede-cbc"] = { key: 16, iv: 8 };
    _i["des-ede"] = { key: 16, iv: 0 };
  });
  Vm = T((Dr) => {
    var Wm = im(), $u = Es(), Ki = ws(), xi = Hm(), Km = Ba();
    function Y9(t, e) {
      t = t.toLowerCase();
      var r, o;
      if (Ki[t])
        r = Ki[t].key, o = Ki[t].iv;
      else if (xi[t])
        r = xi[t].key * 8, o = xi[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f = Km(e, false, r, o);
      return jm(t, f.key, f.iv);
    }
    function X9(t, e) {
      t = t.toLowerCase();
      var r, o;
      if (Ki[t])
        r = Ki[t].key, o = Ki[t].iv;
      else if (xi[t])
        r = xi[t].key * 8, o = xi[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f = Km(e, false, r, o);
      return Zm(t, f.key, f.iv);
    }
    function jm(t, e, r) {
      if (t = t.toLowerCase(), Ki[t])
        return $u.createCipheriv(t, e, r);
      if (xi[t])
        return new Wm({ key: e, iv: r, mode: t });
      throw new TypeError("invalid suite type");
    }
    function Zm(t, e, r) {
      if (t = t.toLowerCase(), Ki[t])
        return $u.createDecipheriv(t, e, r);
      if (xi[t])
        return new Wm({ key: e, iv: r, mode: t, decrypt: true });
      throw new TypeError("invalid suite type");
    }
    function J9() {
      return Object.keys(xi).concat($u.getCiphers());
    }
    Dr.createCipher = Dr.Cipher = Y9;
    Dr.createCipheriv = Dr.Cipheriv = jm;
    Dr.createDecipher = Dr.Decipher = X9;
    Dr.createDecipheriv = Dr.Decipheriv = Zm;
    Dr.listCiphers = Dr.getCiphers = J9;
  });
  ji = T(() => {
  });
  Yu = T(($m, Gu) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o(v2, i) {
        v2.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v2.prototype = new a, v2.prototype.constructor = v2;
      }
      function f(v2, i, a) {
        if (f.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v2 || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b2 = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        return this.strip();
      };
      function m(v2, i) {
        var a = v2.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v2, i, a) {
        var h = m(v2, a);
        return a - 1 >= i && (h |= m(v2, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b2;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v2, i, a, h) {
        for (var s = 0, u = Math.min(v2.length, a), c = i;c < u; c++) {
          var b2 = v2.charCodeAt(c) - 48;
          s *= h, b2 >= 49 ? s += b2 - 49 + 10 : b2 >= 17 ? s += b2 - 17 + 10 : s += b2;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b2 = c % s, l = Math.min(c, c - b2) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b2 !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b2; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b2 = this.words[c], l = ((b2 << s | u) & 16777215).toString(16);
            u = b2 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b2 = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[n] = l;
          for (;n < u; n++)
            b2[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b2[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[u - n - 1] = l;
        }
        return b2;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v2) {
        for (var i = new Array(v2.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v2.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b2 = 0;b2 < u.length; b2++)
          a = (s.words[b2] | 0) - (u.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        for (;c !== 0 && b2 < s.length; b2++)
          a = (s.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        if (c === 0 && b2 < s.length && s !== this)
          for (;b2 < s.length; b2++)
            this.words[b2] = s.words[b2];
        return this.length = Math.max(this.length, b2), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a) {
        a.negative = i.negative ^ v2.negative;
        var h = v2.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v2.words[0] | 0, u = i.words[0] | 0, c = s * u, b2 = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b2;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _2 = Math.max(0, n - v2.length + 1);_2 <= g; _2++) {
            var A = n - _2 | 0;
            s = v2.words[A] | 0, u = i.words[_2] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b2 = 0, l, n, d, w = s[0] | 0, g = w & 8191, _2 = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D2 = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z2 = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $2 = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = u[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J2), n = n + Math.imul(_2, X) | 0, d = Math.imul(_2, J2);
        var ft = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J2), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J2), l = l + Math.imul(g, Q2) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_2, Q2) | 0, d = d + Math.imul(_2, ee) | 0;
        var Be = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J2), n = n + Math.imul(D2, X) | 0, d = Math.imul(D2, J2), l = l + Math.imul(R, Q2) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q2) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_2, te) | 0, d = d + Math.imul(_2, re) | 0;
        var qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J2), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J2), l = l + Math.imul(k, Q2) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D2, Q2) | 0, d = d + Math.imul(D2, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_2, ie) | 0, d = d + Math.imul(_2, ne) | 0;
        var ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J2), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J2), l = l + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q2) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D2, te) | 0, d = d + Math.imul(D2, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_2, fe) | 0, d = d + Math.imul(_2, ae) | 0;
        var He = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z2, X), n = Math.imul(z2, J2), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J2), l = l + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q2) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D2, ie) | 0, d = d + Math.imul(D2, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_2, oe) | 0, d = d + Math.imul(_2, se) | 0;
        var We = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J2), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J2), l = l + Math.imul(z2, Q2) | 0, n = n + Math.imul(z2, ee) | 0, n = n + Math.imul(H, Q2) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D2, fe) | 0, d = d + Math.imul(D2, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_2, he) | 0, d = d + Math.imul(_2, ue) | 0;
        var Ke = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J2), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J2), l = l + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q2) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z2, te) | 0, n = n + Math.imul(z2, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D2, oe) | 0, d = d + Math.imul(D2, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_2, le) | 0, d = d + Math.imul(_2, de) | 0;
        var je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J2), n = n + Math.imul($2, X) | 0, d = Math.imul($2, J2), l = l + Math.imul(j, Q2) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q2) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z2, ie) | 0, n = n + Math.imul(z2, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D2, he) | 0, d = d + Math.imul(D2, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_2, ce) | 0, d = d + Math.imul(_2, pe) | 0;
        var Ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J2), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J2), l = l + Math.imul(V, Q2) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($2, Q2) | 0, d = d + Math.imul($2, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z2, fe) | 0, n = n + Math.imul(z2, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D2, le) | 0, d = d + Math.imul(D2, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_2, ve) | 0, d = d + Math.imul(_2, be) | 0;
        var Ve = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q2), n = Math.imul(G, ee), n = n + Math.imul(Y, Q2) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($2, te) | 0, d = d + Math.imul($2, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z2, oe) | 0, n = n + Math.imul(z2, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D2, ce) | 0, d = d + Math.imul(D2, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($2, ie) | 0, d = d + Math.imul($2, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z2, he) | 0, n = n + Math.imul(z2, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D2, ve) | 0, d = d + Math.imul(D2, be) | 0;
        var Ge = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($2, fe) | 0, d = d + Math.imul($2, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z2, le) | 0, n = n + Math.imul(z2, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($2, oe) | 0, d = d + Math.imul($2, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z2, ce) | 0, n = n + Math.imul(z2, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($2, he) | 0, d = d + Math.imul($2, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z2, ve) | 0, n = n + Math.imul(z2, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($2, le) | 0, d = d + Math.imul($2, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($2, ce) | 0, d = d + Math.imul($2, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($2, ve) | 0, d = d + Math.imul($2, be) | 0;
        var tt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        return b2 = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b2 !== 0 && (c[19] = b2, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v2, i, a) {
        a.negative = i.negative ^ v2.negative, a.length = v2.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b2 = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v2.length + 1);n <= l; n++) {
            var d = u - n, w = v2.words[d] | 0, g = i.words[n] | 0, _2 = w * g, A = _2 & 67108863;
            c = c + (_2 / 67108864 | 0) | 0, A = A + b2 | 0, b2 = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b2, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v2, i, a) {
        var h = new N;
        return h.mulp(v2, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v2, i) {
        this.x = v2, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b2 = 0;b2 < c; b2++)
          s[b2] = a[i[b2]], u[b2] = h[i[b2]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b2 = 1;b2 < u; b2 <<= 1)
          for (var l = b2 << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _2 = d, A = 0;A < b2; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b2], k = s[w + A + b2], D2 = g * Me - _2 * k;
              k = g * k + _2 * Me, Me = D2, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b2] = R - Me, s[w + A + b2] = I - k, A !== l && (D2 = n * g - d * _2, _2 = n * _2 + d * g, g = D2);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b2 = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _2 = h.words;
        _2.length = s, this.convert13b(i.words, i.length, b2, s), this.convert13b(a.words, a.length, d, s), this.transform(b2, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _2, c, s, u), this.conjugate(_2, c, s), this.normalize13b(_2, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b2 = this.words[u] & s, l = (this.words[u] | 0) - b2 << a;
            this.words[u] = l | c, c = b2 >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b2 = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b2;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b2 = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b2;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b2 = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b2, b2 = c >> 26, this.words[u + h] = c & 67108863;
        if (b2 === 0)
          return this.strip();
        for (r(b2 === -1), b2 = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b2, b2 = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b2 = this._countBits(c);
        h = 26 - b2, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _2 = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_2 = Math.min(_2 / c | 0, 67108863), s._ishlnsubmul(u, _2, g);s.negative !== 0; )
            _2--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _2);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b2 = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _2 = 0, A = 1;(h.words[0] & A) === 0 && _2 < 26; ++_2, A <<= 1)
            ;
          if (_2 > 0)
            for (h.iushrn(_2);_2-- > 0; )
              (c.isOdd() || b2.isOdd()) && (c.iadd(n), b2.isub(d)), c.iushrn(1), b2.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b2)) : (h.isub(a), c.isub(s), b2.isub(u));
        }
        return { a: c, b: b2, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b2 = 0, l = 1;(a.words[0] & l) === 0 && b2 < 26; ++b2, l <<= 1)
            ;
          if (b2 > 0)
            for (a.iushrn(b2);b2-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b2 = this.words[c] | 0;
          b2 += u, u = b2 >>> 26, b2 &= 67108863, this.words[c] = b2;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v2, i) {
        this.name = v2, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b2 = i.words[u] | 0;
          i.words[u - 10] = (b2 & h) << 4 | c >>> 22, c = b2;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v2) {
        if (typeof v2 == "string") {
          var i = f._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b2 = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b2) !== 0; )
          n.redIAdd(b2);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _2 = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _2);
          var I = this.pow(d, new f(1).iushln(_2 - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _2 = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b2 = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b2 === 0) {
              l = 0;
              continue;
            }
            b2 <<= 1, b2 |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b2]), l = 0, b2 = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v2) {
        P.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Gu > "u" || Gu, $m);
  });
  Ym = T((Gm, Xu) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o(v2, i) {
        v2.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v2.prototype = new a, v2.prototype.constructor = v2;
      }
      function f(v2, i, a) {
        if (f.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v2 || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b2 = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        return this.strip();
      };
      function m(v2, i) {
        var a = v2.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v2, i, a) {
        var h = m(v2, a);
        return a - 1 >= i && (h |= m(v2, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b2;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v2, i, a, h) {
        for (var s = 0, u = Math.min(v2.length, a), c = i;c < u; c++) {
          var b2 = v2.charCodeAt(c) - 48;
          s *= h, b2 >= 49 ? s += b2 - 49 + 10 : b2 >= 17 ? s += b2 - 17 + 10 : s += b2;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b2 = c % s, l = Math.min(c, c - b2) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b2 !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b2; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b2 = this.words[c], l = ((b2 << s | u) & 16777215).toString(16);
            u = b2 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b2 = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[n] = l;
          for (;n < u; n++)
            b2[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b2[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[u - n - 1] = l;
        }
        return b2;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v2) {
        for (var i = new Array(v2.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v2.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b2 = 0;b2 < u.length; b2++)
          a = (s.words[b2] | 0) - (u.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        for (;c !== 0 && b2 < s.length; b2++)
          a = (s.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        if (c === 0 && b2 < s.length && s !== this)
          for (;b2 < s.length; b2++)
            this.words[b2] = s.words[b2];
        return this.length = Math.max(this.length, b2), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a) {
        a.negative = i.negative ^ v2.negative;
        var h = v2.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v2.words[0] | 0, u = i.words[0] | 0, c = s * u, b2 = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b2;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _2 = Math.max(0, n - v2.length + 1);_2 <= g; _2++) {
            var A = n - _2 | 0;
            s = v2.words[A] | 0, u = i.words[_2] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b2 = 0, l, n, d, w = s[0] | 0, g = w & 8191, _2 = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D2 = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z2 = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $2 = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = u[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J2), n = n + Math.imul(_2, X) | 0, d = Math.imul(_2, J2);
        var ft = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J2), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J2), l = l + Math.imul(g, Q2) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_2, Q2) | 0, d = d + Math.imul(_2, ee) | 0;
        var Be = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J2), n = n + Math.imul(D2, X) | 0, d = Math.imul(D2, J2), l = l + Math.imul(R, Q2) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q2) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_2, te) | 0, d = d + Math.imul(_2, re) | 0;
        var qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J2), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J2), l = l + Math.imul(k, Q2) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D2, Q2) | 0, d = d + Math.imul(D2, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_2, ie) | 0, d = d + Math.imul(_2, ne) | 0;
        var ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J2), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J2), l = l + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q2) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D2, te) | 0, d = d + Math.imul(D2, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_2, fe) | 0, d = d + Math.imul(_2, ae) | 0;
        var He = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z2, X), n = Math.imul(z2, J2), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J2), l = l + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q2) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D2, ie) | 0, d = d + Math.imul(D2, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_2, oe) | 0, d = d + Math.imul(_2, se) | 0;
        var We = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J2), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J2), l = l + Math.imul(z2, Q2) | 0, n = n + Math.imul(z2, ee) | 0, n = n + Math.imul(H, Q2) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D2, fe) | 0, d = d + Math.imul(D2, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_2, he) | 0, d = d + Math.imul(_2, ue) | 0;
        var Ke = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J2), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J2), l = l + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q2) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z2, te) | 0, n = n + Math.imul(z2, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D2, oe) | 0, d = d + Math.imul(D2, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_2, le) | 0, d = d + Math.imul(_2, de) | 0;
        var je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J2), n = n + Math.imul($2, X) | 0, d = Math.imul($2, J2), l = l + Math.imul(j, Q2) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q2) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z2, ie) | 0, n = n + Math.imul(z2, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D2, he) | 0, d = d + Math.imul(D2, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_2, ce) | 0, d = d + Math.imul(_2, pe) | 0;
        var Ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J2), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J2), l = l + Math.imul(V, Q2) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($2, Q2) | 0, d = d + Math.imul($2, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z2, fe) | 0, n = n + Math.imul(z2, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D2, le) | 0, d = d + Math.imul(D2, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_2, ve) | 0, d = d + Math.imul(_2, be) | 0;
        var Ve = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q2), n = Math.imul(G, ee), n = n + Math.imul(Y, Q2) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($2, te) | 0, d = d + Math.imul($2, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z2, oe) | 0, n = n + Math.imul(z2, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D2, ce) | 0, d = d + Math.imul(D2, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($2, ie) | 0, d = d + Math.imul($2, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z2, he) | 0, n = n + Math.imul(z2, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D2, ve) | 0, d = d + Math.imul(D2, be) | 0;
        var Ge = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($2, fe) | 0, d = d + Math.imul($2, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z2, le) | 0, n = n + Math.imul(z2, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($2, oe) | 0, d = d + Math.imul($2, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z2, ce) | 0, n = n + Math.imul(z2, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($2, he) | 0, d = d + Math.imul($2, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z2, ve) | 0, n = n + Math.imul(z2, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($2, le) | 0, d = d + Math.imul($2, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($2, ce) | 0, d = d + Math.imul($2, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($2, ve) | 0, d = d + Math.imul($2, be) | 0;
        var tt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        return b2 = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b2 !== 0 && (c[19] = b2, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v2, i, a) {
        a.negative = i.negative ^ v2.negative, a.length = v2.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b2 = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v2.length + 1);n <= l; n++) {
            var d = u - n, w = v2.words[d] | 0, g = i.words[n] | 0, _2 = w * g, A = _2 & 67108863;
            c = c + (_2 / 67108864 | 0) | 0, A = A + b2 | 0, b2 = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b2, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v2, i, a) {
        var h = new N;
        return h.mulp(v2, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v2, i) {
        this.x = v2, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b2 = 0;b2 < c; b2++)
          s[b2] = a[i[b2]], u[b2] = h[i[b2]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b2 = 1;b2 < u; b2 <<= 1)
          for (var l = b2 << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _2 = d, A = 0;A < b2; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b2], k = s[w + A + b2], D2 = g * Me - _2 * k;
              k = g * k + _2 * Me, Me = D2, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b2] = R - Me, s[w + A + b2] = I - k, A !== l && (D2 = n * g - d * _2, _2 = n * _2 + d * g, g = D2);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b2 = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _2 = h.words;
        _2.length = s, this.convert13b(i.words, i.length, b2, s), this.convert13b(a.words, a.length, d, s), this.transform(b2, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _2, c, s, u), this.conjugate(_2, c, s), this.normalize13b(_2, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b2 = this.words[u] & s, l = (this.words[u] | 0) - b2 << a;
            this.words[u] = l | c, c = b2 >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b2 = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b2;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b2 = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b2;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b2 = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b2, b2 = c >> 26, this.words[u + h] = c & 67108863;
        if (b2 === 0)
          return this.strip();
        for (r(b2 === -1), b2 = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b2, b2 = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b2 = this._countBits(c);
        h = 26 - b2, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _2 = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_2 = Math.min(_2 / c | 0, 67108863), s._ishlnsubmul(u, _2, g);s.negative !== 0; )
            _2--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _2);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b2 = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _2 = 0, A = 1;(h.words[0] & A) === 0 && _2 < 26; ++_2, A <<= 1)
            ;
          if (_2 > 0)
            for (h.iushrn(_2);_2-- > 0; )
              (c.isOdd() || b2.isOdd()) && (c.iadd(n), b2.isub(d)), c.iushrn(1), b2.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b2)) : (h.isub(a), c.isub(s), b2.isub(u));
        }
        return { a: c, b: b2, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b2 = 0, l = 1;(a.words[0] & l) === 0 && b2 < 26; ++b2, l <<= 1)
            ;
          if (b2 > 0)
            for (a.iushrn(b2);b2-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b2 = this.words[c] | 0;
          b2 += u, u = b2 >>> 26, b2 &= 67108863, this.words[c] = b2;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v2, i) {
        this.name = v2, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b2 = i.words[u] | 0;
          i.words[u - 10] = (b2 & h) << 4 | c >>> 22, c = b2;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v2) {
        if (typeof v2 == "string") {
          var i = f._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b2 = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b2) !== 0; )
          n.redIAdd(b2);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _2 = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _2);
          var I = this.pow(d, new f(1).iushln(_2 - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _2 = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b2 = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b2 === 0) {
              l = 0;
              continue;
            }
            b2 <<= 1, b2 |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b2]), l = 0, b2 = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v2) {
        P.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Xu > "u" || Xu, Gm);
  });
  Xm = T(() => {
  });
  As = T(($T, el) => {
    var Ju;
    el.exports = function(e) {
      return Ju || (Ju = new Zi(null)), Ju.generate(e);
    };
    function Zi(t) {
      this.rand = t;
    }
    el.exports.Rand = Zi;
    Zi.prototype.generate = function(e) {
      return this._rand(e);
    };
    Zi.prototype._rand = function(e) {
      if (this.rand.getBytes)
        return this.rand.getBytes(e);
      for (var r = new Uint8Array(e), o = 0;o < r.length; o++)
        r[o] = this.rand.getByte();
      return r;
    };
    if (typeof self == "object")
      self.crypto && self.crypto.getRandomValues ? Zi.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.crypto.getRandomValues(r), r;
      } : self.msCrypto && self.msCrypto.getRandomValues ? Zi.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.msCrypto.getRandomValues(r), r;
      } : typeof window == "object" && (Zi.prototype._rand = function() {
        throw new Error("Not implemented yet");
      });
    else
      try {
        if (Qu = Xm(), typeof Qu.randomBytes != "function")
          throw new Error("Not supported");
        Zi.prototype._rand = function(e) {
          return Qu.randomBytes(e);
        };
      } catch {
      }
    var Qu;
  });
  tl = T((GT, Jm) => {
    var In = Ym(), Q9 = As();
    function Tn(t) {
      this.rand = t || new Q9.Rand;
    }
    Jm.exports = Tn;
    Tn.create = function(e) {
      return new Tn(e);
    };
    Tn.prototype._randbelow = function(e) {
      var r = e.bitLength(), o = Math.ceil(r / 8);
      do
        var f = new In(this.rand.generate(o));
      while (f.cmp(e) >= 0);
      return f;
    };
    Tn.prototype._randrange = function(e, r) {
      var o = r.sub(e);
      return e.add(this._randbelow(o));
    };
    Tn.prototype.test = function(e, r, o) {
      var f = e.bitLength(), p = In.mont(e), m = new In(1).toRed(p);
      r || (r = Math.max(1, f / 48 | 0));
      for (var y = e.subn(1), M = 0;!y.testn(M); M++)
        ;
      for (var x = e.shrn(M), S2 = y.toRed(p), E = true;r > 0; r--) {
        var B = this._randrange(new In(2), y);
        o && o(B);
        var q = B.toRed(p).redPow(x);
        if (!(q.cmp(m) === 0 || q.cmp(S2) === 0)) {
          for (var L = 1;L < M; L++) {
            if (q = q.redSqr(), q.cmp(m) === 0)
              return false;
            if (q.cmp(S2) === 0)
              break;
          }
          if (L === M)
            return false;
        }
      }
      return E;
    };
    Tn.prototype.getDivisor = function(e, r) {
      var o = e.bitLength(), f = In.mont(e), p = new In(1).toRed(f);
      r || (r = Math.max(1, o / 48 | 0));
      for (var m = e.subn(1), y = 0;!m.testn(y); y++)
        ;
      for (var M = e.shrn(y), x = m.toRed(f);r > 0; r--) {
        var S2 = this._randrange(new In(2), m), E = e.gcd(S2);
        if (E.cmpn(1) !== 0)
          return E;
        var B = S2.toRed(f).redPow(M);
        if (!(B.cmp(p) === 0 || B.cmp(x) === 0)) {
          for (var q = 1;q < y; q++) {
            if (B = B.redSqr(), B.cmp(p) === 0)
              return B.fromRed().subn(1).gcd(e);
            if (B.cmp(x) === 0)
              break;
          }
          if (q === y)
            return B = B.redSqr(), B.fromRed().subn(1).gcd(e);
        }
      }
      return false;
    };
  });
  ol = T((ek, tg) => {
    var eS = on();
    tg.exports = al;
    al.simpleSieve = nl;
    al.fermatTest = fl;
    var Ht = Yu(), tS = new Ht(24), rS = tl(), Qm = new rS, iS = new Ht(1), il = new Ht(2), nS = new Ht(5), YT = new Ht(16), XT = new Ht(8), fS = new Ht(10), aS = new Ht(3), JT = new Ht(7), oS = new Ht(11), eg = new Ht(4), QT = new Ht(12), rl = null;
    function sS() {
      if (rl !== null)
        return rl;
      var t = 1048576, e = [];
      e[0] = 2;
      for (var r = 1, o = 3;o < t; o += 2) {
        for (var f = Math.ceil(Math.sqrt(o)), p = 0;p < r && e[p] <= f && o % e[p] !== 0; p++)
          ;
        r !== p && e[p] <= f || (e[r++] = o);
      }
      return rl = e, e;
    }
    function nl(t) {
      for (var e = sS(), r = 0;r < e.length; r++)
        if (t.modn(e[r]) === 0)
          return t.cmpn(e[r]) === 0;
      return true;
    }
    function fl(t) {
      var e = Ht.mont(t);
      return il.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
    }
    function al(t, e) {
      if (t < 16)
        return e === 2 || e === 5 ? new Ht([140, 123]) : new Ht([140, 39]);
      e = new Ht(e);
      for (var r, o;; ) {
        for (r = new Ht(eS(Math.ceil(t / 8)));r.bitLength() > t; )
          r.ishrn(1);
        if (r.isEven() && r.iadd(iS), r.testn(1) || r.iadd(il), e.cmp(il)) {
          if (!e.cmp(nS))
            for (;r.mod(fS).cmp(aS); )
              r.iadd(eg);
        } else
          for (;r.mod(tS).cmp(oS); )
            r.iadd(eg);
        if (o = r.shrn(1), nl(o) && nl(r) && fl(o) && fl(r) && Qm.test(o) && Qm.test(r))
          return r;
      }
    }
  });
  rg = T((tk, hS) => {
    hS.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
  });
  ag = T((rk, fg) => {
    var yr = Yu(), uS = tl(), ig = new uS, lS = new yr(24), dS = new yr(11), cS = new yr(10), pS = new yr(3), vS = new yr(7), ng = ol(), bS = on();
    fg.exports = Si;
    function mS(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._pub = new yr(t), this;
    }
    function gS(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._priv = new yr(t), this;
    }
    var Rs = {};
    function yS(t, e) {
      var r = e.toString("hex"), o = [r, t.toString(16)].join("_");
      if (o in Rs)
        return Rs[o];
      var f = 0;
      if (t.isEven() || !ng.simpleSieve || !ng.fermatTest(t) || !ig.test(t))
        return f += 1, r === "02" || r === "05" ? f += 8 : f += 4, Rs[o] = f, f;
      ig.test(t.shrn(1)) || (f += 2);
      var p;
      switch (r) {
        case "02":
          t.mod(lS).cmp(dS) && (f += 8);
          break;
        case "05":
          p = t.mod(cS), p.cmp(pS) && p.cmp(vS) && (f += 8);
          break;
        default:
          f += 4;
      }
      return Rs[o] = f, f;
    }
    function Si(t, e, r) {
      this.setGenerator(e), this.__prime = new yr(t), this._prime = yr.mont(this.__prime), this._primeLen = t.length, this._pub = undefined, this._priv = undefined, this._primeCode = undefined, r ? (this.setPublicKey = mS, this.setPrivateKey = gS) : this._primeCode = 8;
    }
    Object.defineProperty(Si.prototype, "verifyError", { enumerable: true, get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = yS(this.__prime, this.__gen)), this._primeCode;
    } });
    Si.prototype.generateKeys = function() {
      return this._priv || (this._priv = new yr(bS(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    };
    Si.prototype.computeSecret = function(t) {
      t = new yr(t), t = t.toRed(this._prime);
      var e = t.redPow(this._priv).fromRed(), r = new Buffer(e.toArray()), o = this.getPrime();
      if (r.length < o.length) {
        var f = new Buffer(o.length - r.length);
        f.fill(0), r = Buffer.concat([f, r]);
      }
      return r;
    };
    Si.prototype.getPublicKey = function(e) {
      return Bs(this._pub, e);
    };
    Si.prototype.getPrivateKey = function(e) {
      return Bs(this._priv, e);
    };
    Si.prototype.getPrime = function(t) {
      return Bs(this.__prime, t);
    };
    Si.prototype.getGenerator = function(t) {
      return Bs(this._gen, t);
    };
    Si.prototype.setGenerator = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.__gen = t, this._gen = new yr(t), this;
    };
    function Bs(t, e) {
      var r = new Buffer(t.toArray());
      return e ? r.toString(e) : r;
    }
  });
  hg = T((_f) => {
    var wS = ol(), og = rg(), sl = ag();
    function MS(t) {
      var e = new Buffer(og[t].prime, "hex"), r = new Buffer(og[t].gen, "hex");
      return new sl(e, r);
    }
    var _S = { binary: true, hex: true, base64: true };
    function sg(t, e, r, o) {
      return Buffer.isBuffer(e) || _S[e] === undefined ? sg(t, "binary", e, r) : (e = e || "binary", o = o || "binary", r = r || new Buffer([2]), Buffer.isBuffer(r) || (r = new Buffer(r, o)), typeof t == "number" ? new sl(wS(t, r), r, true) : (Buffer.isBuffer(t) || (t = new Buffer(t, e)), new sl(t, r, true)));
    }
    _f.DiffieHellmanGroup = _f.createDiffieHellmanGroup = _f.getDiffieHellman = MS;
    _f.createDiffieHellman = _f.DiffieHellman = sg;
  });
  hl = T((nk, ug) => {
    ug.exports = ki().EventEmitter;
  });
  pg = T((fk, cg) => {
    function lg(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(t);
        e && (o = o.filter(function(f) {
          return Object.getOwnPropertyDescriptor(t, f).enumerable;
        })), r.push.apply(r, o);
      }
      return r;
    }
    function xS(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? lg(Object(r), true).forEach(function(o) {
          SS(t, o, r[o]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lg(Object(r)).forEach(function(o) {
          Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(r, o));
        });
      }
      return t;
    }
    function SS(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function ES(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function dg(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o = e[r];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
      }
    }
    function AS(t, e, r) {
      return e && dg(t.prototype, e), r && dg(t, r), t;
    }
    var RS = Ut(), qs = RS.Buffer, BS = $f(), ul = BS.inspect, qS = ul && ul.custom || "inspect";
    function IS(t, e, r) {
      qs.prototype.copy.call(t, e, r);
    }
    cg.exports = function() {
      function t() {
        ES(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return AS(t, [{ key: "push", value: function(r) {
        var o = { data: r, next: null };
        this.length > 0 ? this.tail.next = o : this.head = o, this.tail = o, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o = { data: r, next: this.head };
        this.length === 0 && (this.tail = o), this.head = o, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o = this.head, f = "" + o.data;o = o.next; )
          f += r + o.data;
        return f;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return qs.alloc(0);
        for (var o = qs.allocUnsafe(r >>> 0), f = this.head, p = 0;f; )
          IS(f.data, o, p), p += f.data.length, f = f.next;
        return o;
      } }, { key: "consume", value: function(r, o) {
        var f;
        return r < this.head.data.length ? (f = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f = this.shift() : f = o ? this._getString(r) : this._getBuffer(r), f;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o = this.head, f = 1, p = o.data;
        for (r -= p.length;o = o.next; ) {
          var m = o.data, y = r > m.length ? m.length : r;
          if (y === m.length ? p += m : p += m.slice(0, r), r -= y, r === 0) {
            y === m.length ? (++f, o.next ? this.head = o.next : this.head = this.tail = null) : (this.head = o, o.data = m.slice(y));
            break;
          }
          ++f;
        }
        return this.length -= f, p;
      } }, { key: "_getBuffer", value: function(r) {
        var o = qs.allocUnsafe(r), f = this.head, p = 1;
        for (f.data.copy(o), r -= f.data.length;f = f.next; ) {
          var m = f.data, y = r > m.length ? m.length : r;
          if (m.copy(o, o.length - r, 0, y), r -= y, r === 0) {
            y === m.length ? (++p, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = m.slice(y));
            break;
          }
          ++p;
        }
        return this.length -= p, o;
      } }, { key: qS, value: function(r, o) {
        return ul(this, xS({}, o, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  dl = T((ak, bg) => {
    function TS(t, e) {
      var r = this, o = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
      return o || f ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(ll, this, t)) : process.nextTick(ll, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p) {
        !e && p ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Is, r) : (r._writableState.errorEmitted = true, process.nextTick(vg, r, p)) : process.nextTick(vg, r, p) : e ? (process.nextTick(Is, r), e(p)) : process.nextTick(Is, r);
      }), this);
    }
    function vg(t, e) {
      ll(t, e), Is(t);
    }
    function Is(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function kS() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function ll(t, e) {
      t.emit("error", e);
    }
    function LS(t, e) {
      var { _readableState: r, _writableState: o } = t;
      r && r.autoDestroy || o && o.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    bg.exports = { destroy: TS, undestroy: kS, errorOrDestroy: LS };
  });
  kn = T((ok, yg) => {
    function NS(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var gg = {};
    function wr(t, e, r) {
      r || (r = Error);
      function o(p, m, y) {
        return typeof e == "string" ? e : e(p, m, y);
      }
      var f = function(p) {
        NS(m, p);
        function m(y, M, x) {
          return p.call(this, o(y, M, x)) || this;
        }
        return m;
      }(r);
      f.prototype.name = r.name, f.prototype.code = t, gg[t] = f;
    }
    function mg(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o) {
          return String(o);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function DS(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function PS(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function CS(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    wr("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    wr("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o;
      typeof e == "string" && DS(e, "not ") ? (o = "must not be", e = e.replace(/^not /, "")) : o = "must be";
      var f;
      if (PS(t, " argument"))
        f = "The ".concat(t, " ").concat(o, " ").concat(mg(e, "type"));
      else {
        var p = CS(t, ".") ? "property" : "argument";
        f = 'The "'.concat(t, '" ').concat(p, " ").concat(o, " ").concat(mg(e, "type"));
      }
      return f += ". Received type ".concat(typeof r), f;
    }, TypeError);
    wr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    wr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    wr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    wr("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    wr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    wr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    wr("ERR_STREAM_WRITE_AFTER_END", "write after end");
    wr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    wr("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    wr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yg.exports.codes = gg;
  });
  cl = T((sk, wg) => {
    var OS = kn().codes.ERR_INVALID_OPT_VALUE;
    function FS(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function US(t, e, r, o) {
      var f = FS(e, o, r);
      if (f != null) {
        if (!(isFinite(f) && Math.floor(f) === f) || f < 0) {
          var p = o ? r : "highWaterMark";
          throw new OS(p, f);
        }
        return Math.floor(f);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wg.exports = { getHighWaterMark: US };
  });
  bl = T((hk, Ag) => {
    Ag.exports = ut;
    function _g(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        cE(e, t);
      };
    }
    var xf;
    ut.WritableState = ka;
    var zS = { deprecate: G0() }, xg = hl(), ks = Ut().Buffer, HS = global.Uint8Array || function() {
    };
    function WS(t) {
      return ks.from(t);
    }
    function KS(t) {
      return ks.isBuffer(t) || t instanceof HS;
    }
    var vl = dl(), jS = cl(), ZS = jS.getHighWaterMark, Vi = kn().codes, VS = Vi.ERR_INVALID_ARG_TYPE, $S = Vi.ERR_METHOD_NOT_IMPLEMENTED, GS = Vi.ERR_MULTIPLE_CALLBACK, YS = Vi.ERR_STREAM_CANNOT_PIPE, XS = Vi.ERR_STREAM_DESTROYED, JS = Vi.ERR_STREAM_NULL_VALUES, QS = Vi.ERR_STREAM_WRITE_AFTER_END, eE = Vi.ERR_UNKNOWN_ENCODING, Sf = vl.errorOrDestroy;
    Ie()(ut, xg);
    function tE() {
    }
    function ka(t, e, r) {
      xf = xf || Ln(), t = t || {}, typeof r != "boolean" && (r = e instanceof xf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = ZS(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o = t.decodeStrings === false;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f) {
        sE(e, f);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new _g(this);
    }
    ka.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(ka.prototype, "buffer", { get: zS.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var Ts;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ts = Function.prototype[Symbol.hasInstance], Object.defineProperty(ut, Symbol.hasInstance, { value: function(e) {
      return Ts.call(this, e) ? true : this !== ut ? false : e && e._writableState instanceof ka;
    } })) : Ts = function(e) {
      return e instanceof this;
    };
    function ut(t) {
      xf = xf || Ln();
      var e = this instanceof xf;
      if (!e && !Ts.call(ut, this))
        return new ut(t);
      this._writableState = new ka(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), xg.call(this);
    }
    ut.prototype.pipe = function() {
      Sf(this, new YS);
    };
    function rE(t, e) {
      var r = new QS;
      Sf(t, r), process.nextTick(e, r);
    }
    function iE(t, e, r, o) {
      var f;
      return r === null ? f = new JS : typeof r != "string" && !e.objectMode && (f = new VS("chunk", ["string", "Buffer"], r)), f ? (Sf(t, f), process.nextTick(o, f), false) : true;
    }
    ut.prototype.write = function(t, e, r) {
      var o = this._writableState, f = false, p = !o.objectMode && KS(t);
      return p && !ks.isBuffer(t) && (t = WS(t)), typeof e == "function" && (r = e, e = null), p ? e = "buffer" : e || (e = o.defaultEncoding), typeof r != "function" && (r = tE), o.ending ? rE(this, r) : (p || iE(this, o, t, r)) && (o.pendingcb++, f = fE(this, o, p, t, e, r)), f;
    };
    ut.prototype.cork = function() {
      this._writableState.corked++;
    };
    ut.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Sg(this, t));
    };
    ut.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new eE(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ut.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function nE(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ks.from(e, r)), e;
    }
    Object.defineProperty(ut.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function fE(t, e, r, o, f, p) {
      if (!r) {
        var m = nE(e, o, f);
        o !== m && (r = true, f = "buffer", o = m);
      }
      var y = e.objectMode ? 1 : o.length;
      e.length += y;
      var M = e.length < e.highWaterMark;
      if (M || (e.needDrain = true), e.writing || e.corked) {
        var x = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o, encoding: f, isBuf: r, callback: p, next: null }, x ? x.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        pl(t, e, false, y, o, f, p);
      return M;
    }
    function pl(t, e, r, o, f, p, m) {
      e.writelen = o, e.writecb = m, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new XS("write")) : r ? t._writev(f, e.onwrite) : t._write(f, p, e.onwrite), e.sync = false;
    }
    function aE(t, e, r, o, f) {
      --e.pendingcb, r ? (process.nextTick(f, o), process.nextTick(Ta, t, e), t._writableState.errorEmitted = true, Sf(t, o)) : (f(o), t._writableState.errorEmitted = true, Sf(t, o), Ta(t, e));
    }
    function oE(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function sE(t, e) {
      var r = t._writableState, o = r.sync, f = r.writecb;
      if (typeof f != "function")
        throw new GS;
      if (oE(r), e)
        aE(t, r, o, e, f);
      else {
        var p = Eg(r) || t.destroyed;
        !p && !r.corked && !r.bufferProcessing && r.bufferedRequest && Sg(t, r), o ? process.nextTick(Mg, t, r, p, f) : Mg(t, r, p, f);
      }
    }
    function Mg(t, e, r, o) {
      r || hE(t, e), e.pendingcb--, o(), Ta(t, e);
    }
    function hE(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Sg(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o = e.bufferedRequestCount, f = new Array(o), p = e.corkedRequestsFree;
        p.entry = r;
        for (var m = 0, y = true;r; )
          f[m] = r, r.isBuf || (y = false), r = r.next, m += 1;
        f.allBuffers = y, pl(t, e, true, e.length, f, "", p.finish), e.pendingcb++, e.lastBufferedRequest = null, p.next ? (e.corkedRequestsFree = p.next, p.next = null) : e.corkedRequestsFree = new _g(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M, encoding: x, callback: S2 } = r, E = e.objectMode ? 1 : M.length;
          if (pl(t, e, false, E, M, x, S2), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ut.prototype._write = function(t, e, r) {
      r(new $S("_write()"));
    };
    ut.prototype._writev = null;
    ut.prototype.end = function(t, e, r) {
      var o = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o.corked && (o.corked = 1, this.uncork()), o.ending || dE(this, o, r), this;
    };
    Object.defineProperty(ut.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Eg(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function uE(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && Sf(t, r), e.prefinished = true, t.emit("prefinish"), Ta(t, e);
      });
    }
    function lE(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(uE, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Ta(t, e) {
      var r = Eg(e);
      if (r && (lE(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o = t._readableState;
        (!o || o.autoDestroy && o.endEmitted) && t.destroy();
      }
      return r;
    }
    function dE(t, e, r) {
      e.ending = true, Ta(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function cE(t, e, r) {
      var o = t.entry;
      for (t.entry = null;o; ) {
        var f = o.callback;
        e.pendingcb--, f(r), o = o.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ut.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ut.prototype.destroy = vl.destroy;
    ut.prototype._undestroy = vl.undestroy;
    ut.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  Ln = T((uk, Bg) => {
    var pE = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    Bg.exports = ti;
    var Rg = yl(), gl = bl();
    Ie()(ti, Rg);
    for (ml = pE(gl.prototype), Ls = 0;Ls < ml.length; Ls++)
      Ns = ml[Ls], ti.prototype[Ns] || (ti.prototype[Ns] = gl.prototype[Ns]);
    var ml, Ns, Ls;
    function ti(t) {
      if (!(this instanceof ti))
        return new ti(t);
      Rg.call(this, t), gl.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", vE)));
    }
    Object.defineProperty(ti.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty(ti.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty(ti.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function vE() {
      this._writableState.ended || process.nextTick(bE, this);
    }
    function bE(t) {
      t.end();
    }
    Object.defineProperty(ti.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  Ds = T((lk, Tg) => {
    var qg = kn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function mE(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o = new Array(r), f = 0;f < r; f++)
            o[f] = arguments[f];
          t.apply(this, o);
        }
      };
    }
    function gE() {
    }
    function yE(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Ig(t, e, r) {
      if (typeof e == "function")
        return Ig(t, null, e);
      e || (e = {}), r = mE(r || gE);
      var o = e.readable || e.readable !== false && t.readable, f = e.writable || e.writable !== false && t.writable, p = function() {
        t.writable || y();
      }, m = t._writableState && t._writableState.finished, y = function() {
        f = false, m = true, o || r.call(t);
      }, M = t._readableState && t._readableState.endEmitted, x = function() {
        o = false, M = true, f || r.call(t);
      }, S2 = function(L) {
        r.call(t, L);
      }, E = function() {
        var L;
        if (o && !M)
          return (!t._readableState || !t._readableState.ended) && (L = new qg), r.call(t, L);
        if (f && !m)
          return (!t._writableState || !t._writableState.ended) && (L = new qg), r.call(t, L);
      }, B = function() {
        t.req.on("finish", y);
      };
      return yE(t) ? (t.on("complete", y), t.on("abort", E), t.req ? B() : t.on("request", B)) : f && !t._writableState && (t.on("end", p), t.on("close", p)), t.on("end", x), t.on("finish", y), e.error !== false && t.on("error", S2), t.on("close", E), function() {
        t.removeListener("complete", y), t.removeListener("abort", E), t.removeListener("request", B), t.req && t.req.removeListener("finish", y), t.removeListener("end", p), t.removeListener("close", p), t.removeListener("finish", y), t.removeListener("end", x), t.removeListener("error", S2), t.removeListener("close", E);
      };
    }
    Tg.exports = Ig;
  });
  Lg = T((dk, kg) => {
    var Ps;
    function $i(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    var wE = Ds(), Gi = Symbol("lastResolve"), Nn = Symbol("lastReject"), La = Symbol("error"), Cs = Symbol("ended"), Dn = Symbol("lastPromise"), wl = Symbol("handlePromise"), Pn = Symbol("stream");
    function Yi(t, e) {
      return { value: t, done: e };
    }
    function ME(t) {
      var e = t[Gi];
      if (e !== null) {
        var r = t[Pn].read();
        r !== null && (t[Dn] = null, t[Gi] = null, t[Nn] = null, e(Yi(r, false)));
      }
    }
    function _E(t) {
      process.nextTick(ME, t);
    }
    function xE(t, e) {
      return function(r, o) {
        t.then(function() {
          if (e[Cs]) {
            r(Yi(undefined, true));
            return;
          }
          e[wl](r, o);
        }, o);
      };
    }
    var SE = Object.getPrototypeOf(function() {
    }), EE = Object.setPrototypeOf((Ps = { get stream() {
      return this[Pn];
    }, next: function() {
      var e = this, r = this[La];
      if (r !== null)
        return Promise.reject(r);
      if (this[Cs])
        return Promise.resolve(Yi(undefined, true));
      if (this[Pn].destroyed)
        return new Promise(function(m, y) {
          process.nextTick(function() {
            e[La] ? y(e[La]) : m(Yi(undefined, true));
          });
        });
      var o = this[Dn], f;
      if (o)
        f = new Promise(xE(o, this));
      else {
        var p = this[Pn].read();
        if (p !== null)
          return Promise.resolve(Yi(p, false));
        f = new Promise(this[wl]);
      }
      return this[Dn] = f, f;
    } }, $i(Ps, Symbol.asyncIterator, function() {
      return this;
    }), $i(Ps, "return", function() {
      var e = this;
      return new Promise(function(r, o) {
        e[Pn].destroy(null, function(f) {
          if (f) {
            o(f);
            return;
          }
          r(Yi(undefined, true));
        });
      });
    }), Ps), SE), AE = function(e) {
      var r, o = Object.create(EE, (r = {}, $i(r, Pn, { value: e, writable: true }), $i(r, Gi, { value: null, writable: true }), $i(r, Nn, { value: null, writable: true }), $i(r, La, { value: null, writable: true }), $i(r, Cs, { value: e._readableState.endEmitted, writable: true }), $i(r, wl, { value: function(p, m) {
        var y = o[Pn].read();
        y ? (o[Dn] = null, o[Gi] = null, o[Nn] = null, p(Yi(y, false))) : (o[Gi] = p, o[Nn] = m);
      }, writable: true }), r));
      return o[Dn] = null, wE(e, function(f) {
        if (f && f.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p = o[Nn];
          p !== null && (o[Dn] = null, o[Gi] = null, o[Nn] = null, p(f)), o[La] = f;
          return;
        }
        var m = o[Gi];
        m !== null && (o[Dn] = null, o[Gi] = null, o[Nn] = null, m(Yi(undefined, true))), o[Cs] = true;
      }), e.on("readable", _E.bind(null, o)), o;
    };
    kg.exports = AE;
  });
  Dg = T((ck, Ng) => {
    Ng.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  yl = T((vk, jg) => {
    jg.exports = Oe;
    var Ef;
    Oe.ReadableState = Fg;
    var pk = ki().EventEmitter, Og = function(e, r) {
      return e.listeners(r).length;
    }, Da = hl(), Os = Ut().Buffer, RE = global.Uint8Array || function() {
    };
    function BE(t) {
      return Os.from(t);
    }
    function qE(t) {
      return Os.isBuffer(t) || t instanceof RE;
    }
    var Ml = $f(), De;
    Ml && Ml.debuglog ? De = Ml.debuglog("stream") : De = function() {
    };
    var IE = pg(), Bl = dl(), TE = cl(), kE = TE.getHighWaterMark, Fs = kn().codes, LE = Fs.ERR_INVALID_ARG_TYPE, NE = Fs.ERR_STREAM_PUSH_AFTER_EOF, DE = Fs.ERR_METHOD_NOT_IMPLEMENTED, PE = Fs.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Af, _l, xl;
    Ie()(Oe, Da);
    var Na = Bl.errorOrDestroy, Sl = ["error", "close", "destroy", "pause", "resume"];
    function CE(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function Fg(t, e, r) {
      Ef = Ef || Ln(), t = t || {}, typeof r != "boolean" && (r = e instanceof Ef), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = kE(this, t, "readableHighWaterMark", r), this.buffer = new IE, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (Af || (Af = (Qf(), ur(Jf)).StringDecoder), this.decoder = new Af(t.encoding), this.encoding = t.encoding);
    }
    function Oe(t) {
      if (Ef = Ef || Ln(), !(this instanceof Oe))
        return new Oe(t);
      var e = this instanceof Ef;
      this._readableState = new Fg(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), Da.call(this);
    }
    Object.defineProperty(Oe.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Oe.prototype.destroy = Bl.destroy;
    Oe.prototype._undestroy = Bl.undestroy;
    Oe.prototype._destroy = function(t, e) {
      e(t);
    };
    Oe.prototype.push = function(t, e) {
      var r = this._readableState, o;
      return r.objectMode ? o = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = Os.from(t, e), e = ""), o = true), Ug(this, t, e, false, o);
    };
    Oe.prototype.unshift = function(t) {
      return Ug(this, t, null, true, false);
    };
    function Ug(t, e, r, o, f) {
      De("readableAddChunk", e);
      var p = t._readableState;
      if (e === null)
        p.reading = false, UE(t, p);
      else {
        var m;
        if (f || (m = OE(p, e)), m)
          Na(t, m);
        else if (p.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p.objectMode && Object.getPrototypeOf(e) !== Os.prototype && (e = BE(e)), o)
            p.endEmitted ? Na(t, new PE) : El(t, p, e, true);
          else if (p.ended)
            Na(t, new NE);
          else {
            if (p.destroyed)
              return false;
            p.reading = false, p.decoder && !r ? (e = p.decoder.write(e), p.objectMode || e.length !== 0 ? El(t, p, e, false) : Rl(t, p)) : El(t, p, e, false);
          }
        else
          o || (p.reading = false, Rl(t, p));
      }
      return !p.ended && (p.length < p.highWaterMark || p.length === 0);
    }
    function El(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Us(t)), Rl(t, e);
    }
    function OE(t, e) {
      var r;
      return !qE(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new LE("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Oe.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Oe.prototype.setEncoding = function(t) {
      Af || (Af = (Qf(), ur(Jf)).StringDecoder);
      var e = new Af(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o = "";r !== null; )
        o += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o !== "" && this._readableState.buffer.push(o), this._readableState.length = o.length, this;
    };
    var Pg = 1073741824;
    function FE(t) {
      return t >= Pg ? t = Pg : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Cg(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = FE(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Oe.prototype.read = function(t) {
      De("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return De("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Al(this) : Us(this), null;
      if (t = Cg(t, e), t === 0 && e.ended)
        return e.length === 0 && Al(this), null;
      var o = e.needReadable;
      De("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, De("length less than watermark", o)), e.ended || e.reading ? (o = false, De("reading or ended", o)) : o && (De("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Cg(r, e)));
      var f;
      return t > 0 ? f = Wg(t, e) : f = null, f === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Al(this)), f !== null && this.emit("data", f), f;
    };
    function UE(t, e) {
      if (De("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? Us(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, zg(t)));
      }
    }
    function Us(t) {
      var e = t._readableState;
      De("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (De("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(zg, t));
    }
    function zg(t) {
      var e = t._readableState;
      De("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ql(t);
    }
    function Rl(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(zE, t, e));
    }
    function zE(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (De("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Oe.prototype._read = function(t) {
      Na(this, new DE("_read()"));
    };
    Oe.prototype.pipe = function(t, e) {
      var r = this, o = this._readableState;
      switch (o.pipesCount) {
        case 0:
          o.pipes = t;
          break;
        case 1:
          o.pipes = [o.pipes, t];
          break;
        default:
          o.pipes.push(t);
          break;
      }
      o.pipesCount += 1, De("pipe count=%d opts=%j", o.pipesCount, e);
      var f = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p = f ? y : ge;
      o.endEmitted ? process.nextTick(p) : r.once("end", p), t.on("unpipe", m);
      function m(_e, N) {
        De("onunpipe"), _e === r && N && N.hasUnpiped === false && (N.hasUnpiped = true, S2());
      }
      function y() {
        De("onend"), t.end();
      }
      var M = HE(r);
      t.on("drain", M);
      var x = false;
      function S2() {
        De("cleanup"), t.removeListener("close", q), t.removeListener("finish", L), t.removeListener("drain", M), t.removeListener("error", B), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", ge), r.removeListener("data", E), x = true, o.awaitDrain && (!t._writableState || t._writableState.needDrain) && M();
      }
      r.on("data", E);
      function E(_e) {
        De("ondata");
        var N = t.write(_e);
        De("dest.write", N), N === false && ((o.pipesCount === 1 && o.pipes === t || o.pipesCount > 1 && Kg(o.pipes, t) !== -1) && !x && (De("false write response, pause", o.awaitDrain), o.awaitDrain++), r.pause());
      }
      function B(_e) {
        De("onerror", _e), ge(), t.removeListener("error", B), Og(t, "error") === 0 && Na(t, _e);
      }
      CE(t, "error", B);
      function q() {
        t.removeListener("finish", L), ge();
      }
      t.once("close", q);
      function L() {
        De("onfinish"), t.removeListener("close", q), ge();
      }
      t.once("finish", L);
      function ge() {
        De("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o.flowing || (De("pipe resume"), r.resume()), t;
    };
    function HE(t) {
      return function() {
        var r = t._readableState;
        De("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && Og(t, "data") && (r.flowing = true, ql(t));
      };
    }
    Oe.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o, pipesCount: f } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p = 0;p < f; p++)
          o[p].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m = Kg(e.pipes, t);
      return m === -1 ? this : (e.pipes.splice(m, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Oe.prototype.on = function(t, e) {
      var r = Da.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, De("on readable", o.length, o.reading), o.length ? Us(this) : o.reading || process.nextTick(WE, this)), r;
    };
    Oe.prototype.addListener = Oe.prototype.on;
    Oe.prototype.removeListener = function(t, e) {
      var r = Da.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(Hg, this), r;
    };
    Oe.prototype.removeAllListeners = function(t) {
      var e = Da.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(Hg, this), e;
    };
    function Hg(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function WE(t) {
      De("readable nexttick read 0"), t.read(0);
    }
    Oe.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (De("resume"), t.flowing = !t.readableListening, KE(this, t)), t.paused = false, this;
    };
    function KE(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(jE, t, e));
    }
    function jE(t, e) {
      De("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ql(t), e.flowing && !e.reading && t.read(0);
    }
    Oe.prototype.pause = function() {
      return De("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (De("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ql(t) {
      var e = t._readableState;
      for (De("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Oe.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o = false;
      t.on("end", function() {
        if (De("wrapped end"), r.decoder && !r.ended) {
          var m = r.decoder.end();
          m && m.length && e.push(m);
        }
        e.push(null);
      }), t.on("data", function(m) {
        if (De("wrapped data"), r.decoder && (m = r.decoder.write(m)), !(r.objectMode && m == null) && !(!r.objectMode && (!m || !m.length))) {
          var y = e.push(m);
          y || (o = true, t.pause());
        }
      });
      for (var f in t)
        this[f] === undefined && typeof t[f] == "function" && (this[f] = function(y) {
          return function() {
            return t[y].apply(t, arguments);
          };
        }(f));
      for (var p = 0;p < Sl.length; p++)
        t.on(Sl[p], this.emit.bind(this, Sl[p]));
      return this._read = function(m) {
        De("wrapped _read", m), o && (o = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Oe.prototype[Symbol.asyncIterator] = function() {
      return _l === undefined && (_l = Lg()), _l(this);
    });
    Object.defineProperty(Oe.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Oe.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Oe.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Oe._fromList = Wg;
    Object.defineProperty(Oe.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Wg(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Al(t) {
      var e = t._readableState;
      De("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(ZE, e, t));
    }
    function ZE(t, e) {
      if (De("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Oe.from = function(t, e) {
      return xl === undefined && (xl = Dg()), xl(Oe, t, e);
    });
    function Kg(t, e) {
      for (var r = 0, o = t.length;r < o; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  Il = T((bk, Vg) => {
    Vg.exports = Ei;
    var zs = kn().codes, VE = zs.ERR_METHOD_NOT_IMPLEMENTED, $E = zs.ERR_MULTIPLE_CALLBACK, GE = zs.ERR_TRANSFORM_ALREADY_TRANSFORMING, YE = zs.ERR_TRANSFORM_WITH_LENGTH_0, Hs = Ln();
    Ie()(Ei, Hs);
    function XE(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o = r.writecb;
      if (o === null)
        return this.emit("error", new $E);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o(t);
      var f = this._readableState;
      f.reading = false, (f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
    }
    function Ei(t) {
      if (!(this instanceof Ei))
        return new Ei(t);
      Hs.call(this, t), this._transformState = { afterTransform: XE.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", JE);
    }
    function JE() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        Zg(t, e, r);
      }) : Zg(this, null, null);
    }
    Ei.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, Hs.prototype.push.call(this, t, e);
    };
    Ei.prototype._transform = function(t, e, r) {
      r(new VE("_transform()"));
    };
    Ei.prototype._write = function(t, e, r) {
      var o = this._transformState;
      if (o.writecb = r, o.writechunk = t, o.writeencoding = e, !o.transforming) {
        var f = this._readableState;
        (o.needTransform || f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
      }
    };
    Ei.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    Ei.prototype._destroy = function(t, e) {
      Hs.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function Zg(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new YE;
      if (t._transformState.transforming)
        throw new GE;
      return t.push(null);
    }
  });
  Yg = T((mk, Gg) => {
    Gg.exports = Pa;
    var $g = Il();
    Ie()(Pa, $g);
    function Pa(t) {
      if (!(this instanceof Pa))
        return new Pa(t);
      $g.call(this, t);
    }
    Pa.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  t2 = T((gk, e2) => {
    var Tl;
    function QE(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var Qg = kn().codes, eA = Qg.ERR_MISSING_ARGS, tA = Qg.ERR_STREAM_DESTROYED;
    function Xg(t) {
      if (t)
        throw t;
    }
    function rA(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function iA(t, e, r, o) {
      o = QE(o);
      var f = false;
      t.on("close", function() {
        f = true;
      }), Tl === undefined && (Tl = Ds()), Tl(t, { readable: e, writable: r }, function(m) {
        if (m)
          return o(m);
        f = true, o();
      });
      var p = false;
      return function(m) {
        if (!f && !p) {
          if (p = true, rA(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o(m || new tA("pipe"));
        }
      };
    }
    function Jg(t) {
      t();
    }
    function nA(t, e) {
      return t.pipe(e);
    }
    function fA(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? Xg : t.pop();
    }
    function aA() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o = fA(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new eA("streams");
      var f, p = e.map(function(m, y) {
        var M = y < e.length - 1, x = y > 0;
        return iA(m, M, x, function(S2) {
          f || (f = S2), S2 && p.forEach(Jg), !M && (p.forEach(Jg), o(f));
        });
      });
      return e.reduce(nA);
    }
    e2.exports = aA;
  });
  i2 = T((Mr, r2) => {
    Mr = r2.exports = yl();
    Mr.Stream = Mr;
    Mr.Readable = Mr;
    Mr.Writable = bl();
    Mr.Duplex = Ln();
    Mr.Transform = Il();
    Mr.PassThrough = Yg();
    Mr.finished = Ds();
    Mr.pipeline = t2();
  });
  Ws = T((n2, kl) => {
    (function(t, e) {
      function r(h, s) {
        if (!h)
          throw new Error(s || "Assertion failed");
      }
      function o(h, s) {
        h.super_ = s;
        var u = function() {
        };
        u.prototype = s.prototype, h.prototype = new u, h.prototype.constructor = h;
      }
      function f(h, s, u) {
        if (f.isBN(h))
          return h;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, h !== null && ((s === "le" || s === "be") && (u = s, s = 10), this._init(h || 0, s || 10, u || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(s) {
        return s instanceof f ? true : s !== null && typeof s == "object" && s.constructor.wordSize === f.wordSize && Array.isArray(s.words);
      }, f.max = function(s, u) {
        return s.cmp(u) > 0 ? s : u;
      }, f.min = function(s, u) {
        return s.cmp(u) < 0 ? s : u;
      }, f.prototype._init = function(s, u, c) {
        if (typeof s == "number")
          return this._initNumber(s, u, c);
        if (typeof s == "object")
          return this._initArray(s, u, c);
        u === "hex" && (u = 16), r(u === (u | 0) && u >= 2 && u <= 36), s = s.toString().replace(/\s+/g, "");
        var b2 = 0;
        s[0] === "-" && (b2++, this.negative = 1), b2 < s.length && (u === 16 ? this._parseHex(s, b2, c) : (this._parseBase(s, u, b2), c === "le" && this._initArray(this.toArray(), u, c)));
      }, f.prototype._initNumber = function(s, u, c) {
        s < 0 && (this.negative = 1, s = -s), s < 67108864 ? (this.words = [s & 67108863], this.length = 1) : s < 4503599627370496 ? (this.words = [s & 67108863, s / 67108864 & 67108863], this.length = 2) : (r(s < 9007199254740992), this.words = [s & 67108863, s / 67108864 & 67108863, 1], this.length = 3), c === "le" && this._initArray(this.toArray(), u, c);
      }, f.prototype._initArray = function(s, u, c) {
        if (r(typeof s.length == "number"), s.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(s.length / 3), this.words = new Array(this.length);
        for (var b2 = 0;b2 < this.length; b2++)
          this.words[b2] = 0;
        var l, n, d = 0;
        if (c === "be")
          for (b2 = s.length - 1, l = 0;b2 >= 0; b2 -= 3)
            n = s[b2] | s[b2 - 1] << 8 | s[b2 - 2] << 16, this.words[l] |= n << d & 67108863, this.words[l + 1] = n >>> 26 - d & 67108863, d += 24, d >= 26 && (d -= 26, l++);
        else if (c === "le")
          for (b2 = 0, l = 0;b2 < s.length; b2 += 3)
            n = s[b2] | s[b2 + 1] << 8 | s[b2 + 2] << 16, this.words[l] |= n << d & 67108863, this.words[l + 1] = n >>> 26 - d & 67108863, d += 24, d >= 26 && (d -= 26, l++);
        return this._strip();
      };
      function m(h, s) {
        var u = h.charCodeAt(s);
        if (u >= 48 && u <= 57)
          return u - 48;
        if (u >= 65 && u <= 70)
          return u - 55;
        if (u >= 97 && u <= 102)
          return u - 87;
        r(false, "Invalid character in " + h);
      }
      function y(h, s, u) {
        var c = m(h, u);
        return u - 1 >= s && (c |= m(h, u - 1) << 4), c;
      }
      f.prototype._parseHex = function(s, u, c) {
        this.length = Math.ceil((s.length - u) / 6), this.words = new Array(this.length);
        for (var b2 = 0;b2 < this.length; b2++)
          this.words[b2] = 0;
        var l = 0, n = 0, d;
        if (c === "be")
          for (b2 = s.length - 1;b2 >= u; b2 -= 2)
            d = y(s, u, b2) << l, this.words[n] |= d & 67108863, l >= 18 ? (l -= 18, n += 1, this.words[n] |= d >>> 26) : l += 8;
        else {
          var w = s.length - u;
          for (b2 = w % 2 === 0 ? u + 1 : u;b2 < s.length; b2 += 2)
            d = y(s, u, b2) << l, this.words[n] |= d & 67108863, l >= 18 ? (l -= 18, n += 1, this.words[n] |= d >>> 26) : l += 8;
        }
        this._strip();
      };
      function M(h, s, u, c) {
        for (var b2 = 0, l = 0, n = Math.min(h.length, u), d = s;d < n; d++) {
          var w = h.charCodeAt(d) - 48;
          b2 *= c, w >= 49 ? l = w - 49 + 10 : w >= 17 ? l = w - 17 + 10 : l = w, r(w >= 0 && l < c, "Invalid character"), b2 += l;
        }
        return b2;
      }
      f.prototype._parseBase = function(s, u, c) {
        this.words = [0], this.length = 1;
        for (var b2 = 0, l = 1;l <= 67108863; l *= u)
          b2++;
        b2--, l = l / u | 0;
        for (var n = s.length - c, d = n % b2, w = Math.min(n, n - d) + c, g = 0, _2 = c;_2 < w; _2 += b2)
          g = M(s, _2, _2 + b2, u), this.imuln(l), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
        if (d !== 0) {
          var A = 1;
          for (g = M(s, _2, s.length, u), _2 = 0;_2 < d; _2++)
            A *= u;
          this.imuln(A), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
        }
        this._strip();
      }, f.prototype.copy = function(s) {
        s.words = new Array(this.length);
        for (var u = 0;u < this.length; u++)
          s.words[u] = this.words[u];
        s.length = this.length, s.negative = this.negative, s.red = this.red;
      };
      function x(h, s) {
        h.words = s.words, h.length = s.length, h.negative = s.negative, h.red = s.red;
      }
      if (f.prototype._move = function(s) {
        x(s, this);
      }, f.prototype.clone = function() {
        var s = new f(null);
        return this.copy(s), s;
      }, f.prototype._expand = function(s) {
        for (;this.length < s; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype._strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          f.prototype[Symbol.for("nodejs.util.inspect.custom")] = S2;
        } catch {
          f.prototype.inspect = S2;
        }
      else
        f.prototype.inspect = S2;
      function S2() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var E = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(s, u) {
        s = s || 10, u = u | 0 || 1;
        var c;
        if (s === 16 || s === "hex") {
          c = "";
          for (var b2 = 0, l = 0, n = 0;n < this.length; n++) {
            var d = this.words[n], w = ((d << b2 | l) & 16777215).toString(16);
            l = d >>> 24 - b2 & 16777215, b2 += 2, b2 >= 26 && (b2 -= 26, n--), l !== 0 || n !== this.length - 1 ? c = E[6 - w.length] + w + c : c = w + c;
          }
          for (l !== 0 && (c = l.toString(16) + c);c.length % u !== 0; )
            c = "0" + c;
          return this.negative !== 0 && (c = "-" + c), c;
        }
        if (s === (s | 0) && s >= 2 && s <= 36) {
          var g = B[s], _2 = q[s];
          c = "";
          var A = this.clone();
          for (A.negative = 0;!A.isZero(); ) {
            var R = A.modrn(_2).toString(s);
            A = A.idivn(_2), A.isZero() ? c = R + c : c = E[g - R.length] + R + c;
          }
          for (this.isZero() && (c = "0" + c);c.length % u !== 0; )
            c = "0" + c;
          return this.negative !== 0 && (c = "-" + c), c;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var s = this.words[0];
        return this.length === 2 ? s += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? s += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -s : s;
      }, f.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, p && (f.prototype.toBuffer = function(s, u) {
        return this.toArrayLike(p, s, u);
      }), f.prototype.toArray = function(s, u) {
        return this.toArrayLike(Array, s, u);
      };
      var L = function(s, u) {
        return s.allocUnsafe ? s.allocUnsafe(u) : new s(u);
      };
      f.prototype.toArrayLike = function(s, u, c) {
        this._strip();
        var b2 = this.byteLength(), l = c || Math.max(1, b2);
        r(b2 <= l, "byte array longer than desired length"), r(l > 0, "Requested array length <= 0");
        var n = L(s, l), d = u === "le" ? "LE" : "BE";
        return this["_toArrayLike" + d](n, b2), n;
      }, f.prototype._toArrayLikeLE = function(s, u) {
        for (var c = 0, b2 = 0, l = 0, n = 0;l < this.length; l++) {
          var d = this.words[l] << n | b2;
          s[c++] = d & 255, c < s.length && (s[c++] = d >> 8 & 255), c < s.length && (s[c++] = d >> 16 & 255), n === 6 ? (c < s.length && (s[c++] = d >> 24 & 255), b2 = 0, n = 0) : (b2 = d >>> 24, n += 2);
        }
        if (c < s.length)
          for (s[c++] = b2;c < s.length; )
            s[c++] = 0;
      }, f.prototype._toArrayLikeBE = function(s, u) {
        for (var c = s.length - 1, b2 = 0, l = 0, n = 0;l < this.length; l++) {
          var d = this.words[l] << n | b2;
          s[c--] = d & 255, c >= 0 && (s[c--] = d >> 8 & 255), c >= 0 && (s[c--] = d >> 16 & 255), n === 6 ? (c >= 0 && (s[c--] = d >> 24 & 255), b2 = 0, n = 0) : (b2 = d >>> 24, n += 2);
        }
        if (c >= 0)
          for (s[c--] = b2;c >= 0; )
            s[c--] = 0;
      }, Math.clz32 ? f.prototype._countBits = function(s) {
        return 32 - Math.clz32(s);
      } : f.prototype._countBits = function(s) {
        var u = s, c = 0;
        return u >= 4096 && (c += 13, u >>>= 13), u >= 64 && (c += 7, u >>>= 7), u >= 8 && (c += 4, u >>>= 4), u >= 2 && (c += 2, u >>>= 2), c + u;
      }, f.prototype._zeroBits = function(s) {
        if (s === 0)
          return 26;
        var u = s, c = 0;
        return (u & 8191) === 0 && (c += 13, u >>>= 13), (u & 127) === 0 && (c += 7, u >>>= 7), (u & 15) === 0 && (c += 4, u >>>= 4), (u & 3) === 0 && (c += 2, u >>>= 2), (u & 1) === 0 && c++, c;
      }, f.prototype.bitLength = function() {
        var s = this.words[this.length - 1], u = this._countBits(s);
        return (this.length - 1) * 26 + u;
      };
      function ge(h) {
        for (var s = new Array(h.bitLength()), u = 0;u < s.length; u++) {
          var c = u / 26 | 0, b2 = u % 26;
          s[u] = h.words[c] >>> b2 & 1;
        }
        return s;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var s = 0, u = 0;u < this.length; u++) {
          var c = this._zeroBits(this.words[u]);
          if (s += c, c !== 26)
            break;
        }
        return s;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(s) {
        return this.negative !== 0 ? this.abs().inotn(s).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(s) {
        return this.testn(s - 1) ? this.notn(s).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(s) {
        for (;this.length < s.length; )
          this.words[this.length++] = 0;
        for (var u = 0;u < s.length; u++)
          this.words[u] = this.words[u] | s.words[u];
        return this._strip();
      }, f.prototype.ior = function(s) {
        return r((this.negative | s.negative) === 0), this.iuor(s);
      }, f.prototype.or = function(s) {
        return this.length > s.length ? this.clone().ior(s) : s.clone().ior(this);
      }, f.prototype.uor = function(s) {
        return this.length > s.length ? this.clone().iuor(s) : s.clone().iuor(this);
      }, f.prototype.iuand = function(s) {
        var u;
        this.length > s.length ? u = s : u = this;
        for (var c = 0;c < u.length; c++)
          this.words[c] = this.words[c] & s.words[c];
        return this.length = u.length, this._strip();
      }, f.prototype.iand = function(s) {
        return r((this.negative | s.negative) === 0), this.iuand(s);
      }, f.prototype.and = function(s) {
        return this.length > s.length ? this.clone().iand(s) : s.clone().iand(this);
      }, f.prototype.uand = function(s) {
        return this.length > s.length ? this.clone().iuand(s) : s.clone().iuand(this);
      }, f.prototype.iuxor = function(s) {
        var u, c;
        this.length > s.length ? (u = this, c = s) : (u = s, c = this);
        for (var b2 = 0;b2 < c.length; b2++)
          this.words[b2] = u.words[b2] ^ c.words[b2];
        if (this !== u)
          for (;b2 < u.length; b2++)
            this.words[b2] = u.words[b2];
        return this.length = u.length, this._strip();
      }, f.prototype.ixor = function(s) {
        return r((this.negative | s.negative) === 0), this.iuxor(s);
      }, f.prototype.xor = function(s) {
        return this.length > s.length ? this.clone().ixor(s) : s.clone().ixor(this);
      }, f.prototype.uxor = function(s) {
        return this.length > s.length ? this.clone().iuxor(s) : s.clone().iuxor(this);
      }, f.prototype.inotn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = Math.ceil(s / 26) | 0, c = s % 26;
        this._expand(u), c > 0 && u--;
        for (var b2 = 0;b2 < u; b2++)
          this.words[b2] = ~this.words[b2] & 67108863;
        return c > 0 && (this.words[b2] = ~this.words[b2] & 67108863 >> 26 - c), this._strip();
      }, f.prototype.notn = function(s) {
        return this.clone().inotn(s);
      }, f.prototype.setn = function(s, u) {
        r(typeof s == "number" && s >= 0);
        var c = s / 26 | 0, b2 = s % 26;
        return this._expand(c + 1), u ? this.words[c] = this.words[c] | 1 << b2 : this.words[c] = this.words[c] & ~(1 << b2), this._strip();
      }, f.prototype.iadd = function(s) {
        var u;
        if (this.negative !== 0 && s.negative === 0)
          return this.negative = 0, u = this.isub(s), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && s.negative !== 0)
          return s.negative = 0, u = this.isub(s), s.negative = 1, u._normSign();
        var c, b2;
        this.length > s.length ? (c = this, b2 = s) : (c = s, b2 = this);
        for (var l = 0, n = 0;n < b2.length; n++)
          u = (c.words[n] | 0) + (b2.words[n] | 0) + l, this.words[n] = u & 67108863, l = u >>> 26;
        for (;l !== 0 && n < c.length; n++)
          u = (c.words[n] | 0) + l, this.words[n] = u & 67108863, l = u >>> 26;
        if (this.length = c.length, l !== 0)
          this.words[this.length] = l, this.length++;
        else if (c !== this)
          for (;n < c.length; n++)
            this.words[n] = c.words[n];
        return this;
      }, f.prototype.add = function(s) {
        var u;
        return s.negative !== 0 && this.negative === 0 ? (s.negative = 0, u = this.sub(s), s.negative ^= 1, u) : s.negative === 0 && this.negative !== 0 ? (this.negative = 0, u = s.sub(this), this.negative = 1, u) : this.length > s.length ? this.clone().iadd(s) : s.clone().iadd(this);
      }, f.prototype.isub = function(s) {
        if (s.negative !== 0) {
          s.negative = 0;
          var u = this.iadd(s);
          return s.negative = 1, u._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(s), this.negative = 1, this._normSign();
        var c = this.cmp(s);
        if (c === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var b2, l;
        c > 0 ? (b2 = this, l = s) : (b2 = s, l = this);
        for (var n = 0, d = 0;d < l.length; d++)
          u = (b2.words[d] | 0) - (l.words[d] | 0) + n, n = u >> 26, this.words[d] = u & 67108863;
        for (;n !== 0 && d < b2.length; d++)
          u = (b2.words[d] | 0) + n, n = u >> 26, this.words[d] = u & 67108863;
        if (n === 0 && d < b2.length && b2 !== this)
          for (;d < b2.length; d++)
            this.words[d] = b2.words[d];
        return this.length = Math.max(this.length, d), b2 !== this && (this.negative = 1), this._strip();
      }, f.prototype.sub = function(s) {
        return this.clone().isub(s);
      };
      function _e(h, s, u) {
        u.negative = s.negative ^ h.negative;
        var c = h.length + s.length | 0;
        u.length = c, c = c - 1 | 0;
        var b2 = h.words[0] | 0, l = s.words[0] | 0, n = b2 * l, d = n & 67108863, w = n / 67108864 | 0;
        u.words[0] = d;
        for (var g = 1;g < c; g++) {
          for (var _2 = w >>> 26, A = w & 67108863, R = Math.min(g, s.length - 1), I = Math.max(0, g - h.length + 1);I <= R; I++) {
            var Me = g - I | 0;
            b2 = h.words[Me] | 0, l = s.words[I] | 0, n = b2 * l + A, _2 += n / 67108864 | 0, A = n & 67108863;
          }
          u.words[g] = A | 0, w = _2 | 0;
        }
        return w !== 0 ? u.words[g] = w | 0 : u.length--, u._strip();
      }
      var N = function(s, u, c) {
        var b2 = s.words, l = u.words, n = c.words, d = 0, w, g, _2, A = b2[0] | 0, R = A & 8191, I = A >>> 13, Me = b2[1] | 0, k = Me & 8191, D2 = Me >>> 13, nt = b2[2] | 0, C = nt & 8191, O = nt >>> 13, vt = b2[3] | 0, F = vt & 8191, U = vt >>> 13, bt = b2[4] | 0, z2 = bt & 8191, H = bt >>> 13, mt = b2[5] | 0, W = mt & 8191, K = mt >>> 13, gt = b2[6] | 0, j = gt & 8191, Z = gt >>> 13, yt = b2[7] | 0, V = yt & 8191, $2 = yt >>> 13, wt = b2[8] | 0, G = wt & 8191, Y = wt >>> 13, Mt = b2[9] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = l[0] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = l[1] | 0, te = xt & 8191, re = xt >>> 13, St = l[2] | 0, ie = St & 8191, ne = St >>> 13, Et = l[3] | 0, fe = Et & 8191, ae = Et >>> 13, At = l[4] | 0, oe = At & 8191, se = At >>> 13, Rt = l[5] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = l[6] | 0, le = Bt & 8191, de = Bt >>> 13, qt = l[7] | 0, ce = qt & 8191, pe = qt >>> 13, It = l[8] | 0, ve = It & 8191, be = It >>> 13, ft = l[9] | 0, Be = ft & 8191, qe = ft >>> 13;
        c.negative = s.negative ^ u.negative, c.length = 19, w = Math.imul(R, Q2), g = Math.imul(R, ee), g = g + Math.imul(I, Q2) | 0, _2 = Math.imul(I, ee);
        var ze = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, w = Math.imul(k, Q2), g = Math.imul(k, ee), g = g + Math.imul(D2, Q2) | 0, _2 = Math.imul(D2, ee), w = w + Math.imul(R, te) | 0, g = g + Math.imul(R, re) | 0, g = g + Math.imul(I, te) | 0, _2 = _2 + Math.imul(I, re) | 0;
        var He = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, w = Math.imul(C, Q2), g = Math.imul(C, ee), g = g + Math.imul(O, Q2) | 0, _2 = Math.imul(O, ee), w = w + Math.imul(k, te) | 0, g = g + Math.imul(k, re) | 0, g = g + Math.imul(D2, te) | 0, _2 = _2 + Math.imul(D2, re) | 0, w = w + Math.imul(R, ie) | 0, g = g + Math.imul(R, ne) | 0, g = g + Math.imul(I, ie) | 0, _2 = _2 + Math.imul(I, ne) | 0;
        var We = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, w = Math.imul(F, Q2), g = Math.imul(F, ee), g = g + Math.imul(U, Q2) | 0, _2 = Math.imul(U, ee), w = w + Math.imul(C, te) | 0, g = g + Math.imul(C, re) | 0, g = g + Math.imul(O, te) | 0, _2 = _2 + Math.imul(O, re) | 0, w = w + Math.imul(k, ie) | 0, g = g + Math.imul(k, ne) | 0, g = g + Math.imul(D2, ie) | 0, _2 = _2 + Math.imul(D2, ne) | 0, w = w + Math.imul(R, fe) | 0, g = g + Math.imul(R, ae) | 0, g = g + Math.imul(I, fe) | 0, _2 = _2 + Math.imul(I, ae) | 0;
        var Ke = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, w = Math.imul(z2, Q2), g = Math.imul(z2, ee), g = g + Math.imul(H, Q2) | 0, _2 = Math.imul(H, ee), w = w + Math.imul(F, te) | 0, g = g + Math.imul(F, re) | 0, g = g + Math.imul(U, te) | 0, _2 = _2 + Math.imul(U, re) | 0, w = w + Math.imul(C, ie) | 0, g = g + Math.imul(C, ne) | 0, g = g + Math.imul(O, ie) | 0, _2 = _2 + Math.imul(O, ne) | 0, w = w + Math.imul(k, fe) | 0, g = g + Math.imul(k, ae) | 0, g = g + Math.imul(D2, fe) | 0, _2 = _2 + Math.imul(D2, ae) | 0, w = w + Math.imul(R, oe) | 0, g = g + Math.imul(R, se) | 0, g = g + Math.imul(I, oe) | 0, _2 = _2 + Math.imul(I, se) | 0;
        var je = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, w = Math.imul(W, Q2), g = Math.imul(W, ee), g = g + Math.imul(K, Q2) | 0, _2 = Math.imul(K, ee), w = w + Math.imul(z2, te) | 0, g = g + Math.imul(z2, re) | 0, g = g + Math.imul(H, te) | 0, _2 = _2 + Math.imul(H, re) | 0, w = w + Math.imul(F, ie) | 0, g = g + Math.imul(F, ne) | 0, g = g + Math.imul(U, ie) | 0, _2 = _2 + Math.imul(U, ne) | 0, w = w + Math.imul(C, fe) | 0, g = g + Math.imul(C, ae) | 0, g = g + Math.imul(O, fe) | 0, _2 = _2 + Math.imul(O, ae) | 0, w = w + Math.imul(k, oe) | 0, g = g + Math.imul(k, se) | 0, g = g + Math.imul(D2, oe) | 0, _2 = _2 + Math.imul(D2, se) | 0, w = w + Math.imul(R, he) | 0, g = g + Math.imul(R, ue) | 0, g = g + Math.imul(I, he) | 0, _2 = _2 + Math.imul(I, ue) | 0;
        var Ze = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, w = Math.imul(j, Q2), g = Math.imul(j, ee), g = g + Math.imul(Z, Q2) | 0, _2 = Math.imul(Z, ee), w = w + Math.imul(W, te) | 0, g = g + Math.imul(W, re) | 0, g = g + Math.imul(K, te) | 0, _2 = _2 + Math.imul(K, re) | 0, w = w + Math.imul(z2, ie) | 0, g = g + Math.imul(z2, ne) | 0, g = g + Math.imul(H, ie) | 0, _2 = _2 + Math.imul(H, ne) | 0, w = w + Math.imul(F, fe) | 0, g = g + Math.imul(F, ae) | 0, g = g + Math.imul(U, fe) | 0, _2 = _2 + Math.imul(U, ae) | 0, w = w + Math.imul(C, oe) | 0, g = g + Math.imul(C, se) | 0, g = g + Math.imul(O, oe) | 0, _2 = _2 + Math.imul(O, se) | 0, w = w + Math.imul(k, he) | 0, g = g + Math.imul(k, ue) | 0, g = g + Math.imul(D2, he) | 0, _2 = _2 + Math.imul(D2, ue) | 0, w = w + Math.imul(R, le) | 0, g = g + Math.imul(R, de) | 0, g = g + Math.imul(I, le) | 0, _2 = _2 + Math.imul(I, de) | 0;
        var Ve = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, w = Math.imul(V, Q2), g = Math.imul(V, ee), g = g + Math.imul($2, Q2) | 0, _2 = Math.imul($2, ee), w = w + Math.imul(j, te) | 0, g = g + Math.imul(j, re) | 0, g = g + Math.imul(Z, te) | 0, _2 = _2 + Math.imul(Z, re) | 0, w = w + Math.imul(W, ie) | 0, g = g + Math.imul(W, ne) | 0, g = g + Math.imul(K, ie) | 0, _2 = _2 + Math.imul(K, ne) | 0, w = w + Math.imul(z2, fe) | 0, g = g + Math.imul(z2, ae) | 0, g = g + Math.imul(H, fe) | 0, _2 = _2 + Math.imul(H, ae) | 0, w = w + Math.imul(F, oe) | 0, g = g + Math.imul(F, se) | 0, g = g + Math.imul(U, oe) | 0, _2 = _2 + Math.imul(U, se) | 0, w = w + Math.imul(C, he) | 0, g = g + Math.imul(C, ue) | 0, g = g + Math.imul(O, he) | 0, _2 = _2 + Math.imul(O, ue) | 0, w = w + Math.imul(k, le) | 0, g = g + Math.imul(k, de) | 0, g = g + Math.imul(D2, le) | 0, _2 = _2 + Math.imul(D2, de) | 0, w = w + Math.imul(R, ce) | 0, g = g + Math.imul(R, pe) | 0, g = g + Math.imul(I, ce) | 0, _2 = _2 + Math.imul(I, pe) | 0;
        var $e = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, w = Math.imul(G, Q2), g = Math.imul(G, ee), g = g + Math.imul(Y, Q2) | 0, _2 = Math.imul(Y, ee), w = w + Math.imul(V, te) | 0, g = g + Math.imul(V, re) | 0, g = g + Math.imul($2, te) | 0, _2 = _2 + Math.imul($2, re) | 0, w = w + Math.imul(j, ie) | 0, g = g + Math.imul(j, ne) | 0, g = g + Math.imul(Z, ie) | 0, _2 = _2 + Math.imul(Z, ne) | 0, w = w + Math.imul(W, fe) | 0, g = g + Math.imul(W, ae) | 0, g = g + Math.imul(K, fe) | 0, _2 = _2 + Math.imul(K, ae) | 0, w = w + Math.imul(z2, oe) | 0, g = g + Math.imul(z2, se) | 0, g = g + Math.imul(H, oe) | 0, _2 = _2 + Math.imul(H, se) | 0, w = w + Math.imul(F, he) | 0, g = g + Math.imul(F, ue) | 0, g = g + Math.imul(U, he) | 0, _2 = _2 + Math.imul(U, ue) | 0, w = w + Math.imul(C, le) | 0, g = g + Math.imul(C, de) | 0, g = g + Math.imul(O, le) | 0, _2 = _2 + Math.imul(O, de) | 0, w = w + Math.imul(k, ce) | 0, g = g + Math.imul(k, pe) | 0, g = g + Math.imul(D2, ce) | 0, _2 = _2 + Math.imul(D2, pe) | 0, w = w + Math.imul(R, ve) | 0, g = g + Math.imul(R, be) | 0, g = g + Math.imul(I, ve) | 0, _2 = _2 + Math.imul(I, be) | 0;
        var Ge = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, w = Math.imul(X, Q2), g = Math.imul(X, ee), g = g + Math.imul(J2, Q2) | 0, _2 = Math.imul(J2, ee), w = w + Math.imul(G, te) | 0, g = g + Math.imul(G, re) | 0, g = g + Math.imul(Y, te) | 0, _2 = _2 + Math.imul(Y, re) | 0, w = w + Math.imul(V, ie) | 0, g = g + Math.imul(V, ne) | 0, g = g + Math.imul($2, ie) | 0, _2 = _2 + Math.imul($2, ne) | 0, w = w + Math.imul(j, fe) | 0, g = g + Math.imul(j, ae) | 0, g = g + Math.imul(Z, fe) | 0, _2 = _2 + Math.imul(Z, ae) | 0, w = w + Math.imul(W, oe) | 0, g = g + Math.imul(W, se) | 0, g = g + Math.imul(K, oe) | 0, _2 = _2 + Math.imul(K, se) | 0, w = w + Math.imul(z2, he) | 0, g = g + Math.imul(z2, ue) | 0, g = g + Math.imul(H, he) | 0, _2 = _2 + Math.imul(H, ue) | 0, w = w + Math.imul(F, le) | 0, g = g + Math.imul(F, de) | 0, g = g + Math.imul(U, le) | 0, _2 = _2 + Math.imul(U, de) | 0, w = w + Math.imul(C, ce) | 0, g = g + Math.imul(C, pe) | 0, g = g + Math.imul(O, ce) | 0, _2 = _2 + Math.imul(O, pe) | 0, w = w + Math.imul(k, ve) | 0, g = g + Math.imul(k, be) | 0, g = g + Math.imul(D2, ve) | 0, _2 = _2 + Math.imul(D2, be) | 0, w = w + Math.imul(R, Be) | 0, g = g + Math.imul(R, qe) | 0, g = g + Math.imul(I, Be) | 0, _2 = _2 + Math.imul(I, qe) | 0;
        var Ye = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, w = Math.imul(X, te), g = Math.imul(X, re), g = g + Math.imul(J2, te) | 0, _2 = Math.imul(J2, re), w = w + Math.imul(G, ie) | 0, g = g + Math.imul(G, ne) | 0, g = g + Math.imul(Y, ie) | 0, _2 = _2 + Math.imul(Y, ne) | 0, w = w + Math.imul(V, fe) | 0, g = g + Math.imul(V, ae) | 0, g = g + Math.imul($2, fe) | 0, _2 = _2 + Math.imul($2, ae) | 0, w = w + Math.imul(j, oe) | 0, g = g + Math.imul(j, se) | 0, g = g + Math.imul(Z, oe) | 0, _2 = _2 + Math.imul(Z, se) | 0, w = w + Math.imul(W, he) | 0, g = g + Math.imul(W, ue) | 0, g = g + Math.imul(K, he) | 0, _2 = _2 + Math.imul(K, ue) | 0, w = w + Math.imul(z2, le) | 0, g = g + Math.imul(z2, de) | 0, g = g + Math.imul(H, le) | 0, _2 = _2 + Math.imul(H, de) | 0, w = w + Math.imul(F, ce) | 0, g = g + Math.imul(F, pe) | 0, g = g + Math.imul(U, ce) | 0, _2 = _2 + Math.imul(U, pe) | 0, w = w + Math.imul(C, ve) | 0, g = g + Math.imul(C, be) | 0, g = g + Math.imul(O, ve) | 0, _2 = _2 + Math.imul(O, be) | 0, w = w + Math.imul(k, Be) | 0, g = g + Math.imul(k, qe) | 0, g = g + Math.imul(D2, Be) | 0, _2 = _2 + Math.imul(D2, qe) | 0;
        var Xe = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, w = Math.imul(X, ie), g = Math.imul(X, ne), g = g + Math.imul(J2, ie) | 0, _2 = Math.imul(J2, ne), w = w + Math.imul(G, fe) | 0, g = g + Math.imul(G, ae) | 0, g = g + Math.imul(Y, fe) | 0, _2 = _2 + Math.imul(Y, ae) | 0, w = w + Math.imul(V, oe) | 0, g = g + Math.imul(V, se) | 0, g = g + Math.imul($2, oe) | 0, _2 = _2 + Math.imul($2, se) | 0, w = w + Math.imul(j, he) | 0, g = g + Math.imul(j, ue) | 0, g = g + Math.imul(Z, he) | 0, _2 = _2 + Math.imul(Z, ue) | 0, w = w + Math.imul(W, le) | 0, g = g + Math.imul(W, de) | 0, g = g + Math.imul(K, le) | 0, _2 = _2 + Math.imul(K, de) | 0, w = w + Math.imul(z2, ce) | 0, g = g + Math.imul(z2, pe) | 0, g = g + Math.imul(H, ce) | 0, _2 = _2 + Math.imul(H, pe) | 0, w = w + Math.imul(F, ve) | 0, g = g + Math.imul(F, be) | 0, g = g + Math.imul(U, ve) | 0, _2 = _2 + Math.imul(U, be) | 0, w = w + Math.imul(C, Be) | 0, g = g + Math.imul(C, qe) | 0, g = g + Math.imul(O, Be) | 0, _2 = _2 + Math.imul(O, qe) | 0;
        var Je = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, w = Math.imul(X, fe), g = Math.imul(X, ae), g = g + Math.imul(J2, fe) | 0, _2 = Math.imul(J2, ae), w = w + Math.imul(G, oe) | 0, g = g + Math.imul(G, se) | 0, g = g + Math.imul(Y, oe) | 0, _2 = _2 + Math.imul(Y, se) | 0, w = w + Math.imul(V, he) | 0, g = g + Math.imul(V, ue) | 0, g = g + Math.imul($2, he) | 0, _2 = _2 + Math.imul($2, ue) | 0, w = w + Math.imul(j, le) | 0, g = g + Math.imul(j, de) | 0, g = g + Math.imul(Z, le) | 0, _2 = _2 + Math.imul(Z, de) | 0, w = w + Math.imul(W, ce) | 0, g = g + Math.imul(W, pe) | 0, g = g + Math.imul(K, ce) | 0, _2 = _2 + Math.imul(K, pe) | 0, w = w + Math.imul(z2, ve) | 0, g = g + Math.imul(z2, be) | 0, g = g + Math.imul(H, ve) | 0, _2 = _2 + Math.imul(H, be) | 0, w = w + Math.imul(F, Be) | 0, g = g + Math.imul(F, qe) | 0, g = g + Math.imul(U, Be) | 0, _2 = _2 + Math.imul(U, qe) | 0;
        var Qe = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, w = Math.imul(X, oe), g = Math.imul(X, se), g = g + Math.imul(J2, oe) | 0, _2 = Math.imul(J2, se), w = w + Math.imul(G, he) | 0, g = g + Math.imul(G, ue) | 0, g = g + Math.imul(Y, he) | 0, _2 = _2 + Math.imul(Y, ue) | 0, w = w + Math.imul(V, le) | 0, g = g + Math.imul(V, de) | 0, g = g + Math.imul($2, le) | 0, _2 = _2 + Math.imul($2, de) | 0, w = w + Math.imul(j, ce) | 0, g = g + Math.imul(j, pe) | 0, g = g + Math.imul(Z, ce) | 0, _2 = _2 + Math.imul(Z, pe) | 0, w = w + Math.imul(W, ve) | 0, g = g + Math.imul(W, be) | 0, g = g + Math.imul(K, ve) | 0, _2 = _2 + Math.imul(K, be) | 0, w = w + Math.imul(z2, Be) | 0, g = g + Math.imul(z2, qe) | 0, g = g + Math.imul(H, Be) | 0, _2 = _2 + Math.imul(H, qe) | 0;
        var et = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, w = Math.imul(X, he), g = Math.imul(X, ue), g = g + Math.imul(J2, he) | 0, _2 = Math.imul(J2, ue), w = w + Math.imul(G, le) | 0, g = g + Math.imul(G, de) | 0, g = g + Math.imul(Y, le) | 0, _2 = _2 + Math.imul(Y, de) | 0, w = w + Math.imul(V, ce) | 0, g = g + Math.imul(V, pe) | 0, g = g + Math.imul($2, ce) | 0, _2 = _2 + Math.imul($2, pe) | 0, w = w + Math.imul(j, ve) | 0, g = g + Math.imul(j, be) | 0, g = g + Math.imul(Z, ve) | 0, _2 = _2 + Math.imul(Z, be) | 0, w = w + Math.imul(W, Be) | 0, g = g + Math.imul(W, qe) | 0, g = g + Math.imul(K, Be) | 0, _2 = _2 + Math.imul(K, qe) | 0;
        var tt = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, w = Math.imul(X, le), g = Math.imul(X, de), g = g + Math.imul(J2, le) | 0, _2 = Math.imul(J2, de), w = w + Math.imul(G, ce) | 0, g = g + Math.imul(G, pe) | 0, g = g + Math.imul(Y, ce) | 0, _2 = _2 + Math.imul(Y, pe) | 0, w = w + Math.imul(V, ve) | 0, g = g + Math.imul(V, be) | 0, g = g + Math.imul($2, ve) | 0, _2 = _2 + Math.imul($2, be) | 0, w = w + Math.imul(j, Be) | 0, g = g + Math.imul(j, qe) | 0, g = g + Math.imul(Z, Be) | 0, _2 = _2 + Math.imul(Z, qe) | 0;
        var rt = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, w = Math.imul(X, ce), g = Math.imul(X, pe), g = g + Math.imul(J2, ce) | 0, _2 = Math.imul(J2, pe), w = w + Math.imul(G, ve) | 0, g = g + Math.imul(G, be) | 0, g = g + Math.imul(Y, ve) | 0, _2 = _2 + Math.imul(Y, be) | 0, w = w + Math.imul(V, Be) | 0, g = g + Math.imul(V, qe) | 0, g = g + Math.imul($2, Be) | 0, _2 = _2 + Math.imul($2, qe) | 0;
        var S0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (S0 >>> 26) | 0, S0 &= 67108863, w = Math.imul(X, ve), g = Math.imul(X, be), g = g + Math.imul(J2, ve) | 0, _2 = Math.imul(J2, be), w = w + Math.imul(G, Be) | 0, g = g + Math.imul(G, qe) | 0, g = g + Math.imul(Y, Be) | 0, _2 = _2 + Math.imul(Y, qe) | 0;
        var E0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_2 + (g >>> 13) | 0) + (E0 >>> 26) | 0, E0 &= 67108863, w = Math.imul(X, Be), g = Math.imul(X, qe), g = g + Math.imul(J2, Be) | 0, _2 = Math.imul(J2, qe);
        var A0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        return d = (_2 + (g >>> 13) | 0) + (A0 >>> 26) | 0, A0 &= 67108863, n[0] = ze, n[1] = He, n[2] = We, n[3] = Ke, n[4] = je, n[5] = Ze, n[6] = Ve, n[7] = $e, n[8] = Ge, n[9] = Ye, n[10] = Xe, n[11] = Je, n[12] = Qe, n[13] = et, n[14] = tt, n[15] = rt, n[16] = S0, n[17] = E0, n[18] = A0, d !== 0 && (n[19] = d, c.length++), c;
      };
      Math.imul || (N = _e);
      function we(h, s, u) {
        u.negative = s.negative ^ h.negative, u.length = h.length + s.length;
        for (var c = 0, b2 = 0, l = 0;l < u.length - 1; l++) {
          var n = b2;
          b2 = 0;
          for (var d = c & 67108863, w = Math.min(l, s.length - 1), g = Math.max(0, l - h.length + 1);g <= w; g++) {
            var _2 = l - g, A = h.words[_2] | 0, R = s.words[g] | 0, I = A * R, Me = I & 67108863;
            n = n + (I / 67108864 | 0) | 0, Me = Me + d | 0, d = Me & 67108863, n = n + (Me >>> 26) | 0, b2 += n >>> 26, n &= 67108863;
          }
          u.words[l] = d, c = n, n = b2;
        }
        return c !== 0 ? u.words[l] = c : u.length--, u._strip();
      }
      function ye(h, s, u) {
        return we(h, s, u);
      }
      f.prototype.mulTo = function(s, u) {
        var c, b2 = this.length + s.length;
        return this.length === 10 && s.length === 10 ? c = N(this, s, u) : b2 < 63 ? c = _e(this, s, u) : b2 < 1024 ? c = we(this, s, u) : c = ye(this, s, u), c;
      };
      function xe(h, s) {
        this.x = h, this.y = s;
      }
      xe.prototype.makeRBT = function(s) {
        for (var u = new Array(s), c = f.prototype._countBits(s) - 1, b2 = 0;b2 < s; b2++)
          u[b2] = this.revBin(b2, c, s);
        return u;
      }, xe.prototype.revBin = function(s, u, c) {
        if (s === 0 || s === c - 1)
          return s;
        for (var b2 = 0, l = 0;l < u; l++)
          b2 |= (s & 1) << u - l - 1, s >>= 1;
        return b2;
      }, xe.prototype.permute = function(s, u, c, b2, l, n) {
        for (var d = 0;d < n; d++)
          b2[d] = u[s[d]], l[d] = c[s[d]];
      }, xe.prototype.transform = function(s, u, c, b2, l, n) {
        this.permute(n, s, u, c, b2, l);
        for (var d = 1;d < l; d <<= 1)
          for (var w = d << 1, g = Math.cos(2 * Math.PI / w), _2 = Math.sin(2 * Math.PI / w), A = 0;A < l; A += w)
            for (var R = g, I = _2, Me = 0;Me < d; Me++) {
              var k = c[A + Me], D2 = b2[A + Me], nt = c[A + Me + d], C = b2[A + Me + d], O = R * nt - I * C;
              C = R * C + I * nt, nt = O, c[A + Me] = k + nt, b2[A + Me] = D2 + C, c[A + Me + d] = k - nt, b2[A + Me + d] = D2 - C, Me !== w && (O = g * R - _2 * I, I = g * I + _2 * R, R = O);
            }
      }, xe.prototype.guessLen13b = function(s, u) {
        var c = Math.max(u, s) | 1, b2 = c & 1, l = 0;
        for (c = c / 2 | 0;c; c = c >>> 1)
          l++;
        return 1 << l + 1 + b2;
      }, xe.prototype.conjugate = function(s, u, c) {
        if (!(c <= 1))
          for (var b2 = 0;b2 < c / 2; b2++) {
            var l = s[b2];
            s[b2] = s[c - b2 - 1], s[c - b2 - 1] = l, l = u[b2], u[b2] = -u[c - b2 - 1], u[c - b2 - 1] = -l;
          }
      }, xe.prototype.normalize13b = function(s, u) {
        for (var c = 0, b2 = 0;b2 < u / 2; b2++) {
          var l = Math.round(s[2 * b2 + 1] / u) * 8192 + Math.round(s[2 * b2] / u) + c;
          s[b2] = l & 67108863, l < 67108864 ? c = 0 : c = l / 67108864 | 0;
        }
        return s;
      }, xe.prototype.convert13b = function(s, u, c, b2) {
        for (var l = 0, n = 0;n < u; n++)
          l = l + (s[n] | 0), c[2 * n] = l & 8191, l = l >>> 13, c[2 * n + 1] = l & 8191, l = l >>> 13;
        for (n = 2 * u;n < b2; ++n)
          c[n] = 0;
        r(l === 0), r((l & -8192) === 0);
      }, xe.prototype.stub = function(s) {
        for (var u = new Array(s), c = 0;c < s; c++)
          u[c] = 0;
        return u;
      }, xe.prototype.mulp = function(s, u, c) {
        var b2 = 2 * this.guessLen13b(s.length, u.length), l = this.makeRBT(b2), n = this.stub(b2), d = new Array(b2), w = new Array(b2), g = new Array(b2), _2 = new Array(b2), A = new Array(b2), R = new Array(b2), I = c.words;
        I.length = b2, this.convert13b(s.words, s.length, d, b2), this.convert13b(u.words, u.length, _2, b2), this.transform(d, n, w, g, b2, l), this.transform(_2, n, A, R, b2, l);
        for (var Me = 0;Me < b2; Me++) {
          var k = w[Me] * A[Me] - g[Me] * R[Me];
          g[Me] = w[Me] * R[Me] + g[Me] * A[Me], w[Me] = k;
        }
        return this.conjugate(w, g, b2), this.transform(w, g, I, n, b2, l), this.conjugate(I, n, b2), this.normalize13b(I, b2), c.negative = s.negative ^ u.negative, c.length = s.length + u.length, c._strip();
      }, f.prototype.mul = function(s) {
        var u = new f(null);
        return u.words = new Array(this.length + s.length), this.mulTo(s, u);
      }, f.prototype.mulf = function(s) {
        var u = new f(null);
        return u.words = new Array(this.length + s.length), ye(this, s, u);
      }, f.prototype.imul = function(s) {
        return this.clone().mulTo(s, this);
      }, f.prototype.imuln = function(s) {
        var u = s < 0;
        u && (s = -s), r(typeof s == "number"), r(s < 67108864);
        for (var c = 0, b2 = 0;b2 < this.length; b2++) {
          var l = (this.words[b2] | 0) * s, n = (l & 67108863) + (c & 67108863);
          c >>= 26, c += l / 67108864 | 0, c += n >>> 26, this.words[b2] = n & 67108863;
        }
        return c !== 0 && (this.words[b2] = c, this.length++), u ? this.ineg() : this;
      }, f.prototype.muln = function(s) {
        return this.clone().imuln(s);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(s) {
        var u = ge(s);
        if (u.length === 0)
          return new f(1);
        for (var c = this, b2 = 0;b2 < u.length && u[b2] === 0; b2++, c = c.sqr())
          ;
        if (++b2 < u.length)
          for (var l = c.sqr();b2 < u.length; b2++, l = l.sqr())
            u[b2] !== 0 && (c = c.mul(l));
        return c;
      }, f.prototype.iushln = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26, b2 = 67108863 >>> 26 - u << 26 - u, l;
        if (u !== 0) {
          var n = 0;
          for (l = 0;l < this.length; l++) {
            var d = this.words[l] & b2, w = (this.words[l] | 0) - d << u;
            this.words[l] = w | n, n = d >>> 26 - u;
          }
          n && (this.words[l] = n, this.length++);
        }
        if (c !== 0) {
          for (l = this.length - 1;l >= 0; l--)
            this.words[l + c] = this.words[l];
          for (l = 0;l < c; l++)
            this.words[l] = 0;
          this.length += c;
        }
        return this._strip();
      }, f.prototype.ishln = function(s) {
        return r(this.negative === 0), this.iushln(s);
      }, f.prototype.iushrn = function(s, u, c) {
        r(typeof s == "number" && s >= 0);
        var b2;
        u ? b2 = (u - u % 26) / 26 : b2 = 0;
        var l = s % 26, n = Math.min((s - l) / 26, this.length), d = 67108863 ^ 67108863 >>> l << l, w = c;
        if (b2 -= n, b2 = Math.max(0, b2), w) {
          for (var g = 0;g < n; g++)
            w.words[g] = this.words[g];
          w.length = n;
        }
        if (n !== 0)
          if (this.length > n)
            for (this.length -= n, g = 0;g < this.length; g++)
              this.words[g] = this.words[g + n];
          else
            this.words[0] = 0, this.length = 1;
        var _2 = 0;
        for (g = this.length - 1;g >= 0 && (_2 !== 0 || g >= b2); g--) {
          var A = this.words[g] | 0;
          this.words[g] = _2 << 26 - l | A >>> l, _2 = A & d;
        }
        return w && _2 !== 0 && (w.words[w.length++] = _2), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, f.prototype.ishrn = function(s, u, c) {
        return r(this.negative === 0), this.iushrn(s, u, c);
      }, f.prototype.shln = function(s) {
        return this.clone().ishln(s);
      }, f.prototype.ushln = function(s) {
        return this.clone().iushln(s);
      }, f.prototype.shrn = function(s) {
        return this.clone().ishrn(s);
      }, f.prototype.ushrn = function(s) {
        return this.clone().iushrn(s);
      }, f.prototype.testn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26, b2 = 1 << u;
        if (this.length <= c)
          return false;
        var l = this.words[c];
        return !!(l & b2);
      }, f.prototype.imaskn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c)
          return this;
        if (u !== 0 && c++, this.length = Math.min(c, this.length), u !== 0) {
          var b2 = 67108863 ^ 67108863 >>> u << u;
          this.words[this.length - 1] &= b2;
        }
        return this._strip();
      }, f.prototype.maskn = function(s) {
        return this.clone().imaskn(s);
      }, f.prototype.iaddn = function(s) {
        return r(typeof s == "number"), r(s < 67108864), s < 0 ? this.isubn(-s) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= s ? (this.words[0] = s - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(s), this.negative = 1, this) : this._iaddn(s);
      }, f.prototype._iaddn = function(s) {
        this.words[0] += s;
        for (var u = 0;u < this.length && this.words[u] >= 67108864; u++)
          this.words[u] -= 67108864, u === this.length - 1 ? this.words[u + 1] = 1 : this.words[u + 1]++;
        return this.length = Math.max(this.length, u + 1), this;
      }, f.prototype.isubn = function(s) {
        if (r(typeof s == "number"), r(s < 67108864), s < 0)
          return this.iaddn(-s);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(s), this.negative = 1, this;
        if (this.words[0] -= s, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var u = 0;u < this.length && this.words[u] < 0; u++)
            this.words[u] += 67108864, this.words[u + 1] -= 1;
        return this._strip();
      }, f.prototype.addn = function(s) {
        return this.clone().iaddn(s);
      }, f.prototype.subn = function(s) {
        return this.clone().isubn(s);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(s, u, c) {
        var b2 = s.length + c, l;
        this._expand(b2);
        var n, d = 0;
        for (l = 0;l < s.length; l++) {
          n = (this.words[l + c] | 0) + d;
          var w = (s.words[l] | 0) * u;
          n -= w & 67108863, d = (n >> 26) - (w / 67108864 | 0), this.words[l + c] = n & 67108863;
        }
        for (;l < this.length - c; l++)
          n = (this.words[l + c] | 0) + d, d = n >> 26, this.words[l + c] = n & 67108863;
        if (d === 0)
          return this._strip();
        for (r(d === -1), d = 0, l = 0;l < this.length; l++)
          n = -(this.words[l] | 0) + d, d = n >> 26, this.words[l] = n & 67108863;
        return this.negative = 1, this._strip();
      }, f.prototype._wordDiv = function(s, u) {
        var c = this.length - s.length, b2 = this.clone(), l = s, n = l.words[l.length - 1] | 0, d = this._countBits(n);
        c = 26 - d, c !== 0 && (l = l.ushln(c), b2.iushln(c), n = l.words[l.length - 1] | 0);
        var w = b2.length - l.length, g;
        if (u !== "mod") {
          g = new f(null), g.length = w + 1, g.words = new Array(g.length);
          for (var _2 = 0;_2 < g.length; _2++)
            g.words[_2] = 0;
        }
        var A = b2.clone()._ishlnsubmul(l, 1, w);
        A.negative === 0 && (b2 = A, g && (g.words[w] = 1));
        for (var R = w - 1;R >= 0; R--) {
          var I = (b2.words[l.length + R] | 0) * 67108864 + (b2.words[l.length + R - 1] | 0);
          for (I = Math.min(I / n | 0, 67108863), b2._ishlnsubmul(l, I, R);b2.negative !== 0; )
            I--, b2.negative = 0, b2._ishlnsubmul(l, 1, R), b2.isZero() || (b2.negative ^= 1);
          g && (g.words[R] = I);
        }
        return g && g._strip(), b2._strip(), u !== "div" && c !== 0 && b2.iushrn(c), { div: g || null, mod: b2 };
      }, f.prototype.divmod = function(s, u, c) {
        if (r(!s.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var b2, l, n;
        return this.negative !== 0 && s.negative === 0 ? (n = this.neg().divmod(s, u), u !== "mod" && (b2 = n.div.neg()), u !== "div" && (l = n.mod.neg(), c && l.negative !== 0 && l.iadd(s)), { div: b2, mod: l }) : this.negative === 0 && s.negative !== 0 ? (n = this.divmod(s.neg(), u), u !== "mod" && (b2 = n.div.neg()), { div: b2, mod: n.mod }) : (this.negative & s.negative) !== 0 ? (n = this.neg().divmod(s.neg(), u), u !== "div" && (l = n.mod.neg(), c && l.negative !== 0 && l.isub(s)), { div: n.div, mod: l }) : s.length > this.length || this.cmp(s) < 0 ? { div: new f(0), mod: this } : s.length === 1 ? u === "div" ? { div: this.divn(s.words[0]), mod: null } : u === "mod" ? { div: null, mod: new f(this.modrn(s.words[0])) } : { div: this.divn(s.words[0]), mod: new f(this.modrn(s.words[0])) } : this._wordDiv(s, u);
      }, f.prototype.div = function(s) {
        return this.divmod(s, "div", false).div;
      }, f.prototype.mod = function(s) {
        return this.divmod(s, "mod", false).mod;
      }, f.prototype.umod = function(s) {
        return this.divmod(s, "mod", true).mod;
      }, f.prototype.divRound = function(s) {
        var u = this.divmod(s);
        if (u.mod.isZero())
          return u.div;
        var c = u.div.negative !== 0 ? u.mod.isub(s) : u.mod, b2 = s.ushrn(1), l = s.andln(1), n = c.cmp(b2);
        return n < 0 || l === 1 && n === 0 ? u.div : u.div.negative !== 0 ? u.div.isubn(1) : u.div.iaddn(1);
      }, f.prototype.modrn = function(s) {
        var u = s < 0;
        u && (s = -s), r(s <= 67108863);
        for (var c = (1 << 26) % s, b2 = 0, l = this.length - 1;l >= 0; l--)
          b2 = (c * b2 + (this.words[l] | 0)) % s;
        return u ? -b2 : b2;
      }, f.prototype.modn = function(s) {
        return this.modrn(s);
      }, f.prototype.idivn = function(s) {
        var u = s < 0;
        u && (s = -s), r(s <= 67108863);
        for (var c = 0, b2 = this.length - 1;b2 >= 0; b2--) {
          var l = (this.words[b2] | 0) + c * 67108864;
          this.words[b2] = l / s | 0, c = l % s;
        }
        return this._strip(), u ? this.ineg() : this;
      }, f.prototype.divn = function(s) {
        return this.clone().idivn(s);
      }, f.prototype.egcd = function(s) {
        r(s.negative === 0), r(!s.isZero());
        var u = this, c = s.clone();
        u.negative !== 0 ? u = u.umod(s) : u = u.clone();
        for (var b2 = new f(1), l = new f(0), n = new f(0), d = new f(1), w = 0;u.isEven() && c.isEven(); )
          u.iushrn(1), c.iushrn(1), ++w;
        for (var g = c.clone(), _2 = u.clone();!u.isZero(); ) {
          for (var A = 0, R = 1;(u.words[0] & R) === 0 && A < 26; ++A, R <<= 1)
            ;
          if (A > 0)
            for (u.iushrn(A);A-- > 0; )
              (b2.isOdd() || l.isOdd()) && (b2.iadd(g), l.isub(_2)), b2.iushrn(1), l.iushrn(1);
          for (var I = 0, Me = 1;(c.words[0] & Me) === 0 && I < 26; ++I, Me <<= 1)
            ;
          if (I > 0)
            for (c.iushrn(I);I-- > 0; )
              (n.isOdd() || d.isOdd()) && (n.iadd(g), d.isub(_2)), n.iushrn(1), d.iushrn(1);
          u.cmp(c) >= 0 ? (u.isub(c), b2.isub(n), l.isub(d)) : (c.isub(u), n.isub(b2), d.isub(l));
        }
        return { a: n, b: d, gcd: c.iushln(w) };
      }, f.prototype._invmp = function(s) {
        r(s.negative === 0), r(!s.isZero());
        var u = this, c = s.clone();
        u.negative !== 0 ? u = u.umod(s) : u = u.clone();
        for (var b2 = new f(1), l = new f(0), n = c.clone();u.cmpn(1) > 0 && c.cmpn(1) > 0; ) {
          for (var d = 0, w = 1;(u.words[0] & w) === 0 && d < 26; ++d, w <<= 1)
            ;
          if (d > 0)
            for (u.iushrn(d);d-- > 0; )
              b2.isOdd() && b2.iadd(n), b2.iushrn(1);
          for (var g = 0, _2 = 1;(c.words[0] & _2) === 0 && g < 26; ++g, _2 <<= 1)
            ;
          if (g > 0)
            for (c.iushrn(g);g-- > 0; )
              l.isOdd() && l.iadd(n), l.iushrn(1);
          u.cmp(c) >= 0 ? (u.isub(c), b2.isub(l)) : (c.isub(u), l.isub(b2));
        }
        var A;
        return u.cmpn(1) === 0 ? A = b2 : A = l, A.cmpn(0) < 0 && A.iadd(s), A;
      }, f.prototype.gcd = function(s) {
        if (this.isZero())
          return s.abs();
        if (s.isZero())
          return this.abs();
        var u = this.clone(), c = s.clone();
        u.negative = 0, c.negative = 0;
        for (var b2 = 0;u.isEven() && c.isEven(); b2++)
          u.iushrn(1), c.iushrn(1);
        do {
          for (;u.isEven(); )
            u.iushrn(1);
          for (;c.isEven(); )
            c.iushrn(1);
          var l = u.cmp(c);
          if (l < 0) {
            var n = u;
            u = c, c = n;
          } else if (l === 0 || c.cmpn(1) === 0)
            break;
          u.isub(c);
        } while (true);
        return c.iushln(b2);
      }, f.prototype.invm = function(s) {
        return this.egcd(s).a.umod(s);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(s) {
        return this.words[0] & s;
      }, f.prototype.bincn = function(s) {
        r(typeof s == "number");
        var u = s % 26, c = (s - u) / 26, b2 = 1 << u;
        if (this.length <= c)
          return this._expand(c + 1), this.words[c] |= b2, this;
        for (var l = b2, n = c;l !== 0 && n < this.length; n++) {
          var d = this.words[n] | 0;
          d += l, l = d >>> 26, d &= 67108863, this.words[n] = d;
        }
        return l !== 0 && (this.words[n] = l, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(s) {
        var u = s < 0;
        if (this.negative !== 0 && !u)
          return -1;
        if (this.negative === 0 && u)
          return 1;
        this._strip();
        var c;
        if (this.length > 1)
          c = 1;
        else {
          u && (s = -s), r(s <= 67108863, "Number is too big");
          var b2 = this.words[0] | 0;
          c = b2 === s ? 0 : b2 < s ? -1 : 1;
        }
        return this.negative !== 0 ? -c | 0 : c;
      }, f.prototype.cmp = function(s) {
        if (this.negative !== 0 && s.negative === 0)
          return -1;
        if (this.negative === 0 && s.negative !== 0)
          return 1;
        var u = this.ucmp(s);
        return this.negative !== 0 ? -u | 0 : u;
      }, f.prototype.ucmp = function(s) {
        if (this.length > s.length)
          return 1;
        if (this.length < s.length)
          return -1;
        for (var u = 0, c = this.length - 1;c >= 0; c--) {
          var b2 = this.words[c] | 0, l = s.words[c] | 0;
          if (b2 !== l) {
            b2 < l ? u = -1 : b2 > l && (u = 1);
            break;
          }
        }
        return u;
      }, f.prototype.gtn = function(s) {
        return this.cmpn(s) === 1;
      }, f.prototype.gt = function(s) {
        return this.cmp(s) === 1;
      }, f.prototype.gten = function(s) {
        return this.cmpn(s) >= 0;
      }, f.prototype.gte = function(s) {
        return this.cmp(s) >= 0;
      }, f.prototype.ltn = function(s) {
        return this.cmpn(s) === -1;
      }, f.prototype.lt = function(s) {
        return this.cmp(s) === -1;
      }, f.prototype.lten = function(s) {
        return this.cmpn(s) <= 0;
      }, f.prototype.lte = function(s) {
        return this.cmp(s) <= 0;
      }, f.prototype.eqn = function(s) {
        return this.cmpn(s) === 0;
      }, f.prototype.eq = function(s) {
        return this.cmp(s) === 0;
      }, f.red = function(s) {
        return new i(s);
      }, f.prototype.toRed = function(s) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), s.convertTo(this)._forceRed(s);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(s) {
        return this.red = s, this;
      }, f.prototype.forceRed = function(s) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(s);
      }, f.prototype.redAdd = function(s) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, s);
      }, f.prototype.redIAdd = function(s) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, s);
      }, f.prototype.redSub = function(s) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, s);
      }, f.prototype.redISub = function(s) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, s);
      }, f.prototype.redShl = function(s) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, s);
      }, f.prototype.redMul = function(s) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.mul(this, s);
      }, f.prototype.redIMul = function(s) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.imul(this, s);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(s) {
        return r(this.red && !s.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, s);
      };
      var Re = { k256: null, p224: null, p192: null, p25519: null };
      function Ee(h, s) {
        this.name = h, this.p = new f(s, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ee.prototype._tmp = function() {
        var s = new f(null);
        return s.words = new Array(Math.ceil(this.n / 13)), s;
      }, Ee.prototype.ireduce = function(s) {
        var u = s, c;
        do
          this.split(u, this.tmp), u = this.imulK(u), u = u.iadd(this.tmp), c = u.bitLength();
        while (c > this.n);
        var b2 = c < this.n ? -1 : u.ucmp(this.p);
        return b2 === 0 ? (u.words[0] = 0, u.length = 1) : b2 > 0 ? u.isub(this.p) : u.strip !== undefined ? u.strip() : u._strip(), u;
      }, Ee.prototype.split = function(s, u) {
        s.iushrn(this.n, 0, u);
      }, Ee.prototype.imulK = function(s) {
        return s.imul(this.k);
      };
      function Ae() {
        Ee.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(Ae, Ee), Ae.prototype.split = function(s, u) {
        for (var c = 4194303, b2 = Math.min(s.length, 9), l = 0;l < b2; l++)
          u.words[l] = s.words[l];
        if (u.length = b2, s.length <= 9) {
          s.words[0] = 0, s.length = 1;
          return;
        }
        var n = s.words[9];
        for (u.words[u.length++] = n & c, l = 10;l < s.length; l++) {
          var d = s.words[l] | 0;
          s.words[l - 10] = (d & c) << 4 | n >>> 22, n = d;
        }
        n >>>= 22, s.words[l - 10] = n, n === 0 && s.length > 10 ? s.length -= 10 : s.length -= 9;
      }, Ae.prototype.imulK = function(s) {
        s.words[s.length] = 0, s.words[s.length + 1] = 0, s.length += 2;
        for (var u = 0, c = 0;c < s.length; c++) {
          var b2 = s.words[c] | 0;
          u += b2 * 977, s.words[c] = u & 67108863, u = b2 * 64 + (u / 67108864 | 0);
        }
        return s.words[s.length - 1] === 0 && (s.length--, s.words[s.length - 1] === 0 && s.length--), s;
      };
      function P() {
        Ee.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(P, Ee);
      function Se() {
        Ee.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Se, Ee);
      function v2() {
        Ee.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(v2, Ee), v2.prototype.imulK = function(s) {
        for (var u = 0, c = 0;c < s.length; c++) {
          var b2 = (s.words[c] | 0) * 19 + u, l = b2 & 67108863;
          b2 >>>= 26, s.words[c] = l, u = b2;
        }
        return u !== 0 && (s.words[s.length++] = u), s;
      }, f._prime = function(s) {
        if (Re[s])
          return Re[s];
        var u;
        if (s === "k256")
          u = new Ae;
        else if (s === "p224")
          u = new P;
        else if (s === "p192")
          u = new Se;
        else if (s === "p25519")
          u = new v2;
        else
          throw new Error("Unknown prime " + s);
        return Re[s] = u, u;
      };
      function i(h) {
        if (typeof h == "string") {
          var s = f._prime(h);
          this.m = s.p, this.prime = s;
        } else
          r(h.gtn(1), "modulus must be greater than 1"), this.m = h, this.prime = null;
      }
      i.prototype._verify1 = function(s) {
        r(s.negative === 0, "red works only with positives"), r(s.red, "red works only with red numbers");
      }, i.prototype._verify2 = function(s, u) {
        r((s.negative | u.negative) === 0, "red works only with positives"), r(s.red && s.red === u.red, "red works only with red numbers");
      }, i.prototype.imod = function(s) {
        return this.prime ? this.prime.ireduce(s)._forceRed(this) : (x(s, s.umod(this.m)._forceRed(this)), s);
      }, i.prototype.neg = function(s) {
        return s.isZero() ? s.clone() : this.m.sub(s)._forceRed(this);
      }, i.prototype.add = function(s, u) {
        this._verify2(s, u);
        var c = s.add(u);
        return c.cmp(this.m) >= 0 && c.isub(this.m), c._forceRed(this);
      }, i.prototype.iadd = function(s, u) {
        this._verify2(s, u);
        var c = s.iadd(u);
        return c.cmp(this.m) >= 0 && c.isub(this.m), c;
      }, i.prototype.sub = function(s, u) {
        this._verify2(s, u);
        var c = s.sub(u);
        return c.cmpn(0) < 0 && c.iadd(this.m), c._forceRed(this);
      }, i.prototype.isub = function(s, u) {
        this._verify2(s, u);
        var c = s.isub(u);
        return c.cmpn(0) < 0 && c.iadd(this.m), c;
      }, i.prototype.shl = function(s, u) {
        return this._verify1(s), this.imod(s.ushln(u));
      }, i.prototype.imul = function(s, u) {
        return this._verify2(s, u), this.imod(s.imul(u));
      }, i.prototype.mul = function(s, u) {
        return this._verify2(s, u), this.imod(s.mul(u));
      }, i.prototype.isqr = function(s) {
        return this.imul(s, s.clone());
      }, i.prototype.sqr = function(s) {
        return this.mul(s, s);
      }, i.prototype.sqrt = function(s) {
        if (s.isZero())
          return s.clone();
        var u = this.m.andln(3);
        if (r(u % 2 === 1), u === 3) {
          var c = this.m.add(new f(1)).iushrn(2);
          return this.pow(s, c);
        }
        for (var b2 = this.m.subn(1), l = 0;!b2.isZero() && b2.andln(1) === 0; )
          l++, b2.iushrn(1);
        r(!b2.isZero());
        var n = new f(1).toRed(this), d = n.redNeg(), w = this.m.subn(1).iushrn(1), g = this.m.bitLength();
        for (g = new f(2 * g * g).toRed(this);this.pow(g, w).cmp(d) !== 0; )
          g.redIAdd(d);
        for (var _2 = this.pow(g, b2), A = this.pow(s, b2.addn(1).iushrn(1)), R = this.pow(s, b2), I = l;R.cmp(n) !== 0; ) {
          for (var Me = R, k = 0;Me.cmp(n) !== 0; k++)
            Me = Me.redSqr();
          r(k < I);
          var D2 = this.pow(_2, new f(1).iushln(I - k - 1));
          A = A.redMul(D2), _2 = D2.redSqr(), R = R.redMul(_2), I = k;
        }
        return A;
      }, i.prototype.invm = function(s) {
        var u = s._invmp(this.m);
        return u.negative !== 0 ? (u.negative = 0, this.imod(u).redNeg()) : this.imod(u);
      }, i.prototype.pow = function(s, u) {
        if (u.isZero())
          return new f(1).toRed(this);
        if (u.cmpn(1) === 0)
          return s.clone();
        var c = 4, b2 = new Array(1 << c);
        b2[0] = new f(1).toRed(this), b2[1] = s;
        for (var l = 2;l < b2.length; l++)
          b2[l] = this.mul(b2[l - 1], s);
        var n = b2[0], d = 0, w = 0, g = u.bitLength() % 26;
        for (g === 0 && (g = 26), l = u.length - 1;l >= 0; l--) {
          for (var _2 = u.words[l], A = g - 1;A >= 0; A--) {
            var R = _2 >> A & 1;
            if (n !== b2[0] && (n = this.sqr(n)), R === 0 && d === 0) {
              w = 0;
              continue;
            }
            d <<= 1, d |= R, w++, !(w !== c && (l !== 0 || A !== 0)) && (n = this.mul(n, b2[d]), w = 0, d = 0);
          }
          g = 26;
        }
        return n;
      }, i.prototype.convertTo = function(s) {
        var u = s.umod(this.m);
        return u === s ? u.clone() : u;
      }, i.prototype.convertFrom = function(s) {
        var u = s.clone();
        return u.red = null, u;
      }, f.mont = function(s) {
        return new a(s);
      };
      function a(h) {
        i.call(this, h), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(a, i), a.prototype.convertTo = function(s) {
        return this.imod(s.ushln(this.shift));
      }, a.prototype.convertFrom = function(s) {
        var u = this.imod(s.mul(this.rinv));
        return u.red = null, u;
      }, a.prototype.imul = function(s, u) {
        if (s.isZero() || u.isZero())
          return s.words[0] = 0, s.length = 1, s;
        var c = s.imul(u), b2 = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l = c.isub(b2).iushrn(this.shift), n = l;
        return l.cmp(this.m) >= 0 ? n = l.isub(this.m) : l.cmpn(0) < 0 && (n = l.iadd(this.m)), n._forceRed(this);
      }, a.prototype.mul = function(s, u) {
        if (s.isZero() || u.isZero())
          return new f(0)._forceRed(this);
        var c = s.mul(u), b2 = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l = c.isub(b2).iushrn(this.shift), n = l;
        return l.cmp(this.m) >= 0 ? n = l.isub(this.m) : l.cmpn(0) < 0 && (n = l.iadd(this.m)), n._forceRed(this);
      }, a.prototype.invm = function(s) {
        var u = this.imod(s._invmp(this.m).mul(this.r2));
        return u._forceRed(this);
      };
    })(typeof kl > "u" || kl, n2);
  });
  Ks = T((yk, o2) => {
    var Rf = Ws(), oA = on();
    function sA(t) {
      var e = f2(t), r = e.toRed(Rf.mont(t.modulus)).redPow(new Rf(t.publicExponent)).fromRed();
      return { blinder: r, unblinder: e.invm(t.modulus) };
    }
    function f2(t) {
      var e = t.modulus.byteLength(), r;
      do
        r = new Rf(oA(e));
      while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
      return r;
    }
    function a2(t, e) {
      var r = sA(e), o = e.modulus.byteLength(), f = new Rf(t).mul(r.blinder).umod(e.modulus), p = f.toRed(Rf.mont(e.prime1)), m = f.toRed(Rf.mont(e.prime2)), y = e.coefficient, M = e.prime1, x = e.prime2, S2 = p.redPow(e.exponent1).fromRed(), E = m.redPow(e.exponent2).fromRed(), B = S2.isub(E).imul(y).umod(M).imul(x);
      return E.iadd(B).imul(r.unblinder).umod(e.modulus).toArrayLike(Buffer, "be", o);
    }
    a2.getr = f2;
    o2.exports = a2;
  });
  s2 = T((wk, hA) => {
    hA.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
  });
  ri = T((h2, Ll) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o(v2, i) {
        v2.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v2.prototype = new a, v2.prototype.constructor = v2;
      }
      function f(v2, i, a) {
        if (f.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v2 || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b2 = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b2 & 67108863, this.words[u + 1] = c >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, u++);
        return this.strip();
      };
      function m(v2, i) {
        var a = v2.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v2, i, a) {
        var h = m(v2, a);
        return a - 1 >= i && (h |= m(v2, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b2;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b2 = y(i, a, s) << u, this.words[c] |= b2 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b2 >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v2, i, a, h) {
        for (var s = 0, u = Math.min(v2.length, a), c = i;c < u; c++) {
          var b2 = v2.charCodeAt(c) - 48;
          s *= h, b2 >= 49 ? s += b2 - 49 + 10 : b2 >= 17 ? s += b2 - 17 + 10 : s += b2;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b2 = c % s, l = Math.min(c, c - b2) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b2 !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b2; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b2 = this.words[c], l = ((b2 << s | u) & 16777215).toString(16);
            u = b2 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b2 = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[n] = l;
          for (;n < u; n++)
            b2[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b2[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b2[u - n - 1] = l;
        }
        return b2;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v2) {
        for (var i = new Array(v2.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v2.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b2 = 0;b2 < u.length; b2++)
          a = (s.words[b2] | 0) - (u.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        for (;c !== 0 && b2 < s.length; b2++)
          a = (s.words[b2] | 0) + c, c = a >> 26, this.words[b2] = a & 67108863;
        if (c === 0 && b2 < s.length && s !== this)
          for (;b2 < s.length; b2++)
            this.words[b2] = s.words[b2];
        return this.length = Math.max(this.length, b2), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a) {
        a.negative = i.negative ^ v2.negative;
        var h = v2.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v2.words[0] | 0, u = i.words[0] | 0, c = s * u, b2 = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b2;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _2 = Math.max(0, n - v2.length + 1);_2 <= g; _2++) {
            var A = n - _2 | 0;
            s = v2.words[A] | 0, u = i.words[_2] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b2 = 0, l, n, d, w = s[0] | 0, g = w & 8191, _2 = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D2 = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z2 = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $2 = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = u[1] | 0, Q2 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J2), n = n + Math.imul(_2, X) | 0, d = Math.imul(_2, J2);
        var ft = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J2), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J2), l = l + Math.imul(g, Q2) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_2, Q2) | 0, d = d + Math.imul(_2, ee) | 0;
        var Be = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J2), n = n + Math.imul(D2, X) | 0, d = Math.imul(D2, J2), l = l + Math.imul(R, Q2) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q2) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_2, te) | 0, d = d + Math.imul(_2, re) | 0;
        var qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J2), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J2), l = l + Math.imul(k, Q2) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D2, Q2) | 0, d = d + Math.imul(D2, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_2, ie) | 0, d = d + Math.imul(_2, ne) | 0;
        var ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J2), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J2), l = l + Math.imul(C, Q2) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q2) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D2, te) | 0, d = d + Math.imul(D2, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_2, fe) | 0, d = d + Math.imul(_2, ae) | 0;
        var He = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z2, X), n = Math.imul(z2, J2), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J2), l = l + Math.imul(F, Q2) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q2) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D2, ie) | 0, d = d + Math.imul(D2, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_2, oe) | 0, d = d + Math.imul(_2, se) | 0;
        var We = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J2), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J2), l = l + Math.imul(z2, Q2) | 0, n = n + Math.imul(z2, ee) | 0, n = n + Math.imul(H, Q2) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D2, fe) | 0, d = d + Math.imul(D2, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_2, he) | 0, d = d + Math.imul(_2, ue) | 0;
        var Ke = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J2), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J2), l = l + Math.imul(W, Q2) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q2) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z2, te) | 0, n = n + Math.imul(z2, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D2, oe) | 0, d = d + Math.imul(D2, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_2, le) | 0, d = d + Math.imul(_2, de) | 0;
        var je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J2), n = n + Math.imul($2, X) | 0, d = Math.imul($2, J2), l = l + Math.imul(j, Q2) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q2) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z2, ie) | 0, n = n + Math.imul(z2, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D2, he) | 0, d = d + Math.imul(D2, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_2, ce) | 0, d = d + Math.imul(_2, pe) | 0;
        var Ze = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J2), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J2), l = l + Math.imul(V, Q2) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($2, Q2) | 0, d = d + Math.imul($2, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z2, fe) | 0, n = n + Math.imul(z2, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D2, le) | 0, d = d + Math.imul(D2, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_2, ve) | 0, d = d + Math.imul(_2, be) | 0;
        var Ve = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q2), n = Math.imul(G, ee), n = n + Math.imul(Y, Q2) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($2, te) | 0, d = d + Math.imul($2, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z2, oe) | 0, n = n + Math.imul(z2, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D2, ce) | 0, d = d + Math.imul(D2, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($2, ie) | 0, d = d + Math.imul($2, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z2, he) | 0, n = n + Math.imul(z2, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D2, ve) | 0, d = d + Math.imul(D2, be) | 0;
        var Ge = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($2, fe) | 0, d = d + Math.imul($2, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z2, le) | 0, n = n + Math.imul(z2, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($2, oe) | 0, d = d + Math.imul($2, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z2, ce) | 0, n = n + Math.imul(z2, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($2, he) | 0, d = d + Math.imul($2, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z2, ve) | 0, n = n + Math.imul(z2, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($2, le) | 0, d = d + Math.imul($2, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($2, ce) | 0, d = d + Math.imul($2, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($2, ve) | 0, d = d + Math.imul($2, be) | 0;
        var tt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        b2 = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b2 + l | 0) + ((n & 8191) << 13) | 0;
        return b2 = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b2 !== 0 && (c[19] = b2, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v2, i, a) {
        a.negative = i.negative ^ v2.negative, a.length = v2.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b2 = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v2.length + 1);n <= l; n++) {
            var d = u - n, w = v2.words[d] | 0, g = i.words[n] | 0, _2 = w * g, A = _2 & 67108863;
            c = c + (_2 / 67108864 | 0) | 0, A = A + b2 | 0, b2 = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b2, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v2, i, a) {
        var h = new N;
        return h.mulp(v2, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v2, i) {
        this.x = v2, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b2 = 0;b2 < c; b2++)
          s[b2] = a[i[b2]], u[b2] = h[i[b2]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b2 = 1;b2 < u; b2 <<= 1)
          for (var l = b2 << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _2 = d, A = 0;A < b2; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b2], k = s[w + A + b2], D2 = g * Me - _2 * k;
              k = g * k + _2 * Me, Me = D2, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b2] = R - Me, s[w + A + b2] = I - k, A !== l && (D2 = n * g - d * _2, _2 = n * _2 + d * g, g = D2);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b2 = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _2 = h.words;
        _2.length = s, this.convert13b(i.words, i.length, b2, s), this.convert13b(a.words, a.length, d, s), this.transform(b2, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _2, c, s, u), this.conjugate(_2, c, s), this.normalize13b(_2, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b2 = this.words[u] & s, l = (this.words[u] | 0) - b2 << a;
            this.words[u] = l | c, c = b2 >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b2 = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b2;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b2 = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b2;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b2 = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b2, b2 = c >> 26, this.words[u + h] = c & 67108863;
        if (b2 === 0)
          return this.strip();
        for (r(b2 === -1), b2 = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b2, b2 = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b2 = this._countBits(c);
        h = 26 - b2, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _2 = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_2 = Math.min(_2 / c | 0, 67108863), s._ishlnsubmul(u, _2, g);s.negative !== 0; )
            _2--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _2);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b2 = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _2 = 0, A = 1;(h.words[0] & A) === 0 && _2 < 26; ++_2, A <<= 1)
            ;
          if (_2 > 0)
            for (h.iushrn(_2);_2-- > 0; )
              (c.isOdd() || b2.isOdd()) && (c.iadd(n), b2.isub(d)), c.iushrn(1), b2.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b2)) : (h.isub(a), c.isub(s), b2.isub(u));
        }
        return { a: c, b: b2, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b2 = 0, l = 1;(a.words[0] & l) === 0 && b2 < 26; ++b2, l <<= 1)
            ;
          if (b2 > 0)
            for (a.iushrn(b2);b2-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b2 = this.words[c] | 0;
          b2 += u, u = b2 >>> 26, b2 &= 67108863, this.words[c] = b2;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v2, i) {
        this.name = v2, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b2 = i.words[u] | 0;
          i.words[u - 10] = (b2 & h) << 4 | c >>> 22, c = b2;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v2) {
        if (typeof v2 == "string") {
          var i = f._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b2 = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b2) !== 0; )
          n.redIAdd(b2);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _2 = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _2);
          var I = this.pow(d, new f(1).iushln(_2 - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _2 = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b2 = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b2 === 0) {
              l = 0;
              continue;
            }
            b2 <<= 1, b2 |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b2]), l = 0, b2 = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v2) {
        P.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Ll > "u" || Ll, h2);
  });
  Nl = T((d2) => {
    var js = d2;
    function uA(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t != "string") {
        for (var o = 0;o < t.length; o++)
          r[o] = t[o] | 0;
        return r;
      }
      if (e === "hex") {
        t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
        for (var o = 0;o < t.length; o += 2)
          r.push(parseInt(t[o] + t[o + 1], 16));
      } else
        for (var o = 0;o < t.length; o++) {
          var f = t.charCodeAt(o), p = f >> 8, m = f & 255;
          p ? r.push(p, m) : r.push(m);
        }
      return r;
    }
    js.toArray = uA;
    function u2(t) {
      return t.length === 1 ? "0" + t : t;
    }
    js.zero2 = u2;
    function l2(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += u2(t[r].toString(16));
      return e;
    }
    js.toHex = l2;
    js.encode = function(e, r) {
      return r === "hex" ? l2(e) : e;
    };
  });
  or = T((c2) => {
    var Pr = c2, lA = ri(), dA = ar(), Zs = Nl();
    Pr.assert = dA;
    Pr.toArray = Zs.toArray;
    Pr.zero2 = Zs.zero2;
    Pr.toHex = Zs.toHex;
    Pr.encode = Zs.encode;
    function cA(t, e, r) {
      var o = new Array(Math.max(t.bitLength(), r) + 1);
      o.fill(0);
      for (var f = 1 << e + 1, p = t.clone(), m = 0;m < o.length; m++) {
        var y, M = p.andln(f - 1);
        p.isOdd() ? (M > (f >> 1) - 1 ? y = (f >> 1) - M : y = M, p.isubn(y)) : y = 0, o[m] = y, p.iushrn(1);
      }
      return o;
    }
    Pr.getNAF = cA;
    function pA(t, e) {
      var r = [[], []];
      t = t.clone(), e = e.clone();
      for (var o = 0, f = 0, p;t.cmpn(-o) > 0 || e.cmpn(-f) > 0; ) {
        var m = t.andln(3) + o & 3, y = e.andln(3) + f & 3;
        m === 3 && (m = -1), y === 3 && (y = -1);
        var M;
        (m & 1) === 0 ? M = 0 : (p = t.andln(7) + o & 7, (p === 3 || p === 5) && y === 2 ? M = -m : M = m), r[0].push(M);
        var x;
        (y & 1) === 0 ? x = 0 : (p = e.andln(7) + f & 7, (p === 3 || p === 5) && m === 2 ? x = -y : x = y), r[1].push(x), 2 * o === M + 1 && (o = 1 - o), 2 * f === x + 1 && (f = 1 - f), t.iushrn(1), e.iushrn(1);
      }
      return r;
    }
    Pr.getJSF = pA;
    function vA(t, e, r) {
      var o = "_" + e;
      t.prototype[e] = function() {
        return this[o] !== undefined ? this[o] : this[o] = r.call(this);
      };
    }
    Pr.cachedProperty = vA;
    function bA(t) {
      return typeof t == "string" ? Pr.toArray(t, "hex") : t;
    }
    Pr.parseBytes = bA;
    function mA(t) {
      return new lA(t, "hex", "le");
    }
    Pr.intFromLE = mA;
  });
  Oa = T((xk, p2) => {
    var Cn = ri(), Ca = or(), Vs = Ca.getNAF, gA = Ca.getJSF, $s = Ca.assert;
    function Xi(t, e) {
      this.type = t, this.p = new Cn(e.p, 16), this.red = e.prime ? Cn.red(e.prime) : Cn.mont(this.p), this.zero = new Cn(0).toRed(this.red), this.one = new Cn(1).toRed(this.red), this.two = new Cn(2).toRed(this.red), this.n = e.n && new Cn(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var r = this.n && this.p.div(this.n);
      !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
    }
    p2.exports = Xi;
    Xi.prototype.point = function() {
      throw new Error("Not implemented");
    };
    Xi.prototype.validate = function() {
      throw new Error("Not implemented");
    };
    Xi.prototype._fixedNafMul = function(e, r) {
      $s(e.precomputed);
      var o = e._getDoubles(), f = Vs(r, 1, this._bitLength), p = (1 << o.step + 1) - (o.step % 2 === 0 ? 2 : 1);
      p /= 3;
      var m = [], y, M;
      for (y = 0;y < f.length; y += o.step) {
        M = 0;
        for (var x = y + o.step - 1;x >= y; x--)
          M = (M << 1) + f[x];
        m.push(M);
      }
      for (var S2 = this.jpoint(null, null, null), E = this.jpoint(null, null, null), B = p;B > 0; B--) {
        for (y = 0;y < m.length; y++)
          M = m[y], M === B ? E = E.mixedAdd(o.points[y]) : M === -B && (E = E.mixedAdd(o.points[y].neg()));
        S2 = S2.add(E);
      }
      return S2.toP();
    };
    Xi.prototype._wnafMul = function(e, r) {
      var o = 4, f = e._getNAFPoints(o);
      o = f.wnd;
      for (var p = f.points, m = Vs(r, o, this._bitLength), y = this.jpoint(null, null, null), M = m.length - 1;M >= 0; M--) {
        for (var x = 0;M >= 0 && m[M] === 0; M--)
          x++;
        if (M >= 0 && x++, y = y.dblp(x), M < 0)
          break;
        var S2 = m[M];
        $s(S2 !== 0), e.type === "affine" ? S2 > 0 ? y = y.mixedAdd(p[S2 - 1 >> 1]) : y = y.mixedAdd(p[-S2 - 1 >> 1].neg()) : S2 > 0 ? y = y.add(p[S2 - 1 >> 1]) : y = y.add(p[-S2 - 1 >> 1].neg());
      }
      return e.type === "affine" ? y.toP() : y;
    };
    Xi.prototype._wnafMulAdd = function(e, r, o, f, p) {
      var m = this._wnafT1, y = this._wnafT2, M = this._wnafT3, x = 0, S2, E, B;
      for (S2 = 0;S2 < f; S2++) {
        B = r[S2];
        var q = B._getNAFPoints(e);
        m[S2] = q.wnd, y[S2] = q.points;
      }
      for (S2 = f - 1;S2 >= 1; S2 -= 2) {
        var L = S2 - 1, ge = S2;
        if (m[L] !== 1 || m[ge] !== 1) {
          M[L] = Vs(o[L], m[L], this._bitLength), M[ge] = Vs(o[ge], m[ge], this._bitLength), x = Math.max(M[L].length, x), x = Math.max(M[ge].length, x);
          continue;
        }
        var _e = [r[L], null, null, r[ge]];
        r[L].y.cmp(r[ge].y) === 0 ? (_e[1] = r[L].add(r[ge]), _e[2] = r[L].toJ().mixedAdd(r[ge].neg())) : r[L].y.cmp(r[ge].y.redNeg()) === 0 ? (_e[1] = r[L].toJ().mixedAdd(r[ge]), _e[2] = r[L].add(r[ge].neg())) : (_e[1] = r[L].toJ().mixedAdd(r[ge]), _e[2] = r[L].toJ().mixedAdd(r[ge].neg()));
        var N = [-3, -1, -5, -7, 0, 7, 5, 1, 3], we = gA(o[L], o[ge]);
        for (x = Math.max(we[0].length, x), M[L] = new Array(x), M[ge] = new Array(x), E = 0;E < x; E++) {
          var ye = we[0][E] | 0, xe = we[1][E] | 0;
          M[L][E] = N[(ye + 1) * 3 + (xe + 1)], M[ge][E] = 0, y[L] = _e;
        }
      }
      var Re = this.jpoint(null, null, null), Ee = this._wnafT4;
      for (S2 = x;S2 >= 0; S2--) {
        for (var Ae = 0;S2 >= 0; ) {
          var P = true;
          for (E = 0;E < f; E++)
            Ee[E] = M[E][S2] | 0, Ee[E] !== 0 && (P = false);
          if (!P)
            break;
          Ae++, S2--;
        }
        if (S2 >= 0 && Ae++, Re = Re.dblp(Ae), S2 < 0)
          break;
        for (E = 0;E < f; E++) {
          var Se = Ee[E];
          Se !== 0 && (Se > 0 ? B = y[E][Se - 1 >> 1] : Se < 0 && (B = y[E][-Se - 1 >> 1].neg()), B.type === "affine" ? Re = Re.mixedAdd(B) : Re = Re.add(B));
        }
      }
      for (S2 = 0;S2 < f; S2++)
        y[S2] = null;
      return p ? Re : Re.toP();
    };
    function _r(t, e) {
      this.curve = t, this.type = e, this.precomputed = null;
    }
    Xi.BasePoint = _r;
    _r.prototype.eq = function() {
      throw new Error("Not implemented");
    };
    _r.prototype.validate = function() {
      return this.curve.validate(this);
    };
    Xi.prototype.decodePoint = function(e, r) {
      e = Ca.toArray(e, r);
      var o = this.p.byteLength();
      if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * o) {
        e[0] === 6 ? $s(e[e.length - 1] % 2 === 0) : e[0] === 7 && $s(e[e.length - 1] % 2 === 1);
        var f = this.point(e.slice(1, 1 + o), e.slice(1 + o, 1 + 2 * o));
        return f;
      } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === o)
        return this.pointFromX(e.slice(1, 1 + o), e[0] === 3);
      throw new Error("Unknown point format");
    };
    _r.prototype.encodeCompressed = function(e) {
      return this.encode(e, true);
    };
    _r.prototype._encode = function(e) {
      var r = this.curve.p.byteLength(), o = this.getX().toArray("be", r);
      return e ? [this.getY().isEven() ? 2 : 3].concat(o) : [4].concat(o, this.getY().toArray("be", r));
    };
    _r.prototype.encode = function(e, r) {
      return Ca.encode(this._encode(r), e);
    };
    _r.prototype.precompute = function(e) {
      if (this.precomputed)
        return this;
      var r = { doubles: null, naf: null, beta: null };
      return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
    };
    _r.prototype._hasDoubles = function(e) {
      if (!this.precomputed)
        return false;
      var r = this.precomputed.doubles;
      return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : false;
    };
    _r.prototype._getDoubles = function(e, r) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      for (var o = [this], f = this, p = 0;p < r; p += e) {
        for (var m = 0;m < e; m++)
          f = f.dbl();
        o.push(f);
      }
      return { step: e, points: o };
    };
    _r.prototype._getNAFPoints = function(e) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      for (var r = [this], o = (1 << e) - 1, f = o === 1 ? null : this.dbl(), p = 1;p < o; p++)
        r[p] = r[p - 1].add(f);
      return { wnd: e, points: r };
    };
    _r.prototype._getBeta = function() {
      return null;
    };
    _r.prototype.dblp = function(e) {
      for (var r = this, o = 0;o < e; o++)
        r = r.dbl();
      return r;
    };
  });
  b2 = T((Sk, v2) => {
    var yA = or(), lt = ri(), Dl = Ie(), Bf = Oa(), wA = yA.assert;
    function xr2(t) {
      Bf.call(this, "short", t), this.a = new lt(t.a, 16).toRed(this.red), this.b = new lt(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    Dl(xr2, Bf);
    v2.exports = xr2;
    xr2.prototype._getEndomorphism = function(e) {
      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, o;
        if (e.beta)
          r = new lt(e.beta, 16).toRed(this.red);
        else {
          var f = this._getEndoRoots(this.p);
          r = f[0].cmp(f[1]) < 0 ? f[0] : f[1], r = r.toRed(this.red);
        }
        if (e.lambda)
          o = new lt(e.lambda, 16);
        else {
          var p = this._getEndoRoots(this.n);
          this.g.mul(p[0]).x.cmp(this.g.x.redMul(r)) === 0 ? o = p[0] : (o = p[1], wA(this.g.mul(o).x.cmp(this.g.x.redMul(r)) === 0));
        }
        var m;
        return e.basis ? m = e.basis.map(function(y) {
          return { a: new lt(y.a, 16), b: new lt(y.b, 16) };
        }) : m = this._getEndoBasis(o), { beta: r, lambda: o, basis: m };
      }
    };
    xr2.prototype._getEndoRoots = function(e) {
      var r = e === this.p ? this.red : lt.mont(e), o = new lt(2).toRed(r).redInvm(), f = o.redNeg(), p = new lt(3).toRed(r).redNeg().redSqrt().redMul(o), m = f.redAdd(p).fromRed(), y = f.redSub(p).fromRed();
      return [m, y];
    };
    xr2.prototype._getEndoBasis = function(e) {
      for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), o = e, f = this.n.clone(), p = new lt(1), m = new lt(0), y = new lt(0), M = new lt(1), x, S2, E, B, q, L, ge, _e = 0, N, we;o.cmpn(0) !== 0; ) {
        var ye = f.div(o);
        N = f.sub(ye.mul(o)), we = y.sub(ye.mul(p));
        var xe = M.sub(ye.mul(m));
        if (!E && N.cmp(r) < 0)
          x = ge.neg(), S2 = p, E = N.neg(), B = we;
        else if (E && ++_e === 2)
          break;
        ge = N, f = o, o = N, y = p, p = we, M = m, m = xe;
      }
      q = N.neg(), L = we;
      var Re = E.sqr().add(B.sqr()), Ee = q.sqr().add(L.sqr());
      return Ee.cmp(Re) >= 0 && (q = x, L = S2), E.negative && (E = E.neg(), B = B.neg()), q.negative && (q = q.neg(), L = L.neg()), [{ a: E, b: B }, { a: q, b: L }];
    };
    xr2.prototype._endoSplit = function(e) {
      var r = this.endo.basis, o = r[0], f = r[1], p = f.b.mul(e).divRound(this.n), m = o.b.neg().mul(e).divRound(this.n), y = p.mul(o.a), M = m.mul(f.a), x = p.mul(o.b), S2 = m.mul(f.b), E = e.sub(y).sub(M), B = x.add(S2).neg();
      return { k1: E, k2: B };
    };
    xr2.prototype.pointFromX = function(e, r) {
      e = new lt(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), f = o.redSqrt();
      if (f.redSqr().redSub(o).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var p = f.fromRed().isOdd();
      return (r && !p || !r && p) && (f = f.redNeg()), this.point(e, f);
    };
    xr2.prototype.validate = function(e) {
      if (e.inf)
        return true;
      var { x: r, y: o } = e, f = this.a.redMul(r), p = r.redSqr().redMul(r).redIAdd(f).redIAdd(this.b);
      return o.redSqr().redISub(p).cmpn(0) === 0;
    };
    xr2.prototype._endoWnafMulAdd = function(e, r, o) {
      for (var f = this._endoWnafT1, p = this._endoWnafT2, m = 0;m < e.length; m++) {
        var y = this._endoSplit(r[m]), M = e[m], x = M._getBeta();
        y.k1.negative && (y.k1.ineg(), M = M.neg(true)), y.k2.negative && (y.k2.ineg(), x = x.neg(true)), f[m * 2] = M, f[m * 2 + 1] = x, p[m * 2] = y.k1, p[m * 2 + 1] = y.k2;
      }
      for (var S2 = this._wnafMulAdd(1, f, p, m * 2, o), E = 0;E < m * 2; E++)
        f[E] = null, p[E] = null;
      return S2;
    };
    function Ct(t, e, r, o) {
      Bf.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new lt(e, 16), this.y = new lt(r, 16), o && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
    }
    Dl(Ct, Bf.BasePoint);
    xr2.prototype.point = function(e, r, o) {
      return new Ct(this, e, r, o);
    };
    xr2.prototype.pointFromJSON = function(e, r) {
      return Ct.fromJSON(this, e, r);
    };
    Ct.prototype._getBeta = function() {
      if (!!this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta)
          return e.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
          var o = this.curve, f = function(p) {
            return o.point(p.x.redMul(o.endo.beta), p.y);
          };
          e.beta = r, r.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(f) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(f) } };
        }
        return r;
      }
    };
    Ct.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
    };
    Ct.fromJSON = function(e, r, o) {
      typeof r == "string" && (r = JSON.parse(r));
      var f = e.point(r[0], r[1], o);
      if (!r[2])
        return f;
      function p(y) {
        return e.point(y[0], y[1], o);
      }
      var m = r[2];
      return f.precomputed = { beta: null, doubles: m.doubles && { step: m.doubles.step, points: [f].concat(m.doubles.points.map(p)) }, naf: m.naf && { wnd: m.naf.wnd, points: [f].concat(m.naf.points.map(p)) } }, f;
    };
    Ct.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Ct.prototype.isInfinity = function() {
      return this.inf;
    };
    Ct.prototype.add = function(e) {
      if (this.inf)
        return e;
      if (e.inf)
        return this;
      if (this.eq(e))
        return this.dbl();
      if (this.neg().eq(e))
        return this.curve.point(null, null);
      if (this.x.cmp(e.x) === 0)
        return this.curve.point(null, null);
      var r = this.y.redSub(e.y);
      r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
      var o = r.redSqr().redISub(this.x).redISub(e.x), f = r.redMul(this.x.redSub(o)).redISub(this.y);
      return this.curve.point(o, f);
    };
    Ct.prototype.dbl = function() {
      if (this.inf)
        return this;
      var e = this.y.redAdd(this.y);
      if (e.cmpn(0) === 0)
        return this.curve.point(null, null);
      var r = this.curve.a, o = this.x.redSqr(), f = e.redInvm(), p = o.redAdd(o).redIAdd(o).redIAdd(r).redMul(f), m = p.redSqr().redISub(this.x.redAdd(this.x)), y = p.redMul(this.x.redSub(m)).redISub(this.y);
      return this.curve.point(m, y);
    };
    Ct.prototype.getX = function() {
      return this.x.fromRed();
    };
    Ct.prototype.getY = function() {
      return this.y.fromRed();
    };
    Ct.prototype.mul = function(e) {
      return e = new lt(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
    };
    Ct.prototype.mulAdd = function(e, r, o) {
      var f = [this, r], p = [e, o];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f, p) : this.curve._wnafMulAdd(1, f, p, 2);
    };
    Ct.prototype.jmulAdd = function(e, r, o) {
      var f = [this, r], p = [e, o];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f, p, true) : this.curve._wnafMulAdd(1, f, p, 2, true);
    };
    Ct.prototype.eq = function(e) {
      return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
    };
    Ct.prototype.neg = function(e) {
      if (this.inf)
        return this;
      var r = this.curve.point(this.x, this.y.redNeg());
      if (e && this.precomputed) {
        var o = this.precomputed, f = function(p) {
          return p.neg();
        };
        r.precomputed = { naf: o.naf && { wnd: o.naf.wnd, points: o.naf.points.map(f) }, doubles: o.doubles && { step: o.doubles.step, points: o.doubles.points.map(f) } };
      }
      return r;
    };
    Ct.prototype.toJ = function() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var e = this.curve.jpoint(this.x, this.y, this.curve.one);
      return e;
    };
    function Wt(t, e, r, o) {
      Bf.BasePoint.call(this, t, "jacobian"), e === null && r === null && o === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new lt(0)) : (this.x = new lt(e, 16), this.y = new lt(r, 16), this.z = new lt(o, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    Dl(Wt, Bf.BasePoint);
    xr2.prototype.jpoint = function(e, r, o) {
      return new Wt(this, e, r, o);
    };
    Wt.prototype.toP = function() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var e = this.z.redInvm(), r = e.redSqr(), o = this.x.redMul(r), f = this.y.redMul(r).redMul(e);
      return this.curve.point(o, f);
    };
    Wt.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    Wt.prototype.add = function(e) {
      if (this.isInfinity())
        return e;
      if (e.isInfinity())
        return this;
      var r = e.z.redSqr(), o = this.z.redSqr(), f = this.x.redMul(r), p = e.x.redMul(o), m = this.y.redMul(r.redMul(e.z)), y = e.y.redMul(o.redMul(this.z)), M = f.redSub(p), x = m.redSub(y);
      if (M.cmpn(0) === 0)
        return x.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var S2 = M.redSqr(), E = S2.redMul(M), B = f.redMul(S2), q = x.redSqr().redIAdd(E).redISub(B).redISub(B), L = x.redMul(B.redISub(q)).redISub(m.redMul(E)), ge = this.z.redMul(e.z).redMul(M);
      return this.curve.jpoint(q, L, ge);
    };
    Wt.prototype.mixedAdd = function(e) {
      if (this.isInfinity())
        return e.toJ();
      if (e.isInfinity())
        return this;
      var r = this.z.redSqr(), o = this.x, f = e.x.redMul(r), p = this.y, m = e.y.redMul(r).redMul(this.z), y = o.redSub(f), M = p.redSub(m);
      if (y.cmpn(0) === 0)
        return M.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var x = y.redSqr(), S2 = x.redMul(y), E = o.redMul(x), B = M.redSqr().redIAdd(S2).redISub(E).redISub(E), q = M.redMul(E.redISub(B)).redISub(p.redMul(S2)), L = this.z.redMul(y);
      return this.curve.jpoint(B, q, L);
    };
    Wt.prototype.dblp = function(e) {
      if (e === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!e)
        return this.dbl();
      var r;
      if (this.curve.zeroA || this.curve.threeA) {
        var o = this;
        for (r = 0;r < e; r++)
          o = o.dbl();
        return o;
      }
      var f = this.curve.a, p = this.curve.tinv, m = this.x, y = this.y, M = this.z, x = M.redSqr().redSqr(), S2 = y.redAdd(y);
      for (r = 0;r < e; r++) {
        var E = m.redSqr(), B = S2.redSqr(), q = B.redSqr(), L = E.redAdd(E).redIAdd(E).redIAdd(f.redMul(x)), ge = m.redMul(B), _e = L.redSqr().redISub(ge.redAdd(ge)), N = ge.redISub(_e), we = L.redMul(N);
        we = we.redIAdd(we).redISub(q);
        var ye = S2.redMul(M);
        r + 1 < e && (x = x.redMul(q)), m = _e, M = ye, S2 = we;
      }
      return this.curve.jpoint(m, S2.redMul(p), M);
    };
    Wt.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    };
    Wt.prototype._zeroDbl = function() {
      var e, r, o;
      if (this.zOne) {
        var f = this.x.redSqr(), p = this.y.redSqr(), m = p.redSqr(), y = this.x.redAdd(p).redSqr().redISub(f).redISub(m);
        y = y.redIAdd(y);
        var M = f.redAdd(f).redIAdd(f), x = M.redSqr().redISub(y).redISub(y), S2 = m.redIAdd(m);
        S2 = S2.redIAdd(S2), S2 = S2.redIAdd(S2), e = x, r = M.redMul(y.redISub(x)).redISub(S2), o = this.y.redAdd(this.y);
      } else {
        var E = this.x.redSqr(), B = this.y.redSqr(), q = B.redSqr(), L = this.x.redAdd(B).redSqr().redISub(E).redISub(q);
        L = L.redIAdd(L);
        var ge = E.redAdd(E).redIAdd(E), _e = ge.redSqr(), N = q.redIAdd(q);
        N = N.redIAdd(N), N = N.redIAdd(N), e = _e.redISub(L).redISub(L), r = ge.redMul(L.redISub(e)).redISub(N), o = this.y.redMul(this.z), o = o.redIAdd(o);
      }
      return this.curve.jpoint(e, r, o);
    };
    Wt.prototype._threeDbl = function() {
      var e, r, o;
      if (this.zOne) {
        var f = this.x.redSqr(), p = this.y.redSqr(), m = p.redSqr(), y = this.x.redAdd(p).redSqr().redISub(f).redISub(m);
        y = y.redIAdd(y);
        var M = f.redAdd(f).redIAdd(f).redIAdd(this.curve.a), x = M.redSqr().redISub(y).redISub(y);
        e = x;
        var S2 = m.redIAdd(m);
        S2 = S2.redIAdd(S2), S2 = S2.redIAdd(S2), r = M.redMul(y.redISub(x)).redISub(S2), o = this.y.redAdd(this.y);
      } else {
        var E = this.z.redSqr(), B = this.y.redSqr(), q = this.x.redMul(B), L = this.x.redSub(E).redMul(this.x.redAdd(E));
        L = L.redAdd(L).redIAdd(L);
        var ge = q.redIAdd(q);
        ge = ge.redIAdd(ge);
        var _e = ge.redAdd(ge);
        e = L.redSqr().redISub(_e), o = this.y.redAdd(this.z).redSqr().redISub(B).redISub(E);
        var N = B.redSqr();
        N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N), r = L.redMul(ge.redISub(e)).redISub(N);
      }
      return this.curve.jpoint(e, r, o);
    };
    Wt.prototype._dbl = function() {
      var e = this.curve.a, r = this.x, o = this.y, f = this.z, p = f.redSqr().redSqr(), m = r.redSqr(), y = o.redSqr(), M = m.redAdd(m).redIAdd(m).redIAdd(e.redMul(p)), x = r.redAdd(r);
      x = x.redIAdd(x);
      var S2 = x.redMul(y), E = M.redSqr().redISub(S2.redAdd(S2)), B = S2.redISub(E), q = y.redSqr();
      q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
      var L = M.redMul(B).redISub(q), ge = o.redAdd(o).redMul(f);
      return this.curve.jpoint(E, L, ge);
    };
    Wt.prototype.trpl = function() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var e = this.x.redSqr(), r = this.y.redSqr(), o = this.z.redSqr(), f = r.redSqr(), p = e.redAdd(e).redIAdd(e), m = p.redSqr(), y = this.x.redAdd(r).redSqr().redISub(e).redISub(f);
      y = y.redIAdd(y), y = y.redAdd(y).redIAdd(y), y = y.redISub(m);
      var M = y.redSqr(), x = f.redIAdd(f);
      x = x.redIAdd(x), x = x.redIAdd(x), x = x.redIAdd(x);
      var S2 = p.redIAdd(y).redSqr().redISub(m).redISub(M).redISub(x), E = r.redMul(S2);
      E = E.redIAdd(E), E = E.redIAdd(E);
      var B = this.x.redMul(M).redISub(E);
      B = B.redIAdd(B), B = B.redIAdd(B);
      var q = this.y.redMul(S2.redMul(x.redISub(S2)).redISub(y.redMul(M)));
      q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
      var L = this.z.redAdd(y).redSqr().redISub(o).redISub(M);
      return this.curve.jpoint(B, q, L);
    };
    Wt.prototype.mul = function(e, r) {
      return e = new lt(e, r), this.curve._wnafMul(this, e);
    };
    Wt.prototype.eq = function(e) {
      if (e.type === "affine")
        return this.eq(e.toJ());
      if (this === e)
        return true;
      var r = this.z.redSqr(), o = e.z.redSqr();
      if (this.x.redMul(o).redISub(e.x.redMul(r)).cmpn(0) !== 0)
        return false;
      var f = r.redMul(this.z), p = o.redMul(e.z);
      return this.y.redMul(p).redISub(e.y.redMul(f)).cmpn(0) === 0;
    };
    Wt.prototype.eqXToP = function(e) {
      var r = this.z.redSqr(), o = e.toRed(this.curve.red).redMul(r);
      if (this.x.cmp(o) === 0)
        return true;
      for (var f = e.clone(), p = this.curve.redN.redMul(r);; ) {
        if (f.iadd(this.curve.n), f.cmp(this.curve.p) >= 0)
          return false;
        if (o.redIAdd(p), this.x.cmp(o) === 0)
          return true;
      }
    };
    Wt.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    Wt.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
  });
  y2 = T((Ek, g2) => {
    var qf = ri(), m2 = Ie(), Gs = Oa(), MA = or();
    function If(t) {
      Gs.call(this, "mont", t), this.a = new qf(t.a, 16).toRed(this.red), this.b = new qf(t.b, 16).toRed(this.red), this.i4 = new qf(4).toRed(this.red).redInvm(), this.two = new qf(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    m2(If, Gs);
    g2.exports = If;
    If.prototype.validate = function(e) {
      var r = e.normalize().x, o = r.redSqr(), f = o.redMul(r).redAdd(o.redMul(this.a)).redAdd(r), p = f.redSqrt();
      return p.redSqr().cmp(f) === 0;
    };
    function Ot(t, e, r) {
      Gs.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new qf(e, 16), this.z = new qf(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    m2(Ot, Gs.BasePoint);
    If.prototype.decodePoint = function(e, r) {
      return this.point(MA.toArray(e, r), 1);
    };
    If.prototype.point = function(e, r) {
      return new Ot(this, e, r);
    };
    If.prototype.pointFromJSON = function(e) {
      return Ot.fromJSON(this, e);
    };
    Ot.prototype.precompute = function() {
    };
    Ot.prototype._encode = function() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Ot.fromJSON = function(e, r) {
      return new Ot(e, r[0], r[1] || e.one);
    };
    Ot.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Ot.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
    Ot.prototype.dbl = function() {
      var e = this.x.redAdd(this.z), r = e.redSqr(), o = this.x.redSub(this.z), f = o.redSqr(), p = r.redSub(f), m = r.redMul(f), y = p.redMul(f.redAdd(this.curve.a24.redMul(p)));
      return this.curve.point(m, y);
    };
    Ot.prototype.add = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.diffAdd = function(e, r) {
      var o = this.x.redAdd(this.z), f = this.x.redSub(this.z), p = e.x.redAdd(e.z), m = e.x.redSub(e.z), y = m.redMul(o), M = p.redMul(f), x = r.z.redMul(y.redAdd(M).redSqr()), S2 = r.x.redMul(y.redISub(M).redSqr());
      return this.curve.point(x, S2);
    };
    Ot.prototype.mul = function(e) {
      for (var r = e.clone(), o = this, f = this.curve.point(null, null), p = this, m = [];r.cmpn(0) !== 0; r.iushrn(1))
        m.push(r.andln(1));
      for (var y = m.length - 1;y >= 0; y--)
        m[y] === 0 ? (o = o.diffAdd(f, p), f = f.dbl()) : (f = o.diffAdd(f, p), o = o.dbl());
      return f;
    };
    Ot.prototype.mulAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.jumlAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.eq = function(e) {
      return this.getX().cmp(e.getX()) === 0;
    };
    Ot.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    };
    Ot.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
  });
  _2 = T((Ak, M2) => {
    var _A = or(), Ai = ri(), w2 = Ie(), Ys = Oa(), xA = _A.assert;
    function ii(t) {
      this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Ys.call(this, "edwards", t), this.a = new Ai(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Ai(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Ai(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), xA(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
    }
    w2(ii, Ys);
    M2.exports = ii;
    ii.prototype._mulA = function(e) {
      return this.mOneA ? e.redNeg() : this.a.redMul(e);
    };
    ii.prototype._mulC = function(e) {
      return this.oneC ? e : this.c.redMul(e);
    };
    ii.prototype.jpoint = function(e, r, o, f) {
      return this.point(e, r, o, f);
    };
    ii.prototype.pointFromX = function(e, r) {
      e = new Ai(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr(), f = this.c2.redSub(this.a.redMul(o)), p = this.one.redSub(this.c2.redMul(this.d).redMul(o)), m = f.redMul(p.redInvm()), y = m.redSqrt();
      if (y.redSqr().redSub(m).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var M = y.fromRed().isOdd();
      return (r && !M || !r && M) && (y = y.redNeg()), this.point(e, y);
    };
    ii.prototype.pointFromY = function(e, r) {
      e = new Ai(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr(), f = o.redSub(this.c2), p = o.redMul(this.d).redMul(this.c2).redSub(this.a), m = f.redMul(p.redInvm());
      if (m.cmp(this.zero) === 0) {
        if (r)
          throw new Error("invalid point");
        return this.point(this.zero, e);
      }
      var y = m.redSqrt();
      if (y.redSqr().redSub(m).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      return y.fromRed().isOdd() !== r && (y = y.redNeg()), this.point(y, e);
    };
    ii.prototype.validate = function(e) {
      if (e.isInfinity())
        return true;
      e.normalize();
      var r = e.x.redSqr(), o = e.y.redSqr(), f = r.redMul(this.a).redAdd(o), p = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(o)));
      return f.cmp(p) === 0;
    };
    function at(t, e, r, o, f) {
      Ys.BasePoint.call(this, t, "projective"), e === null && r === null && o === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new Ai(e, 16), this.y = new Ai(r, 16), this.z = o ? new Ai(o, 16) : this.curve.one, this.t = f && new Ai(f, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    w2(at, Ys.BasePoint);
    ii.prototype.pointFromJSON = function(e) {
      return at.fromJSON(this, e);
    };
    ii.prototype.point = function(e, r, o, f) {
      return new at(this, e, r, o, f);
    };
    at.fromJSON = function(e, r) {
      return new at(e, r[0], r[1], r[2]);
    };
    at.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    at.prototype.isInfinity = function() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    at.prototype._extDbl = function() {
      var e = this.x.redSqr(), r = this.y.redSqr(), o = this.z.redSqr();
      o = o.redIAdd(o);
      var f = this.curve._mulA(e), p = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), m = f.redAdd(r), y = m.redSub(o), M = f.redSub(r), x = p.redMul(y), S2 = m.redMul(M), E = p.redMul(M), B = y.redMul(m);
      return this.curve.point(x, S2, B, E);
    };
    at.prototype._projDbl = function() {
      var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), o = this.y.redSqr(), f, p, m, y, M, x;
      if (this.curve.twisted) {
        y = this.curve._mulA(r);
        var S2 = y.redAdd(o);
        this.zOne ? (f = e.redSub(r).redSub(o).redMul(S2.redSub(this.curve.two)), p = S2.redMul(y.redSub(o)), m = S2.redSqr().redSub(S2).redSub(S2)) : (M = this.z.redSqr(), x = S2.redSub(M).redISub(M), f = e.redSub(r).redISub(o).redMul(x), p = S2.redMul(y.redSub(o)), m = S2.redMul(x));
      } else
        y = r.redAdd(o), M = this.curve._mulC(this.z).redSqr(), x = y.redSub(M).redSub(M), f = this.curve._mulC(e.redISub(y)).redMul(x), p = this.curve._mulC(y).redMul(r.redISub(o)), m = y.redMul(x);
      return this.curve.point(f, p, m);
    };
    at.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    };
    at.prototype._extAdd = function(e) {
      var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), o = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), f = this.t.redMul(this.curve.dd).redMul(e.t), p = this.z.redMul(e.z.redAdd(e.z)), m = o.redSub(r), y = p.redSub(f), M = p.redAdd(f), x = o.redAdd(r), S2 = m.redMul(y), E = M.redMul(x), B = m.redMul(x), q = y.redMul(M);
      return this.curve.point(S2, E, q, B);
    };
    at.prototype._projAdd = function(e) {
      var r = this.z.redMul(e.z), o = r.redSqr(), f = this.x.redMul(e.x), p = this.y.redMul(e.y), m = this.curve.d.redMul(f).redMul(p), y = o.redSub(m), M = o.redAdd(m), x = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(f).redISub(p), S2 = r.redMul(y).redMul(x), E, B;
      return this.curve.twisted ? (E = r.redMul(M).redMul(p.redSub(this.curve._mulA(f))), B = y.redMul(M)) : (E = r.redMul(M).redMul(p.redSub(f)), B = this.curve._mulC(y).redMul(M)), this.curve.point(S2, E, B);
    };
    at.prototype.add = function(e) {
      return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
    };
    at.prototype.mul = function(e) {
      return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
    };
    at.prototype.mulAdd = function(e, r, o) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o], 2, false);
    };
    at.prototype.jmulAdd = function(e, r, o) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o], 2, true);
    };
    at.prototype.normalize = function() {
      if (this.zOne)
        return this;
      var e = this.z.redInvm();
      return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
    };
    at.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    at.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
    at.prototype.getY = function() {
      return this.normalize(), this.y.fromRed();
    };
    at.prototype.eq = function(e) {
      return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
    };
    at.prototype.eqXToP = function(e) {
      var r = e.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(r) === 0)
        return true;
      for (var o = e.clone(), f = this.curve.redN.redMul(this.z);; ) {
        if (o.iadd(this.curve.n), o.cmp(this.curve.p) >= 0)
          return false;
        if (r.redIAdd(f), this.x.cmp(r) === 0)
          return true;
      }
    };
    at.prototype.toP = at.prototype.normalize;
    at.prototype.mixedAdd = at.prototype.add;
  });
  Pl = T((x2) => {
    var Xs = x2;
    Xs.base = Oa();
    Xs.short = b2();
    Xs.mont = y2();
    Xs.edwards = _2();
  });
  Cr = T((it) => {
    var SA = ar(), EA = Ie();
    it.inherits = EA;
    function AA(t, e) {
      return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
    }
    function RA(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t == "string")
        if (e) {
          if (e === "hex")
            for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), f = 0;f < t.length; f += 2)
              r.push(parseInt(t[f] + t[f + 1], 16));
        } else
          for (var o = 0, f = 0;f < t.length; f++) {
            var p = t.charCodeAt(f);
            p < 128 ? r[o++] = p : p < 2048 ? (r[o++] = p >> 6 | 192, r[o++] = p & 63 | 128) : AA(t, f) ? (p = 65536 + ((p & 1023) << 10) + (t.charCodeAt(++f) & 1023), r[o++] = p >> 18 | 240, r[o++] = p >> 12 & 63 | 128, r[o++] = p >> 6 & 63 | 128, r[o++] = p & 63 | 128) : (r[o++] = p >> 12 | 224, r[o++] = p >> 6 & 63 | 128, r[o++] = p & 63 | 128);
          }
      else
        for (f = 0;f < t.length; f++)
          r[f] = t[f] | 0;
      return r;
    }
    it.toArray = RA;
    function BA(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += E2(t[r].toString(16));
      return e;
    }
    it.toHex = BA;
    function S2(t) {
      var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
      return e >>> 0;
    }
    it.htonl = S2;
    function qA(t, e) {
      for (var r = "", o = 0;o < t.length; o++) {
        var f = t[o];
        e === "little" && (f = S2(f)), r += A2(f.toString(16));
      }
      return r;
    }
    it.toHex32 = qA;
    function E2(t) {
      return t.length === 1 ? "0" + t : t;
    }
    it.zero2 = E2;
    function A2(t) {
      return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
    }
    it.zero8 = A2;
    function IA(t, e, r, o) {
      var f = r - e;
      SA(f % 4 === 0);
      for (var p = new Array(f / 4), m = 0, y = e;m < p.length; m++, y += 4) {
        var M;
        o === "big" ? M = t[y] << 24 | t[y + 1] << 16 | t[y + 2] << 8 | t[y + 3] : M = t[y + 3] << 24 | t[y + 2] << 16 | t[y + 1] << 8 | t[y], p[m] = M >>> 0;
      }
      return p;
    }
    it.join32 = IA;
    function TA(t, e) {
      for (var r = new Array(t.length * 4), o = 0, f = 0;o < t.length; o++, f += 4) {
        var p = t[o];
        e === "big" ? (r[f] = p >>> 24, r[f + 1] = p >>> 16 & 255, r[f + 2] = p >>> 8 & 255, r[f + 3] = p & 255) : (r[f + 3] = p >>> 24, r[f + 2] = p >>> 16 & 255, r[f + 1] = p >>> 8 & 255, r[f] = p & 255);
      }
      return r;
    }
    it.split32 = TA;
    function kA(t, e) {
      return t >>> e | t << 32 - e;
    }
    it.rotr32 = kA;
    function LA(t, e) {
      return t << e | t >>> 32 - e;
    }
    it.rotl32 = LA;
    function NA(t, e) {
      return t + e >>> 0;
    }
    it.sum32 = NA;
    function DA(t, e, r) {
      return t + e + r >>> 0;
    }
    it.sum32_3 = DA;
    function PA(t, e, r, o) {
      return t + e + r + o >>> 0;
    }
    it.sum32_4 = PA;
    function CA(t, e, r, o, f) {
      return t + e + r + o + f >>> 0;
    }
    it.sum32_5 = CA;
    function OA(t, e, r, o) {
      var f = t[e], p = t[e + 1], m = o + p >>> 0, y = (m < o ? 1 : 0) + r + f;
      t[e] = y >>> 0, t[e + 1] = m;
    }
    it.sum64 = OA;
    function FA(t, e, r, o) {
      var f = e + o >>> 0, p = (f < e ? 1 : 0) + t + r;
      return p >>> 0;
    }
    it.sum64_hi = FA;
    function UA(t, e, r, o) {
      var f = e + o;
      return f >>> 0;
    }
    it.sum64_lo = UA;
    function zA(t, e, r, o, f, p, m, y) {
      var M = 0, x = e;
      x = x + o >>> 0, M += x < e ? 1 : 0, x = x + p >>> 0, M += x < p ? 1 : 0, x = x + y >>> 0, M += x < y ? 1 : 0;
      var S3 = t + r + f + m + M;
      return S3 >>> 0;
    }
    it.sum64_4_hi = zA;
    function HA(t, e, r, o, f, p, m, y) {
      var M = e + o + p + y;
      return M >>> 0;
    }
    it.sum64_4_lo = HA;
    function WA(t, e, r, o, f, p, m, y, M, x) {
      var S3 = 0, E = e;
      E = E + o >>> 0, S3 += E < e ? 1 : 0, E = E + p >>> 0, S3 += E < p ? 1 : 0, E = E + y >>> 0, S3 += E < y ? 1 : 0, E = E + x >>> 0, S3 += E < x ? 1 : 0;
      var B = t + r + f + m + M + S3;
      return B >>> 0;
    }
    it.sum64_5_hi = WA;
    function KA(t, e, r, o, f, p, m, y, M, x) {
      var S3 = e + o + p + y + x;
      return S3 >>> 0;
    }
    it.sum64_5_lo = KA;
    function jA(t, e, r) {
      var o = e << 32 - r | t >>> r;
      return o >>> 0;
    }
    it.rotr64_hi = jA;
    function ZA(t, e, r) {
      var o = t << 32 - r | e >>> r;
      return o >>> 0;
    }
    it.rotr64_lo = ZA;
    function VA(t, e, r) {
      return t >>> r;
    }
    it.shr64_hi = VA;
    function $A(t, e, r) {
      var o = t << 32 - r | e >>> r;
      return o >>> 0;
    }
    it.shr64_lo = $A;
  });
  Tf = T((B2) => {
    var R2 = Cr(), GA = ar();
    function Js() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    B2.BlockHash = Js;
    Js.prototype.update = function(e, r) {
      if (e = R2.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
        e = this.pending;
        var o = e.length % this._delta8;
        this.pending = e.slice(e.length - o, e.length), this.pending.length === 0 && (this.pending = null), e = R2.join32(e, 0, e.length - o, this.endian);
        for (var f = 0;f < e.length; f += this._delta32)
          this._update(e, f, f + this._delta32);
      }
      return this;
    };
    Js.prototype.digest = function(e) {
      return this.update(this._pad()), GA(this.pending === null), this._digest(e);
    };
    Js.prototype._pad = function() {
      var e = this.pendingTotal, r = this._delta8, o = r - (e + this.padLength) % r, f = new Array(o + this.padLength);
      f[0] = 128;
      for (var p = 1;p < o; p++)
        f[p] = 0;
      if (e <<= 3, this.endian === "big") {
        for (var m = 8;m < this.padLength; m++)
          f[p++] = 0;
        f[p++] = 0, f[p++] = 0, f[p++] = 0, f[p++] = 0, f[p++] = e >>> 24 & 255, f[p++] = e >>> 16 & 255, f[p++] = e >>> 8 & 255, f[p++] = e & 255;
      } else
        for (f[p++] = e & 255, f[p++] = e >>> 8 & 255, f[p++] = e >>> 16 & 255, f[p++] = e >>> 24 & 255, f[p++] = 0, f[p++] = 0, f[p++] = 0, f[p++] = 0, m = 8;m < this.padLength; m++)
          f[p++] = 0;
      return f;
    };
  });
  Cl = T((Ri) => {
    var YA = Cr(), ni = YA.rotr32;
    function XA(t, e, r, o) {
      if (t === 0)
        return q2(e, r, o);
      if (t === 1 || t === 3)
        return T2(e, r, o);
      if (t === 2)
        return I2(e, r, o);
    }
    Ri.ft_1 = XA;
    function q2(t, e, r) {
      return t & e ^ ~t & r;
    }
    Ri.ch32 = q2;
    function I2(t, e, r) {
      return t & e ^ t & r ^ e & r;
    }
    Ri.maj32 = I2;
    function T2(t, e, r) {
      return t ^ e ^ r;
    }
    Ri.p32 = T2;
    function JA(t) {
      return ni(t, 2) ^ ni(t, 13) ^ ni(t, 22);
    }
    Ri.s0_256 = JA;
    function QA(t) {
      return ni(t, 6) ^ ni(t, 11) ^ ni(t, 25);
    }
    Ri.s1_256 = QA;
    function eR(t) {
      return ni(t, 7) ^ ni(t, 18) ^ t >>> 3;
    }
    Ri.g0_256 = eR;
    function tR(t) {
      return ni(t, 17) ^ ni(t, 19) ^ t >>> 10;
    }
    Ri.g1_256 = tR;
  });
  N2 = T((Tk, L2) => {
    var kf = Cr(), rR = Tf(), iR = Cl(), Ol = kf.rotl32, Fa = kf.sum32, nR = kf.sum32_5, fR = iR.ft_1, k2 = rR.BlockHash, aR = [1518500249, 1859775393, 2400959708, 3395469782];
    function fi() {
      if (!(this instanceof fi))
        return new fi;
      k2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
    }
    kf.inherits(fi, k2);
    L2.exports = fi;
    fi.blockSize = 512;
    fi.outSize = 160;
    fi.hmacStrength = 80;
    fi.padLength = 64;
    fi.prototype._update = function(e, r) {
      for (var o = this.W, f = 0;f < 16; f++)
        o[f] = e[r + f];
      for (;f < o.length; f++)
        o[f] = Ol(o[f - 3] ^ o[f - 8] ^ o[f - 14] ^ o[f - 16], 1);
      var p = this.h[0], m = this.h[1], y = this.h[2], M = this.h[3], x = this.h[4];
      for (f = 0;f < o.length; f++) {
        var S2 = ~~(f / 20), E = nR(Ol(p, 5), fR(S2, m, y, M), x, o[f], aR[S2]);
        x = M, M = y, y = Ol(m, 30), m = p, p = E;
      }
      this.h[0] = Fa(this.h[0], p), this.h[1] = Fa(this.h[1], m), this.h[2] = Fa(this.h[2], y), this.h[3] = Fa(this.h[3], M), this.h[4] = Fa(this.h[4], x);
    };
    fi.prototype._digest = function(e) {
      return e === "hex" ? kf.toHex32(this.h, "big") : kf.split32(this.h, "big");
    };
  });
  Fl = T((kk, P2) => {
    var Lf = Cr(), oR = Tf(), Nf = Cl(), sR = ar(), Or = Lf.sum32, hR = Lf.sum32_4, uR = Lf.sum32_5, lR = Nf.ch32, dR = Nf.maj32, cR = Nf.s0_256, pR = Nf.s1_256, vR = Nf.g0_256, bR = Nf.g1_256, D2 = oR.BlockHash, mR = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function ai() {
      if (!(this instanceof ai))
        return new ai;
      D2.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = mR, this.W = new Array(64);
    }
    Lf.inherits(ai, D2);
    P2.exports = ai;
    ai.blockSize = 512;
    ai.outSize = 256;
    ai.hmacStrength = 192;
    ai.padLength = 64;
    ai.prototype._update = function(e, r) {
      for (var o = this.W, f = 0;f < 16; f++)
        o[f] = e[r + f];
      for (;f < o.length; f++)
        o[f] = hR(bR(o[f - 2]), o[f - 7], vR(o[f - 15]), o[f - 16]);
      var p = this.h[0], m = this.h[1], y = this.h[2], M = this.h[3], x = this.h[4], S2 = this.h[5], E = this.h[6], B = this.h[7];
      for (sR(this.k.length === o.length), f = 0;f < o.length; f++) {
        var q = uR(B, pR(x), lR(x, S2, E), this.k[f], o[f]), L = Or(cR(p), dR(p, m, y));
        B = E, E = S2, S2 = x, x = Or(M, q), M = y, y = m, m = p, p = Or(q, L);
      }
      this.h[0] = Or(this.h[0], p), this.h[1] = Or(this.h[1], m), this.h[2] = Or(this.h[2], y), this.h[3] = Or(this.h[3], M), this.h[4] = Or(this.h[4], x), this.h[5] = Or(this.h[5], S2), this.h[6] = Or(this.h[6], E), this.h[7] = Or(this.h[7], B);
    };
    ai.prototype._digest = function(e) {
      return e === "hex" ? Lf.toHex32(this.h, "big") : Lf.split32(this.h, "big");
    };
  });
  F2 = T((Lk, O2) => {
    var Ul = Cr(), C2 = Fl();
    function Bi() {
      if (!(this instanceof Bi))
        return new Bi;
      C2.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    Ul.inherits(Bi, C2);
    O2.exports = Bi;
    Bi.blockSize = 512;
    Bi.outSize = 224;
    Bi.hmacStrength = 192;
    Bi.padLength = 64;
    Bi.prototype._digest = function(e) {
      return e === "hex" ? Ul.toHex32(this.h.slice(0, 7), "big") : Ul.split32(this.h.slice(0, 7), "big");
    };
  });
  Wl = T((Nk, W2) => {
    var ir = Cr(), gR = Tf(), yR = ar(), oi = ir.rotr64_hi, si = ir.rotr64_lo, U2 = ir.shr64_hi, z2 = ir.shr64_lo, Ji = ir.sum64, zl = ir.sum64_hi, Hl = ir.sum64_lo, wR = ir.sum64_4_hi, MR = ir.sum64_4_lo, _R = ir.sum64_5_hi, xR = ir.sum64_5_lo, H2 = gR.BlockHash, SR = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function Fr2() {
      if (!(this instanceof Fr2))
        return new Fr2;
      H2.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = SR, this.W = new Array(160);
    }
    ir.inherits(Fr2, H2);
    W2.exports = Fr2;
    Fr2.blockSize = 1024;
    Fr2.outSize = 512;
    Fr2.hmacStrength = 192;
    Fr2.padLength = 128;
    Fr2.prototype._prepareBlock = function(e, r) {
      for (var o = this.W, f = 0;f < 32; f++)
        o[f] = e[r + f];
      for (;f < o.length; f += 2) {
        var p = DR(o[f - 4], o[f - 3]), m = PR(o[f - 4], o[f - 3]), y = o[f - 14], M = o[f - 13], x = LR(o[f - 30], o[f - 29]), S2 = NR(o[f - 30], o[f - 29]), E = o[f - 32], B = o[f - 31];
        o[f] = wR(p, m, y, M, x, S2, E, B), o[f + 1] = MR(p, m, y, M, x, S2, E, B);
      }
    };
    Fr2.prototype._update = function(e, r) {
      this._prepareBlock(e, r);
      var o = this.W, f = this.h[0], p = this.h[1], m = this.h[2], y = this.h[3], M = this.h[4], x = this.h[5], S2 = this.h[6], E = this.h[7], B = this.h[8], q = this.h[9], L = this.h[10], ge = this.h[11], _e = this.h[12], N = this.h[13], we = this.h[14], ye = this.h[15];
      yR(this.k.length === o.length);
      for (var xe = 0;xe < o.length; xe += 2) {
        var Re = we, Ee = ye, Ae = TR(B, q), P = kR(B, q), Se = ER(B, q, L, ge, _e, N), v2 = AR(B, q, L, ge, _e, N), i = this.k[xe], a = this.k[xe + 1], h = o[xe], s = o[xe + 1], u = _R(Re, Ee, Ae, P, Se, v2, i, a, h, s), c = xR(Re, Ee, Ae, P, Se, v2, i, a, h, s);
        Re = qR(f, p), Ee = IR(f, p), Ae = RR(f, p, m, y, M, x), P = BR(f, p, m, y, M, x);
        var b3 = zl(Re, Ee, Ae, P), l = Hl(Re, Ee, Ae, P);
        we = _e, ye = N, _e = L, N = ge, L = B, ge = q, B = zl(S2, E, u, c), q = Hl(E, E, u, c), S2 = M, E = x, M = m, x = y, m = f, y = p, f = zl(u, c, b3, l), p = Hl(u, c, b3, l);
      }
      Ji(this.h, 0, f, p), Ji(this.h, 2, m, y), Ji(this.h, 4, M, x), Ji(this.h, 6, S2, E), Ji(this.h, 8, B, q), Ji(this.h, 10, L, ge), Ji(this.h, 12, _e, N), Ji(this.h, 14, we, ye);
    };
    Fr2.prototype._digest = function(e) {
      return e === "hex" ? ir.toHex32(this.h, "big") : ir.split32(this.h, "big");
    };
    function ER(t, e, r, o, f) {
      var p = t & r ^ ~t & f;
      return p < 0 && (p += 4294967296), p;
    }
    function AR(t, e, r, o, f, p) {
      var m = e & o ^ ~e & p;
      return m < 0 && (m += 4294967296), m;
    }
    function RR(t, e, r, o, f) {
      var p = t & r ^ t & f ^ r & f;
      return p < 0 && (p += 4294967296), p;
    }
    function BR(t, e, r, o, f, p) {
      var m = e & o ^ e & p ^ o & p;
      return m < 0 && (m += 4294967296), m;
    }
    function qR(t, e) {
      var r = oi(t, e, 28), o = oi(e, t, 2), f = oi(e, t, 7), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function IR(t, e) {
      var r = si(t, e, 28), o = si(e, t, 2), f = si(e, t, 7), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function TR(t, e) {
      var r = oi(t, e, 14), o = oi(t, e, 18), f = oi(e, t, 9), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function kR(t, e) {
      var r = si(t, e, 14), o = si(t, e, 18), f = si(e, t, 9), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function LR(t, e) {
      var r = oi(t, e, 1), o = oi(t, e, 8), f = U2(t, e, 7), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function NR(t, e) {
      var r = si(t, e, 1), o = si(t, e, 8), f = z2(t, e, 7), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function DR(t, e) {
      var r = oi(t, e, 19), o = oi(e, t, 29), f = U2(t, e, 6), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
    function PR(t, e) {
      var r = si(t, e, 19), o = si(e, t, 29), f = z2(t, e, 6), p = r ^ o ^ f;
      return p < 0 && (p += 4294967296), p;
    }
  });
  Z2 = T((Dk, j2) => {
    var Kl = Cr(), K2 = Wl();
    function qi() {
      if (!(this instanceof qi))
        return new qi;
      K2.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    Kl.inherits(qi, K2);
    j2.exports = qi;
    qi.blockSize = 1024;
    qi.outSize = 384;
    qi.hmacStrength = 192;
    qi.padLength = 128;
    qi.prototype._digest = function(e) {
      return e === "hex" ? Kl.toHex32(this.h.slice(0, 12), "big") : Kl.split32(this.h.slice(0, 12), "big");
    };
  });
  V2 = T((Df) => {
    Df.sha1 = N2();
    Df.sha224 = F2();
    Df.sha256 = Fl();
    Df.sha384 = Z2();
    Df.sha512 = Wl();
  });
  Q2 = T((J2) => {
    var On = Cr(), CR = Tf(), Qs = On.rotl32, $2 = On.sum32, Ua = On.sum32_3, G2 = On.sum32_4, X2 = CR.BlockHash;
    function hi() {
      if (!(this instanceof hi))
        return new hi;
      X2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    On.inherits(hi, X2);
    J2.ripemd160 = hi;
    hi.blockSize = 512;
    hi.outSize = 160;
    hi.hmacStrength = 192;
    hi.padLength = 64;
    hi.prototype._update = function(e, r) {
      for (var o = this.h[0], f = this.h[1], p = this.h[2], m = this.h[3], y = this.h[4], M = o, x = f, S2 = p, E = m, B = y, q = 0;q < 80; q++) {
        var L = $2(Qs(G2(o, Y2(q, f, p, m), e[UR[q] + r], OR(q)), HR[q]), y);
        o = y, y = m, m = Qs(p, 10), p = f, f = L, L = $2(Qs(G2(M, Y2(79 - q, x, S2, E), e[zR[q] + r], FR(q)), WR[q]), B), M = B, B = E, E = Qs(S2, 10), S2 = x, x = L;
      }
      L = Ua(this.h[1], p, E), this.h[1] = Ua(this.h[2], m, B), this.h[2] = Ua(this.h[3], y, M), this.h[3] = Ua(this.h[4], o, x), this.h[4] = Ua(this.h[0], f, S2), this.h[0] = L;
    };
    hi.prototype._digest = function(e) {
      return e === "hex" ? On.toHex32(this.h, "little") : On.split32(this.h, "little");
    };
    function Y2(t, e, r, o) {
      return t <= 15 ? e ^ r ^ o : t <= 31 ? e & r | ~e & o : t <= 47 ? (e | ~r) ^ o : t <= 63 ? e & o | r & ~o : e ^ (r | ~o);
    }
    function OR(t) {
      return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
    }
    function FR(t) {
      return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
    }
    var UR = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], zR = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], HR = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], WR = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  });
  ty = T((Ok, ey) => {
    var KR = Cr(), jR = ar();
    function Pf(t, e, r) {
      if (!(this instanceof Pf))
        return new Pf(t, e, r);
      this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(KR.toArray(e, r));
    }
    ey.exports = Pf;
    Pf.prototype._init = function(e) {
      e.length > this.blockSize && (e = new this.Hash().update(e).digest()), jR(e.length <= this.blockSize);
      for (var r = e.length;r < this.blockSize; r++)
        e.push(0);
      for (r = 0;r < e.length; r++)
        e[r] ^= 54;
      for (this.inner = new this.Hash().update(e), r = 0;r < e.length; r++)
        e[r] ^= 106;
      this.outer = new this.Hash().update(e);
    };
    Pf.prototype.update = function(e, r) {
      return this.inner.update(e, r), this;
    };
    Pf.prototype.digest = function(e) {
      return this.outer.update(this.inner.digest()), this.outer.digest(e);
    };
  });
  e0 = T((ry) => {
    var Kt = ry;
    Kt.utils = Cr();
    Kt.common = Tf();
    Kt.sha = V2();
    Kt.ripemd = Q2();
    Kt.hmac = ty();
    Kt.sha1 = Kt.sha.sha1;
    Kt.sha256 = Kt.sha.sha256;
    Kt.sha224 = Kt.sha.sha224;
    Kt.sha384 = Kt.sha.sha384;
    Kt.sha512 = Kt.sha.sha512;
    Kt.ripemd160 = Kt.ripemd.ripemd160;
  });
  ny = T((Uk, iy) => {
    iy.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
  });
  t0 = T((oy) => {
    var Zl = oy, Qi = e0(), jl = Pl(), ZR = or(), fy = ZR.assert;
    function ay(t) {
      t.type === "short" ? this.curve = new jl.short(t) : t.type === "edwards" ? this.curve = new jl.edwards(t) : this.curve = new jl.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, fy(this.g.validate(), "Invalid curve"), fy(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    Zl.PresetCurve = ay;
    function en(t, e) {
      Object.defineProperty(Zl, t, { configurable: true, enumerable: true, get: function() {
        var r = new ay(e);
        return Object.defineProperty(Zl, t, { configurable: true, enumerable: true, value: r }), r;
      } });
    }
    en("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Qi.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
    en("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Qi.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
    en("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Qi.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
    en("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Qi.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
    en("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Qi.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
    en("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi.sha256, gRed: false, g: ["9"] });
    en("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
    var Vl;
    try {
      Vl = ny();
    } catch {
      Vl = undefined;
    }
    en("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Qi.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", Vl] });
  });
  uy = T((Hk, hy) => {
    var VR = e0(), Fn = Nl(), sy = ar();
    function tn(t) {
      if (!(this instanceof tn))
        return new tn(t);
      this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var e = Fn.toArray(t.entropy, t.entropyEnc || "hex"), r = Fn.toArray(t.nonce, t.nonceEnc || "hex"), o = Fn.toArray(t.pers, t.persEnc || "hex");
      sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, o);
    }
    hy.exports = tn;
    tn.prototype._init = function(e, r, o) {
      var f = e.concat(r).concat(o);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var p = 0;p < this.V.length; p++)
        this.K[p] = 0, this.V[p] = 1;
      this._update(f), this._reseed = 1, this.reseedInterval = 281474976710656;
    };
    tn.prototype._hmac = function() {
      return new VR.hmac(this.hash, this.K);
    };
    tn.prototype._update = function(e) {
      var r = this._hmac().update(this.V).update([0]);
      e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
    };
    tn.prototype.reseed = function(e, r, o, f) {
      typeof r != "string" && (f = o, o = r, r = null), e = Fn.toArray(e, r), o = Fn.toArray(o, f), sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(o || [])), this._reseed = 1;
    };
    tn.prototype.generate = function(e, r, o, f) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      typeof r != "string" && (f = o, o = r, r = null), o && (o = Fn.toArray(o, f || "hex"), this._update(o));
      for (var p = [];p.length < e; )
        this.V = this._hmac().update(this.V).digest(), p = p.concat(this.V);
      var m = p.slice(0, e);
      return this._update(o), this._reseed++, Fn.encode(m, r);
    };
  });
  dy = T((Wk, ly) => {
    var $R = ri(), GR = or(), $l = GR.assert;
    function Gt(t, e) {
      this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
    }
    ly.exports = Gt;
    Gt.fromPublic = function(e, r, o) {
      return r instanceof Gt ? r : new Gt(e, { pub: r, pubEnc: o });
    };
    Gt.fromPrivate = function(e, r, o) {
      return r instanceof Gt ? r : new Gt(e, { priv: r, privEnc: o });
    };
    Gt.prototype.validate = function() {
      var e = this.getPublic();
      return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
    };
    Gt.prototype.getPublic = function(e, r) {
      return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
    };
    Gt.prototype.getPrivate = function(e) {
      return e === "hex" ? this.priv.toString(16, 2) : this.priv;
    };
    Gt.prototype._importPrivate = function(e, r) {
      this.priv = new $R(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
    };
    Gt.prototype._importPublic = function(e, r) {
      if (e.x || e.y) {
        this.ec.curve.type === "mont" ? $l(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && $l(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(e, r);
    };
    Gt.prototype.derive = function(e) {
      return e.validate() || $l(e.validate(), "public point not validated"), e.mul(this.priv).getX();
    };
    Gt.prototype.sign = function(e, r, o) {
      return this.ec.sign(e, this, r, o);
    };
    Gt.prototype.verify = function(e, r) {
      return this.ec.verify(e, r, this);
    };
    Gt.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  });
  vy = T((Kk, py) => {
    var r0 = ri(), Xl = or(), YR = Xl.assert;
    function i0(t, e) {
      if (t instanceof i0)
        return t;
      this._importDER(t, e) || (YR(t.r && t.s, "Signature without r or s"), this.r = new r0(t.r, 16), this.s = new r0(t.s, 16), t.recoveryParam === undefined ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
    }
    py.exports = i0;
    function XR() {
      this.place = 0;
    }
    function Gl(t, e) {
      var r = t[e.place++];
      if (!(r & 128))
        return r;
      var o = r & 15;
      if (o === 0 || o > 4)
        return false;
      for (var f = 0, p = 0, m = e.place;p < o; p++, m++)
        f <<= 8, f |= t[m], f >>>= 0;
      return f <= 127 ? false : (e.place = m, f);
    }
    function cy(t) {
      for (var e = 0, r = t.length - 1;!t[e] && !(t[e + 1] & 128) && e < r; )
        e++;
      return e === 0 ? t : t.slice(e);
    }
    i0.prototype._importDER = function(e, r) {
      e = Xl.toArray(e, r);
      var o = new XR;
      if (e[o.place++] !== 48)
        return false;
      var f = Gl(e, o);
      if (f === false || f + o.place !== e.length || e[o.place++] !== 2)
        return false;
      var p = Gl(e, o);
      if (p === false)
        return false;
      var m = e.slice(o.place, p + o.place);
      if (o.place += p, e[o.place++] !== 2)
        return false;
      var y = Gl(e, o);
      if (y === false || e.length !== y + o.place)
        return false;
      var M = e.slice(o.place, y + o.place);
      if (m[0] === 0)
        if (m[1] & 128)
          m = m.slice(1);
        else
          return false;
      if (M[0] === 0)
        if (M[1] & 128)
          M = M.slice(1);
        else
          return false;
      return this.r = new r0(m), this.s = new r0(M), this.recoveryParam = null, true;
    };
    function Yl(t, e) {
      if (e < 128) {
        t.push(e);
        return;
      }
      var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
      for (t.push(r | 128);--r; )
        t.push(e >>> (r << 3) & 255);
      t.push(e);
    }
    i0.prototype.toDER = function(e) {
      var r = this.r.toArray(), o = this.s.toArray();
      for (r[0] & 128 && (r = [0].concat(r)), o[0] & 128 && (o = [0].concat(o)), r = cy(r), o = cy(o);!o[0] && !(o[1] & 128); )
        o = o.slice(1);
      var f = [2];
      Yl(f, r.length), f = f.concat(r), f.push(2), Yl(f, o.length);
      var p = f.concat(o), m = [48];
      return Yl(m, p.length), m = m.concat(p), Xl.encode(m, e);
    };
  });
  yy = T((jk, gy) => {
    var Un = ri(), by = uy(), JR = or(), Jl = t0(), QR = As(), my = JR.assert, Ql = dy(), n0 = vy();
    function Sr(t) {
      if (!(this instanceof Sr))
        return new Sr(t);
      typeof t == "string" && (my(Object.prototype.hasOwnProperty.call(Jl, t), "Unknown curve " + t), t = Jl[t]), t instanceof Jl.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
    }
    gy.exports = Sr;
    Sr.prototype.keyPair = function(e) {
      return new Ql(this, e);
    };
    Sr.prototype.keyFromPrivate = function(e, r) {
      return Ql.fromPrivate(this, e, r);
    };
    Sr.prototype.keyFromPublic = function(e, r) {
      return Ql.fromPublic(this, e, r);
    };
    Sr.prototype.genKeyPair = function(e) {
      e || (e = {});
      for (var r = new by({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || QR(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), o = this.n.byteLength(), f = this.n.sub(new Un(2));; ) {
        var p = new Un(r.generate(o));
        if (!(p.cmp(f) > 0))
          return p.iaddn(1), this.keyFromPrivate(p);
      }
    };
    Sr.prototype._truncateToN = function(e, r) {
      var o = e.byteLength() * 8 - this.n.bitLength();
      return o > 0 && (e = e.ushrn(o)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
    };
    Sr.prototype.sign = function(e, r, o, f) {
      typeof o == "object" && (f = o, o = null), f || (f = {}), r = this.keyFromPrivate(r, o), e = this._truncateToN(new Un(e, 16));
      for (var p = this.n.byteLength(), m = r.getPrivate().toArray("be", p), y = e.toArray("be", p), M = new by({ hash: this.hash, entropy: m, nonce: y, pers: f.pers, persEnc: f.persEnc || "utf8" }), x = this.n.sub(new Un(1)), S2 = 0;; S2++) {
        var E = f.k ? f.k(S2) : new Un(M.generate(this.n.byteLength()));
        if (E = this._truncateToN(E, true), !(E.cmpn(1) <= 0 || E.cmp(x) >= 0)) {
          var B = this.g.mul(E);
          if (!B.isInfinity()) {
            var q = B.getX(), L = q.umod(this.n);
            if (L.cmpn(0) !== 0) {
              var ge = E.invm(this.n).mul(L.mul(r.getPrivate()).iadd(e));
              if (ge = ge.umod(this.n), ge.cmpn(0) !== 0) {
                var _e = (B.getY().isOdd() ? 1 : 0) | (q.cmp(L) !== 0 ? 2 : 0);
                return f.canonical && ge.cmp(this.nh) > 0 && (ge = this.n.sub(ge), _e ^= 1), new n0({ r: L, s: ge, recoveryParam: _e });
              }
            }
          }
        }
      }
    };
    Sr.prototype.verify = function(e, r, o, f) {
      e = this._truncateToN(new Un(e, 16)), o = this.keyFromPublic(o, f), r = new n0(r, "hex");
      var { r: p, s: m } = r;
      if (p.cmpn(1) < 0 || p.cmp(this.n) >= 0 || m.cmpn(1) < 0 || m.cmp(this.n) >= 0)
        return false;
      var y = m.invm(this.n), M = y.mul(e).umod(this.n), x = y.mul(p).umod(this.n), S2;
      return this.curve._maxwellTrick ? (S2 = this.g.jmulAdd(M, o.getPublic(), x), S2.isInfinity() ? false : S2.eqXToP(p)) : (S2 = this.g.mulAdd(M, o.getPublic(), x), S2.isInfinity() ? false : S2.getX().umod(this.n).cmp(p) === 0);
    };
    Sr.prototype.recoverPubKey = function(t, e, r, o) {
      my((3 & r) === r, "The recovery param is more than two bits"), e = new n0(e, o);
      var f = this.n, p = new Un(t), m = e.r, y = e.s, M = r & 1, x = r >> 1;
      if (m.cmp(this.curve.p.umod(this.curve.n)) >= 0 && x)
        throw new Error("Unable to find sencond key candinate");
      x ? m = this.curve.pointFromX(m.add(this.curve.n), M) : m = this.curve.pointFromX(m, M);
      var S2 = e.r.invm(f), E = f.sub(p).mul(S2).umod(f), B = y.mul(S2).umod(f);
      return this.g.mulAdd(E, m, B);
    };
    Sr.prototype.getKeyRecoveryParam = function(t, e, r, o) {
      if (e = new n0(e, o), e.recoveryParam !== null)
        return e.recoveryParam;
      for (var f = 0;f < 4; f++) {
        var p;
        try {
          p = this.recoverPubKey(t, e, f);
        } catch {
          continue;
        }
        if (p.eq(r))
          return f;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  });
  xy = T((Zk, _y) => {
    var za = or(), My = za.assert, wy = za.parseBytes, Cf = za.cachedProperty;
    function Ft(t, e) {
      this.eddsa = t, this._secret = wy(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = wy(e.pub);
    }
    Ft.fromPublic = function(e, r) {
      return r instanceof Ft ? r : new Ft(e, { pub: r });
    };
    Ft.fromSecret = function(e, r) {
      return r instanceof Ft ? r : new Ft(e, { secret: r });
    };
    Ft.prototype.secret = function() {
      return this._secret;
    };
    Cf(Ft, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub());
    });
    Cf(Ft, "pub", function() {
      return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    });
    Cf(Ft, "privBytes", function() {
      var e = this.eddsa, r = this.hash(), o = e.encodingLength - 1, f = r.slice(0, e.encodingLength);
      return f[0] &= 248, f[o] &= 127, f[o] |= 64, f;
    });
    Cf(Ft, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    Cf(Ft, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    Cf(Ft, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    Ft.prototype.sign = function(e) {
      return My(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
    };
    Ft.prototype.verify = function(e, r) {
      return this.eddsa.verify(e, r, this);
    };
    Ft.prototype.getSecret = function(e) {
      return My(this._secret, "KeyPair is public only"), za.encode(this.secret(), e);
    };
    Ft.prototype.getPublic = function(e) {
      return za.encode(this.pubBytes(), e);
    };
    _y.exports = Ft;
  });
  Ey = T((Vk, Sy) => {
    var eB = ri(), f0 = or(), tB = f0.assert, a0 = f0.cachedProperty, rB = f0.parseBytes;
    function zn(t, e) {
      this.eddsa = t, typeof e != "object" && (e = rB(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), tB(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof eB && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
    }
    a0(zn, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    a0(zn, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    a0(zn, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R());
    });
    a0(zn, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S());
    });
    zn.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded());
    };
    zn.prototype.toHex = function() {
      return f0.encode(this.toBytes(), "hex").toUpperCase();
    };
    Sy.exports = zn;
  });
  Iy = T(($k, qy) => {
    var iB = e0(), nB = t0(), Of = or(), fB = Of.assert, Ry = Of.parseBytes, By = xy(), Ay = Ey();
    function nr(t) {
      if (fB(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof nr))
        return new nr(t);
      t = nB[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = iB.sha512;
    }
    qy.exports = nr;
    nr.prototype.sign = function(e, r) {
      e = Ry(e);
      var o = this.keyFromSecret(r), f = this.hashInt(o.messagePrefix(), e), p = this.g.mul(f), m = this.encodePoint(p), y = this.hashInt(m, o.pubBytes(), e).mul(o.priv()), M = f.add(y).umod(this.curve.n);
      return this.makeSignature({ R: p, S: M, Rencoded: m });
    };
    nr.prototype.verify = function(e, r, o) {
      e = Ry(e), r = this.makeSignature(r);
      var f = this.keyFromPublic(o), p = this.hashInt(r.Rencoded(), f.pubBytes(), e), m = this.g.mul(r.S()), y = r.R().add(f.pub().mul(p));
      return y.eq(m);
    };
    nr.prototype.hashInt = function() {
      for (var e = this.hash(), r = 0;r < arguments.length; r++)
        e.update(arguments[r]);
      return Of.intFromLE(e.digest()).umod(this.curve.n);
    };
    nr.prototype.keyFromPublic = function(e) {
      return By.fromPublic(this, e);
    };
    nr.prototype.keyFromSecret = function(e) {
      return By.fromSecret(this, e);
    };
    nr.prototype.makeSignature = function(e) {
      return e instanceof Ay ? e : new Ay(this, e);
    };
    nr.prototype.encodePoint = function(e) {
      var r = e.getY().toArray("le", this.encodingLength);
      return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
    };
    nr.prototype.decodePoint = function(e) {
      e = Of.parseBytes(e);
      var r = e.length - 1, o = e.slice(0, r).concat(e[r] & -129), f = (e[r] & 128) !== 0, p = Of.intFromLE(o);
      return this.curve.pointFromY(p, f);
    };
    nr.prototype.encodeInt = function(e) {
      return e.toArray("le", this.encodingLength);
    };
    nr.prototype.decodeInt = function(e) {
      return Of.intFromLE(e);
    };
    nr.prototype.isPoint = function(e) {
      return e instanceof this.pointClass;
    };
  });
  o0 = T((Ty) => {
    var Hn = Ty;
    Hn.version = s2().version;
    Hn.utils = or();
    Hn.rand = As();
    Hn.curve = Pl();
    Hn.curves = t0();
    Hn.ec = yy();
    Hn.eddsa = Iy();
  });
  td = T((ky, ed) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o(v2, i) {
        v2.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v2.prototype = new a, v2.prototype.constructor = v2;
      }
      function f(v2, i, a) {
        if (f.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v2 || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b3 = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
        return this.strip();
      };
      function m(v2, i) {
        var a = v2.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v2, i, a) {
        var h = m(v2, a);
        return a - 1 >= i && (h |= m(v2, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b3;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b3 = y(i, a, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b3 = y(i, a, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v2, i, a, h) {
        for (var s = 0, u = Math.min(v2.length, a), c = i;c < u; c++) {
          var b3 = v2.charCodeAt(c) - 48;
          s *= h, b3 >= 49 ? s += b3 - 49 + 10 : b3 >= 17 ? s += b3 - 17 + 10 : s += b3;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b3 = c % s, l = Math.min(c, c - b3) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b3 !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b3; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b3 = this.words[c], l = ((b3 << s | u) & 16777215).toString(16);
            u = b3 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b3 = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b3[n] = l;
          for (;n < u; n++)
            b3[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b3[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b3[u - n - 1] = l;
        }
        return b3;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v2) {
        for (var i = new Array(v2.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v2.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b3 = 0;b3 < u.length; b3++)
          a = (s.words[b3] | 0) - (u.words[b3] | 0) + c, c = a >> 26, this.words[b3] = a & 67108863;
        for (;c !== 0 && b3 < s.length; b3++)
          a = (s.words[b3] | 0) + c, c = a >> 26, this.words[b3] = a & 67108863;
        if (c === 0 && b3 < s.length && s !== this)
          for (;b3 < s.length; b3++)
            this.words[b3] = s.words[b3];
        return this.length = Math.max(this.length, b3), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a) {
        a.negative = i.negative ^ v2.negative;
        var h = v2.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v2.words[0] | 0, u = i.words[0] | 0, c = s * u, b3 = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b3;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _3 = Math.max(0, n - v2.length + 1);_3 <= g; _3++) {
            var A = n - _3 | 0;
            s = v2.words[A] | 0, u = i.words[_3] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b3 = 0, l, n, d, w = s[0] | 0, g = w & 8191, _3 = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D2 = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z2 = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $2 = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = u[1] | 0, Q3 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J2), n = n + Math.imul(_3, X) | 0, d = Math.imul(_3, J2);
        var ft = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J2), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J2), l = l + Math.imul(g, Q3) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_3, Q3) | 0, d = d + Math.imul(_3, ee) | 0;
        var Be = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J2), n = n + Math.imul(D2, X) | 0, d = Math.imul(D2, J2), l = l + Math.imul(R, Q3) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q3) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_3, te) | 0, d = d + Math.imul(_3, re) | 0;
        var qe = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J2), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J2), l = l + Math.imul(k, Q3) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D2, Q3) | 0, d = d + Math.imul(D2, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_3, ie) | 0, d = d + Math.imul(_3, ne) | 0;
        var ze = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J2), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J2), l = l + Math.imul(C, Q3) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q3) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D2, te) | 0, d = d + Math.imul(D2, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_3, fe) | 0, d = d + Math.imul(_3, ae) | 0;
        var He = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z2, X), n = Math.imul(z2, J2), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J2), l = l + Math.imul(F, Q3) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q3) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D2, ie) | 0, d = d + Math.imul(D2, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_3, oe) | 0, d = d + Math.imul(_3, se) | 0;
        var We = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J2), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J2), l = l + Math.imul(z2, Q3) | 0, n = n + Math.imul(z2, ee) | 0, n = n + Math.imul(H, Q3) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D2, fe) | 0, d = d + Math.imul(D2, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_3, he) | 0, d = d + Math.imul(_3, ue) | 0;
        var Ke = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J2), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J2), l = l + Math.imul(W, Q3) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q3) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z2, te) | 0, n = n + Math.imul(z2, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D2, oe) | 0, d = d + Math.imul(D2, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_3, le) | 0, d = d + Math.imul(_3, de) | 0;
        var je = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J2), n = n + Math.imul($2, X) | 0, d = Math.imul($2, J2), l = l + Math.imul(j, Q3) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q3) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z2, ie) | 0, n = n + Math.imul(z2, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D2, he) | 0, d = d + Math.imul(D2, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_3, ce) | 0, d = d + Math.imul(_3, pe) | 0;
        var Ze = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J2), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J2), l = l + Math.imul(V, Q3) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($2, Q3) | 0, d = d + Math.imul($2, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z2, fe) | 0, n = n + Math.imul(z2, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D2, le) | 0, d = d + Math.imul(D2, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_3, ve) | 0, d = d + Math.imul(_3, be) | 0;
        var Ve = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q3), n = Math.imul(G, ee), n = n + Math.imul(Y, Q3) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($2, te) | 0, d = d + Math.imul($2, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z2, oe) | 0, n = n + Math.imul(z2, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D2, ce) | 0, d = d + Math.imul(D2, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($2, ie) | 0, d = d + Math.imul($2, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z2, he) | 0, n = n + Math.imul(z2, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D2, ve) | 0, d = d + Math.imul(D2, be) | 0;
        var Ge = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($2, fe) | 0, d = d + Math.imul($2, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z2, le) | 0, n = n + Math.imul(z2, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($2, oe) | 0, d = d + Math.imul($2, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z2, ce) | 0, n = n + Math.imul(z2, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($2, he) | 0, d = d + Math.imul($2, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z2, ve) | 0, n = n + Math.imul(z2, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($2, le) | 0, d = d + Math.imul($2, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($2, ce) | 0, d = d + Math.imul($2, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($2, ve) | 0, d = d + Math.imul($2, be) | 0;
        var tt = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        return b3 = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b3 !== 0 && (c[19] = b3, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v2, i, a) {
        a.negative = i.negative ^ v2.negative, a.length = v2.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b3 = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v2.length + 1);n <= l; n++) {
            var d = u - n, w = v2.words[d] | 0, g = i.words[n] | 0, _3 = w * g, A = _3 & 67108863;
            c = c + (_3 / 67108864 | 0) | 0, A = A + b3 | 0, b3 = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b3, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v2, i, a) {
        var h = new N;
        return h.mulp(v2, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v2, i) {
        this.x = v2, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b3 = 0;b3 < c; b3++)
          s[b3] = a[i[b3]], u[b3] = h[i[b3]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b3 = 1;b3 < u; b3 <<= 1)
          for (var l = b3 << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _3 = d, A = 0;A < b3; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b3], k = s[w + A + b3], D2 = g * Me - _3 * k;
              k = g * k + _3 * Me, Me = D2, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b3] = R - Me, s[w + A + b3] = I - k, A !== l && (D2 = n * g - d * _3, _3 = n * _3 + d * g, g = D2);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b3 = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _3 = h.words;
        _3.length = s, this.convert13b(i.words, i.length, b3, s), this.convert13b(a.words, a.length, d, s), this.transform(b3, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _3, c, s, u), this.conjugate(_3, c, s), this.normalize13b(_3, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b3 = this.words[u] & s, l = (this.words[u] | 0) - b3 << a;
            this.words[u] = l | c, c = b3 >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b3 = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b3;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b3 = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b3;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b3 = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b3, b3 = c >> 26, this.words[u + h] = c & 67108863;
        if (b3 === 0)
          return this.strip();
        for (r(b3 === -1), b3 = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b3, b3 = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b3 = this._countBits(c);
        h = 26 - b3, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _3 = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_3 = Math.min(_3 / c | 0, 67108863), s._ishlnsubmul(u, _3, g);s.negative !== 0; )
            _3--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _3);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b3 = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _3 = 0, A = 1;(h.words[0] & A) === 0 && _3 < 26; ++_3, A <<= 1)
            ;
          if (_3 > 0)
            for (h.iushrn(_3);_3-- > 0; )
              (c.isOdd() || b3.isOdd()) && (c.iadd(n), b3.isub(d)), c.iushrn(1), b3.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b3)) : (h.isub(a), c.isub(s), b3.isub(u));
        }
        return { a: c, b: b3, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b3 = 0, l = 1;(a.words[0] & l) === 0 && b3 < 26; ++b3, l <<= 1)
            ;
          if (b3 > 0)
            for (a.iushrn(b3);b3-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b3 = this.words[c] | 0;
          b3 += u, u = b3 >>> 26, b3 &= 67108863, this.words[c] = b3;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v2, i) {
        this.name = v2, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b3 = i.words[u] | 0;
          i.words[u - 10] = (b3 & h) << 4 | c >>> 22, c = b3;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v2) {
        if (typeof v2 == "string") {
          var i = f._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b3 = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b3) !== 0; )
          n.redIAdd(b3);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _3 = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _3);
          var I = this.pow(d, new f(1).iushln(_3 - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _3 = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b3 = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b3 === 0) {
              l = 0;
              continue;
            }
            b3 <<= 1, b3 |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b3]), l = 0, b3 = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v2) {
        P.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof ed > "u" || ed, ky);
  });
  h0 = T((Yk, Ly) => {
    var s0 = Ut(), Ff = s0.Buffer, Er2 = {}, Ar;
    for (Ar in s0)
      !s0.hasOwnProperty(Ar) || Ar === "SlowBuffer" || Ar === "Buffer" || (Er2[Ar] = s0[Ar]);
    var Uf = Er2.Buffer = {};
    for (Ar in Ff)
      !Ff.hasOwnProperty(Ar) || Ar === "allocUnsafe" || Ar === "allocUnsafeSlow" || (Uf[Ar] = Ff[Ar]);
    Er2.Buffer.prototype = Ff.prototype;
    (!Uf.from || Uf.from === Uint8Array.from) && (Uf.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
      if (t && typeof t.length > "u")
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      return Ff(t, e, r);
    });
    Uf.alloc || (Uf.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
      if (t < 0 || t >= 2 * (1 << 30))
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      var o = Ff(t);
      return !e || e.length === 0 ? o.fill(0) : typeof r == "string" ? o.fill(e, r) : o.fill(e), o;
    });
    if (!Er2.kStringMaxLength)
      try {
        Er2.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch {
      }
    Er2.constants || (Er2.constants = { MAX_LENGTH: Er2.kMaxLength }, Er2.kStringMaxLength && (Er2.constants.MAX_STRING_LENGTH = Er2.kStringMaxLength));
    Ly.exports = Er2;
  });
  u0 = T((Ny) => {
    var aB = Ie();
    function Rr(t) {
      this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
    }
    Ny.Reporter = Rr;
    Rr.prototype.isError = function(e) {
      return e instanceof zf;
    };
    Rr.prototype.save = function() {
      let e = this._reporterState;
      return { obj: e.obj, pathLen: e.path.length };
    };
    Rr.prototype.restore = function(e) {
      let r = this._reporterState;
      r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
    };
    Rr.prototype.enterKey = function(e) {
      return this._reporterState.path.push(e);
    };
    Rr.prototype.exitKey = function(e) {
      let r = this._reporterState;
      r.path = r.path.slice(0, e - 1);
    };
    Rr.prototype.leaveKey = function(e, r, o) {
      let f = this._reporterState;
      this.exitKey(e), f.obj !== null && (f.obj[r] = o);
    };
    Rr.prototype.path = function() {
      return this._reporterState.path.join("/");
    };
    Rr.prototype.enterObject = function() {
      let e = this._reporterState, r = e.obj;
      return e.obj = {}, r;
    };
    Rr.prototype.leaveObject = function(e) {
      let r = this._reporterState, o = r.obj;
      return r.obj = e, o;
    };
    Rr.prototype.error = function(e) {
      let r, o = this._reporterState, f = e instanceof zf;
      if (f ? r = e : r = new zf(o.path.map(function(p) {
        return "[" + JSON.stringify(p) + "]";
      }).join(""), e.message || e, e.stack), !o.options.partial)
        throw r;
      return f || o.errors.push(r), r;
    };
    Rr.prototype.wrapResult = function(e) {
      let r = this._reporterState;
      return r.options.partial ? { result: this.isError(e) ? null : e, errors: r.errors } : e;
    };
    function zf(t, e) {
      this.path = t, this.rethrow(e);
    }
    aB(zf, Error);
    zf.prototype.rethrow = function(e) {
      if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, zf), !this.stack)
        try {
          throw new Error(this.message);
        } catch (r) {
          this.stack = r.stack;
        }
      return this;
    };
  });
  Kf = T((rd) => {
    var oB = Ie(), l0 = u0().Reporter, Hf = h0().Buffer;
    function Br(t, e) {
      if (l0.call(this, e), !Hf.isBuffer(t)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = t, this.offset = 0, this.length = t.length;
    }
    oB(Br, l0);
    rd.DecoderBuffer = Br;
    Br.isDecoderBuffer = function(e) {
      return e instanceof Br ? true : typeof e == "object" && Hf.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
    };
    Br.prototype.save = function() {
      return { offset: this.offset, reporter: l0.prototype.save.call(this) };
    };
    Br.prototype.restore = function(e) {
      let r = new Br(this.base);
      return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, l0.prototype.restore.call(this, e.reporter), r;
    };
    Br.prototype.isEmpty = function() {
      return this.offset === this.length;
    };
    Br.prototype.readUInt8 = function(e) {
      return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
    };
    Br.prototype.skip = function(e, r) {
      if (!(this.offset + e <= this.length))
        return this.error(r || "DecoderBuffer overrun");
      let o = new Br(this.base);
      return o._reporterState = this._reporterState, o.offset = this.offset, o.length = this.offset + e, this.offset += e, o;
    };
    Br.prototype.raw = function(e) {
      return this.base.slice(e ? e.offset : this.offset, this.length);
    };
    function Wf(t, e) {
      if (Array.isArray(t))
        this.length = 0, this.value = t.map(function(r) {
          return Wf.isEncoderBuffer(r) || (r = new Wf(r, e)), this.length += r.length, r;
        }, this);
      else if (typeof t == "number") {
        if (!(0 <= t && t <= 255))
          return e.error("non-byte EncoderBuffer value");
        this.value = t, this.length = 1;
      } else if (typeof t == "string")
        this.value = t, this.length = Hf.byteLength(t);
      else if (Hf.isBuffer(t))
        this.value = t, this.length = t.length;
      else
        return e.error("Unsupported type: " + typeof t);
    }
    rd.EncoderBuffer = Wf;
    Wf.isEncoderBuffer = function(e) {
      return e instanceof Wf ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
    };
    Wf.prototype.join = function(e, r) {
      return e || (e = Hf.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(o) {
        o.join(e, r), r += o.length;
      }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : Hf.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;
    };
  });
  d0 = T((Qk, Py) => {
    var sB = u0().Reporter, hB = Kf().EncoderBuffer, uB = Kf().DecoderBuffer, Qt = ar(), Dy = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], lB = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Dy), dB = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function Ue(t, e, r) {
      let o = {};
      this._baseState = o, o.name = r, o.enc = t, o.parent = e || null, o.children = null, o.tag = null, o.args = null, o.reverseArgs = null, o.choice = null, o.optional = false, o.any = false, o.obj = false, o.use = null, o.useDecoder = null, o.key = null, o.default = null, o.explicit = null, o.implicit = null, o.contains = null, o.parent || (o.children = [], this._wrap());
    }
    Py.exports = Ue;
    var cB = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    Ue.prototype.clone = function() {
      let e = this._baseState, r = {};
      cB.forEach(function(f) {
        r[f] = e[f];
      });
      let o = new this.constructor(r.parent);
      return o._baseState = r, o;
    };
    Ue.prototype._wrap = function() {
      let e = this._baseState;
      lB.forEach(function(r) {
        this[r] = function() {
          let f = new this.constructor(this);
          return e.children.push(f), f[r].apply(f, arguments);
        };
      }, this);
    };
    Ue.prototype._init = function(e) {
      let r = this._baseState;
      Qt(r.parent === null), e.call(this), r.children = r.children.filter(function(o) {
        return o._baseState.parent === this;
      }, this), Qt.equal(r.children.length, 1, "Root node can have only one child");
    };
    Ue.prototype._useArgs = function(e) {
      let r = this._baseState, o = e.filter(function(f) {
        return f instanceof this.constructor;
      }, this);
      e = e.filter(function(f) {
        return !(f instanceof this.constructor);
      }, this), o.length !== 0 && (Qt(r.children === null), r.children = o, o.forEach(function(f) {
        f._baseState.parent = this;
      }, this)), e.length !== 0 && (Qt(r.args === null), r.args = e, r.reverseArgs = e.map(function(f) {
        if (typeof f != "object" || f.constructor !== Object)
          return f;
        let p = {};
        return Object.keys(f).forEach(function(m) {
          m == (m | 0) && (m |= 0);
          let y = f[m];
          p[y] = m;
        }), p;
      }));
    };
    dB.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState;
        throw new Error(t + " not implemented for encoding: " + r.enc);
      };
    });
    Dy.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState, o = Array.prototype.slice.call(arguments);
        return Qt(r.tag === null), r.tag = t, this._useArgs(o), this;
      };
    });
    Ue.prototype.use = function(e) {
      Qt(e);
      let r = this._baseState;
      return Qt(r.use === null), r.use = e, this;
    };
    Ue.prototype.optional = function() {
      let e = this._baseState;
      return e.optional = true, this;
    };
    Ue.prototype.def = function(e) {
      let r = this._baseState;
      return Qt(r.default === null), r.default = e, r.optional = true, this;
    };
    Ue.prototype.explicit = function(e) {
      let r = this._baseState;
      return Qt(r.explicit === null && r.implicit === null), r.explicit = e, this;
    };
    Ue.prototype.implicit = function(e) {
      let r = this._baseState;
      return Qt(r.explicit === null && r.implicit === null), r.implicit = e, this;
    };
    Ue.prototype.obj = function() {
      let e = this._baseState, r = Array.prototype.slice.call(arguments);
      return e.obj = true, r.length !== 0 && this._useArgs(r), this;
    };
    Ue.prototype.key = function(e) {
      let r = this._baseState;
      return Qt(r.key === null), r.key = e, this;
    };
    Ue.prototype.any = function() {
      let e = this._baseState;
      return e.any = true, this;
    };
    Ue.prototype.choice = function(e) {
      let r = this._baseState;
      return Qt(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(o) {
        return e[o];
      })), this;
    };
    Ue.prototype.contains = function(e) {
      let r = this._baseState;
      return Qt(r.use === null), r.contains = e, this;
    };
    Ue.prototype._decode = function(e, r) {
      let o = this._baseState;
      if (o.parent === null)
        return e.wrapResult(o.children[0]._decode(e, r));
      let f = o.default, p = true, m = null;
      if (o.key !== null && (m = e.enterKey(o.key)), o.optional) {
        let M = null;
        if (o.explicit !== null ? M = o.explicit : o.implicit !== null ? M = o.implicit : o.tag !== null && (M = o.tag), M === null && !o.any) {
          let x = e.save();
          try {
            o.choice === null ? this._decodeGeneric(o.tag, e, r) : this._decodeChoice(e, r), p = true;
          } catch {
            p = false;
          }
          e.restore(x);
        } else if (p = this._peekTag(e, M, o.any), e.isError(p))
          return p;
      }
      let y;
      if (o.obj && p && (y = e.enterObject()), p) {
        if (o.explicit !== null) {
          let x = this._decodeTag(e, o.explicit);
          if (e.isError(x))
            return x;
          e = x;
        }
        let M = e.offset;
        if (o.use === null && o.choice === null) {
          let x;
          o.any && (x = e.save());
          let S2 = this._decodeTag(e, o.implicit !== null ? o.implicit : o.tag, o.any);
          if (e.isError(S2))
            return S2;
          o.any ? f = e.raw(x) : e = S2;
        }
        if (r && r.track && o.tag !== null && r.track(e.path(), M, e.length, "tagged"), r && r.track && o.tag !== null && r.track(e.path(), e.offset, e.length, "content"), o.any || (o.choice === null ? f = this._decodeGeneric(o.tag, e, r) : f = this._decodeChoice(e, r)), e.isError(f))
          return f;
        if (!o.any && o.choice === null && o.children !== null && o.children.forEach(function(S2) {
          S2._decode(e, r);
        }), o.contains && (o.tag === "octstr" || o.tag === "bitstr")) {
          let x = new uB(f);
          f = this._getUse(o.contains, e._reporterState.obj)._decode(x, r);
        }
      }
      return o.obj && p && (f = e.leaveObject(y)), o.key !== null && (f !== null || p === true) ? e.leaveKey(m, o.key, f) : m !== null && e.exitKey(m), f;
    };
    Ue.prototype._decodeGeneric = function(e, r, o) {
      let f = this._baseState;
      return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, f.args[0], o) : /str$/.test(e) ? this._decodeStr(r, e, o) : e === "objid" && f.args ? this._decodeObjid(r, f.args[0], f.args[1], o) : e === "objid" ? this._decodeObjid(r, null, null, o) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, o) : e === "null_" ? this._decodeNull(r, o) : e === "bool" ? this._decodeBool(r, o) : e === "objDesc" ? this._decodeStr(r, e, o) : e === "int" || e === "enum" ? this._decodeInt(r, f.args && f.args[0], o) : f.use !== null ? this._getUse(f.use, r._reporterState.obj)._decode(r, o) : r.error("unknown tag: " + e);
    };
    Ue.prototype._getUse = function(e, r) {
      let o = this._baseState;
      return o.useDecoder = this._use(e, r), Qt(o.useDecoder._baseState.parent === null), o.useDecoder = o.useDecoder._baseState.children[0], o.implicit !== o.useDecoder._baseState.implicit && (o.useDecoder = o.useDecoder.clone(), o.useDecoder._baseState.implicit = o.implicit), o.useDecoder;
    };
    Ue.prototype._decodeChoice = function(e, r) {
      let o = this._baseState, f = null, p = false;
      return Object.keys(o.choice).some(function(m) {
        let y = e.save(), M = o.choice[m];
        try {
          let x = M._decode(e, r);
          if (e.isError(x))
            return false;
          f = { type: m, value: x }, p = true;
        } catch {
          return e.restore(y), false;
        }
        return true;
      }, this), p ? f : e.error("Choice not matched");
    };
    Ue.prototype._createEncoderBuffer = function(e) {
      return new hB(e, this.reporter);
    };
    Ue.prototype._encode = function(e, r, o) {
      let f = this._baseState;
      if (f.default !== null && f.default === e)
        return;
      let p = this._encodeValue(e, r, o);
      if (p !== undefined && !this._skipDefault(p, r, o))
        return p;
    };
    Ue.prototype._encodeValue = function(e, r, o) {
      let f = this._baseState;
      if (f.parent === null)
        return f.children[0]._encode(e, r || new sB);
      let p = null;
      if (this.reporter = r, f.optional && e === undefined)
        if (f.default !== null)
          e = f.default;
        else
          return;
      let m = null, y = false;
      if (f.any)
        p = this._createEncoderBuffer(e);
      else if (f.choice)
        p = this._encodeChoice(e, r);
      else if (f.contains)
        m = this._getUse(f.contains, o)._encode(e, r), y = true;
      else if (f.children)
        m = f.children.map(function(M) {
          if (M._baseState.tag === "null_")
            return M._encode(null, r, e);
          if (M._baseState.key === null)
            return r.error("Child should have a key");
          let x = r.enterKey(M._baseState.key);
          if (typeof e != "object")
            return r.error("Child expected, but input is not object");
          let S2 = M._encode(e[M._baseState.key], r, e);
          return r.leaveKey(x), S2;
        }, this).filter(function(M) {
          return M;
        }), m = this._createEncoderBuffer(m);
      else if (f.tag === "seqof" || f.tag === "setof") {
        if (!(f.args && f.args.length === 1))
          return r.error("Too many args for : " + f.tag);
        if (!Array.isArray(e))
          return r.error("seqof/setof, but data is not Array");
        let M = this.clone();
        M._baseState.implicit = null, m = this._createEncoderBuffer(e.map(function(x) {
          let S2 = this._baseState;
          return this._getUse(S2.args[0], e)._encode(x, r);
        }, M));
      } else
        f.use !== null ? p = this._getUse(f.use, o)._encode(e, r) : (m = this._encodePrimitive(f.tag, e), y = true);
      if (!f.any && f.choice === null) {
        let M = f.implicit !== null ? f.implicit : f.tag, x = f.implicit === null ? "universal" : "context";
        M === null ? f.use === null && r.error("Tag could be omitted only for .use()") : f.use === null && (p = this._encodeComposite(M, y, x, m));
      }
      return f.explicit !== null && (p = this._encodeComposite(f.explicit, false, "context", p)), p;
    };
    Ue.prototype._encodeChoice = function(e, r) {
      let o = this._baseState, f = o.choice[e.type];
      return f || Qt(false, e.type + " not found in " + JSON.stringify(Object.keys(o.choice))), f._encode(e.value, r);
    };
    Ue.prototype._encodePrimitive = function(e, r) {
      let o = this._baseState;
      if (/str$/.test(e))
        return this._encodeStr(r, e);
      if (e === "objid" && o.args)
        return this._encodeObjid(r, o.reverseArgs[0], o.args[1]);
      if (e === "objid")
        return this._encodeObjid(r, null, null);
      if (e === "gentime" || e === "utctime")
        return this._encodeTime(r, e);
      if (e === "null_")
        return this._encodeNull();
      if (e === "int" || e === "enum")
        return this._encodeInt(r, o.args && o.reverseArgs[0]);
      if (e === "bool")
        return this._encodeBool(r);
      if (e === "objDesc")
        return this._encodeStr(r, e);
      throw new Error("Unsupported tag: " + e);
    };
    Ue.prototype._isNumstr = function(e) {
      return /^[0-9 ]*$/.test(e);
    };
    Ue.prototype._isPrintstr = function(e) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
    };
  });
  c0 = T((Wn) => {
    function Cy(t) {
      let e = {};
      return Object.keys(t).forEach(function(r) {
        (r | 0) == r && (r = r | 0);
        let o = t[r];
        e[o] = r;
      }), e;
    }
    Wn.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
    Wn.tagClassByName = Cy(Wn.tagClass);
    Wn.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
    Wn.tagByName = Cy(Wn.tag);
  });
  nd = T((tL, Uy) => {
    var pB = Ie(), Ii = h0().Buffer, Oy = d0(), id = c0();
    function Fy(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Ur, this.tree._init(t.body);
    }
    Uy.exports = Fy;
    Fy.prototype.encode = function(e, r) {
      return this.tree._encode(e, r).join();
    };
    function Ur(t) {
      Oy.call(this, "der", t);
    }
    pB(Ur, Oy);
    Ur.prototype._encodeComposite = function(e, r, o, f) {
      let p = vB(e, r, o, this.reporter);
      if (f.length < 128) {
        let M = Ii.alloc(2);
        return M[0] = p, M[1] = f.length, this._createEncoderBuffer([M, f]);
      }
      let m = 1;
      for (let M = f.length;M >= 256; M >>= 8)
        m++;
      let y = Ii.alloc(1 + 1 + m);
      y[0] = p, y[1] = 128 | m;
      for (let M = 1 + m, x = f.length;x > 0; M--, x >>= 8)
        y[M] = x & 255;
      return this._createEncoderBuffer([y, f]);
    };
    Ur.prototype._encodeStr = function(e, r) {
      if (r === "bitstr")
        return this._createEncoderBuffer([e.unused | 0, e.data]);
      if (r === "bmpstr") {
        let o = Ii.alloc(e.length * 2);
        for (let f = 0;f < e.length; f++)
          o.writeUInt16BE(e.charCodeAt(f), f * 2);
        return this._createEncoderBuffer(o);
      } else
        return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported");
    };
    Ur.prototype._encodeObjid = function(e, r, o) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("string objid given, but no values map found");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("objid not found in values map");
        e = r[e].split(/[\s.]+/g);
        for (let y = 0;y < e.length; y++)
          e[y] |= 0;
      } else if (Array.isArray(e)) {
        e = e.slice();
        for (let y = 0;y < e.length; y++)
          e[y] |= 0;
      }
      if (!Array.isArray(e))
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
      if (!o) {
        if (e[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        e.splice(0, 2, e[0] * 40 + e[1]);
      }
      let f = 0;
      for (let y = 0;y < e.length; y++) {
        let M = e[y];
        for (f++;M >= 128; M >>= 7)
          f++;
      }
      let p = Ii.alloc(f), m = p.length - 1;
      for (let y = e.length - 1;y >= 0; y--) {
        let M = e[y];
        for (p[m--] = M & 127;(M >>= 7) > 0; )
          p[m--] = 128 | M & 127;
      }
      return this._createEncoderBuffer(p);
    };
    function qr(t) {
      return t < 10 ? "0" + t : t;
    }
    Ur.prototype._encodeTime = function(e, r) {
      let o, f = new Date(e);
      return r === "gentime" ? o = [qr(f.getUTCFullYear()), qr(f.getUTCMonth() + 1), qr(f.getUTCDate()), qr(f.getUTCHours()), qr(f.getUTCMinutes()), qr(f.getUTCSeconds()), "Z"].join("") : r === "utctime" ? o = [qr(f.getUTCFullYear() % 100), qr(f.getUTCMonth() + 1), qr(f.getUTCDate()), qr(f.getUTCHours()), qr(f.getUTCMinutes()), qr(f.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(o, "octstr");
    };
    Ur.prototype._encodeNull = function() {
      return this._createEncoderBuffer("");
    };
    Ur.prototype._encodeInt = function(e, r) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("String int or enum given, but no values map");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
        e = r[e];
      }
      if (typeof e != "number" && !Ii.isBuffer(e)) {
        let p = e.toArray();
        !e.sign && p[0] & 128 && p.unshift(0), e = Ii.from(p);
      }
      if (Ii.isBuffer(e)) {
        let p = e.length;
        e.length === 0 && p++;
        let m = Ii.alloc(p);
        return e.copy(m), e.length === 0 && (m[0] = 0), this._createEncoderBuffer(m);
      }
      if (e < 128)
        return this._createEncoderBuffer(e);
      if (e < 256)
        return this._createEncoderBuffer([0, e]);
      let o = 1;
      for (let p = e;p >= 256; p >>= 8)
        o++;
      let f = new Array(o);
      for (let p = f.length - 1;p >= 0; p--)
        f[p] = e & 255, e >>= 8;
      return f[0] & 128 && f.unshift(0), this._createEncoderBuffer(Ii.from(f));
    };
    Ur.prototype._encodeBool = function(e) {
      return this._createEncoderBuffer(e ? 255 : 0);
    };
    Ur.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree;
    };
    Ur.prototype._skipDefault = function(e, r, o) {
      let f = this._baseState, p;
      if (f.default === null)
        return false;
      let m = e.join();
      if (f.defaultBuffer === undefined && (f.defaultBuffer = this._encodeValue(f.default, r, o).join()), m.length !== f.defaultBuffer.length)
        return false;
      for (p = 0;p < m.length; p++)
        if (m[p] !== f.defaultBuffer[p])
          return false;
      return true;
    };
    function vB(t, e, r, o) {
      let f;
      if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), id.tagByName.hasOwnProperty(t))
        f = id.tagByName[t];
      else if (typeof t == "number" && (t | 0) === t)
        f = t;
      else
        return o.error("Unknown tag: " + t);
      return f >= 31 ? o.error("Multi-octet tag encoding unsupported") : (e || (f |= 32), f |= id.tagClassByName[r || "universal"] << 6, f);
    }
  });
  Hy = T((rL, zy) => {
    var bB = Ie(), fd = nd();
    function ad(t) {
      fd.call(this, t), this.enc = "pem";
    }
    bB(ad, fd);
    zy.exports = ad;
    ad.prototype.encode = function(e, r) {
      let f = fd.prototype.encode.call(this, e).toString("base64"), p = ["-----BEGIN " + r.label + "-----"];
      for (let m = 0;m < f.length; m += 64)
        p.push(f.slice(m, m + 64));
      return p.push("-----END " + r.label + "-----"), p.join(`
`);
    };
  });
  od = T((Ky) => {
    var Wy = Ky;
    Wy.der = nd();
    Wy.pem = Hy();
  });
  hd = T((nL, Yy) => {
    var mB = Ie(), gB = td(), jy = Kf().DecoderBuffer, Vy = d0(), Zy = c0();
    function $y(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new sr, this.tree._init(t.body);
    }
    Yy.exports = $y;
    $y.prototype.decode = function(e, r) {
      return jy.isDecoderBuffer(e) || (e = new jy(e, r)), this.tree._decode(e, r);
    };
    function sr(t) {
      Vy.call(this, "der", t);
    }
    mB(sr, Vy);
    sr.prototype._peekTag = function(e, r, o) {
      if (e.isEmpty())
        return false;
      let f = e.save(), p = sd(e, 'Failed to peek tag: "' + r + '"');
      return e.isError(p) ? p : (e.restore(f), p.tag === r || p.tagStr === r || p.tagStr + "of" === r || o);
    };
    sr.prototype._decodeTag = function(e, r, o) {
      let f = sd(e, 'Failed to decode tag of "' + r + '"');
      if (e.isError(f))
        return f;
      let p = Gy(e, f.primitive, 'Failed to get length of "' + r + '"');
      if (e.isError(p))
        return p;
      if (!o && f.tag !== r && f.tagStr !== r && f.tagStr + "of" !== r)
        return e.error('Failed to match tag: "' + r + '"');
      if (f.primitive || p !== null)
        return e.skip(p, 'Failed to match body of: "' + r + '"');
      let m = e.save(), y = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
      return e.isError(y) ? y : (p = e.offset - m.offset, e.restore(m), e.skip(p, 'Failed to match body of: "' + r + '"'));
    };
    sr.prototype._skipUntilEnd = function(e, r) {
      for (;; ) {
        let o = sd(e, r);
        if (e.isError(o))
          return o;
        let f = Gy(e, o.primitive, r);
        if (e.isError(f))
          return f;
        let p;
        if (o.primitive || f !== null ? p = e.skip(f) : p = this._skipUntilEnd(e, r), e.isError(p))
          return p;
        if (o.tagStr === "end")
          break;
      }
    };
    sr.prototype._decodeList = function(e, r, o, f) {
      let p = [];
      for (;!e.isEmpty(); ) {
        let m = this._peekTag(e, "end");
        if (e.isError(m))
          return m;
        let y = o.decode(e, "der", f);
        if (e.isError(y) && m)
          break;
        p.push(y);
      }
      return p;
    };
    sr.prototype._decodeStr = function(e, r) {
      if (r === "bitstr") {
        let o = e.readUInt8();
        return e.isError(o) ? o : { unused: o, data: e.raw() };
      } else if (r === "bmpstr") {
        let o = e.raw();
        if (o.length % 2 === 1)
          return e.error("Decoding of string type: bmpstr length mismatch");
        let f = "";
        for (let p = 0;p < o.length / 2; p++)
          f += String.fromCharCode(o.readUInt16BE(p * 2));
        return f;
      } else if (r === "numstr") {
        let o = e.raw().toString("ascii");
        return this._isNumstr(o) ? o : e.error("Decoding of string type: numstr unsupported characters");
      } else {
        if (r === "octstr")
          return e.raw();
        if (r === "objDesc")
          return e.raw();
        if (r === "printstr") {
          let o = e.raw().toString("ascii");
          return this._isPrintstr(o) ? o : e.error("Decoding of string type: printstr unsupported characters");
        } else
          return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported");
      }
    };
    sr.prototype._decodeObjid = function(e, r, o) {
      let f, p = [], m = 0, y = 0;
      for (;!e.isEmpty(); )
        y = e.readUInt8(), m <<= 7, m |= y & 127, (y & 128) === 0 && (p.push(m), m = 0);
      y & 128 && p.push(m);
      let M = p[0] / 40 | 0, x = p[0] % 40;
      if (o ? f = p : f = [M, x].concat(p.slice(1)), r) {
        let S2 = r[f.join(" ")];
        S2 === undefined && (S2 = r[f.join(".")]), S2 !== undefined && (f = S2);
      }
      return f;
    };
    sr.prototype._decodeTime = function(e, r) {
      let o = e.raw().toString(), f, p, m, y, M, x;
      if (r === "gentime")
        f = o.slice(0, 4) | 0, p = o.slice(4, 6) | 0, m = o.slice(6, 8) | 0, y = o.slice(8, 10) | 0, M = o.slice(10, 12) | 0, x = o.slice(12, 14) | 0;
      else if (r === "utctime")
        f = o.slice(0, 2) | 0, p = o.slice(2, 4) | 0, m = o.slice(4, 6) | 0, y = o.slice(6, 8) | 0, M = o.slice(8, 10) | 0, x = o.slice(10, 12) | 0, f < 70 ? f = 2000 + f : f = 1900 + f;
      else
        return e.error("Decoding " + r + " time is not supported yet");
      return Date.UTC(f, p - 1, m, y, M, x, 0);
    };
    sr.prototype._decodeNull = function() {
      return null;
    };
    sr.prototype._decodeBool = function(e) {
      let r = e.readUInt8();
      return e.isError(r) ? r : r !== 0;
    };
    sr.prototype._decodeInt = function(e, r) {
      let o = e.raw(), f = new gB(o);
      return r && (f = r[f.toString(10)] || f), f;
    };
    sr.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree;
    };
    function sd(t, e) {
      let r = t.readUInt8(e);
      if (t.isError(r))
        return r;
      let o = Zy.tagClass[r >> 6], f = (r & 32) === 0;
      if ((r & 31) === 31) {
        let m = r;
        for (r = 0;(m & 128) === 128; ) {
          if (m = t.readUInt8(e), t.isError(m))
            return m;
          r <<= 7, r |= m & 127;
        }
      } else
        r &= 31;
      let p = Zy.tag[r];
      return { cls: o, primitive: f, tag: r, tagStr: p };
    }
    function Gy(t, e, r) {
      let o = t.readUInt8(r);
      if (t.isError(o))
        return o;
      if (!e && o === 128)
        return null;
      if ((o & 128) === 0)
        return o;
      let f = o & 127;
      if (f > 4)
        return t.error("length octect is too long");
      o = 0;
      for (let p = 0;p < f; p++) {
        o <<= 8;
        let m = t.readUInt8(r);
        if (t.isError(m))
          return m;
        o |= m;
      }
      return o;
    }
  });
  Jy = T((fL, Xy) => {
    var yB = Ie(), wB = h0().Buffer, ud = hd();
    function ld(t) {
      ud.call(this, t), this.enc = "pem";
    }
    yB(ld, ud);
    Xy.exports = ld;
    ld.prototype.decode = function(e, r) {
      let o = e.toString().split(/[\r\n]+/g), f = r.label.toUpperCase(), p = /^-----(BEGIN|END) ([^-]+)-----$/, m = -1, y = -1;
      for (let S2 = 0;S2 < o.length; S2++) {
        let E = o[S2].match(p);
        if (E !== null && E[2] === f)
          if (m === -1) {
            if (E[1] !== "BEGIN")
              break;
            m = S2;
          } else {
            if (E[1] !== "END")
              break;
            y = S2;
            break;
          }
      }
      if (m === -1 || y === -1)
        throw new Error("PEM section not found for: " + f);
      let M = o.slice(m + 1, y).join("");
      M.replace(/[^a-z0-9+/=]+/gi, "");
      let x = wB.from(M, "base64");
      return ud.prototype.decode.call(this, x, r);
    };
  });
  dd = T((e3) => {
    var Qy = e3;
    Qy.der = hd();
    Qy.pem = Jy();
  });
  r3 = T((t3) => {
    var MB = od(), _B = dd(), xB = Ie(), SB = t3;
    SB.define = function(e, r) {
      return new jf(e, r);
    };
    function jf(t, e) {
      this.name = t, this.body = e, this.decoders = {}, this.encoders = {};
    }
    jf.prototype._createNamed = function(e) {
      let r = this.name;
      function o(f) {
        this._initNamed(f, r);
      }
      return xB(o, e), o.prototype._initNamed = function(p, m) {
        e.call(this, p, m);
      }, new o(this);
    };
    jf.prototype._getDecoder = function(e) {
      return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(_B[e])), this.decoders[e];
    };
    jf.prototype.decode = function(e, r, o) {
      return this._getDecoder(r).decode(e, o);
    };
    jf.prototype._getEncoder = function(e) {
      return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(MB[e])), this.encoders[e];
    };
    jf.prototype.encode = function(e, r, o) {
      return this._getEncoder(r).encode(e, o);
    };
  });
  n3 = T((i3) => {
    var p0 = i3;
    p0.Reporter = u0().Reporter;
    p0.DecoderBuffer = Kf().DecoderBuffer;
    p0.EncoderBuffer = Kf().EncoderBuffer;
    p0.Node = d0();
  });
  o3 = T((a3) => {
    var f3 = a3;
    f3._reverse = function(e) {
      let r = {};
      return Object.keys(e).forEach(function(o) {
        (o | 0) == o && (o = o | 0);
        let f = e[o];
        r[f] = o;
      }), r;
    };
    f3.der = c0();
  });
  cd = T((s3) => {
    var Zf = s3;
    Zf.bignum = td();
    Zf.define = r3().define;
    Zf.base = n3();
    Zf.constants = o3();
    Zf.decoders = dd();
    Zf.encoders = od();
  });
  d3 = T((lL, l3) => {
    var zr = cd(), h3 = zr.define("Time", function() {
      this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
    }), EB = zr.define("AttributeTypeValue", function() {
      this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), pd = zr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), AB = zr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(pd), this.key("subjectPublicKey").bitstr());
    }), RB = zr.define("RelativeDistinguishedName", function() {
      this.setof(EB);
    }), BB = zr.define("RDNSequence", function() {
      this.seqof(RB);
    }), u3 = zr.define("Name", function() {
      this.choice({ rdnSequence: this.use(BB) });
    }), qB = zr.define("Validity", function() {
      this.seq().obj(this.key("notBefore").use(h3), this.key("notAfter").use(h3));
    }), IB = zr.define("Extension", function() {
      this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
    }), TB = zr.define("TBSCertificate", function() {
      this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(pd), this.key("issuer").use(u3), this.key("validity").use(qB), this.key("subject").use(u3), this.key("subjectPublicKeyInfo").use(AB), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(IB).optional());
    }), kB = zr.define("X509Certificate", function() {
      this.seq().obj(this.key("tbsCertificate").use(TB), this.key("signatureAlgorithm").use(pd), this.key("signatureValue").bitstr());
    });
    l3.exports = kB;
  });
  p3 = T((Wr) => {
    var Hr = cd();
    Wr.certificate = d3();
    var LB = Hr.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    Wr.RSAPrivateKey = LB;
    var NB = Hr.define("RSAPublicKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    Wr.RSAPublicKey = NB;
    var DB = Hr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(c3), this.key("subjectPublicKey").bitstr());
    });
    Wr.PublicKey = DB;
    var c3 = Hr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), PB = Hr.define("PrivateKeyInfo", function() {
      this.seq().obj(this.key("version").int(), this.key("algorithm").use(c3), this.key("subjectPrivateKey").octstr());
    });
    Wr.PrivateKey = PB;
    var CB = Hr.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    Wr.EncryptedPrivateKey = CB;
    var OB = Hr.define("DSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    Wr.DSAPrivateKey = OB;
    Wr.DSAparam = Hr.define("DSAparam", function() {
      this.int();
    });
    var FB = Hr.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(UB), this.key("publicKey").optional().explicit(1).bitstr());
    });
    Wr.ECPrivateKey = FB;
    var UB = Hr.define("ECParameters", function() {
      this.choice({ namedCurve: this.objid() });
    });
    Wr.signature = Hr.define("signature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    });
  });
  v3 = T((cL, zB) => {
    zB.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
  });
  m3 = T((pL, b3) => {
    var HB = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, WB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, KB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, jB = Ba(), ZB = Es(), v0 = Te().Buffer;
    b3.exports = function(t, e) {
      var r = t.toString(), o = r.match(HB), f;
      if (o) {
        var m = "aes" + o[1], y = v0.from(o[2], "hex"), M = v0.from(o[3].replace(/[\r\n]/g, ""), "base64"), x = jB(e, y.slice(0, 8), parseInt(o[1], 10)).key, S2 = [], E = ZB.createDecipheriv(m, x, y);
        S2.push(E.update(M)), S2.push(E.final()), f = v0.concat(S2);
      } else {
        var p = r.match(KB);
        f = v0.from(p[2].replace(/[\r\n]/g, ""), "base64");
      }
      var B = r.match(WB)[1];
      return { tag: B, data: f };
    };
  });
  Ha = T((vL, y3) => {
    var fr = p3(), VB = v3(), $B = m3(), GB = Es(), YB = Iu(), vd = Te().Buffer;
    y3.exports = g3;
    function g3(t) {
      var e;
      typeof t == "object" && !vd.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = vd.from(t));
      var r = $B(t, e), o = r.tag, f = r.data, p, m;
      switch (o) {
        case "CERTIFICATE":
          m = fr.certificate.decode(f, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          switch (m || (m = fr.PublicKey.decode(f, "der")), p = m.algorithm.algorithm.join("."), p) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPublicKey.decode(m.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              return m.subjectPrivateKey = m.subjectPublicKey, { type: "ec", data: m };
            case "1.2.840.10040.4.1":
              return m.algorithm.params.pub_key = fr.DSAparam.decode(m.subjectPublicKey.data, "der"), { type: "dsa", data: m.algorithm.params };
            default:
              throw new Error("unknown key id " + p);
          }
        case "ENCRYPTED PRIVATE KEY":
          f = fr.EncryptedPrivateKey.decode(f, "der"), f = XB(f, e);
        case "PRIVATE KEY":
          switch (m = fr.PrivateKey.decode(f, "der"), p = m.algorithm.algorithm.join("."), p) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPrivateKey.decode(m.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return { curve: m.algorithm.curve, privateKey: fr.ECPrivateKey.decode(m.subjectPrivateKey, "der").privateKey };
            case "1.2.840.10040.4.1":
              return m.algorithm.params.priv_key = fr.DSAparam.decode(m.subjectPrivateKey, "der"), { type: "dsa", params: m.algorithm.params };
            default:
              throw new Error("unknown key id " + p);
          }
        case "RSA PUBLIC KEY":
          return fr.RSAPublicKey.decode(f, "der");
        case "RSA PRIVATE KEY":
          return fr.RSAPrivateKey.decode(f, "der");
        case "DSA PRIVATE KEY":
          return { type: "dsa", params: fr.DSAPrivateKey.decode(f, "der") };
        case "EC PRIVATE KEY":
          return f = fr.ECPrivateKey.decode(f, "der"), { curve: f.parameters.value, privateKey: f.privateKey };
        default:
          throw new Error("unknown key type " + o);
      }
    }
    g3.signature = fr.signature;
    function XB(t, e) {
      var r = t.algorithm.decrypt.kde.kdeparams.salt, o = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), f = VB[t.algorithm.decrypt.cipher.algo.join(".")], p = t.algorithm.decrypt.cipher.iv, m = t.subjectPrivateKey, y = parseInt(f.split("-")[1], 10) / 8, M = YB.pbkdf2Sync(e, r, o, y, "sha1"), x = GB.createDecipheriv(f, M, p), S2 = [];
      return S2.push(x.update(m)), S2.push(x.final()), vd.concat(S2);
    }
  });
  bd = T((bL, JB) => {
    JB.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
  });
  _3 = T((mL, m0) => {
    var Yt = Te().Buffer, Kn = wu(), QB = Ks(), eq = o0().ec, b0 = Ws(), tq = Ha(), rq = bd();
    function iq(t, e, r, o, f) {
      var p = tq(e);
      if (p.curve) {
        if (o !== "ecdsa" && o !== "ecdsa/rsa")
          throw new Error("wrong private key type");
        return nq(t, p);
      } else if (p.type === "dsa") {
        if (o !== "dsa")
          throw new Error("wrong private key type");
        return fq(t, p, r);
      } else if (o !== "rsa" && o !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      t = Yt.concat([f, t]);
      for (var m = p.modulus.byteLength(), y = [0, 1];t.length + y.length + 1 < m; )
        y.push(255);
      y.push(0);
      for (var M = -1;++M < t.length; )
        y.push(t[M]);
      var x = QB(y, p);
      return x;
    }
    function nq(t, e) {
      var r = rq[e.curve.join(".")];
      if (!r)
        throw new Error("unknown curve " + e.curve.join("."));
      var o = new eq(r), f = o.keyFromPrivate(e.privateKey), p = f.sign(t);
      return Yt.from(p.toDER());
    }
    function fq(t, e, r) {
      for (var o = e.params.priv_key, f = e.params.p, p = e.params.q, m = e.params.g, y = new b0(0), M, x = md(t, p).mod(p), S2 = false, E = w3(o, p, t, r);S2 === false; )
        M = M3(p, E, r), y = sq(m, M, f, p), S2 = M.invm(p).imul(x.add(o.mul(y))).mod(p), S2.cmpn(0) === 0 && (S2 = false, y = new b0(0));
      return aq(y, S2);
    }
    function aq(t, e) {
      t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e));
      var r = t.length + e.length + 4, o = [48, r, 2, t.length];
      return o = o.concat(t, [2, e.length], e), Yt.from(o);
    }
    function w3(t, e, r, o) {
      if (t = Yt.from(t.toArray()), t.length < e.byteLength()) {
        var f = Yt.alloc(e.byteLength() - t.length);
        t = Yt.concat([f, t]);
      }
      var p = r.length, m = oq(r, e), y = Yt.alloc(p);
      y.fill(1);
      var M = Yt.alloc(p);
      return M = Kn(o, M).update(y).update(Yt.from([0])).update(t).update(m).digest(), y = Kn(o, M).update(y).digest(), M = Kn(o, M).update(y).update(Yt.from([1])).update(t).update(m).digest(), y = Kn(o, M).update(y).digest(), { k: M, v: y };
    }
    function md(t, e) {
      var r = new b0(t), o = (t.length << 3) - e.bitLength();
      return o > 0 && r.ishrn(o), r;
    }
    function oq(t, e) {
      t = md(t, e), t = t.mod(e);
      var r = Yt.from(t.toArray());
      if (r.length < e.byteLength()) {
        var o = Yt.alloc(e.byteLength() - r.length);
        r = Yt.concat([o, r]);
      }
      return r;
    }
    function M3(t, e, r) {
      var o, f;
      do {
        for (o = Yt.alloc(0);o.length * 8 < t.bitLength(); )
          e.v = Kn(r, e.k).update(e.v).digest(), o = Yt.concat([o, e.v]);
        f = md(o, t), e.k = Kn(r, e.k).update(e.v).update(Yt.from([0])).digest(), e.v = Kn(r, e.k).update(e.v).digest();
      } while (f.cmp(t) !== -1);
      return f;
    }
    function sq(t, e, r, o) {
      return t.toRed(b0.mont(r)).redPow(e).fromRed().mod(o);
    }
    m0.exports = iq;
    m0.exports.getKey = w3;
    m0.exports.makeKey = M3;
  });
  A3 = T((gL, E3) => {
    var gd = Te().Buffer, Wa = Ws(), hq = o0().ec, S3 = Ha(), uq = bd();
    function lq(t, e, r, o, f) {
      var p = S3(r);
      if (p.type === "ec") {
        if (o !== "ecdsa" && o !== "ecdsa/rsa")
          throw new Error("wrong public key type");
        return dq(t, e, p);
      } else if (p.type === "dsa") {
        if (o !== "dsa")
          throw new Error("wrong public key type");
        return cq(t, e, p);
      } else if (o !== "rsa" && o !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      e = gd.concat([f, e]);
      for (var m = p.modulus.byteLength(), y = [1], M = 0;e.length + y.length + 2 < m; )
        y.push(255), M++;
      y.push(0);
      for (var x = -1;++x < e.length; )
        y.push(e[x]);
      y = gd.from(y);
      var S2 = Wa.mont(p.modulus);
      t = new Wa(t).toRed(S2), t = t.redPow(new Wa(p.publicExponent)), t = gd.from(t.fromRed().toArray());
      var E = M < 8 ? 1 : 0;
      for (m = Math.min(t.length, y.length), t.length !== y.length && (E = 1), x = -1;++x < m; )
        E |= t[x] ^ y[x];
      return E === 0;
    }
    function dq(t, e, r) {
      var o = uq[r.data.algorithm.curve.join(".")];
      if (!o)
        throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
      var f = new hq(o), p = r.data.subjectPrivateKey.data;
      return f.verify(e, t, p);
    }
    function cq(t, e, r) {
      var o = r.data.p, f = r.data.q, p = r.data.g, m = r.data.pub_key, y = S3.signature.decode(t, "der"), M = y.s, x = y.r;
      x3(M, f), x3(x, f);
      var S2 = Wa.mont(o), E = M.invm(f), B = p.toRed(S2).redPow(new Wa(e).mul(E).mod(f)).fromRed().mul(m.toRed(S2).redPow(x.mul(E).mod(f)).fromRed()).mod(o).mod(f);
      return B.cmp(x) === 0;
    }
    function x3(t, e) {
      if (t.cmpn(0) <= 0)
        throw new Error("invalid sig");
      if (t.cmp(e) >= e)
        throw new Error("invalid sig");
    }
    E3.exports = lq;
  });
  k3 = T((yL, T3) => {
    var g0 = Te().Buffer, q3 = bf(), y0 = i2(), I3 = Ie(), pq = _3(), vq = A3(), jn = Mu();
    Object.keys(jn).forEach(function(t) {
      jn[t].id = g0.from(jn[t].id, "hex"), jn[t.toLowerCase()] = jn[t];
    });
    function Ka(t) {
      y0.Writable.call(this);
      var e = jn[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hashType = e.hash, this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    I3(Ka, y0.Writable);
    Ka.prototype._write = function(e, r, o) {
      this._hash.update(e), o();
    };
    Ka.prototype.update = function(e, r) {
      return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
    };
    Ka.prototype.sign = function(e, r) {
      this.end();
      var o = this._hash.digest(), f = pq(o, e, this._hashType, this._signType, this._tag);
      return r ? f.toString(r) : f;
    };
    function ja(t) {
      y0.Writable.call(this);
      var e = jn[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    I3(ja, y0.Writable);
    ja.prototype._write = function(e, r, o) {
      this._hash.update(e), o();
    };
    ja.prototype.update = function(e, r) {
      return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
    };
    ja.prototype.verify = function(e, r, o) {
      typeof r == "string" && (r = g0.from(r, o)), this.end();
      var f = this._hash.digest();
      return vq(r, f, e, this._signType, this._tag);
    };
    function R3(t) {
      return new Ka(t);
    }
    function B3(t) {
      return new ja(t);
    }
    T3.exports = { Sign: R3, Verify: B3, createSign: R3, createVerify: B3 };
  });
  N3 = T((L3, yd) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o(v2, i) {
        v2.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v2.prototype = new a, v2.prototype.constructor = v2;
      }
      function f(v2, i, a) {
        if (f.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v2 || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b3 = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
        return this.strip();
      };
      function m(v2, i) {
        var a = v2.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v2, i, a) {
        var h = m(v2, a);
        return a - 1 >= i && (h |= m(v2, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b3;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b3 = y(i, a, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b3 = y(i, a, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v2, i, a, h) {
        for (var s = 0, u = Math.min(v2.length, a), c = i;c < u; c++) {
          var b3 = v2.charCodeAt(c) - 48;
          s *= h, b3 >= 49 ? s += b3 - 49 + 10 : b3 >= 17 ? s += b3 - 17 + 10 : s += b3;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b3 = c % s, l = Math.min(c, c - b3) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b3 !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b3; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b3 = this.words[c], l = ((b3 << s | u) & 16777215).toString(16);
            u = b3 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b3 = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b3[n] = l;
          for (;n < u; n++)
            b3[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b3[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b3[u - n - 1] = l;
        }
        return b3;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v2) {
        for (var i = new Array(v2.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v2.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b3 = 0;b3 < u.length; b3++)
          a = (s.words[b3] | 0) - (u.words[b3] | 0) + c, c = a >> 26, this.words[b3] = a & 67108863;
        for (;c !== 0 && b3 < s.length; b3++)
          a = (s.words[b3] | 0) + c, c = a >> 26, this.words[b3] = a & 67108863;
        if (c === 0 && b3 < s.length && s !== this)
          for (;b3 < s.length; b3++)
            this.words[b3] = s.words[b3];
        return this.length = Math.max(this.length, b3), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a) {
        a.negative = i.negative ^ v2.negative;
        var h = v2.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v2.words[0] | 0, u = i.words[0] | 0, c = s * u, b3 = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b3;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _4 = Math.max(0, n - v2.length + 1);_4 <= g; _4++) {
            var A = n - _4 | 0;
            s = v2.words[A] | 0, u = i.words[_4] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b3 = 0, l, n, d, w = s[0] | 0, g = w & 8191, _4 = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D2 = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z2 = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $2 = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = u[1] | 0, Q3 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J2), n = n + Math.imul(_4, X) | 0, d = Math.imul(_4, J2);
        var ft = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J2), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J2), l = l + Math.imul(g, Q3) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_4, Q3) | 0, d = d + Math.imul(_4, ee) | 0;
        var Be = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J2), n = n + Math.imul(D2, X) | 0, d = Math.imul(D2, J2), l = l + Math.imul(R, Q3) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q3) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_4, te) | 0, d = d + Math.imul(_4, re) | 0;
        var qe = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J2), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J2), l = l + Math.imul(k, Q3) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D2, Q3) | 0, d = d + Math.imul(D2, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_4, ie) | 0, d = d + Math.imul(_4, ne) | 0;
        var ze = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J2), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J2), l = l + Math.imul(C, Q3) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q3) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D2, te) | 0, d = d + Math.imul(D2, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_4, fe) | 0, d = d + Math.imul(_4, ae) | 0;
        var He = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z2, X), n = Math.imul(z2, J2), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J2), l = l + Math.imul(F, Q3) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q3) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D2, ie) | 0, d = d + Math.imul(D2, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_4, oe) | 0, d = d + Math.imul(_4, se) | 0;
        var We = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J2), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J2), l = l + Math.imul(z2, Q3) | 0, n = n + Math.imul(z2, ee) | 0, n = n + Math.imul(H, Q3) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D2, fe) | 0, d = d + Math.imul(D2, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_4, he) | 0, d = d + Math.imul(_4, ue) | 0;
        var Ke = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J2), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J2), l = l + Math.imul(W, Q3) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q3) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z2, te) | 0, n = n + Math.imul(z2, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D2, oe) | 0, d = d + Math.imul(D2, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_4, le) | 0, d = d + Math.imul(_4, de) | 0;
        var je = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J2), n = n + Math.imul($2, X) | 0, d = Math.imul($2, J2), l = l + Math.imul(j, Q3) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q3) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z2, ie) | 0, n = n + Math.imul(z2, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D2, he) | 0, d = d + Math.imul(D2, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_4, ce) | 0, d = d + Math.imul(_4, pe) | 0;
        var Ze = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J2), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J2), l = l + Math.imul(V, Q3) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($2, Q3) | 0, d = d + Math.imul($2, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z2, fe) | 0, n = n + Math.imul(z2, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D2, le) | 0, d = d + Math.imul(D2, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_4, ve) | 0, d = d + Math.imul(_4, be) | 0;
        var Ve = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q3), n = Math.imul(G, ee), n = n + Math.imul(Y, Q3) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($2, te) | 0, d = d + Math.imul($2, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z2, oe) | 0, n = n + Math.imul(z2, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D2, ce) | 0, d = d + Math.imul(D2, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($2, ie) | 0, d = d + Math.imul($2, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z2, he) | 0, n = n + Math.imul(z2, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D2, ve) | 0, d = d + Math.imul(D2, be) | 0;
        var Ge = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($2, fe) | 0, d = d + Math.imul($2, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z2, le) | 0, n = n + Math.imul(z2, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($2, oe) | 0, d = d + Math.imul($2, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z2, ce) | 0, n = n + Math.imul(z2, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($2, he) | 0, d = d + Math.imul($2, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z2, ve) | 0, n = n + Math.imul(z2, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($2, le) | 0, d = d + Math.imul($2, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($2, ce) | 0, d = d + Math.imul($2, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($2, ve) | 0, d = d + Math.imul($2, be) | 0;
        var tt = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        return b3 = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b3 !== 0 && (c[19] = b3, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v2, i, a) {
        a.negative = i.negative ^ v2.negative, a.length = v2.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b3 = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v2.length + 1);n <= l; n++) {
            var d = u - n, w = v2.words[d] | 0, g = i.words[n] | 0, _4 = w * g, A = _4 & 67108863;
            c = c + (_4 / 67108864 | 0) | 0, A = A + b3 | 0, b3 = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b3, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v2, i, a) {
        var h = new N;
        return h.mulp(v2, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v2, i) {
        this.x = v2, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b3 = 0;b3 < c; b3++)
          s[b3] = a[i[b3]], u[b3] = h[i[b3]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b3 = 1;b3 < u; b3 <<= 1)
          for (var l = b3 << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _4 = d, A = 0;A < b3; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b3], k = s[w + A + b3], D2 = g * Me - _4 * k;
              k = g * k + _4 * Me, Me = D2, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b3] = R - Me, s[w + A + b3] = I - k, A !== l && (D2 = n * g - d * _4, _4 = n * _4 + d * g, g = D2);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b3 = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _4 = h.words;
        _4.length = s, this.convert13b(i.words, i.length, b3, s), this.convert13b(a.words, a.length, d, s), this.transform(b3, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _4, c, s, u), this.conjugate(_4, c, s), this.normalize13b(_4, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b3 = this.words[u] & s, l = (this.words[u] | 0) - b3 << a;
            this.words[u] = l | c, c = b3 >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b3 = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b3;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b3 = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b3;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b3 = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b3, b3 = c >> 26, this.words[u + h] = c & 67108863;
        if (b3 === 0)
          return this.strip();
        for (r(b3 === -1), b3 = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b3, b3 = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b3 = this._countBits(c);
        h = 26 - b3, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _4 = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_4 = Math.min(_4 / c | 0, 67108863), s._ishlnsubmul(u, _4, g);s.negative !== 0; )
            _4--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _4);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b3 = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _4 = 0, A = 1;(h.words[0] & A) === 0 && _4 < 26; ++_4, A <<= 1)
            ;
          if (_4 > 0)
            for (h.iushrn(_4);_4-- > 0; )
              (c.isOdd() || b3.isOdd()) && (c.iadd(n), b3.isub(d)), c.iushrn(1), b3.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b3)) : (h.isub(a), c.isub(s), b3.isub(u));
        }
        return { a: c, b: b3, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b3 = 0, l = 1;(a.words[0] & l) === 0 && b3 < 26; ++b3, l <<= 1)
            ;
          if (b3 > 0)
            for (a.iushrn(b3);b3-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b3 = this.words[c] | 0;
          b3 += u, u = b3 >>> 26, b3 &= 67108863, this.words[c] = b3;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v2, i) {
        this.name = v2, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b3 = i.words[u] | 0;
          i.words[u - 10] = (b3 & h) << 4 | c >>> 22, c = b3;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v2) {
        if (typeof v2 == "string") {
          var i = f._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b3 = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b3) !== 0; )
          n.redIAdd(b3);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _4 = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _4);
          var I = this.pow(d, new f(1).iushln(_4 - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _4 = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b3 = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b3 === 0) {
              l = 0;
              continue;
            }
            b3 <<= 1, b3 |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b3]), l = 0, b3 = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v2) {
        P.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof yd > "u" || yd, L3);
  });
  P3 = T((wL, D3) => {
    var bq = o0(), mq = N3();
    D3.exports = function(e) {
      return new Zn(e);
    };
    var hr = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
    hr.p224 = hr.secp224r1;
    hr.p256 = hr.secp256r1 = hr.prime256v1;
    hr.p192 = hr.secp192r1 = hr.prime192v1;
    hr.p384 = hr.secp384r1;
    hr.p521 = hr.secp521r1;
    function Zn(t) {
      this.curveType = hr[t], this.curveType || (this.curveType = { name: t }), this.curve = new bq.ec(this.curveType.name), this.keys = undefined;
    }
    Zn.prototype.generateKeys = function(t, e) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e);
    };
    Zn.prototype.computeSecret = function(t, e, r) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var o = this.curve.keyFromPublic(t).getPublic(), f = o.mul(this.keys.getPrivate()).getX();
      return wd(f, r, this.curveType.byteLength);
    };
    Zn.prototype.getPublicKey = function(t, e) {
      var r = this.keys.getPublic(e === "compressed", true);
      return e === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), wd(r, t);
    };
    Zn.prototype.getPrivateKey = function(t) {
      return wd(this.keys.getPrivate(), t);
    };
    Zn.prototype.setPublicKey = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.keys._importPublic(t), this;
    };
    Zn.prototype.setPrivateKey = function(t, e) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var r = new mq(t);
      return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
    };
    function wd(t, e, r) {
      Array.isArray(t) || (t = t.toArray());
      var o = new Buffer(t);
      if (r && o.length < r) {
        var f = new Buffer(r - o.length);
        f.fill(0), o = Buffer.concat([f, o]);
      }
      return e ? o.toString(e) : o;
    }
  });
  _d = T((ML, C3) => {
    var gq = bf(), Md = Te().Buffer;
    C3.exports = function(t, e) {
      for (var r = Md.alloc(0), o = 0, f;r.length < e; )
        f = yq(o++), r = Md.concat([r, gq("sha1").update(t).update(f).digest()]);
      return r.slice(0, e);
    };
    function yq(t) {
      var e = Md.allocUnsafe(4);
      return e.writeUInt32BE(t, 0), e;
    }
  });
  xd = T((_L, O3) => {
    O3.exports = function(e, r) {
      for (var o = e.length, f = -1;++f < o; )
        e[f] ^= r[f];
      return e;
    };
  });
  w0 = T((F3, Sd) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o(v2, i) {
        v2.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v2.prototype = new a, v2.prototype.constructor = v2;
      }
      function f(v2, i, a) {
        if (f.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v2 || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b3 = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b3 & 67108863, this.words[u + 1] = c >>> 26 - b3 & 67108863, b3 += 24, b3 >= 26 && (b3 -= 26, u++);
        return this.strip();
      };
      function m(v2, i) {
        var a = v2.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v2, i, a) {
        var h = m(v2, a);
        return a - 1 >= i && (h |= m(v2, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b3;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b3 = y(i, a, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b3 = y(i, a, s) << u, this.words[c] |= b3 & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b3 >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v2, i, a, h) {
        for (var s = 0, u = Math.min(v2.length, a), c = i;c < u; c++) {
          var b3 = v2.charCodeAt(c) - 48;
          s *= h, b3 >= 49 ? s += b3 - 49 + 10 : b3 >= 17 ? s += b3 - 17 + 10 : s += b3;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b3 = c % s, l = Math.min(c, c - b3) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b3 !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b3; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b3 = this.words[c], l = ((b3 << s | u) & 16777215).toString(16);
            u = b3 >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d = E[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p < "u"), this.toArrayLike(p, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b3 = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b3[n] = l;
          for (;n < u; n++)
            b3[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b3[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b3[u - n - 1] = l;
        }
        return b3;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v2) {
        for (var i = new Array(v2.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v2.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b3 = 0;b3 < u.length; b3++)
          a = (s.words[b3] | 0) - (u.words[b3] | 0) + c, c = a >> 26, this.words[b3] = a & 67108863;
        for (;c !== 0 && b3 < s.length; b3++)
          a = (s.words[b3] | 0) + c, c = a >> 26, this.words[b3] = a & 67108863;
        if (c === 0 && b3 < s.length && s !== this)
          for (;b3 < s.length; b3++)
            this.words[b3] = s.words[b3];
        return this.length = Math.max(this.length, b3), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a) {
        a.negative = i.negative ^ v2.negative;
        var h = v2.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v2.words[0] | 0, u = i.words[0] | 0, c = s * u, b3 = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b3;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _4 = Math.max(0, n - v2.length + 1);_4 <= g; _4++) {
            var A = n - _4 | 0;
            s = v2.words[A] | 0, u = i.words[_4] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b3 = 0, l, n, d, w = s[0] | 0, g = w & 8191, _4 = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D2 = Me >>> 13, nt = s[3] | 0, C = nt & 8191, O = nt >>> 13, vt = s[4] | 0, F = vt & 8191, U = vt >>> 13, bt = s[5] | 0, z2 = bt & 8191, H = bt >>> 13, mt = s[6] | 0, W = mt & 8191, K = mt >>> 13, gt = s[7] | 0, j = gt & 8191, Z = gt >>> 13, yt = s[8] | 0, V = yt & 8191, $2 = yt >>> 13, wt = s[9] | 0, G = wt & 8191, Y = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J2 = Mt >>> 13, _t = u[1] | 0, Q3 = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At = u[5] | 0, oe = At & 8191, se = At >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J2), n = n + Math.imul(_4, X) | 0, d = Math.imul(_4, J2);
        var ft = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J2), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J2), l = l + Math.imul(g, Q3) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_4, Q3) | 0, d = d + Math.imul(_4, ee) | 0;
        var Be = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J2), n = n + Math.imul(D2, X) | 0, d = Math.imul(D2, J2), l = l + Math.imul(R, Q3) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q3) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re) | 0, n = n + Math.imul(_4, te) | 0, d = d + Math.imul(_4, re) | 0;
        var qe = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (qe >>> 26) | 0, qe &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J2), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J2), l = l + Math.imul(k, Q3) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D2, Q3) | 0, d = d + Math.imul(D2, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_4, ie) | 0, d = d + Math.imul(_4, ne) | 0;
        var ze = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F, X), n = Math.imul(F, J2), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J2), l = l + Math.imul(C, Q3) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q3) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re) | 0, n = n + Math.imul(D2, te) | 0, d = d + Math.imul(D2, re) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_4, fe) | 0, d = d + Math.imul(_4, ae) | 0;
        var He = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z2, X), n = Math.imul(z2, J2), n = n + Math.imul(H, X) | 0, d = Math.imul(H, J2), l = l + Math.imul(F, Q3) | 0, n = n + Math.imul(F, ee) | 0, n = n + Math.imul(U, Q3) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D2, ie) | 0, d = d + Math.imul(D2, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_4, oe) | 0, d = d + Math.imul(_4, se) | 0;
        var We = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J2), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J2), l = l + Math.imul(z2, Q3) | 0, n = n + Math.imul(z2, ee) | 0, n = n + Math.imul(H, Q3) | 0, d = d + Math.imul(H, ee) | 0, l = l + Math.imul(F, te) | 0, n = n + Math.imul(F, re) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D2, fe) | 0, d = d + Math.imul(D2, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_4, he) | 0, d = d + Math.imul(_4, ue) | 0;
        var Ke = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J2), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J2), l = l + Math.imul(W, Q3) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q3) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z2, te) | 0, n = n + Math.imul(z2, re) | 0, n = n + Math.imul(H, te) | 0, d = d + Math.imul(H, re) | 0, l = l + Math.imul(F, ie) | 0, n = n + Math.imul(F, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D2, oe) | 0, d = d + Math.imul(D2, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_4, le) | 0, d = d + Math.imul(_4, de) | 0;
        var je = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V, X), n = Math.imul(V, J2), n = n + Math.imul($2, X) | 0, d = Math.imul($2, J2), l = l + Math.imul(j, Q3) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q3) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re) | 0, l = l + Math.imul(z2, ie) | 0, n = n + Math.imul(z2, ne) | 0, n = n + Math.imul(H, ie) | 0, d = d + Math.imul(H, ne) | 0, l = l + Math.imul(F, fe) | 0, n = n + Math.imul(F, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D2, he) | 0, d = d + Math.imul(D2, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_4, ce) | 0, d = d + Math.imul(_4, pe) | 0;
        var Ze = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J2), n = n + Math.imul(Y, X) | 0, d = Math.imul(Y, J2), l = l + Math.imul(V, Q3) | 0, n = n + Math.imul(V, ee) | 0, n = n + Math.imul($2, Q3) | 0, d = d + Math.imul($2, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z2, fe) | 0, n = n + Math.imul(z2, ae) | 0, n = n + Math.imul(H, fe) | 0, d = d + Math.imul(H, ae) | 0, l = l + Math.imul(F, oe) | 0, n = n + Math.imul(F, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D2, le) | 0, d = d + Math.imul(D2, de) | 0, l = l + Math.imul(R, ce) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_4, ve) | 0, d = d + Math.imul(_4, be) | 0;
        var Ve = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q3), n = Math.imul(G, ee), n = n + Math.imul(Y, Q3) | 0, d = Math.imul(Y, ee), l = l + Math.imul(V, te) | 0, n = n + Math.imul(V, re) | 0, n = n + Math.imul($2, te) | 0, d = d + Math.imul($2, re) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z2, oe) | 0, n = n + Math.imul(z2, se) | 0, n = n + Math.imul(H, oe) | 0, d = d + Math.imul(H, se) | 0, l = l + Math.imul(F, he) | 0, n = n + Math.imul(F, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D2, ce) | 0, d = d + Math.imul(D2, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re), n = n + Math.imul(Y, te) | 0, d = Math.imul(Y, re), l = l + Math.imul(V, ie) | 0, n = n + Math.imul(V, ne) | 0, n = n + Math.imul($2, ie) | 0, d = d + Math.imul($2, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z2, he) | 0, n = n + Math.imul(z2, ue) | 0, n = n + Math.imul(H, he) | 0, d = d + Math.imul(H, ue) | 0, l = l + Math.imul(F, le) | 0, n = n + Math.imul(F, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D2, ve) | 0, d = d + Math.imul(D2, be) | 0;
        var Ge = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y, ie) | 0, d = Math.imul(Y, ne), l = l + Math.imul(V, fe) | 0, n = n + Math.imul(V, ae) | 0, n = n + Math.imul($2, fe) | 0, d = d + Math.imul($2, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z2, le) | 0, n = n + Math.imul(z2, de) | 0, n = n + Math.imul(H, le) | 0, d = d + Math.imul(H, de) | 0, l = l + Math.imul(F, ce) | 0, n = n + Math.imul(F, pe) | 0, n = n + Math.imul(U, ce) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y, fe) | 0, d = Math.imul(Y, ae), l = l + Math.imul(V, oe) | 0, n = n + Math.imul(V, se) | 0, n = n + Math.imul($2, oe) | 0, d = d + Math.imul($2, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z2, ce) | 0, n = n + Math.imul(z2, pe) | 0, n = n + Math.imul(H, ce) | 0, d = d + Math.imul(H, pe) | 0, l = l + Math.imul(F, ve) | 0, n = n + Math.imul(F, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y, oe) | 0, d = Math.imul(Y, se), l = l + Math.imul(V, he) | 0, n = n + Math.imul(V, ue) | 0, n = n + Math.imul($2, he) | 0, d = d + Math.imul($2, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z2, ve) | 0, n = n + Math.imul(z2, be) | 0, n = n + Math.imul(H, ve) | 0, d = d + Math.imul(H, be) | 0;
        var Je = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y, he) | 0, d = Math.imul(Y, ue), l = l + Math.imul(V, le) | 0, n = n + Math.imul(V, de) | 0, n = n + Math.imul($2, le) | 0, d = d + Math.imul($2, de) | 0, l = l + Math.imul(j, ce) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y, le) | 0, d = Math.imul(Y, de), l = l + Math.imul(V, ce) | 0, n = n + Math.imul(V, pe) | 0, n = n + Math.imul($2, ce) | 0, d = d + Math.imul($2, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce), n = Math.imul(G, pe), n = n + Math.imul(Y, ce) | 0, d = Math.imul(Y, pe), l = l + Math.imul(V, ve) | 0, n = n + Math.imul(V, be) | 0, n = n + Math.imul($2, ve) | 0, d = d + Math.imul($2, be) | 0;
        var tt = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        b3 = (d + (n >>> 13) | 0) + (tt >>> 26) | 0, tt &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y, ve) | 0, d = Math.imul(Y, be);
        var rt = (b3 + l | 0) + ((n & 8191) << 13) | 0;
        return b3 = (d + (n >>> 13) | 0) + (rt >>> 26) | 0, rt &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt, c[18] = rt, b3 !== 0 && (c[19] = b3, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v2, i, a) {
        a.negative = i.negative ^ v2.negative, a.length = v2.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b3 = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v2.length + 1);n <= l; n++) {
            var d = u - n, w = v2.words[d] | 0, g = i.words[n] | 0, _4 = w * g, A = _4 & 67108863;
            c = c + (_4 / 67108864 | 0) | 0, A = A + b3 | 0, b3 = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b3, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v2, i, a) {
        var h = new N;
        return h.mulp(v2, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N(v2, i) {
        this.x = v2, this.y = i;
      }
      N.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N.prototype.permute = function(i, a, h, s, u, c) {
        for (var b3 = 0;b3 < c; b3++)
          s[b3] = a[i[b3]], u[b3] = h[i[b3]];
      }, N.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b3 = 1;b3 < u; b3 <<= 1)
          for (var l = b3 << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _4 = d, A = 0;A < b3; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b3], k = s[w + A + b3], D2 = g * Me - _4 * k;
              k = g * k + _4 * Me, Me = D2, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b3] = R - Me, s[w + A + b3] = I - k, A !== l && (D2 = n * g - d * _4, _4 = n * _4 + d * g, g = D2);
            }
      }, N.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b3 = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _4 = h.words;
        _4.length = s, this.convert13b(i.words, i.length, b3, s), this.convert13b(a.words, a.length, d, s), this.transform(b3, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _4, c, s, u), this.conjugate(_4, c, s), this.normalize13b(_4, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b3 = this.words[u] & s, l = (this.words[u] | 0) - b3 << a;
            this.words[u] = l | c, c = b3 >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b3 = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b3;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b3 = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b3;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b3 = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b3, b3 = c >> 26, this.words[u + h] = c & 67108863;
        if (b3 === 0)
          return this.strip();
        for (r(b3 === -1), b3 = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b3, b3 = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b3 = this._countBits(c);
        h = 26 - b3, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _4 = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_4 = Math.min(_4 / c | 0, 67108863), s._ishlnsubmul(u, _4, g);s.negative !== 0; )
            _4--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _4);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b3 = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _4 = 0, A = 1;(h.words[0] & A) === 0 && _4 < 26; ++_4, A <<= 1)
            ;
          if (_4 > 0)
            for (h.iushrn(_4);_4-- > 0; )
              (c.isOdd() || b3.isOdd()) && (c.iadd(n), b3.isub(d)), c.iushrn(1), b3.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b3)) : (h.isub(a), c.isub(s), b3.isub(u));
        }
        return { a: c, b: b3, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b3 = 0, l = 1;(a.words[0] & l) === 0 && b3 < 26; ++b3, l <<= 1)
            ;
          if (b3 > 0)
            for (a.iushrn(b3);b3-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b3 = this.words[c] | 0;
          b3 += u, u = b3 >>> 26, b3 &= 67108863, this.words[c] = b3;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v2, i) {
        this.name = v2, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b3 = i.words[u] | 0;
          i.words[u - 10] = (b3 & h) << 4 | c >>> 22, c = b3;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae, ye), Ae.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v2) {
        if (typeof v2 == "string") {
          var i = f._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b3 = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b3) !== 0; )
          n.redIAdd(b3);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _4 = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _4);
          var I = this.pow(d, new f(1).iushln(_4 - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _4 = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b3 = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b3 === 0) {
              l = 0;
              continue;
            }
            b3 <<= 1, b3 |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b3]), l = 0, b3 = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se(i);
      };
      function Se(v2) {
        P.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se, P), Se.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Sd > "u" || Sd, F3);
  });
  Ed = T((xL, z3) => {
    var U3 = w0(), wq = Te().Buffer;
    function Mq(t, e) {
      return wq.from(t.toRed(U3.mont(e.modulus)).redPow(new U3(e.publicExponent)).fromRed().toArray());
    }
    z3.exports = Mq;
  });
  j3 = T((SL, K3) => {
    var _q = Ha(), Ad = on(), xq = bf(), H3 = _d(), W3 = xd(), Rd = w0(), Sq = Ed(), Eq = Ks(), Kr = Te().Buffer;
    K3.exports = function(e, r, o) {
      var f;
      e.padding ? f = e.padding : o ? f = 1 : f = 4;
      var p = _q(e), m;
      if (f === 4)
        m = Aq(p, r);
      else if (f === 1)
        m = Rq(p, r, o);
      else if (f === 3) {
        if (m = new Rd(r), m.cmp(p.modulus) >= 0)
          throw new Error("data too long for modulus");
      } else
        throw new Error("unknown padding");
      return o ? Eq(m, p) : Sq(m, p);
    };
    function Aq(t, e) {
      var r = t.modulus.byteLength(), o = e.length, f = xq("sha1").update(Kr.alloc(0)).digest(), p = f.length, m = 2 * p;
      if (o > r - m - 2)
        throw new Error("message too long");
      var y = Kr.alloc(r - o - m - 2), M = r - p - 1, x = Ad(p), S2 = W3(Kr.concat([f, y, Kr.alloc(1, 1), e], M), H3(x, M)), E = W3(x, H3(S2, p));
      return new Rd(Kr.concat([Kr.alloc(1), E, S2], r));
    }
    function Rq(t, e, r) {
      var o = e.length, f = t.modulus.byteLength();
      if (o > f - 11)
        throw new Error("message too long");
      var p;
      return r ? p = Kr.alloc(f - o - 3, 255) : p = Bq(f - o - 3), new Rd(Kr.concat([Kr.from([0, r ? 1 : 2]), p, Kr.alloc(1), e], f));
    }
    function Bq(t) {
      for (var e = Kr.allocUnsafe(t), r = 0, o = Ad(t * 2), f = 0, p;r < t; )
        f === o.length && (o = Ad(t * 2), f = 0), p = o[f++], p && (e[r++] = p);
      return e;
    }
  });
  Y3 = T((EL, G3) => {
    var qq = Ha(), Z3 = _d(), V3 = xd(), $3 = w0(), Iq = Ks(), Tq = bf(), kq = Ed(), Za = Te().Buffer;
    G3.exports = function(e, r, o) {
      var f;
      e.padding ? f = e.padding : o ? f = 1 : f = 4;
      var p = qq(e), m = p.modulus.byteLength();
      if (r.length > m || new $3(r).cmp(p.modulus) >= 0)
        throw new Error("decryption error");
      var y;
      o ? y = kq(new $3(r), p) : y = Iq(r, p);
      var M = Za.alloc(m - y.length);
      if (y = Za.concat([M, y], m), f === 4)
        return Lq(p, y);
      if (f === 1)
        return Nq(p, y, o);
      if (f === 3)
        return y;
      throw new Error("unknown padding");
    };
    function Lq(t, e) {
      var r = t.modulus.byteLength(), o = Tq("sha1").update(Za.alloc(0)).digest(), f = o.length;
      if (e[0] !== 0)
        throw new Error("decryption error");
      var p = e.slice(1, f + 1), m = e.slice(f + 1), y = V3(p, Z3(m, f)), M = V3(m, Z3(y, r - f - 1));
      if (Dq(o, M.slice(0, f)))
        throw new Error("decryption error");
      for (var x = f;M[x] === 0; )
        x++;
      if (M[x++] !== 1)
        throw new Error("decryption error");
      return M.slice(x);
    }
    function Nq(t, e, r) {
      for (var o = e.slice(0, 2), f = 2, p = 0;e[f++] !== 0; )
        if (f >= e.length) {
          p++;
          break;
        }
      var m = e.slice(2, f - 1);
      if ((o.toString("hex") !== "0002" && !r || o.toString("hex") !== "0001" && r) && p++, m.length < 8 && p++, p)
        throw new Error("decryption error");
      return e.slice(f);
    }
    function Dq(t, e) {
      t = Za.from(t), e = Za.from(e);
      var r = 0, o = t.length;
      t.length !== e.length && (r++, o = Math.min(t.length, e.length));
      for (var f = -1;++f < o; )
        r += t[f] ^ e[f];
      return r;
    }
  });
  X3 = T((Vn) => {
    Vn.publicEncrypt = j3();
    Vn.privateDecrypt = Y3();
    Vn.privateEncrypt = function(e, r) {
      return Vn.publicEncrypt(e, r, true);
    };
    Vn.publicDecrypt = function(e, r) {
      return Vn.privateDecrypt(e, r, true);
    };
  });
  ow = T((Va) => {
    function J3() {
      throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
    }
    var ew = Te(), Q3 = on(), tw = ew.Buffer, rw = ew.kMaxLength, Bd = global.crypto || global.msCrypto, iw = Math.pow(2, 32) - 1;
    function nw(t, e) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("offset must be a number");
      if (t > iw || t < 0)
        throw new TypeError("offset must be a uint32");
      if (t > rw || t > e)
        throw new RangeError("offset out of range");
    }
    function fw(t, e, r) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("size must be a number");
      if (t > iw || t < 0)
        throw new TypeError("size must be a uint32");
      if (t + e > r || t > rw)
        throw new RangeError("buffer too small");
    }
    Bd && Bd.getRandomValues ? (Va.randomFill = Pq, Va.randomFillSync = Cq) : (Va.randomFill = J3, Va.randomFillSync = J3);
    function Pq(t, e, r, o) {
      if (!tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (typeof e == "function")
        o = e, e = 0, r = t.length;
      else if (typeof r == "function")
        o = r, r = t.length - e;
      else if (typeof o != "function")
        throw new TypeError('"cb" argument must be a function');
      return nw(e, t.length), fw(r, e, t.length), aw(t, e, r, o);
    }
    function aw(t, e, r, o) {
      if (true) {
        var f = t.buffer, p = new Uint8Array(f, e, r);
        if (Bd.getRandomValues(p), o) {
          process.nextTick(function() {
            o(null, t);
          });
          return;
        }
        return t;
      }
      if (o) {
        Q3(r, function(y, M) {
          if (y)
            return o(y);
          M.copy(t, e), o(null, t);
        });
        return;
      }
      var m = Q3(r);
      return m.copy(t, e), t;
    }
    function Cq(t, e, r) {
      if (typeof e > "u" && (e = 0), !tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      return nw(e, t.length), r === undefined && (r = t.length - e), fw(r, e, t.length), aw(t, e, r);
    }
  });
  qd = T((ke) => {
    ke.randomBytes = ke.rng = ke.pseudoRandomBytes = ke.prng = on();
    ke.createHash = ke.Hash = bf();
    ke.createHmac = ke.Hmac = wu();
    var Oq = Eb(), Fq = Object.keys(Oq), Uq = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(Fq);
    ke.getHashes = function() {
      return Uq;
    };
    var sw = Iu();
    ke.pbkdf2 = sw.pbkdf2;
    ke.pbkdf2Sync = sw.pbkdf2Sync;
    var ui = Vm();
    ke.Cipher = ui.Cipher;
    ke.createCipher = ui.createCipher;
    ke.Cipheriv = ui.Cipheriv;
    ke.createCipheriv = ui.createCipheriv;
    ke.Decipher = ui.Decipher;
    ke.createDecipher = ui.createDecipher;
    ke.Decipheriv = ui.Decipheriv;
    ke.createDecipheriv = ui.createDecipheriv;
    ke.getCiphers = ui.getCiphers;
    ke.listCiphers = ui.listCiphers;
    var $a = hg();
    ke.DiffieHellmanGroup = $a.DiffieHellmanGroup;
    ke.createDiffieHellmanGroup = $a.createDiffieHellmanGroup;
    ke.getDiffieHellman = $a.getDiffieHellman;
    ke.createDiffieHellman = $a.createDiffieHellman;
    ke.DiffieHellman = $a.DiffieHellman;
    var M0 = k3();
    ke.createSign = M0.createSign;
    ke.Sign = M0.Sign;
    ke.createVerify = M0.createVerify;
    ke.Verify = M0.Verify;
    ke.createECDH = P3();
    var _0 = X3();
    ke.publicEncrypt = _0.publicEncrypt;
    ke.privateEncrypt = _0.privateEncrypt;
    ke.publicDecrypt = _0.publicDecrypt;
    ke.privateDecrypt = _0.privateDecrypt;
    var hw = ow();
    ke.randomFill = hw.randomFill;
    ke.randomFillSync = hw.randomFillSync;
    ke.createCredentials = function() {
      throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
    };
    ke.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
  });
  Xt = {};
  Ja(Xt, { DEFAULT_ENCODING: () => Ga, default: () => Wq, getCurves: () => dw, getRandomValues: () => uw, randomUUID: () => lw, scrypt: () => Td, scryptSync: () => Id, timingSafeEqual: () => x0, webcrypto: () => cw });
  ot(Xt, rn(qd()));
  zq = rn(qd());
  Ga = "buffer";
  uw = (t) => crypto.getRandomValues(t);
  lw = () => crypto.randomUUID();
  Hq = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
  x0 = "timingSafeEqual" in crypto ? (t, e) => {
    let { byteLength: r } = t, { byteLength: o } = e;
    if (typeof r != "number" || typeof o != "number")
      throw new TypeError("Input must be an array buffer view");
    if (r !== o)
      throw new RangeError("Input buffers must have the same length");
    return crypto.timingSafeEqual(t, e);
  } : undefined;
  Id = "scryptSync" in crypto ? (t, e, r, o) => {
    let f = crypto.scryptSync(t, e, r, o);
    return Ga !== "buffer" ? new Buffer(f).toString(Ga) : new Buffer(f);
  } : undefined;
  Td = "scryptSync" in crypto ? function(t, e, r, o, f) {
    if (typeof o == "function" && (f = o, o = undefined), typeof f != "function") {
      var p = new TypeError("callback must be a function");
      throw p.code = "ERR_INVALID_CALLBACK", p;
    }
    try {
      let m = crypto.scryptSync(t, e, r, o);
      process.nextTick(f, null, Ga !== "buffer" ? new Buffer(m).toString(Ga) : new Buffer(m));
    } catch (m) {
      throw m;
    }
  } : undefined;
  x0 && (Object.defineProperty(x0, "name", { value: "::bunternal::" }), Object.defineProperty(Td, "name", { value: "::bunternal::" }), Object.defineProperty(Id, "name", { value: "::bunternal::" }));
  cw = crypto;
  Wq = { ...zq, getRandomValues: uw, randomUUID: lw, timingSafeEqual: x0, scryptSync: Id, scrypt: Td, webcrypto: cw, getCurves: dw };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/brorand/index.js
var require_brorand = __commonJS((exports, module) => {
  var Rand = function(rand) {
    this.rand = rand;
  };
  var r;
  module.exports = function rand(len) {
    if (!r)
      r = new Rand(null);
    return r.generate(len);
  };
  module.exports.Rand = Rand;
  Rand.prototype.generate = function generate(len) {
    return this._rand(len);
  };
  Rand.prototype._rand = function _rand(n) {
    if (this.rand.getBytes)
      return this.rand.getBytes(n);
    var res = new Uint8Array(n);
    for (var i = 0;i < res.length; i++)
      res[i] = this.rand.getByte();
    return res;
  };
  if (typeof self === "object") {
    if (self.crypto && self.crypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (self.msCrypto && self.msCrypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.msCrypto.getRandomValues(arr);
        return arr;
      };
    } else if (typeof window === "object") {
      Rand.prototype._rand = function() {
        throw new Error("Not implemented yet");
      };
    }
  } else {
    try {
      crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
      if (typeof crypto2.randomBytes !== "function")
        throw new Error("Not supported");
      Rand.prototype._rand = function _rand(n) {
        return crypto2.randomBytes(n);
      };
    } catch (e) {
    }
  }
  var crypto2;
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS((exports, module) => {
  var BaseCurve = function(type, conf) {
    this.type = type;
    this.p = new BN(conf.p, 16);
    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
    this.zero = new BN(0).toRed(this.red);
    this.one = new BN(1).toRed(this.red);
    this.two = new BN(2).toRed(this.red);
    this.n = conf.n && new BN(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  };
  var BasePoint = function(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
  };
  var BN = require_bn2();
  var utils = require_utils3();
  var getNAF = utils.getNAF;
  var getJSF = utils.getJSF;
  var assert = utils.assert;
  module.exports = BaseCurve;
  BaseCurve.prototype.point = function point() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype.validate = function validate() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k, 1, this._bitLength);
    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    var repr = [];
    var j;
    var nafW;
    for (j = 0;j < naf.length; j += doubles.step) {
      nafW = 0;
      for (var l = j + doubles.step - 1;l >= j; l--)
        nafW = (nafW << 1) + naf[l];
      repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b3 = this.jpoint(null, null, null);
    for (var i = I;i > 0; i--) {
      for (j = 0;j < repr.length; j++) {
        nafW = repr[j];
        if (nafW === i)
          b3 = b3.mixedAdd(doubles.points[j]);
        else if (nafW === -i)
          b3 = b3.mixedAdd(doubles.points[j].neg());
      }
      a = a.add(b3);
    }
    return a.toP();
  };
  BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k, w, this._bitLength);
    var acc = this.jpoint(null, null, null);
    for (var i = naf.length - 1;i >= 0; i--) {
      for (var l = 0;i >= 0 && naf[i] === 0; i--)
        l++;
      if (i >= 0)
        l++;
      acc = acc.dblp(l);
      if (i < 0)
        break;
      var z2 = naf[i];
      assert(z2 !== 0);
      if (p.type === "affine") {
        if (z2 > 0)
          acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
        else
          acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
      } else {
        if (z2 > 0)
          acc = acc.add(wnd[z2 - 1 >> 1]);
        else
          acc = acc.add(wnd[-z2 - 1 >> 1].neg());
      }
    }
    return p.type === "affine" ? acc.toP() : acc;
  };
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max = 0;
    var i;
    var j;
    var p;
    for (i = 0;i < len; i++) {
      p = points[i];
      var nafPoints = p._getNAFPoints(defW);
      wndWidth[i] = nafPoints.wnd;
      wnd[i] = nafPoints.points;
    }
    for (i = len - 1;i >= 1; i -= 2) {
      var a = i - 1;
      var b3 = i;
      if (wndWidth[a] !== 1 || wndWidth[b3] !== 1) {
        naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
        naf[b3] = getNAF(coeffs[b3], wndWidth[b3], this._bitLength);
        max = Math.max(naf[a].length, max);
        max = Math.max(naf[b3].length, max);
        continue;
      }
      var comb = [
        points[a],
        null,
        null,
        points[b3]
      ];
      if (points[a].y.cmp(points[b3].y) === 0) {
        comb[1] = points[a].add(points[b3]);
        comb[2] = points[a].toJ().mixedAdd(points[b3].neg());
      } else if (points[a].y.cmp(points[b3].y.redNeg()) === 0) {
        comb[1] = points[a].toJ().mixedAdd(points[b3]);
        comb[2] = points[a].add(points[b3].neg());
      } else {
        comb[1] = points[a].toJ().mixedAdd(points[b3]);
        comb[2] = points[a].toJ().mixedAdd(points[b3].neg());
      }
      var index = [
        -3,
        -1,
        -5,
        -7,
        0,
        7,
        5,
        1,
        3
      ];
      var jsf = getJSF(coeffs[a], coeffs[b3]);
      max = Math.max(jsf[0].length, max);
      naf[a] = new Array(max);
      naf[b3] = new Array(max);
      for (j = 0;j < max; j++) {
        var ja = jsf[0][j] | 0;
        var jb = jsf[1][j] | 0;
        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
        naf[b3][j] = 0;
        wnd[a] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (i = max;i >= 0; i--) {
      var k = 0;
      while (i >= 0) {
        var zero = true;
        for (j = 0;j < len; j++) {
          tmp[j] = naf[j][i] | 0;
          if (tmp[j] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k++;
        i--;
      }
      if (i >= 0)
        k++;
      acc = acc.dblp(k);
      if (i < 0)
        break;
      for (j = 0;j < len; j++) {
        var z2 = tmp[j];
        if (z2 === 0)
          continue;
        else if (z2 > 0)
          p = wnd[j][z2 - 1 >> 1];
        else if (z2 < 0)
          p = wnd[j][-z2 - 1 >> 1].neg();
        if (p.type === "affine")
          acc = acc.mixedAdd(p);
        else
          acc = acc.add(p);
      }
    }
    for (i = 0;i < len; i++)
      wnd[i] = null;
    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };
  BaseCurve.BasePoint = BasePoint;
  BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
  };
  BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
  };
  BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils.toArray(bytes, enc);
    var len = this.p.byteLength();
    if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
      if (bytes[0] === 6)
        assert(bytes[bytes.length - 1] % 2 === 0);
      else if (bytes[0] === 7)
        assert(bytes[bytes.length - 1] % 2 === 1);
      var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
      return res;
    } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
      return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
    }
    throw new Error("Unknown point format");
  };
  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };
  BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray("be", len);
    if (compact)
      return [this.getY().isEven() ? 2 : 3].concat(x);
    return [4].concat(x, this.getY().toArray("be", len));
  };
  BasePoint.prototype.encode = function encode(enc, compact) {
    return utils.encode(this._encode(compact), enc);
  };
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed)
      return false;
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
  };
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;
    for (var i = 0;i < power; i += step) {
      for (var j = 0;j < step; j++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step,
      points: doubles
    };
  };
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    var res = [this];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for (var i = 1;i < max; i++)
      res[i] = res[i - 1].add(dbl);
    return {
      wnd,
      points: res
    };
  };
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for (var i = 0;i < k; i++)
      r = r.dbl();
    return r;
  };
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS((exports, module) => {
  var ShortCurve = function(conf) {
    Base.call(this, "short", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  };
  var Point = function(curve, x, y, isRed) {
    Base.BasePoint.call(this, curve, "affine");
    if (x === null && y === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  };
  var JPoint = function(curve, x, y, z2) {
    Base.BasePoint.call(this, curve, "jacobian");
    if (x === null && y === null && z2 === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN(0);
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      this.z = new BN(z2, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  };
  var utils = require_utils3();
  var BN = require_bn2();
  var inherits = require_inherits_browser();
  var Base = require_base();
  var assert = utils.assert;
  inherits(ShortCurve, Base);
  module.exports = ShortCurve;
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new BN(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new BN(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new BN(vec.a, 16),
          b: new BN(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta,
      lambda,
      basis
    };
  };
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    var red = num === this.p ? this.red : BN.mont(num);
    var tinv = new BN(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [l1, l2];
  };
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    var u = lambda;
    var v2 = this.n.clone();
    var x1 = new BN(1);
    var y1 = new BN(0);
    var x2 = new BN(0);
    var y22 = new BN(1);
    var a0;
    var b0;
    var a1;
    var b1;
    var a2;
    var b22;
    var prevR;
    var i = 0;
    var r;
    var x;
    while (u.cmpn(0) !== 0) {
      var q = v2.div(u);
      r = v2.sub(q.mul(u));
      x = x2.sub(q.mul(x1));
      var y = y22.sub(q.mul(y1));
      if (!a1 && r.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r.neg();
        b1 = x;
      } else if (a1 && ++i === 2) {
        break;
      }
      prevR = r;
      v2 = u;
      u = r;
      x2 = x1;
      x1 = x;
      y22 = y1;
      y1 = y;
    }
    a2 = r.neg();
    b22 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b22.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b22 = b0;
    }
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.negative) {
      a2 = a2.neg();
      b22 = b22.neg();
    }
    return [
      { a: a1, b: b1 },
      { a: a2, b: b22 }
    ];
  };
  ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    var k12 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return { k1: k12, k2 };
  };
  ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var y22 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y22.redSqrt();
    if (y.redSqr().redSub(y22).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  ShortCurve.prototype.validate = function validate(point) {
    if (point.inf)
      return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i = 0;i < points.length; i++) {
      var split = this._endoSplit(coeffs[i]);
      var p = points[i];
      var beta = p._getBeta();
      if (split.k1.negative) {
        split.k1.ineg();
        p = p.neg(true);
      }
      if (split.k2.negative) {
        split.k2.ineg();
        beta = beta.neg(true);
      }
      npoints[i * 2] = p;
      npoints[i * 2 + 1] = beta;
      ncoeffs[i * 2] = split.k1;
      ncoeffs[i * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
    for (var j = 0;j < i * 2; j++) {
      npoints[j] = null;
      ncoeffs[j] = null;
    }
    return res;
  };
  inherits(Point, Base.BasePoint);
  ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point(this, x, y, isRed);
  };
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
  };
  Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo)
      return;
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve = this.curve;
      var endoMul = function(p) {
        return curve.point(p.x.redMul(curve.endo.beta), p.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }
    return beta;
  };
  Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed)
      return [this.x, this.y];
    return [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }];
  };
  Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === "string")
      obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2])
      return res;
    function obj2point(obj2) {
      return curve.point(obj2[0], obj2[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  Point.prototype.add = function add(p) {
    if (this.inf)
      return p;
    if (p.inf)
      return this;
    if (this.eq(p))
      return this.dbl();
    if (this.neg().eq(p))
      return this.curve.point(null, null);
    if (this.x.cmp(p.x) === 0)
      return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0)
      c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny2 = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny2);
  };
  Point.prototype.dbl = function dbl() {
    if (this.inf)
      return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny2 = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny2);
  };
  Point.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  Point.prototype.mul = function mul(k) {
    k = new BN(k, 16);
    if (this.isInfinity())
      return this;
    else if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([this], [k]);
    else
      return this.curve._wnafMul(this, k);
  };
  Point.prototype.mulAdd = function mulAdd(k12, p2, k2) {
    var points = [this, p2];
    var coeffs = [k12, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point.prototype.jmulAdd = function jmulAdd(k12, p2, k2) {
    var points = [this, p2];
    var coeffs = [k12, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  Point.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
  };
  Point.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p) {
        return p.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }
    return res;
  };
  Point.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  inherits(JPoint, Base.BasePoint);
  ShortCurve.prototype.jpoint = function jpoint(x, y, z2) {
    return new JPoint(this, x, y, z2);
  };
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s22 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s22);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v2 = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
    var ny2 = r.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny2, nz);
  };
  JPoint.prototype.mixedAdd = function mixedAdd(p) {
    if (this.isInfinity())
      return p.toJ();
    if (p.isInfinity())
      return this;
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s22 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s22);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v2 = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
    var ny2 = r.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny2, nz);
  };
  JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow)
      return this.dbl();
    var i;
    if (this.curve.zeroA || this.curve.threeA) {
      var r = this;
      for (i = 0;i < pow; i++)
        r = r.dbl();
      return r;
    }
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (i = 0;i < pow; i++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t22 = t1.redISub(nx);
      var dny = c.redMul(t22);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i + 1 < pow)
        jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny2;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy2 = this.y.redSqr();
      var yyyy = yy2.redSqr();
      var s = this.x.redAdd(yy2).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx);
      var t = m.redSqr().redISub(s).redISub(s);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t;
      ny2 = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a = this.x.redSqr();
      var b3 = this.y.redSqr();
      var c = b3.redSqr();
      var d = this.x.redAdd(b3).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d);
      var e = a.redAdd(a).redIAdd(a);
      var f = e.redSqr();
      var c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f.redISub(d).redISub(d);
      ny2 = e.redMul(d.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny2, nz);
  };
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny2;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy2 = this.y.redSqr();
      var yyyy = yy2.redSqr();
      var s = this.x.redAdd(yy2).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t = m.redSqr().redISub(s).redISub(s);
      nx = t;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny2 = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny2 = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny2, nz);
  };
  JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t22 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny2 = c.redMul(t22).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny2, nz);
  };
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy2 = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy2.redSqr();
    var m = xx.redAdd(xx).redIAdd(xx);
    var mm = m.redSqr();
    var e = this.x.redAdd(yy2).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    var ee = e.redSqr();
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    var yyu4 = yy2.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny2 = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny2 = ny2.redIAdd(ny2);
    ny2 = ny2.redIAdd(ny2);
    ny2 = ny2.redIAdd(ny2);
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny2, nz);
  };
  JPoint.prototype.mul = function mul(k, kbase) {
    k = new BN(k, kbase);
    return this.curve._wnafMul(this, k);
  };
  JPoint.prototype.eq = function eq(p) {
    if (p.type === "affine")
      return this.eq(p.toJ());
    if (this === p)
      return true;
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
      return false;
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
  };
  JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for (;; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  JPoint.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS((exports, module) => {
  var MontCurve = function(conf) {
    Base.call(this, "mont", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.i4 = new BN(4).toRed(this.red).redInvm();
    this.two = new BN(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  };
  var Point = function(curve, x, z2) {
    Base.BasePoint.call(this, curve, "projective");
    if (x === null && z2 === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN(x, 16);
      this.z = new BN(z2, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
  };
  var BN = require_bn2();
  var inherits = require_inherits_browser();
  var Base = require_base();
  var utils = require_utils3();
  inherits(MontCurve, Base);
  module.exports = MontCurve;
  MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
  };
  inherits(Point, Base.BasePoint);
  MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils.toArray(bytes, enc), 1);
  };
  MontCurve.prototype.point = function point(x, z2) {
    return new Point(this, x, z2);
  };
  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  Point.prototype.precompute = function precompute() {
  };
  Point.prototype._encode = function _encode() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1] || curve.one);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  Point.prototype.dbl = function dbl() {
    var a = this.x.redAdd(this.z);
    var aa = a.redSqr();
    var b3 = this.x.redSub(this.z);
    var bb = b3.redSqr();
    var c = aa.redSub(bb);
    var nx = aa.redMul(bb);
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
  };
  Point.prototype.add = function add() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.diffAdd = function diffAdd(p, diff) {
    var a = this.x.redAdd(this.z);
    var b3 = this.x.redSub(this.z);
    var c = p.x.redAdd(p.z);
    var d = p.x.redSub(p.z);
    var da = d.redMul(a);
    var cb = c.redMul(b3);
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };
  Point.prototype.mul = function mul(k) {
    var t = k.clone();
    var a = this;
    var b3 = this.curve.point(null, null);
    var c = this;
    for (var bits = [];t.cmpn(0) !== 0; t.iushrn(1))
      bits.push(t.andln(1));
    for (var i = bits.length - 1;i >= 0; i--) {
      if (bits[i] === 0) {
        a = a.diffAdd(b3, c);
        b3 = b3.dbl();
      } else {
        b3 = a.diffAdd(b3, c);
        a = a.dbl();
      }
    }
    return b3;
  };
  Point.prototype.mulAdd = function mulAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.jumlAdd = function jumlAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
  };
  Point.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS((exports, module) => {
  var EdwardsCurve = function(conf) {
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, "edwards", conf);
    this.a = new BN(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  };
  var Point = function(curve, x, y, z2, t) {
    Base.BasePoint.call(this, curve, "projective");
    if (x === null && y === null && z2 === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      this.z = z2 ? new BN(z2, 16) : this.curve.one;
      this.t = t && new BN(t, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redMul(this.z.redInvm());
      }
    }
  };
  var utils = require_utils3();
  var BN = require_bn2();
  var inherits = require_inherits_browser();
  var Base = require_base();
  var assert = utils.assert;
  inherits(EdwardsCurve, Base);
  module.exports = EdwardsCurve;
  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA)
      return num.redNeg();
    else
      return this.a.redMul(num);
  };
  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC)
      return num;
    else
      return this.c.redMul(num);
  };
  EdwardsCurve.prototype.jpoint = function jpoint(x, y, z2, t) {
    return this.point(x, y, z2, t);
  };
  EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    var y22 = rhs.redMul(lhs.redInvm());
    var y = y22.redSqrt();
    if (y.redSqr().redSub(y22).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN(y, 16);
    if (!y.red)
      y = y.toRed(this.red);
    var y22 = y.redSqr();
    var lhs = y22.redSub(this.c2);
    var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
      if (odd)
        throw new Error("invalid point");
      else
        return this.point(this.zero, y);
    }
    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    if (x.fromRed().isOdd() !== odd)
      x = x.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity())
      return true;
    point.normalize();
    var x2 = point.x.redSqr();
    var y22 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y22);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y22)));
    return lhs.cmp(rhs) === 0;
  };
  inherits(Point, Base.BasePoint);
  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  EdwardsCurve.prototype.point = function point(x, y, z2, t) {
    return new Point(this, x, y, z2, t);
  };
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1], obj[2]);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  Point.prototype._extDbl = function _extDbl() {
    var a = this.x.redSqr();
    var b3 = this.y.redSqr();
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    var d = this.curve._mulA(a);
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b3);
    var g = d.redAdd(b3);
    var f = g.redSub(c);
    var h = d.redSub(b3);
    var nx = e.redMul(f);
    var ny2 = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny2, nz, nt);
  };
  Point.prototype._projDbl = function _projDbl() {
    var b3 = this.x.redAdd(this.y).redSqr();
    var c = this.x.redSqr();
    var d = this.y.redSqr();
    var nx;
    var ny2;
    var nz;
    var e;
    var h;
    var j;
    if (this.curve.twisted) {
      e = this.curve._mulA(c);
      var f = e.redAdd(d);
      if (this.zOne) {
        nx = b3.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
        ny2 = f.redMul(e.redSub(d));
        nz = f.redSqr().redSub(f).redSub(f);
      } else {
        h = this.z.redSqr();
        j = f.redSub(h).redISub(h);
        nx = b3.redSub(c).redISub(d).redMul(j);
        ny2 = f.redMul(e.redSub(d));
        nz = f.redMul(j);
      }
    } else {
      e = c.redAdd(d);
      h = this.curve._mulC(this.z).redSqr();
      j = e.redSub(h).redSub(h);
      nx = this.curve._mulC(b3.redISub(e)).redMul(j);
      ny2 = this.curve._mulC(e).redMul(c.redISub(d));
      nz = e.redMul(j);
    }
    return this.curve.point(nx, ny2, nz);
  };
  Point.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extDbl();
    else
      return this._projDbl();
  };
  Point.prototype._extAdd = function _extAdd(p) {
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    var b3 = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    var d = this.z.redMul(p.z.redAdd(p.z));
    var e = b3.redSub(a);
    var f = d.redSub(c);
    var g = d.redAdd(c);
    var h = b3.redAdd(a);
    var nx = e.redMul(f);
    var ny2 = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny2, nz, nt);
  };
  Point.prototype._projAdd = function _projAdd(p) {
    var a = this.z.redMul(p.z);
    var b3 = a.redSqr();
    var c = this.x.redMul(p.x);
    var d = this.y.redMul(p.y);
    var e = this.curve.d.redMul(c).redMul(d);
    var f = b3.redSub(e);
    var g = b3.redAdd(e);
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny2;
    var nz;
    if (this.curve.twisted) {
      ny2 = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
      nz = f.redMul(g);
    } else {
      ny2 = a.redMul(g).redMul(d.redSub(c));
      nz = this.curve._mulC(f).redMul(g);
    }
    return this.curve.point(nx, ny2, nz);
  };
  Point.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extAdd(p);
    else
      return this._projAdd(p);
  };
  Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else
      return this.curve._wnafMul(this, k);
  };
  Point.prototype.mulAdd = function mulAdd(k12, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k12, k2], 2, false);
  };
  Point.prototype.jmulAdd = function jmulAdd(k12, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k12, k2], 2, true);
  };
  Point.prototype.normalize = function normalize() {
    if (this.zOne)
      return this;
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t)
      this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };
  Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };
  Point.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
  };
  Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);
    for (;; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  Point.prototype.toP = Point.prototype.normalize;
  Point.prototype.mixedAdd = Point.prototype.add;
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS((exports) => {
  var curve = exports;
  curve.base = require_base();
  curve.short = require_short();
  curve.mont = require_mont();
  curve.edwards = require_edwards();
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS((exports, module) => {
  module.exports = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  };
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS((exports) => {
  var PresetCurve = function(options) {
    if (options.type === "short")
      this.curve = new curve.short(options);
    else if (options.type === "edwards")
      this.curve = new curve.edwards(options);
    else
      this.curve = new curve.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert(this.g.validate(), "Invalid curve");
    assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  };
  var defineCurve = function(name, options) {
    Object.defineProperty(curves, name, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve2 = new PresetCurve(options);
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          value: curve2
        });
        return curve2;
      }
    });
  };
  var curves = exports;
  var hash = require_hash();
  var curve = require_curve();
  var utils = require_utils3();
  var assert = utils.assert;
  curves.PresetCurve = PresetCurve;
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = require_secp256k1();
  } catch (e) {
    pre = undefined;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS((exports, module) => {
  var HmacDRBG = function(options) {
    if (!(this instanceof HmacDRBG))
      return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
    var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
    var pers = utils.toArray(options.pers, options.persEnc || "hex");
    assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._init(entropy, nonce, pers);
  };
  var hash = require_hash();
  var utils = require_utils2();
  var assert = require_minimalistic_assert();
  module.exports = HmacDRBG;
  HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i = 0;i < this.V.length; i++) {
      this.K[i] = 0;
      this.V[i] = 1;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 281474976710656;
  };
  HmacDRBG.prototype._hmac = function hmac() {
    return new hash.hmac(this.hash, this.K);
  };
  HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([0]);
    if (seed)
      kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed)
      return;
    this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
  };
  HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    if (typeof entropyEnc !== "string") {
      addEnc = add;
      add = entropyEnc;
      entropyEnc = null;
    }
    entropy = utils.toArray(entropy, entropyEnc);
    add = utils.toArray(add, addEnc);
    assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._update(entropy.concat(add || []));
    this._reseed = 1;
  };
  HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    if (typeof enc !== "string") {
      addEnc = add;
      add = enc;
      enc = null;
    }
    if (add) {
      add = utils.toArray(add, addEnc || "hex");
      this._update(add);
    }
    var temp = [];
    while (temp.length < len) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add);
    this._reseed++;
    return utils.encode(res, enc);
  };
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS((exports, module) => {
  var KeyPair = function(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;
    if (options.priv)
      this._importPrivate(options.priv, options.privEnc);
    if (options.pub)
      this._importPublic(options.pub, options.pubEnc);
  };
  var BN = require_bn2();
  var utils = require_utils3();
  var assert = utils.assert;
  module.exports = KeyPair;
  KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(ec, {
      pub,
      pubEnc: enc
    });
  };
  KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair)
      return priv;
    return new KeyPair(ec, {
      priv,
      privEnc: enc
    });
  };
  KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity())
      return { result: false, reason: "Invalid public key" };
    if (!pub.validate())
      return { result: false, reason: "Public key is not a point" };
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return { result: false, reason: "Public key * N != O" };
    return { result: true, reason: null };
  };
  KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    if (typeof compact === "string") {
      enc = compact;
      compact = null;
    }
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
    if (!enc)
      return this.pub;
    return this.pub.encode(enc, compact);
  };
  KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex")
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new BN(key, enc || 16);
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  KeyPair.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
      if (this.ec.curve.type === "mont") {
        assert(key.x, "Need x coordinate");
      } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
        assert(key.x && key.y, "Need both x and y coordinate");
      }
      this.pub = this.ec.curve.point(key.x, key.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
  };
  KeyPair.prototype.derive = function derive(pub) {
    if (!pub.validate()) {
      assert(pub.validate(), "public point not validated");
    }
    return pub.mul(this.priv).getX();
  };
  KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };
  KeyPair.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
  };
  KeyPair.prototype.inspect = function inspect() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS((exports, module) => {
  var Signature = function(options, enc) {
    if (options instanceof Signature)
      return options;
    if (this._importDER(options, enc))
      return;
    assert(options.r && options.s, "Signature without r or s");
    this.r = new BN(options.r, 16);
    this.s = new BN(options.s, 16);
    if (options.recoveryParam === undefined)
      this.recoveryParam = null;
    else
      this.recoveryParam = options.recoveryParam;
  };
  var Position = function() {
    this.place = 0;
  };
  var getLength = function(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 128)) {
      return initial;
    }
    var octetLen = initial & 15;
    if (octetLen === 0 || octetLen > 4) {
      return false;
    }
    var val = 0;
    for (var i = 0, off = p.place;i < octetLen; i++, off++) {
      val <<= 8;
      val |= buf[off];
      val >>>= 0;
    }
    if (val <= 127) {
      return false;
    }
    p.place = off;
    return val;
  };
  var rmPadding = function(buf) {
    var i = 0;
    var len = buf.length - 1;
    while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
      i++;
    }
    if (i === 0) {
      return buf;
    }
    return buf.slice(i);
  };
  var constructLength = function(arr, len) {
    if (len < 128) {
      arr.push(len);
      return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 128);
    while (--octets) {
      arr.push(len >>> (octets << 3) & 255);
    }
    arr.push(len);
  };
  var BN = require_bn2();
  var utils = require_utils3();
  var assert = utils.assert;
  module.exports = Signature;
  Signature.prototype._importDER = function _importDER(data, enc) {
    data = utils.toArray(data, enc);
    var p = new Position;
    if (data[p.place++] !== 48) {
      return false;
    }
    var len = getLength(data, p);
    if (len === false) {
      return false;
    }
    if (len + p.place !== data.length) {
      return false;
    }
    if (data[p.place++] !== 2) {
      return false;
    }
    var rlen = getLength(data, p);
    if (rlen === false) {
      return false;
    }
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 2) {
      return false;
    }
    var slen = getLength(data, p);
    if (slen === false) {
      return false;
    }
    if (data.length !== slen + p.place) {
      return false;
    }
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0) {
      if (r[1] & 128) {
        r = r.slice(1);
      } else {
        return false;
      }
    }
    if (s[0] === 0) {
      if (s[1] & 128) {
        s = s.slice(1);
      } else {
        return false;
      }
    }
    this.r = new BN(r);
    this.s = new BN(s);
    this.recoveryParam = null;
    return true;
  };
  Signature.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    if (r[0] & 128)
      r = [0].concat(r);
    if (s[0] & 128)
      s = [0].concat(s);
    r = rmPadding(r);
    s = rmPadding(s);
    while (!s[0] && !(s[1] & 128)) {
      s = s.slice(1);
    }
    var arr = [2];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(2);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [48];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils.encode(res, enc);
  };
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS((exports, module) => {
  var EC = function(options) {
    if (!(this instanceof EC))
      return new EC(options);
    if (typeof options === "string") {
      assert(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options);
      options = curves[options];
    }
    if (options instanceof curves.PresetCurve)
      options = { curve: options };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  };
  var BN = require_bn2();
  var HmacDRBG = require_hmac_drbg();
  var utils = require_utils3();
  var curves = require_curves();
  var rand = require_brorand();
  var assert = utils.assert;
  var KeyPair = require_key();
  var Signature = require_signature();
  module.exports = EC;
  EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair(this, options);
  };
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
  };
  EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
  };
  EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};
    var drbg = new HmacDRBG({
      hash: this.hash,
      pers: options.pers,
      persEnc: options.persEnc || "utf8",
      entropy: options.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options.entropy && options.entropyEnc || "utf8",
      nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN(2));
    for (;; ) {
      var priv = new BN(drbg.generate(bytes));
      if (priv.cmp(ns2) > 0)
        continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    }
  };
  EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === "object") {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new BN(msg, 16));
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray("be", bytes);
    var nonce = msg.toArray("be", bytes);
    var drbg = new HmacDRBG({
      hash: this.hash,
      entropy: bkey,
      nonce,
      pers: options.pers,
      persEnc: options.persEnc || "utf8"
    });
    var ns1 = this.n.sub(new BN(1));
    for (var iter = 0;; iter++) {
      var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
      k = this._truncateToN(k, true);
      if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r = kpX.umod(this.n);
      if (r.cmpn(0) === 0)
        continue;
      var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
      s = s.umod(this.n);
      if (s.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
      if (options.canonical && s.cmp(this.nh) > 0) {
        s = this.n.sub(s);
        recoveryParam ^= 1;
      }
      return new Signature({ r, s, recoveryParam });
    }
  };
  EC.prototype.verify = function verify(msg, signature, key, enc) {
    msg = this._truncateToN(new BN(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature = new Signature(signature, "hex");
    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
      return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
      return false;
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    var p;
    if (!this.curve._maxwellTrick) {
      p = this.g.mulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.getX().umod(this.n).cmp(r) === 0;
    }
    p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.eqXToP(r);
  };
  EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
    assert((3 & j) === j, "The recovery param is more than two bits");
    signature = new Signature(signature, enc);
    var n = this.n;
    var e = new BN(msg);
    var r = signature.r;
    var s = signature.s;
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error("Unable to find sencond key candinate");
    if (isSecondKey)
      r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else
      r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s22 = s.mul(rInv).umod(n);
    return this.g.mulAdd(s1, r, s22);
  };
  EC.prototype.getKeyRecoveryParam = function(e, signature, Q3, enc) {
    signature = new Signature(signature, enc);
    if (signature.recoveryParam !== null)
      return signature.recoveryParam;
    for (var i = 0;i < 4; i++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e, signature, i);
      } catch (e2) {
        continue;
      }
      if (Qprime.eq(Q3))
        return i;
    }
    throw new Error("Unable to find valid recovery factor");
  };
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS((exports, module) => {
  var KeyPair = function(eddsa, params) {
    this.eddsa = eddsa;
    this._secret = parseBytes(params.secret);
    if (eddsa.isPoint(params.pub))
      this._pub = params.pub;
    else
      this._pubBytes = parseBytes(params.pub);
  };
  var utils = require_utils3();
  var assert = utils.assert;
  var parseBytes = utils.parseBytes;
  var cachedProperty = utils.cachedProperty;
  KeyPair.fromPublic = function fromPublic(eddsa, pub) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(eddsa, { pub });
  };
  KeyPair.fromSecret = function fromSecret(eddsa, secret) {
    if (secret instanceof KeyPair)
      return secret;
    return new KeyPair(eddsa, { secret });
  };
  KeyPair.prototype.secret = function secret() {
    return this._secret;
  };
  cachedProperty(KeyPair, "pubBytes", function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
  });
  cachedProperty(KeyPair, "pub", function pub() {
    if (this._pubBytes)
      return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });
  cachedProperty(KeyPair, "privBytes", function privBytes() {
    var eddsa = this.eddsa;
    var hash = this.hash();
    var lastIx = eddsa.encodingLength - 1;
    var a = hash.slice(0, eddsa.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
    return a;
  });
  cachedProperty(KeyPair, "priv", function priv() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  cachedProperty(KeyPair, "hash", function hash() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  KeyPair.prototype.sign = function sign(message) {
    assert(this._secret, "KeyPair can only verify");
    return this.eddsa.sign(message, this);
  };
  KeyPair.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };
  KeyPair.prototype.getSecret = function getSecret(enc) {
    assert(this._secret, "KeyPair is public only");
    return utils.encode(this.secret(), enc);
  };
  KeyPair.prototype.getPublic = function getPublic(enc) {
    return utils.encode(this.pubBytes(), enc);
  };
  module.exports = KeyPair;
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS((exports, module) => {
  var Signature = function(eddsa, sig) {
    this.eddsa = eddsa;
    if (typeof sig !== "object")
      sig = parseBytes(sig);
    if (Array.isArray(sig)) {
      sig = {
        R: sig.slice(0, eddsa.encodingLength),
        S: sig.slice(eddsa.encodingLength)
      };
    }
    assert(sig.R && sig.S, "Signature without R or S");
    if (eddsa.isPoint(sig.R))
      this._R = sig.R;
    if (sig.S instanceof BN)
      this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  };
  var BN = require_bn2();
  var utils = require_utils3();
  var assert = utils.assert;
  var cachedProperty = utils.cachedProperty;
  var parseBytes = utils.parseBytes;
  cachedProperty(Signature, "S", function S() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  cachedProperty(Signature, "R", function R() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  cachedProperty(Signature, "Rencoded", function Rencoded() {
    return this.eddsa.encodePoint(this.R());
  });
  cachedProperty(Signature, "Sencoded", function Sencoded() {
    return this.eddsa.encodeInt(this.S());
  });
  Signature.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Signature.prototype.toHex = function toHex() {
    return utils.encode(this.toBytes(), "hex").toUpperCase();
  };
  module.exports = Signature;
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS((exports, module) => {
  var EDDSA = function(curve) {
    assert(curve === "ed25519", "only tested with ed25519 so far");
    if (!(this instanceof EDDSA))
      return new EDDSA(curve);
    curve = curves[curve].curve;
    this.curve = curve;
    this.g = curve.g;
    this.g.precompute(curve.n.bitLength() + 1);
    this.pointClass = curve.point().constructor;
    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    this.hash = hash.sha512;
  };
  var hash = require_hash();
  var curves = require_curves();
  var utils = require_utils3();
  var assert = utils.assert;
  var parseBytes = utils.parseBytes;
  var KeyPair = require_key2();
  var Signature = require_signature2();
  module.exports = EDDSA;
  EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
    var S2 = r.add(s_).umod(this.curve.n);
    return this.makeSignature({ R, S: S2, Rencoded });
  };
  EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key.pub().mul(h));
    return RplusAh.eq(SG);
  };
  EDDSA.prototype.hashInt = function hashInt() {
    var hash2 = this.hash();
    for (var i = 0;i < arguments.length; i++)
      hash2.update(arguments[i]);
    return utils.intFromLE(hash2.digest()).umod(this.curve.n);
  };
  EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
  };
  EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
  };
  EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature)
      return sig;
    return new Signature(this, sig);
  };
  EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray("le", this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
    return enc;
  };
  EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils.parseBytes(bytes);
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
    var xIsOdd = (bytes[lastIx] & 128) !== 0;
    var y = utils.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
  };
  EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray("le", this.encodingLength);
  };
  EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return utils.intFromLE(bytes);
  };
  EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
  };
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS((exports) => {
  var elliptic = exports;
  elliptic.version = require_package().version;
  elliptic.utils = require_utils3();
  elliptic.rand = require_brorand();
  elliptic.curve = require_curve();
  elliptic.curves = require_curves();
  elliptic.ec = require_ec();
  elliptic.eddsa = require_eddsa();
});

// node_modules/@ethersproject/signing-key/lib/elliptic.js
var require_elliptic2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EC = undefined;
  var elliptic_1 = __importDefault(require_elliptic());
  var EC = elliptic_1.default.ec;
  exports.EC = EC;
});

// node_modules/@ethersproject/signing-key/lib/_version.js
var require__version11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "signing-key/5.7.0";
});

// node_modules/@ethersproject/signing-key/lib/index.js
var require_lib17 = __commonJS((exports) => {
  var getCurve = function() {
    if (!_curve) {
      _curve = new elliptic_1.EC("secp256k1");
    }
    return _curve;
  };
  var recoverPublicKey = function(digest, signature) {
    var sig = (0, bytes_1.splitSignature)(signature);
    var rs = { r: (0, bytes_1.arrayify)(sig.r), s: (0, bytes_1.arrayify)(sig.s) };
    return "0x" + getCurve().recoverPubKey((0, bytes_1.arrayify)(digest), rs, sig.recoveryParam).encode("hex", false);
  };
  var computePublicKey = function(key, compressed) {
    var bytes = (0, bytes_1.arrayify)(key);
    if (bytes.length === 32) {
      var signingKey = new SigningKey(bytes);
      if (compressed) {
        return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
      }
      return signingKey.publicKey;
    } else if (bytes.length === 33) {
      if (compressed) {
        return (0, bytes_1.hexlify)(bytes);
      }
      return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
    } else if (bytes.length === 65) {
      if (!compressed) {
        return (0, bytes_1.hexlify)(bytes);
      }
      return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
    }
    return logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.computePublicKey = exports.recoverPublicKey = exports.SigningKey = undefined;
  var elliptic_1 = require_elliptic2();
  var bytes_1 = require_lib2();
  var properties_1 = require_lib4();
  var logger_1 = require_lib();
  var _version_1 = require__version11();
  var logger = new logger_1.Logger(_version_1.version);
  var _curve = null;
  var SigningKey = function() {
    function SigningKey2(privateKey) {
      (0, properties_1.defineReadOnly)(this, "curve", "secp256k1");
      (0, properties_1.defineReadOnly)(this, "privateKey", (0, bytes_1.hexlify)(privateKey));
      if ((0, bytes_1.hexDataLength)(this.privateKey) !== 32) {
        logger.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
      }
      var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
      (0, properties_1.defineReadOnly)(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
      (0, properties_1.defineReadOnly)(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
      (0, properties_1.defineReadOnly)(this, "_isSigningKey", true);
    }
    SigningKey2.prototype._addPoint = function(other) {
      var p0 = getCurve().keyFromPublic((0, bytes_1.arrayify)(this.publicKey));
      var p1 = getCurve().keyFromPublic((0, bytes_1.arrayify)(other));
      return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
    };
    SigningKey2.prototype.signDigest = function(digest) {
      var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
      var digestBytes = (0, bytes_1.arrayify)(digest);
      if (digestBytes.length !== 32) {
        logger.throwArgumentError("bad digest length", "digest", digest);
      }
      var signature = keyPair.sign(digestBytes, { canonical: true });
      return (0, bytes_1.splitSignature)({
        recoveryParam: signature.recoveryParam,
        r: (0, bytes_1.hexZeroPad)("0x" + signature.r.toString(16), 32),
        s: (0, bytes_1.hexZeroPad)("0x" + signature.s.toString(16), 32)
      });
    };
    SigningKey2.prototype.computeSharedSecret = function(otherKey) {
      var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
      var otherKeyPair = getCurve().keyFromPublic((0, bytes_1.arrayify)(computePublicKey(otherKey)));
      return (0, bytes_1.hexZeroPad)("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
    };
    SigningKey2.isSigningKey = function(value) {
      return !!(value && value._isSigningKey);
    };
    return SigningKey2;
  }();
  exports.SigningKey = SigningKey;
  exports.recoverPublicKey = recoverPublicKey;
  exports.computePublicKey = computePublicKey;
});

// node_modules/@ethersproject/transactions/lib/_version.js
var require__version12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "transactions/5.7.0";
});

// node_modules/@ethersproject/transactions/lib/index.js
var require_lib18 = __commonJS((exports) => {
  var handleAddress = function(value) {
    if (value === "0x") {
      return null;
    }
    return (0, address_1.getAddress)(value);
  };
  var handleNumber = function(value) {
    if (value === "0x") {
      return constants_1.Zero;
    }
    return bignumber_1.BigNumber.from(value);
  };
  var computeAddress = function(key) {
    var publicKey = (0, signing_key_1.computePublicKey)(key);
    return (0, address_1.getAddress)((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.hexDataSlice)(publicKey, 1)), 12));
  };
  var recoverAddress = function(digest, signature) {
    return computeAddress((0, signing_key_1.recoverPublicKey)((0, bytes_1.arrayify)(digest), signature));
  };
  var formatNumber = function(value, name) {
    var result = (0, bytes_1.stripZeros)(bignumber_1.BigNumber.from(value).toHexString());
    if (result.length > 32) {
      logger.throwArgumentError("invalid length for " + name, "transaction:" + name, value);
    }
    return result;
  };
  var accessSetify = function(addr, storageKeys) {
    return {
      address: (0, address_1.getAddress)(addr),
      storageKeys: (storageKeys || []).map(function(storageKey, index) {
        if ((0, bytes_1.hexDataLength)(storageKey) !== 32) {
          logger.throwArgumentError("invalid access list storageKey", "accessList[" + addr + ":" + index + "]", storageKey);
        }
        return storageKey.toLowerCase();
      })
    };
  };
  var accessListify = function(value) {
    if (Array.isArray(value)) {
      return value.map(function(set, index) {
        if (Array.isArray(set)) {
          if (set.length > 2) {
            logger.throwArgumentError("access list expected to be [ address, storageKeys[] ]", "value[" + index + "]", set);
          }
          return accessSetify(set[0], set[1]);
        }
        return accessSetify(set.address, set.storageKeys);
      });
    }
    var result = Object.keys(value).map(function(addr) {
      var storageKeys = value[addr].reduce(function(accum, storageKey) {
        accum[storageKey] = true;
        return accum;
      }, {});
      return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort(function(a, b3) {
      return a.address.localeCompare(b3.address);
    });
    return result;
  };
  var formatAccessList = function(value) {
    return accessListify(value).map(function(set) {
      return [set.address, set.storageKeys];
    });
  };
  var _serializeEip1559 = function(transaction, signature) {
    if (transaction.gasPrice != null) {
      var gasPrice = bignumber_1.BigNumber.from(transaction.gasPrice);
      var maxFeePerGas = bignumber_1.BigNumber.from(transaction.maxFeePerGas || 0);
      if (!gasPrice.eq(maxFeePerGas)) {
        logger.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
          gasPrice,
          maxFeePerGas
        });
      }
    }
    var fields = [
      formatNumber(transaction.chainId || 0, "chainId"),
      formatNumber(transaction.nonce || 0, "nonce"),
      formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
      formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
      formatNumber(transaction.gasLimit || 0, "gasLimit"),
      transaction.to != null ? (0, address_1.getAddress)(transaction.to) : "0x",
      formatNumber(transaction.value || 0, "value"),
      transaction.data || "0x",
      formatAccessList(transaction.accessList || [])
    ];
    if (signature) {
      var sig = (0, bytes_1.splitSignature)(signature);
      fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
      fields.push((0, bytes_1.stripZeros)(sig.r));
      fields.push((0, bytes_1.stripZeros)(sig.s));
    }
    return (0, bytes_1.hexConcat)(["0x02", RLP.encode(fields)]);
  };
  var _serializeEip2930 = function(transaction, signature) {
    var fields = [
      formatNumber(transaction.chainId || 0, "chainId"),
      formatNumber(transaction.nonce || 0, "nonce"),
      formatNumber(transaction.gasPrice || 0, "gasPrice"),
      formatNumber(transaction.gasLimit || 0, "gasLimit"),
      transaction.to != null ? (0, address_1.getAddress)(transaction.to) : "0x",
      formatNumber(transaction.value || 0, "value"),
      transaction.data || "0x",
      formatAccessList(transaction.accessList || [])
    ];
    if (signature) {
      var sig = (0, bytes_1.splitSignature)(signature);
      fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
      fields.push((0, bytes_1.stripZeros)(sig.r));
      fields.push((0, bytes_1.stripZeros)(sig.s));
    }
    return (0, bytes_1.hexConcat)(["0x01", RLP.encode(fields)]);
  };
  var _serialize = function(transaction, signature) {
    (0, properties_1.checkProperties)(transaction, allowedTransactionKeys);
    var raw = [];
    transactionFields.forEach(function(fieldInfo) {
      var value = transaction[fieldInfo.name] || [];
      var options = {};
      if (fieldInfo.numeric) {
        options.hexPad = "left";
      }
      value = (0, bytes_1.arrayify)((0, bytes_1.hexlify)(value, options));
      if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
        logger.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
      if (fieldInfo.maxLength) {
        value = (0, bytes_1.stripZeros)(value);
        if (value.length > fieldInfo.maxLength) {
          logger.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
        }
      }
      raw.push((0, bytes_1.hexlify)(value));
    });
    var chainId = 0;
    if (transaction.chainId != null) {
      chainId = transaction.chainId;
      if (typeof chainId !== "number") {
        logger.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
      }
    } else if (signature && !(0, bytes_1.isBytesLike)(signature) && signature.v > 28) {
      chainId = Math.floor((signature.v - 35) / 2);
    }
    if (chainId !== 0) {
      raw.push((0, bytes_1.hexlify)(chainId));
      raw.push("0x");
      raw.push("0x");
    }
    if (!signature) {
      return RLP.encode(raw);
    }
    var sig = (0, bytes_1.splitSignature)(signature);
    var v2 = 27 + sig.recoveryParam;
    if (chainId !== 0) {
      raw.pop();
      raw.pop();
      raw.pop();
      v2 += chainId * 2 + 8;
      if (sig.v > 28 && sig.v !== v2) {
        logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
      }
    } else if (sig.v !== v2) {
      logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
    }
    raw.push((0, bytes_1.hexlify)(v2));
    raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.r)));
    raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.s)));
    return RLP.encode(raw);
  };
  var serialize = function(transaction, signature) {
    if (transaction.type == null || transaction.type === 0) {
      if (transaction.accessList != null) {
        logger.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
      }
      return _serialize(transaction, signature);
    }
    switch (transaction.type) {
      case 1:
        return _serializeEip2930(transaction, signature);
      case 2:
        return _serializeEip1559(transaction, signature);
      default:
        break;
    }
    return logger.throwError("unsupported transaction type: " + transaction.type, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "serializeTransaction",
      transactionType: transaction.type
    });
  };
  var _parseEipSignature = function(tx, fields, serialize2) {
    try {
      var recid = handleNumber(fields[0]).toNumber();
      if (recid !== 0 && recid !== 1) {
        throw new Error("bad recid");
      }
      tx.v = recid;
    } catch (error) {
      logger.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
    }
    tx.r = (0, bytes_1.hexZeroPad)(fields[1], 32);
    tx.s = (0, bytes_1.hexZeroPad)(fields[2], 32);
    try {
      var digest = (0, keccak256_1.keccak256)(serialize2(tx));
      tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
    } catch (error) {
    }
  };
  var _parseEip1559 = function(payload) {
    var transaction = RLP.decode(payload.slice(1));
    if (transaction.length !== 9 && transaction.length !== 12) {
      logger.throwArgumentError("invalid component count for transaction type: 2", "payload", (0, bytes_1.hexlify)(payload));
    }
    var maxPriorityFeePerGas = handleNumber(transaction[2]);
    var maxFeePerGas = handleNumber(transaction[3]);
    var tx = {
      type: 2,
      chainId: handleNumber(transaction[0]).toNumber(),
      nonce: handleNumber(transaction[1]).toNumber(),
      maxPriorityFeePerGas,
      maxFeePerGas,
      gasPrice: null,
      gasLimit: handleNumber(transaction[4]),
      to: handleAddress(transaction[5]),
      value: handleNumber(transaction[6]),
      data: transaction[7],
      accessList: accessListify(transaction[8])
    };
    if (transaction.length === 9) {
      return tx;
    }
    tx.hash = (0, keccak256_1.keccak256)(payload);
    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
    return tx;
  };
  var _parseEip2930 = function(payload) {
    var transaction = RLP.decode(payload.slice(1));
    if (transaction.length !== 8 && transaction.length !== 11) {
      logger.throwArgumentError("invalid component count for transaction type: 1", "payload", (0, bytes_1.hexlify)(payload));
    }
    var tx = {
      type: 1,
      chainId: handleNumber(transaction[0]).toNumber(),
      nonce: handleNumber(transaction[1]).toNumber(),
      gasPrice: handleNumber(transaction[2]),
      gasLimit: handleNumber(transaction[3]),
      to: handleAddress(transaction[4]),
      value: handleNumber(transaction[5]),
      data: transaction[6],
      accessList: accessListify(transaction[7])
    };
    if (transaction.length === 8) {
      return tx;
    }
    tx.hash = (0, keccak256_1.keccak256)(payload);
    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
    return tx;
  };
  var _parse = function(rawTransaction) {
    var transaction = RLP.decode(rawTransaction);
    if (transaction.length !== 9 && transaction.length !== 6) {
      logger.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
    }
    var tx = {
      nonce: handleNumber(transaction[0]).toNumber(),
      gasPrice: handleNumber(transaction[1]),
      gasLimit: handleNumber(transaction[2]),
      to: handleAddress(transaction[3]),
      value: handleNumber(transaction[4]),
      data: transaction[5],
      chainId: 0
    };
    if (transaction.length === 6) {
      return tx;
    }
    try {
      tx.v = bignumber_1.BigNumber.from(transaction[6]).toNumber();
    } catch (error) {
      return tx;
    }
    tx.r = (0, bytes_1.hexZeroPad)(transaction[7], 32);
    tx.s = (0, bytes_1.hexZeroPad)(transaction[8], 32);
    if (bignumber_1.BigNumber.from(tx.r).isZero() && bignumber_1.BigNumber.from(tx.s).isZero()) {
      tx.chainId = tx.v;
      tx.v = 0;
    } else {
      tx.chainId = Math.floor((tx.v - 35) / 2);
      if (tx.chainId < 0) {
        tx.chainId = 0;
      }
      var recoveryParam = tx.v - 27;
      var raw = transaction.slice(0, 6);
      if (tx.chainId !== 0) {
        raw.push((0, bytes_1.hexlify)(tx.chainId));
        raw.push("0x");
        raw.push("0x");
        recoveryParam -= tx.chainId * 2 + 8;
      }
      var digest = (0, keccak256_1.keccak256)(RLP.encode(raw));
      try {
        tx.from = recoverAddress(digest, { r: (0, bytes_1.hexlify)(tx.r), s: (0, bytes_1.hexlify)(tx.s), recoveryParam });
      } catch (error) {
      }
      tx.hash = (0, keccak256_1.keccak256)(rawTransaction);
    }
    tx.type = null;
    return tx;
  };
  var parse = function(rawTransaction) {
    var payload = (0, bytes_1.arrayify)(rawTransaction);
    if (payload[0] > 127) {
      return _parse(payload);
    }
    switch (payload[0]) {
      case 1:
        return _parseEip2930(payload);
      case 2:
        return _parseEip1559(payload);
      default:
        break;
    }
    return logger.throwError("unsupported transaction type: " + payload[0], logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "parseTransaction",
      transactionType: payload[0]
    });
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
    Object.defineProperty(o, "default", { enumerable: true, value: v2 });
  } : function(o, v2) {
    o["default"] = v2;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = exports.serialize = exports.accessListify = exports.recoverAddress = exports.computeAddress = exports.TransactionTypes = undefined;
  var address_1 = require_lib7();
  var bignumber_1 = require_lib3();
  var bytes_1 = require_lib2();
  var constants_1 = require_lib8();
  var keccak256_1 = require_lib5();
  var properties_1 = require_lib4();
  var RLP = __importStar(require_lib6());
  var signing_key_1 = require_lib17();
  var logger_1 = require_lib();
  var _version_1 = require__version12();
  var logger = new logger_1.Logger(_version_1.version);
  var TransactionTypes;
  (function(TransactionTypes2) {
    TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
    TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
    TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
  })(TransactionTypes = exports.TransactionTypes || (exports.TransactionTypes = {}));
  var transactionFields = [
    { name: "nonce", maxLength: 32, numeric: true },
    { name: "gasPrice", maxLength: 32, numeric: true },
    { name: "gasLimit", maxLength: 32, numeric: true },
    { name: "to", length: 20 },
    { name: "value", maxLength: 32, numeric: true },
    { name: "data" }
  ];
  var allowedTransactionKeys = {
    chainId: true,
    data: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    type: true,
    value: true
  };
  exports.computeAddress = computeAddress;
  exports.recoverAddress = recoverAddress;
  exports.accessListify = accessListify;
  exports.serialize = serialize;
  exports.parse = parse;
});

// node_modules/@ethersproject/wordlists/lib/_version.js
var require__version13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "wordlists/5.7.0";
});

// node_modules/@ethersproject/wordlists/lib/wordlist.js
var require_wordlist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Wordlist = exports.logger = undefined;
  var exportWordlist = false;
  var hash_1 = require_lib12();
  var properties_1 = require_lib4();
  var logger_1 = require_lib();
  var _version_1 = require__version13();
  exports.logger = new logger_1.Logger(_version_1.version);
  var Wordlist = function() {
    function Wordlist2(locale) {
      var _newTarget = this.constructor;
      exports.logger.checkAbstract(_newTarget, Wordlist2);
      (0, properties_1.defineReadOnly)(this, "locale", locale);
    }
    Wordlist2.prototype.split = function(mnemonic) {
      return mnemonic.toLowerCase().split(/ +/g);
    };
    Wordlist2.prototype.join = function(words) {
      return words.join(" ");
    };
    Wordlist2.check = function(wordlist) {
      var words = [];
      for (var i = 0;i < 2048; i++) {
        var word = wordlist.getWord(i);
        if (i !== wordlist.getWordIndex(word)) {
          return "0x";
        }
        words.push(word);
      }
      return (0, hash_1.id)(words.join("\n") + "\n");
    };
    Wordlist2.register = function(lang, name) {
      if (!name) {
        name = lang.locale;
      }
      if (exportWordlist) {
        try {
          var anyGlobal = window;
          if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {
            if (!anyGlobal._ethers.wordlists[name]) {
              (0, properties_1.defineReadOnly)(anyGlobal._ethers.wordlists, name, lang);
            }
          }
        } catch (error) {
        }
      }
    };
    return Wordlist2;
  }();
  exports.Wordlist = Wordlist;
});

// node_modules/@ethersproject/wordlists/lib/lang-cz.js
var require_lang_cz = __commonJS((exports) => {
  var loadWords = function(lang) {
    if (wordlist != null) {
      return;
    }
    wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
    if (wordlist_1.Wordlist.check(lang) !== "0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a") {
      wordlist = null;
      throw new Error("BIP39 Wordlist for en (English) FAILED");
    }
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
        d2.__proto__ = b4;
      } || function(d2, b4) {
        for (var p in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p))
            d2[p] = b4[p];
      };
      return extendStatics(d, b3);
    };
    return function(d, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d, b3);
      function __() {
        this.constructor = d;
      }
      d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.langCz = undefined;
  var wordlist_1 = require_wordlist();
  var words = "AbdikaceAbecedaAdresaAgreseAkceAktovkaAlejAlkoholAmputaceAnanasAndulkaAnekdotaAnketaAntikaAnulovatArchaAroganceAsfaltAsistentAspiraceAstmaAstronomAtlasAtletikaAtolAutobusAzylBabkaBachorBacilBaculkaBadatelBagetaBagrBahnoBakterieBaladaBaletkaBalkonBalonekBalvanBalzaBambusBankomatBarbarBaretBarmanBarokoBarvaBaterkaBatohBavlnaBazalkaBazilikaBazukaBednaBeranBesedaBestieBetonBezinkaBezmocBeztakBicyklBidloBiftekBikinyBilanceBiografBiologBitvaBizonBlahobytBlatouchBlechaBleduleBleskBlikatBliznaBlokovatBlouditBludBobekBobrBodlinaBodnoutBohatostBojkotBojovatBokorysBolestBorecBoroviceBotaBoubelBouchatBoudaBouleBouratBoxerBradavkaBramboraBrankaBratrBreptaBriketaBrkoBrlohBronzBroskevBrunetkaBrusinkaBrzdaBrzyBublinaBubnovatBuchtaBuditelBudkaBudovaBufetBujarostBukviceBuldokBulvaBundaBunkrBurzaButikBuvolBuzolaBydletBylinaBytovkaBzukotCapartCarevnaCedrCeduleCejchCejnCelaCelerCelkemCelniceCeninaCennostCenovkaCentrumCenzorCestopisCetkaChalupaChapadloCharitaChataChechtatChemieChichotChirurgChladChlebaChlubitChmelChmuraChobotChocholChodbaCholeraChomoutChopitChorobaChovChrapotChrlitChrtChrupChtivostChudinaChutnatChvatChvilkaChvostChybaChystatChytitCibuleCigaretaCihelnaCihlaCinkotCirkusCisternaCitaceCitrusCizinecCizostClonaCokolivCouvatCtitelCtnostCudnostCuketaCukrCupotCvaknoutCvalCvikCvrkotCyklistaDalekoDarebaDatelDatumDceraDebataDechovkaDecibelDeficitDeflaceDeklDekretDemokratDepreseDerbyDeskaDetektivDikobrazDiktovatDiodaDiplomDiskDisplejDivadloDivochDlahaDlouhoDluhopisDnesDobroDobytekDocentDochutitDodnesDohledDohodaDohraDojemDojniceDokladDokolaDoktorDokumentDolarDolevaDolinaDomaDominantDomluvitDomovDonutitDopadDopisDoplnitDoposudDoprovodDopustitDorazitDorostDortDosahDoslovDostatekDosudDosytaDotazDotekDotknoutDoufatDoutnatDovozceDozaduDoznatDozorceDrahotaDrakDramatikDravecDrazeDrdolDrobnostDrogerieDrozdDrsnostDrtitDrzostDubenDuchovnoDudekDuhaDuhovkaDusitDusnoDutostDvojiceDvorecDynamitEkologEkonomieElektronElipsaEmailEmiseEmoceEmpatieEpizodaEpochaEpopejEposEsejEsenceEskortaEskymoEtiketaEuforieEvoluceExekuceExkurzeExpediceExplozeExportExtraktFackaFajfkaFakultaFanatikFantazieFarmacieFavoritFazoleFederaceFejetonFenkaFialkaFigurantFilozofFiltrFinanceFintaFixaceFjordFlanelFlirtFlotilaFondFosforFotbalFotkaFotonFrakceFreskaFrontaFukarFunkceFyzikaGalejeGarantGenetikaGeologGilotinaGlazuraGlejtGolemGolfistaGotikaGrafGramofonGranuleGrepGrilGrogGroteskaGumaHadiceHadrHalaHalenkaHanbaHanopisHarfaHarpunaHavranHebkostHejkalHejnoHejtmanHektarHelmaHematomHerecHernaHesloHezkyHistorikHladovkaHlasivkyHlavaHledatHlenHlodavecHlohHloupostHltatHlubinaHluchotaHmatHmotaHmyzHnisHnojivoHnoutHoblinaHobojHochHodinyHodlatHodnotaHodovatHojnostHokejHolinkaHolkaHolubHomoleHonitbaHonoraceHoralHordaHorizontHorkoHorlivecHormonHorninaHoroskopHorstvoHospodaHostinaHotovostHoubaHoufHoupatHouskaHovorHradbaHraniceHravostHrazdaHrbolekHrdinaHrdloHrdostHrnekHrobkaHromadaHrotHroudaHrozenHrstkaHrubostHryzatHubenostHubnoutHudbaHukotHumrHusitaHustotaHvozdHybnostHydrantHygienaHymnaHysterikIdylkaIhnedIkonaIluzeImunitaInfekceInflaceInkasoInovaceInspekceInternetInvalidaInvestorInzerceIronieJablkoJachtaJahodaJakmileJakostJalovecJantarJarmarkJaroJasanJasnoJatkaJavorJazykJedinecJedleJednatelJehlanJekotJelenJelitoJemnostJenomJepiceJeseterJevitJezdecJezeroJinakJindyJinochJiskraJistotaJitrniceJizvaJmenovatJogurtJurtaKabaretKabelKabinetKachnaKadetKadidloKahanKajakKajutaKakaoKaktusKalamitaKalhotyKalibrKalnostKameraKamkolivKamnaKanibalKanoeKantorKapalinaKapelaKapitolaKapkaKapleKapotaKaprKapustaKapybaraKaramelKarotkaKartonKasaKatalogKatedraKauceKauzaKavalecKazajkaKazetaKazivostKdekolivKdesiKedlubenKempKeramikaKinoKlacekKladivoKlamKlapotKlasikaKlaunKlecKlenbaKlepatKlesnoutKlidKlimaKlisnaKloboukKlokanKlopaKloubKlubovnaKlusatKluzkostKmenKmitatKmotrKnihaKnotKoaliceKoberecKobkaKoblihaKobylaKocourKohoutKojenecKokosKoktejlKolapsKoledaKolizeKoloKomandoKometaKomikKomnataKomoraKompasKomunitaKonatKonceptKondiceKonecKonfeseKongresKoninaKonkursKontaktKonzervaKopanecKopieKopnoutKoprovkaKorbelKorektorKormidloKoroptevKorpusKorunaKorytoKorzetKosatecKostkaKotelKotletaKotoulKoukatKoupelnaKousekKouzloKovbojKozaKozorohKrabiceKrachKrajinaKralovatKrasopisKravataKreditKrejcarKresbaKrevetaKriketKritikKrizeKrkavecKrmelecKrmivoKrocanKrokKronikaKropitKroupaKrovkaKrtekKruhadloKrupiceKrutostKrvinkaKrychleKryptaKrystalKrytKudlankaKufrKujnostKuklaKulajdaKulichKulkaKulometKulturaKunaKupodivuKurtKurzorKutilKvalitaKvasinkaKvestorKynologKyselinaKytaraKyticeKytkaKytovecKyvadloLabradorLachtanLadnostLaikLakomecLamelaLampaLanovkaLasiceLasoLasturaLatinkaLavinaLebkaLeckdyLedenLedniceLedovkaLedvinaLegendaLegieLegraceLehceLehkostLehnoutLektvarLenochodLentilkaLepenkaLepidloLetadloLetecLetmoLetokruhLevhartLevitaceLevobokLibraLichotkaLidojedLidskostLihovinaLijavecLilekLimetkaLinieLinkaLinoleumListopadLitinaLitovatLobistaLodivodLogikaLogopedLokalitaLoketLomcovatLopataLopuchLordLososLotrLoudalLouhLoukaLouskatLovecLstivostLucernaLuciferLumpLuskLustraceLviceLyraLyrikaLysinaMadamMadloMagistrMahagonMajetekMajitelMajoritaMakakMakoviceMakrelaMalbaMalinaMalovatMalviceMaminkaMandleMankoMarnostMasakrMaskotMasopustMaticeMatrikaMaturitaMazanecMazivoMazlitMazurkaMdlobaMechanikMeditaceMedovinaMelasaMelounMentolkaMetlaMetodaMetrMezeraMigraceMihnoutMihuleMikinaMikrofonMilenecMilimetrMilostMimikaMincovnaMinibarMinometMinulostMiskaMistrMixovatMladostMlhaMlhovinaMlokMlsatMluvitMnichMnohemMobilMocnostModelkaModlitbaMohylaMokroMolekulaMomentkaMonarchaMonoklMonstrumMontovatMonzunMosazMoskytMostMotivaceMotorkaMotykaMouchaMoudrostMozaikaMozekMozolMramorMravenecMrkevMrtvolaMrzetMrzutostMstitelMudrcMuflonMulatMumieMuniceMusetMutaceMuzeumMuzikantMyslivecMzdaNabouratNachytatNadaceNadbytekNadhozNadobroNadpisNahlasNahnatNahodileNahraditNaivitaNajednouNajistoNajmoutNaklonitNakonecNakrmitNalevoNamazatNamluvitNanometrNaokoNaopakNaostroNapadatNapevnoNaplnitNapnoutNaposledNaprostoNaroditNarubyNarychloNasaditNasekatNaslepoNastatNatolikNavenekNavrchNavzdoryNazvatNebeNechatNeckyNedalekoNedbatNeduhNegaceNehetNehodaNejenNejprveNeklidNelibostNemilostNemocNeochotaNeonkaNepokojNerostNervNesmyslNesouladNetvorNeuronNevinaNezvykleNicotaNijakNikamNikdyNiklNikterakNitroNoclehNohaviceNominaceNoraNorekNositelNosnostNouzeNovinyNovotaNozdraNudaNudleNugetNutitNutnostNutrieNymfaObalObarvitObavaObdivObecObehnatObejmoutObezitaObhajobaObilniceObjasnitObjektObklopitOblastOblekOblibaOblohaObludaObnosObohatitObojekOboutObrazecObrnaObrubaObrysObsahObsluhaObstaratObuvObvazObvinitObvodObvykleObyvatelObzorOcasOcelOcenitOchladitOchotaOchranaOcitnoutOdbojOdbytOdchodOdcizitOdebratOdeslatOdevzdatOdezvaOdhadceOdhoditOdjetOdjinudOdkazOdkoupitOdlivOdlukaOdmlkaOdolnostOdpadOdpisOdploutOdporOdpustitOdpykatOdrazkaOdsouditOdstupOdsunOdtokOdtudOdvahaOdvetaOdvolatOdvracetOdznakOfinaOfsajdOhlasOhniskoOhradaOhrozitOhryzekOkapOkeniceOklikaOknoOkouzlitOkovyOkrasaOkresOkrsekOkruhOkupantOkurkaOkusitOlejninaOlizovatOmakOmeletaOmezitOmladinaOmlouvatOmluvaOmylOnehdyOpakovatOpasekOperaceOpiceOpilostOpisovatOporaOpoziceOpravduOprotiOrbitalOrchestrOrgieOrliceOrlojOrtelOsadaOschnoutOsikaOsivoOslavaOslepitOslnitOslovitOsnovaOsobaOsolitOspalecOstenOstrahaOstudaOstychOsvojitOteplitOtiskOtopOtrhatOtrlostOtrokOtrubyOtvorOvanoutOvarOvesOvlivnitOvoceOxidOzdobaPachatelPacientPadouchPahorekPaktPalandaPalecPalivoPalubaPamfletPamlsekPanenkaPanikaPannaPanovatPanstvoPantoflePaprikaParketaParodiePartaParukaParybaPasekaPasivitaPastelkaPatentPatronaPavoukPaznehtPazourekPeckaPedagogPejsekPekloPelotonPenaltaPendrekPenzePeriskopPeroPestrostPetardaPeticePetrolejPevninaPexesoPianistaPihaPijavicePiklePiknikPilinaPilnostPilulkaPinzetaPipetaPisatelPistolePitevnaPivnicePivovarPlacentaPlakatPlamenPlanetaPlastikaPlatitPlavidloPlazPlechPlemenoPlentaPlesPletivoPlevelPlivatPlnitPlnoPlochaPlodinaPlombaPloutPlukPlynPobavitPobytPochodPocitPoctivecPodatPodcenitPodepsatPodhledPodivitPodkladPodmanitPodnikPodobaPodporaPodrazPodstataPodvodPodzimPoeziePohankaPohnutkaPohovorPohromaPohybPointaPojistkaPojmoutPokazitPoklesPokojPokrokPokutaPokynPolednePolibekPolknoutPolohaPolynomPomaluPominoutPomlkaPomocPomstaPomysletPonechatPonorkaPonurostPopadatPopelPopisekPoplachPoprositPopsatPopudPoradcePorcePorodPoruchaPoryvPosaditPosedPosilaPoskokPoslanecPosouditPospoluPostavaPosudekPosypPotahPotkanPotleskPotomekPotravaPotupaPotvoraPoukazPoutoPouzdroPovahaPovidlaPovlakPovozPovrchPovstatPovykPovzdechPozdravPozemekPoznatekPozorPozvatPracovatPrahoryPraktikaPralesPraotecPraporekPrasePravdaPrincipPrknoProbuditProcentoProdejProfeseProhraProjektProlomitPromilePronikatPropadProrokProsbaProtonProutekProvazPrskavkaPrstenPrudkostPrutPrvekPrvohoryPsanecPsovodPstruhPtactvoPubertaPuchPudlPukavecPuklinaPukrlePultPumpaPuncPupenPusaPusinkaPustinaPutovatPutykaPyramidaPyskPytelRacekRachotRadiaceRadniceRadonRaftRagbyRaketaRakovinaRamenoRampouchRandeRarachRaritaRasovnaRastrRatolestRazanceRazidloReagovatReakceReceptRedaktorReferentReflexRejnokReklamaRekordRekrutRektorReputaceRevizeRevmaRevolverRezervaRiskovatRizikoRobotikaRodokmenRohovkaRokleRokokoRomanetoRopovodRopuchaRorejsRosolRostlinaRotmistrRotopedRotundaRoubenkaRouchoRoupRouraRovinaRovniceRozborRozchodRozdatRozeznatRozhodceRozinkaRozjezdRozkazRozlohaRozmarRozpadRozruchRozsahRoztokRozumRozvodRubrikaRuchadloRukaviceRukopisRybaRybolovRychlostRydloRypadloRytinaRyzostSadistaSahatSakoSamecSamizdatSamotaSanitkaSardinkaSasankaSatelitSazbaSazeniceSborSchovatSebrankaSeceseSedadloSedimentSedloSehnatSejmoutSekeraSektaSekundaSekvojeSemenoSenoServisSesaditSeshoraSeskokSeslatSestraSesuvSesypatSetbaSetinaSetkatSetnoutSetrvatSeverSeznamShodaShrnoutSifonSilniceSirkaSirotekSirupSituaceSkafandrSkaliskoSkanzenSkautSkeptikSkicaSkladbaSkleniceSkloSkluzSkobaSkokanSkoroSkriptaSkrzSkupinaSkvostSkvrnaSlabikaSladidloSlaninaSlastSlavnostSledovatSlepecSlevaSlezinaSlibSlinaSlizniceSlonSloupekSlovoSluchSluhaSlunceSlupkaSlzaSmaragdSmetanaSmilstvoSmlouvaSmogSmradSmrkSmrtkaSmutekSmyslSnadSnahaSnobSobotaSochaSodovkaSokolSopkaSotvaSoubojSoucitSoudceSouhlasSouladSoumrakSoupravaSousedSoutokSouvisetSpalovnaSpasitelSpisSplavSpodekSpojenecSpoluSponzorSpornostSpoustaSprchaSpustitSrandaSrazSrdceSrnaSrnecSrovnatSrpenSrstSrubStaniceStarostaStatikaStavbaStehnoStezkaStodolaStolekStopaStornoStoupatStrachStresStrhnoutStromStrunaStudnaStupniceStvolStykSubjektSubtropySucharSudostSuknoSundatSunoutSurikataSurovinaSvahSvalstvoSvetrSvatbaSvazekSvisleSvitekSvobodaSvodidloSvorkaSvrabSykavkaSykotSynekSynovecSypatSypkostSyrovostSyselSytostTabletkaTabuleTahounTajemnoTajfunTajgaTajitTajnostTaktikaTamhleTamponTancovatTanecTankerTapetaTaveninaTazatelTechnikaTehdyTekutinaTelefonTemnotaTendenceTenistaTenorTeplotaTepnaTeprveTerapieTermoskaTextilTichoTiskopisTitulekTkadlecTkaninaTlapkaTleskatTlukotTlupaTmelToaletaTopinkaTopolTorzoTouhaToulecTradiceTraktorTrampTrasaTraverzaTrefitTrestTrezorTrhavinaTrhlinaTrochuTrojiceTroskaTroubaTrpceTrpitelTrpkostTrubecTruchlitTruhliceTrusTrvatTudyTuhnoutTuhostTundraTuristaTurnajTuzemskoTvarohTvorbaTvrdostTvrzTygrTykevUbohostUbozeUbratUbrousekUbrusUbytovnaUchoUctivostUdivitUhraditUjednatUjistitUjmoutUkazatelUklidnitUklonitUkotvitUkrojitUliceUlitaUlovitUmyvadloUnavitUniformaUniknoutUpadnoutUplatnitUplynoutUpoutatUpravitUranUrazitUsednoutUsilovatUsmrtitUsnadnitUsnoutUsouditUstlatUstrnoutUtahovatUtkatUtlumitUtonoutUtopenecUtrousitUvalitUvolnitUvozovkaUzdravitUzelUzeninaUzlinaUznatVagonValchaValounVanaVandalVanilkaVaranVarhanyVarovatVcelkuVchodVdovaVedroVegetaceVejceVelbloudVeletrhVelitelVelmocVelrybaVenkovVerandaVerzeVeselkaVeskrzeVesniceVespoduVestaVeterinaVeverkaVibraceVichrVideohraVidinaVidleVilaViniceVisetVitalitaVizeVizitkaVjezdVkladVkusVlajkaVlakVlasecVlevoVlhkostVlivVlnovkaVloupatVnucovatVnukVodaVodivostVodoznakVodstvoVojenskyVojnaVojskoVolantVolbaVolitVolnoVoskovkaVozidloVozovnaVpravoVrabecVracetVrahVrataVrbaVrcholekVrhatVrstvaVrtuleVsaditVstoupitVstupVtipVybavitVybratVychovatVydatVydraVyfotitVyhledatVyhnoutVyhoditVyhraditVyhubitVyjasnitVyjetVyjmoutVyklopitVykonatVylekatVymazatVymezitVymizetVymysletVynechatVynikatVynutitVypadatVyplatitVypravitVypustitVyrazitVyrovnatVyrvatVyslovitVysokoVystavitVysunoutVysypatVytasitVytesatVytratitVyvinoutVyvolatVyvrhelVyzdobitVyznatVzaduVzbuditVzchopitVzdorVzduchVzdychatVzestupVzhledemVzkazVzlykatVznikVzorekVzpouraVztahVztekXylofonZabratZabydletZachovatZadarmoZadusitZafoukatZahltitZahoditZahradaZahynoutZajatecZajetZajistitZaklepatZakoupitZalepitZamezitZamotatZamysletZanechatZanikatZaplatitZapojitZapsatZarazitZastavitZasunoutZatajitZatemnitZatknoutZaujmoutZavalitZaveletZavinitZavolatZavrtatZazvonitZbavitZbrusuZbudovatZbytekZdalekaZdarmaZdatnostZdivoZdobitZdrojZdvihZdymadloZeleninaZemanZeminaZeptatZezaduZezdolaZhatitZhltnoutZhlubokaZhotovitZhrubaZimaZimniceZjemnitZklamatZkoumatZkratkaZkumavkaZlatoZlehkaZlobaZlomZlostZlozvykZmapovatZmarZmatekZmijeZmizetZmocnitZmodratZmrzlinaZmutovatZnakZnalostZnamenatZnovuZobrazitZotavitZoubekZoufaleZploditZpomalitZpravaZprostitZprudkaZprvuZradaZranitZrcadloZrnitostZrnoZrovnaZrychlitZrzavostZtichaZtratitZubovinaZubrZvednoutZvenkuZveselaZvonZvratZvukovodZvyk";
  var wordlist = null;
  var LangCz = function(_super) {
    __extends(LangCz2, _super);
    function LangCz2() {
      return _super.call(this, "cz") || this;
    }
    LangCz2.prototype.getWord = function(index) {
      loadWords(this);
      return wordlist[index];
    };
    LangCz2.prototype.getWordIndex = function(word) {
      loadWords(this);
      return wordlist.indexOf(word);
    };
    return LangCz2;
  }(wordlist_1.Wordlist);
  var langCz = new LangCz;
  exports.langCz = langCz;
  wordlist_1.Wordlist.register(langCz);
});

// node_modules/@ethersproject/wordlists/lib/lang-en.js
var require_lang_en = __commonJS((exports) => {
  var loadWords = function(lang) {
    if (wordlist != null) {
      return;
    }
    wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
    if (wordlist_1.Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
      wordlist = null;
      throw new Error("BIP39 Wordlist for en (English) FAILED");
    }
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
        d2.__proto__ = b4;
      } || function(d2, b4) {
        for (var p in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p))
            d2[p] = b4[p];
      };
      return extendStatics(d, b3);
    };
    return function(d, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d, b3);
      function __() {
        this.constructor = d;
      }
      d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.langEn = undefined;
  var wordlist_1 = require_wordlist();
  var words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
  var wordlist = null;
  var LangEn = function(_super) {
    __extends(LangEn2, _super);
    function LangEn2() {
      return _super.call(this, "en") || this;
    }
    LangEn2.prototype.getWord = function(index) {
      loadWords(this);
      return wordlist[index];
    };
    LangEn2.prototype.getWordIndex = function(word) {
      loadWords(this);
      return wordlist.indexOf(word);
    };
    return LangEn2;
  }(wordlist_1.Wordlist);
  var langEn = new LangEn;
  exports.langEn = langEn;
  wordlist_1.Wordlist.register(langEn);
});

// node_modules/@ethersproject/wordlists/lib/lang-es.js
var require_lang_es = __commonJS((exports) => {
  var dropDiacritic = function(word) {
    wordlist_1.logger.checkNormalize();
    return (0, strings_1.toUtf8String)(Array.prototype.filter.call((0, strings_1.toUtf8Bytes)(word.normalize("NFD").toLowerCase()), function(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 123;
    }));
  };
  var expand = function(word) {
    var output = [];
    Array.prototype.forEach.call((0, strings_1.toUtf8Bytes)(word), function(c) {
      if (c === 47) {
        output.push(204);
        output.push(129);
      } else if (c === 126) {
        output.push(110);
        output.push(204);
        output.push(131);
      } else {
        output.push(c);
      }
    });
    return (0, strings_1.toUtf8String)(output);
  };
  var loadWords = function(lang) {
    if (wordlist != null) {
      return;
    }
    wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ").map(function(w) {
      return expand(w);
    });
    wordlist.forEach(function(word, index) {
      lookup[dropDiacritic(word)] = index;
    });
    if (wordlist_1.Wordlist.check(lang) !== "0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300") {
      wordlist = null;
      throw new Error("BIP39 Wordlist for es (Spanish) FAILED");
    }
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
        d2.__proto__ = b4;
      } || function(d2, b4) {
        for (var p in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p))
            d2[p] = b4[p];
      };
      return extendStatics(d, b3);
    };
    return function(d, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d, b3);
      function __() {
        this.constructor = d;
      }
      d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.langEs = undefined;
  var strings_1 = require_lib9();
  var wordlist_1 = require_wordlist();
  var words = "A/bacoAbdomenAbejaAbiertoAbogadoAbonoAbortoAbrazoAbrirAbueloAbusoAcabarAcademiaAccesoAccio/nAceiteAcelgaAcentoAceptarA/cidoAclararAcne/AcogerAcosoActivoActoActrizActuarAcudirAcuerdoAcusarAdictoAdmitirAdoptarAdornoAduanaAdultoAe/reoAfectarAficio/nAfinarAfirmarA/gilAgitarAgoni/aAgostoAgotarAgregarAgrioAguaAgudoA/guilaAgujaAhogoAhorroAireAislarAjedrezAjenoAjusteAlacra/nAlambreAlarmaAlbaA/lbumAlcaldeAldeaAlegreAlejarAlertaAletaAlfilerAlgaAlgodo/nAliadoAlientoAlivioAlmaAlmejaAlmi/barAltarAltezaAltivoAltoAlturaAlumnoAlzarAmableAmanteAmapolaAmargoAmasarA/mbarA/mbitoAmenoAmigoAmistadAmorAmparoAmplioAnchoAncianoAnclaAndarAnde/nAnemiaA/nguloAnilloA/nimoAni/sAnotarAntenaAntiguoAntojoAnualAnularAnuncioA~adirA~ejoA~oApagarAparatoApetitoApioAplicarApodoAporteApoyoAprenderAprobarApuestaApuroAradoAra~aArarA/rbitroA/rbolArbustoArchivoArcoArderArdillaArduoA/reaA/ridoAriesArmoni/aArne/sAromaArpaArpo/nArregloArrozArrugaArteArtistaAsaAsadoAsaltoAscensoAsegurarAseoAsesorAsientoAsiloAsistirAsnoAsombroA/speroAstillaAstroAstutoAsumirAsuntoAtajoAtaqueAtarAtentoAteoA/ticoAtletaA/tomoAtraerAtrozAtu/nAudazAudioAugeAulaAumentoAusenteAutorAvalAvanceAvaroAveAvellanaAvenaAvestruzAvio/nAvisoAyerAyudaAyunoAzafra/nAzarAzoteAzu/carAzufreAzulBabaBaborBacheBahi/aBaileBajarBalanzaBalco/nBaldeBambu/BancoBandaBa~oBarbaBarcoBarnizBarroBa/sculaBasto/nBasuraBatallaBateri/aBatirBatutaBau/lBazarBebe/BebidaBelloBesarBesoBestiaBichoBienBingoBlancoBloqueBlusaBoaBobinaBoboBocaBocinaBodaBodegaBoinaBolaBoleroBolsaBombaBondadBonitoBonoBonsa/iBordeBorrarBosqueBoteBoti/nBo/vedaBozalBravoBrazoBrechaBreveBrilloBrincoBrisaBrocaBromaBronceBroteBrujaBruscoBrutoBuceoBucleBuenoBueyBufandaBufo/nBu/hoBuitreBultoBurbujaBurlaBurroBuscarButacaBuzo/nCaballoCabezaCabinaCabraCacaoCada/verCadenaCaerCafe/Cai/daCaima/nCajaCajo/nCalCalamarCalcioCaldoCalidadCalleCalmaCalorCalvoCamaCambioCamelloCaminoCampoCa/ncerCandilCanelaCanguroCanicaCantoCa~aCa~o/nCaobaCaosCapazCapita/nCapoteCaptarCapuchaCaraCarbo/nCa/rcelCaretaCargaCari~oCarneCarpetaCarroCartaCasaCascoCaseroCaspaCastorCatorceCatreCaudalCausaCazoCebollaCederCedroCeldaCe/lebreCelosoCe/lulaCementoCenizaCentroCercaCerdoCerezaCeroCerrarCertezaCe/spedCetroChacalChalecoChampu/ChanclaChapaCharlaChicoChisteChivoChoqueChozaChuletaChuparCiclo/nCiegoCieloCienCiertoCifraCigarroCimaCincoCineCintaCipre/sCircoCiruelaCisneCitaCiudadClamorClanClaroClaseClaveClienteClimaCli/nicaCobreCoccio/nCochinoCocinaCocoCo/digoCodoCofreCogerCoheteCoji/nCojoColaColchaColegioColgarColinaCollarColmoColumnaCombateComerComidaCo/modoCompraCondeConejoCongaConocerConsejoContarCopaCopiaCorazo/nCorbataCorchoCordo/nCoronaCorrerCoserCosmosCostaCra/neoCra/terCrearCrecerCrei/doCremaCri/aCrimenCriptaCrisisCromoCro/nicaCroquetaCrudoCruzCuadroCuartoCuatroCuboCubrirCucharaCuelloCuentoCuerdaCuestaCuevaCuidarCulebraCulpaCultoCumbreCumplirCunaCunetaCuotaCupo/nCu/pulaCurarCuriosoCursoCurvaCutisDamaDanzaDarDardoDa/tilDeberDe/bilDe/cadaDecirDedoDefensaDefinirDejarDelfi/nDelgadoDelitoDemoraDensoDentalDeporteDerechoDerrotaDesayunoDeseoDesfileDesnudoDestinoDesvi/oDetalleDetenerDeudaDi/aDiabloDiademaDiamanteDianaDiarioDibujoDictarDienteDietaDiezDifi/cilDignoDilemaDiluirDineroDirectoDirigirDiscoDise~oDisfrazDivaDivinoDobleDoceDolorDomingoDonDonarDoradoDormirDorsoDosDosisDrago/nDrogaDuchaDudaDueloDue~oDulceDu/oDuqueDurarDurezaDuroE/banoEbrioEcharEcoEcuadorEdadEdicio/nEdificioEditorEducarEfectoEficazEjeEjemploElefanteElegirElementoElevarElipseE/liteElixirElogioEludirEmbudoEmitirEmocio/nEmpateEmpe~oEmpleoEmpresaEnanoEncargoEnchufeEnci/aEnemigoEneroEnfadoEnfermoEnga~oEnigmaEnlaceEnormeEnredoEnsayoEnse~arEnteroEntrarEnvaseEnvi/oE/pocaEquipoErizoEscalaEscenaEscolarEscribirEscudoEsenciaEsferaEsfuerzoEspadaEspejoEspi/aEsposaEspumaEsqui/EstarEsteEstiloEstufaEtapaEternoE/ticaEtniaEvadirEvaluarEventoEvitarExactoExamenExcesoExcusaExentoExigirExilioExistirE/xitoExpertoExplicarExponerExtremoFa/bricaFa/bulaFachadaFa/cilFactorFaenaFajaFaldaFalloFalsoFaltarFamaFamiliaFamosoFarao/nFarmaciaFarolFarsaFaseFatigaFaunaFavorFaxFebreroFechaFelizFeoFeriaFerozFe/rtilFervorFesti/nFiableFianzaFiarFibraFiccio/nFichaFideoFiebreFielFieraFiestaFiguraFijarFijoFilaFileteFilialFiltroFinFincaFingirFinitoFirmaFlacoFlautaFlechaFlorFlotaFluirFlujoFlu/orFobiaFocaFogataFogo/nFolioFolletoFondoFormaForroFortunaForzarFosaFotoFracasoFra/gilFranjaFraseFraudeFrei/rFrenoFresaFri/oFritoFrutaFuegoFuenteFuerzaFugaFumarFuncio/nFundaFurgo/nFuriaFusilFu/tbolFuturoGacelaGafasGaitaGajoGalaGaleri/aGalloGambaGanarGanchoGangaGansoGarajeGarzaGasolinaGastarGatoGavila/nGemeloGemirGenGe/neroGenioGenteGeranioGerenteGermenGestoGiganteGimnasioGirarGiroGlaciarGloboGloriaGolGolfoGolosoGolpeGomaGordoGorilaGorraGotaGoteoGozarGradaGra/ficoGranoGrasaGratisGraveGrietaGrilloGripeGrisGritoGrosorGru/aGruesoGrumoGrupoGuanteGuapoGuardiaGuerraGui/aGui~oGuionGuisoGuitarraGusanoGustarHaberHa/bilHablarHacerHachaHadaHallarHamacaHarinaHazHaza~aHebillaHebraHechoHeladoHelioHembraHerirHermanoHe/roeHervirHieloHierroHi/gadoHigieneHijoHimnoHistoriaHocicoHogarHogueraHojaHombreHongoHonorHonraHoraHormigaHornoHostilHoyoHuecoHuelgaHuertaHuesoHuevoHuidaHuirHumanoHu/medoHumildeHumoHundirHuraca/nHurtoIconoIdealIdiomaI/doloIglesiaIglu/IgualIlegalIlusio/nImagenIma/nImitarImparImperioImponerImpulsoIncapazI/ndiceInerteInfielInformeIngenioInicioInmensoInmuneInnatoInsectoInstanteIntere/sI/ntimoIntuirInu/tilInviernoIraIrisIroni/aIslaIsloteJabali/Jabo/nJamo/nJarabeJardi/nJarraJaulaJazmi/nJefeJeringaJineteJornadaJorobaJovenJoyaJuergaJuevesJuezJugadorJugoJugueteJuicioJuncoJunglaJunioJuntarJu/piterJurarJustoJuvenilJuzgarKiloKoalaLabioLacioLacraLadoLadro/nLagartoLa/grimaLagunaLaicoLamerLa/minaLa/mparaLanaLanchaLangostaLanzaLa/pizLargoLarvaLa/stimaLataLa/texLatirLaurelLavarLazoLealLeccio/nLecheLectorLeerLegio/nLegumbreLejanoLenguaLentoLe~aLeo/nLeopardoLesio/nLetalLetraLeveLeyendaLibertadLibroLicorLi/derLidiarLienzoLigaLigeroLimaLi/miteLimo/nLimpioLinceLindoLi/neaLingoteLinoLinternaLi/quidoLisoListaLiteraLitioLitroLlagaLlamaLlantoLlaveLlegarLlenarLlevarLlorarLloverLluviaLoboLocio/nLocoLocuraLo/gicaLogroLombrizLomoLonjaLoteLuchaLucirLugarLujoLunaLunesLupaLustroLutoLuzMacetaMachoMaderaMadreMaduroMaestroMafiaMagiaMagoMai/zMaldadMaletaMallaMaloMama/MamboMamutMancoMandoManejarMangaManiqui/ManjarManoMansoMantaMa~anaMapaMa/quinaMarMarcoMareaMarfilMargenMaridoMa/rmolMarro/nMartesMarzoMasaMa/scaraMasivoMatarMateriaMatizMatrizMa/ximoMayorMazorcaMechaMedallaMedioMe/dulaMejillaMejorMelenaMelo/nMemoriaMenorMensajeMenteMenu/MercadoMerengueMe/ritoMesMeso/nMetaMeterMe/todoMetroMezclaMiedoMielMiembroMigaMilMilagroMilitarMillo/nMimoMinaMineroMi/nimoMinutoMiopeMirarMisaMiseriaMisilMismoMitadMitoMochilaMocio/nModaModeloMohoMojarMoldeMolerMolinoMomentoMomiaMonarcaMonedaMonjaMontoMo~oMoradaMorderMorenoMorirMorroMorsaMortalMoscaMostrarMotivoMoverMo/vilMozoMuchoMudarMuebleMuelaMuerteMuestraMugreMujerMulaMuletaMultaMundoMu~ecaMuralMuroMu/sculoMuseoMusgoMu/sicaMusloNa/carNacio/nNadarNaipeNaranjaNarizNarrarNasalNatalNativoNaturalNa/useaNavalNaveNavidadNecioNe/ctarNegarNegocioNegroNeo/nNervioNetoNeutroNevarNeveraNichoNidoNieblaNietoNi~ezNi~oNi/tidoNivelNoblezaNocheNo/minaNoriaNormaNorteNotaNoticiaNovatoNovelaNovioNubeNucaNu/cleoNudilloNudoNueraNueveNuezNuloNu/meroNutriaOasisObesoObispoObjetoObraObreroObservarObtenerObvioOcaOcasoOce/anoOchentaOchoOcioOcreOctavoOctubreOcultoOcuparOcurrirOdiarOdioOdiseaOesteOfensaOfertaOficioOfrecerOgroOi/doOi/rOjoOlaOleadaOlfatoOlivoOllaOlmoOlorOlvidoOmbligoOndaOnzaOpacoOpcio/nO/peraOpinarOponerOptarO/pticaOpuestoOracio/nOradorOralO/rbitaOrcaOrdenOrejaO/rganoOrgi/aOrgulloOrienteOrigenOrillaOroOrquestaOrugaOsadi/aOscuroOseznoOsoOstraOto~oOtroOvejaO/vuloO/xidoOxi/genoOyenteOzonoPactoPadrePaellaPa/ginaPagoPai/sPa/jaroPalabraPalcoPaletaPa/lidoPalmaPalomaPalparPanPanalPa/nicoPanteraPa~ueloPapa/PapelPapillaPaquetePararParcelaParedParirParoPa/rpadoParquePa/rrafoPartePasarPaseoPasio/nPasoPastaPataPatioPatriaPausaPautaPavoPayasoPeato/nPecadoPeceraPechoPedalPedirPegarPeinePelarPelda~oPeleaPeligroPellejoPeloPelucaPenaPensarPe~o/nPeo/nPeorPepinoPeque~oPeraPerchaPerderPerezaPerfilPericoPerlaPermisoPerroPersonaPesaPescaPe/simoPesta~aPe/taloPetro/leoPezPezu~aPicarPicho/nPiePiedraPiernaPiezaPijamaPilarPilotoPimientaPinoPintorPinzaPi~aPiojoPipaPirataPisarPiscinaPisoPistaPito/nPizcaPlacaPlanPlataPlayaPlazaPleitoPlenoPlomoPlumaPluralPobrePocoPoderPodioPoemaPoesi/aPoetaPolenPolici/aPolloPolvoPomadaPomeloPomoPompaPonerPorcio/nPortalPosadaPoseerPosiblePostePotenciaPotroPozoPradoPrecozPreguntaPremioPrensaPresoPrevioPrimoPri/ncipePrisio/nPrivarProaProbarProcesoProductoProezaProfesorProgramaProlePromesaProntoPropioPro/ximoPruebaPu/blicoPucheroPudorPuebloPuertaPuestoPulgaPulirPulmo/nPulpoPulsoPumaPuntoPu~alPu~oPupaPupilaPure/QuedarQuejaQuemarQuererQuesoQuietoQui/micaQuinceQuitarRa/banoRabiaRaboRacio/nRadicalRai/zRamaRampaRanchoRangoRapazRa/pidoRaptoRasgoRaspaRatoRayoRazaRazo/nReaccio/nRealidadReba~oReboteRecaerRecetaRechazoRecogerRecreoRectoRecursoRedRedondoReducirReflejoReformaRefra/nRefugioRegaloRegirReglaRegresoRehe/nReinoRei/rRejaRelatoRelevoRelieveRellenoRelojRemarRemedioRemoRencorRendirRentaRepartoRepetirReposoReptilResRescateResinaRespetoRestoResumenRetiroRetornoRetratoReunirReve/sRevistaReyRezarRicoRiegoRiendaRiesgoRifaRi/gidoRigorRinco/nRi~o/nRi/oRiquezaRisaRitmoRitoRizoRobleRoceRociarRodarRodeoRodillaRoerRojizoRojoRomeroRomperRonRoncoRondaRopaRoperoRosaRoscaRostroRotarRubi/RuborRudoRuedaRugirRuidoRuinaRuletaRuloRumboRumorRupturaRutaRutinaSa/badoSaberSabioSableSacarSagazSagradoSalaSaldoSaleroSalirSalmo/nSalo/nSalsaSaltoSaludSalvarSambaSancio/nSandi/aSanearSangreSanidadSanoSantoSapoSaqueSardinaSarte/nSastreSata/nSaunaSaxofo/nSeccio/nSecoSecretoSectaSedSeguirSeisSelloSelvaSemanaSemillaSendaSensorSe~alSe~orSepararSepiaSequi/aSerSerieSermo/nServirSesentaSesio/nSetaSetentaSeveroSexoSextoSidraSiestaSieteSigloSignoSi/labaSilbarSilencioSillaSi/mboloSimioSirenaSistemaSitioSituarSobreSocioSodioSolSolapaSoldadoSoledadSo/lidoSoltarSolucio/nSombraSondeoSonidoSonoroSonrisaSopaSoplarSoporteSordoSorpresaSorteoSoste/nSo/tanoSuaveSubirSucesoSudorSuegraSueloSue~oSuerteSufrirSujetoSulta/nSumarSuperarSuplirSuponerSupremoSurSurcoSure~oSurgirSustoSutilTabacoTabiqueTablaTabu/TacoTactoTajoTalarTalcoTalentoTallaTalo/nTama~oTamborTangoTanqueTapaTapeteTapiaTapo/nTaquillaTardeTareaTarifaTarjetaTarotTarroTartaTatuajeTauroTazaTazo/nTeatroTechoTeclaTe/cnicaTejadoTejerTejidoTelaTele/fonoTemaTemorTemploTenazTenderTenerTenisTensoTeori/aTerapiaTercoTe/rminoTernuraTerrorTesisTesoroTestigoTeteraTextoTezTibioTiburo/nTiempoTiendaTierraTiesoTigreTijeraTildeTimbreTi/midoTimoTintaTi/oTi/picoTipoTiraTiro/nTita/nTi/tereTi/tuloTizaToallaTobilloTocarTocinoTodoTogaToldoTomarTonoTontoToparTopeToqueTo/raxToreroTormentaTorneoToroTorpedoTorreTorsoTortugaTosToscoToserTo/xicoTrabajoTractorTraerTra/ficoTragoTrajeTramoTranceTratoTraumaTrazarTre/bolTreguaTreintaTrenTreparTresTribuTrigoTripaTristeTriunfoTrofeoTrompaTroncoTropaTroteTrozoTrucoTruenoTrufaTuberi/aTuboTuertoTumbaTumorTu/nelTu/nicaTurbinaTurismoTurnoTutorUbicarU/lceraUmbralUnidadUnirUniversoUnoUntarU~aUrbanoUrbeUrgenteUrnaUsarUsuarioU/tilUtopi/aUvaVacaVaci/oVacunaVagarVagoVainaVajillaValeVa/lidoValleValorVa/lvulaVampiroVaraVariarVaro/nVasoVecinoVectorVehi/culoVeinteVejezVelaVeleroVelozVenaVencerVendaVenenoVengarVenirVentaVenusVerVeranoVerboVerdeVeredaVerjaVersoVerterVi/aViajeVibrarVicioVi/ctimaVidaVi/deoVidrioViejoViernesVigorVilVillaVinagreVinoVi~edoVioli/nViralVirgoVirtudVisorVi/speraVistaVitaminaViudoVivazViveroVivirVivoVolca/nVolumenVolverVorazVotarVotoVozVueloVulgarYacerYateYeguaYemaYernoYesoYodoYogaYogurZafiroZanjaZapatoZarzaZonaZorroZumoZurdo";
  var lookup = {};
  var wordlist = null;
  var LangEs = function(_super) {
    __extends(LangEs2, _super);
    function LangEs2() {
      return _super.call(this, "es") || this;
    }
    LangEs2.prototype.getWord = function(index) {
      loadWords(this);
      return wordlist[index];
    };
    LangEs2.prototype.getWordIndex = function(word) {
      loadWords(this);
      return lookup[dropDiacritic(word)];
    };
    return LangEs2;
  }(wordlist_1.Wordlist);
  var langEs = new LangEs;
  exports.langEs = langEs;
  wordlist_1.Wordlist.register(langEs);
});

// node_modules/@ethersproject/wordlists/lib/lang-fr.js
var require_lang_fr = __commonJS((exports) => {
  var dropDiacritic = function(word) {
    wordlist_1.logger.checkNormalize();
    return (0, strings_1.toUtf8String)(Array.prototype.filter.call((0, strings_1.toUtf8Bytes)(word.normalize("NFD").toLowerCase()), function(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 123;
    }));
  };
  var expand = function(word) {
    var output = [];
    Array.prototype.forEach.call((0, strings_1.toUtf8Bytes)(word), function(c) {
      if (c === 47) {
        output.push(204);
        output.push(129);
      } else if (c === 45) {
        output.push(204);
        output.push(128);
      } else {
        output.push(c);
      }
    });
    return (0, strings_1.toUtf8String)(output);
  };
  var loadWords = function(lang) {
    if (wordlist != null) {
      return;
    }
    wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ").map(function(w) {
      return expand(w);
    });
    wordlist.forEach(function(word, index) {
      lookup[dropDiacritic(word)] = index;
    });
    if (wordlist_1.Wordlist.check(lang) !== "0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045") {
      wordlist = null;
      throw new Error("BIP39 Wordlist for fr (French) FAILED");
    }
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
        d2.__proto__ = b4;
      } || function(d2, b4) {
        for (var p in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p))
            d2[p] = b4[p];
      };
      return extendStatics(d, b3);
    };
    return function(d, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d, b3);
      function __() {
        this.constructor = d;
      }
      d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.langFr = undefined;
  var strings_1 = require_lib9();
  var wordlist_1 = require_wordlist();
  var words = "AbaisserAbandonAbdiquerAbeilleAbolirAborderAboutirAboyerAbrasifAbreuverAbriterAbrogerAbruptAbsenceAbsoluAbsurdeAbusifAbyssalAcade/mieAcajouAcarienAccablerAccepterAcclamerAccoladeAccrocheAccuserAcerbeAchatAcheterAcidulerAcierAcompteAcque/rirAcronymeActeurActifActuelAdepteAde/quatAdhe/sifAdjectifAdjugerAdmettreAdmirerAdopterAdorerAdoucirAdresseAdroitAdulteAdverbeAe/rerAe/ronefAffaireAffecterAfficheAffreuxAffublerAgacerAgencerAgileAgiterAgraferAgre/ableAgrumeAiderAiguilleAilierAimableAisanceAjouterAjusterAlarmerAlchimieAlerteAlge-breAlgueAlie/nerAlimentAlle/gerAlliageAllouerAllumerAlourdirAlpagaAltesseAlve/oleAmateurAmbiguAmbreAme/nagerAmertumeAmidonAmiralAmorcerAmourAmovibleAmphibieAmpleurAmusantAnalyseAnaphoreAnarchieAnatomieAncienAne/antirAngleAngoisseAnguleuxAnimalAnnexerAnnonceAnnuelAnodinAnomalieAnonymeAnormalAntenneAntidoteAnxieuxApaiserApe/ritifAplanirApologieAppareilAppelerApporterAppuyerAquariumAqueducArbitreArbusteArdeurArdoiseArgentArlequinArmatureArmementArmoireArmureArpenterArracherArriverArroserArsenicArte/rielArticleAspectAsphalteAspirerAssautAsservirAssietteAssocierAssurerAsticotAstreAstuceAtelierAtomeAtriumAtroceAttaqueAttentifAttirerAttraperAubaineAubergeAudaceAudibleAugurerAuroreAutomneAutrucheAvalerAvancerAvariceAvenirAverseAveugleAviateurAvideAvionAviserAvoineAvouerAvrilAxialAxiomeBadgeBafouerBagageBaguetteBaignadeBalancerBalconBaleineBalisageBambinBancaireBandageBanlieueBannie-reBanquierBarbierBarilBaronBarqueBarrageBassinBastionBatailleBateauBatterieBaudrierBavarderBeletteBe/lierBeloteBe/ne/ficeBerceauBergerBerlineBermudaBesaceBesogneBe/tailBeurreBiberonBicycleBiduleBijouBilanBilingueBillardBinaireBiologieBiopsieBiotypeBiscuitBisonBistouriBitumeBizarreBlafardBlagueBlanchirBlessantBlinderBlondBloquerBlousonBobardBobineBoireBoiserBolideBonbonBondirBonheurBonifierBonusBordureBorneBotteBoucleBoueuxBougieBoulonBouquinBourseBoussoleBoutiqueBoxeurBrancheBrasierBraveBrebisBre-cheBreuvageBricolerBrigadeBrillantBriocheBriqueBrochureBroderBronzerBrousseBroyeurBrumeBrusqueBrutalBruyantBuffleBuissonBulletinBureauBurinBustierButinerButoirBuvableBuvetteCabanonCabineCachetteCadeauCadreCafe/ineCaillouCaissonCalculerCalepinCalibreCalmerCalomnieCalvaireCamaradeCame/raCamionCampagneCanalCanetonCanonCantineCanularCapableCaporalCapriceCapsuleCapterCapucheCarabineCarboneCaresserCaribouCarnageCarotteCarreauCartonCascadeCasierCasqueCassureCauserCautionCavalierCaverneCaviarCe/dilleCeintureCe/lesteCelluleCendrierCensurerCentralCercleCe/re/bralCeriseCernerCerveauCesserChagrinChaiseChaleurChambreChanceChapitreCharbonChasseurChatonChaussonChavirerChemiseChenilleChe/quierChercherChevalChienChiffreChignonChime-reChiotChlorureChocolatChoisirChoseChouetteChromeChuteCigareCigogneCimenterCine/maCintrerCirculerCirerCirqueCiterneCitoyenCitronCivilClaironClameurClaquerClasseClavierClientClignerClimatClivageClocheClonageCloporteCobaltCobraCocasseCocotierCoderCodifierCoffreCognerCohe/sionCoifferCoincerCole-reColibriCollineColmaterColonelCombatCome/dieCommandeCompactConcertConduireConfierCongelerConnoterConsonneContactConvexeCopainCopieCorailCorbeauCordageCornicheCorpusCorrectCorte-geCosmiqueCostumeCotonCoudeCoupureCourageCouteauCouvrirCoyoteCrabeCrainteCravateCrayonCre/atureCre/diterCre/meuxCreuserCrevetteCriblerCrierCristalCrite-reCroireCroquerCrotaleCrucialCruelCrypterCubiqueCueillirCuille-reCuisineCuivreCulminerCultiverCumulerCupideCuratifCurseurCyanureCycleCylindreCyniqueDaignerDamierDangerDanseurDauphinDe/battreDe/biterDe/borderDe/briderDe/butantDe/calerDe/cembreDe/chirerDe/ciderDe/clarerDe/corerDe/crireDe/cuplerDe/daleDe/ductifDe/esseDe/fensifDe/filerDe/frayerDe/gagerDe/givrerDe/glutirDe/graferDe/jeunerDe/liceDe/logerDemanderDemeurerDe/molirDe/nicherDe/nouerDentelleDe/nuderDe/partDe/penserDe/phaserDe/placerDe/poserDe/rangerDe/roberDe/sastreDescenteDe/sertDe/signerDe/sobe/irDessinerDestrierDe/tacherDe/testerDe/tourerDe/tresseDevancerDevenirDevinerDevoirDiableDialogueDiamantDicterDiffe/rerDige/rerDigitalDigneDiluerDimancheDiminuerDioxydeDirectifDirigerDiscuterDisposerDissiperDistanceDivertirDiviserDocileDocteurDogmeDoigtDomaineDomicileDompterDonateurDonjonDonnerDopamineDortoirDorureDosageDoseurDossierDotationDouanierDoubleDouceurDouterDoyenDragonDraperDresserDribblerDroitureDuperieDuplexeDurableDurcirDynastieE/blouirE/carterE/charpeE/chelleE/clairerE/clipseE/cloreE/cluseE/coleE/conomieE/corceE/couterE/craserE/cre/merE/crivainE/crouE/cumeE/cureuilE/difierE/duquerEffacerEffectifEffigieEffortEffrayerEffusionE/galiserE/garerE/jecterE/laborerE/largirE/lectronE/le/gantE/le/phantE/le-veE/ligibleE/litismeE/logeE/luciderE/luderEmballerEmbellirEmbryonE/meraudeE/missionEmmenerE/motionE/mouvoirEmpereurEmployerEmporterEmpriseE/mulsionEncadrerEnche-reEnclaveEncocheEndiguerEndosserEndroitEnduireE/nergieEnfanceEnfermerEnfouirEngagerEnginEngloberE/nigmeEnjamberEnjeuEnleverEnnemiEnnuyeuxEnrichirEnrobageEnseigneEntasserEntendreEntierEntourerEntraverE/nume/rerEnvahirEnviableEnvoyerEnzymeE/olienE/paissirE/pargneE/patantE/pauleE/picerieE/pide/mieE/pierE/pilogueE/pineE/pisodeE/pitapheE/poqueE/preuveE/prouverE/puisantE/querreE/quipeE/rigerE/rosionErreurE/ruptionEscalierEspadonEspe-ceEspie-gleEspoirEspritEsquiverEssayerEssenceEssieuEssorerEstimeEstomacEstradeE/tage-reE/talerE/tancheE/tatiqueE/teindreE/tendoirE/ternelE/thanolE/thiqueEthnieE/tirerE/tofferE/toileE/tonnantE/tourdirE/trangeE/troitE/tudeEuphorieE/valuerE/vasionE/ventailE/videnceE/viterE/volutifE/voquerExactExage/rerExaucerExcellerExcitantExclusifExcuseExe/cuterExempleExercerExhalerExhorterExigenceExilerExisterExotiqueExpe/dierExplorerExposerExprimerExquisExtensifExtraireExulterFableFabuleuxFacetteFacileFactureFaiblirFalaiseFameuxFamilleFarceurFarfeluFarineFaroucheFascinerFatalFatigueFauconFautifFaveurFavoriFe/brileFe/conderFe/de/rerFe/linFemmeFe/murFendoirFe/odalFermerFe/roceFerveurFestivalFeuilleFeutreFe/vrierFiascoFicelerFictifFide-leFigureFilatureFiletageFilie-reFilleulFilmerFilouFiltrerFinancerFinirFioleFirmeFissureFixerFlairerFlammeFlasqueFlatteurFle/auFle-cheFleurFlexionFloconFloreFluctuerFluideFluvialFolieFonderieFongibleFontaineForcerForgeronFormulerFortuneFossileFoudreFouge-reFouillerFoulureFourmiFragileFraiseFranchirFrapperFrayeurFre/gateFreinerFrelonFre/mirFre/ne/sieFre-reFriableFrictionFrissonFrivoleFroidFromageFrontalFrotterFruitFugitifFuiteFureurFurieuxFurtifFusionFuturGagnerGalaxieGalerieGambaderGarantirGardienGarnirGarrigueGazelleGazonGe/antGe/latineGe/luleGendarmeGe/ne/ralGe/nieGenouGentilGe/ologieGe/ome-treGe/raniumGermeGestuelGeyserGibierGiclerGirafeGivreGlaceGlaiveGlisserGlobeGloireGlorieuxGolfeurGommeGonflerGorgeGorilleGoudronGouffreGoulotGoupilleGourmandGoutteGraduelGraffitiGraineGrandGrappinGratuitGravirGrenatGriffureGrillerGrimperGrognerGronderGrotteGroupeGrugerGrutierGruye-reGue/pardGuerrierGuideGuimauveGuitareGustatifGymnasteGyrostatHabitudeHachoirHalteHameauHangarHannetonHaricotHarmonieHarponHasardHe/liumHe/matomeHerbeHe/rissonHermineHe/ronHe/siterHeureuxHibernerHibouHilarantHistoireHiverHomardHommageHomoge-neHonneurHonorerHonteuxHordeHorizonHorlogeHormoneHorribleHouleuxHousseHublotHuileuxHumainHumbleHumideHumourHurlerHydromelHygie-neHymneHypnoseIdylleIgnorerIguaneIlliciteIllusionImageImbiberImiterImmenseImmobileImmuableImpactImpe/rialImplorerImposerImprimerImputerIncarnerIncendieIncidentInclinerIncoloreIndexerIndiceInductifIne/ditIneptieInexactInfiniInfligerInformerInfusionInge/rerInhalerInhiberInjecterInjureInnocentInoculerInonderInscrireInsecteInsigneInsoliteInspirerInstinctInsulterIntactIntenseIntimeIntrigueIntuitifInutileInvasionInventerInviterInvoquerIroniqueIrradierIrre/elIrriterIsolerIvoireIvresseJaguarJaillirJambeJanvierJardinJaugerJauneJavelotJetableJetonJeudiJeunesseJoindreJoncherJonglerJoueurJouissifJournalJovialJoyauJoyeuxJubilerJugementJuniorJuponJuristeJusticeJuteuxJuve/nileKayakKimonoKiosqueLabelLabialLabourerLace/rerLactoseLaguneLaineLaisserLaitierLambeauLamelleLampeLanceurLangageLanterneLapinLargeurLarmeLaurierLavaboLavoirLectureLe/galLe/gerLe/gumeLessiveLettreLevierLexiqueLe/zardLiasseLibe/rerLibreLicenceLicorneLie-geLie-vreLigatureLigoterLigueLimerLimiteLimonadeLimpideLine/aireLingotLionceauLiquideLisie-reListerLithiumLitigeLittoralLivreurLogiqueLointainLoisirLombricLoterieLouerLourdLoutreLouveLoyalLubieLucideLucratifLueurLugubreLuisantLumie-reLunaireLundiLuronLutterLuxueuxMachineMagasinMagentaMagiqueMaigreMaillonMaintienMairieMaisonMajorerMalaxerMale/ficeMalheurMaliceMalletteMammouthMandaterManiableManquantManteauManuelMarathonMarbreMarchandMardiMaritimeMarqueurMarronMartelerMascotteMassifMate/rielMatie-reMatraqueMaudireMaussadeMauveMaximalMe/chantMe/connuMe/dailleMe/decinMe/diterMe/duseMeilleurMe/langeMe/lodieMembreMe/moireMenacerMenerMenhirMensongeMentorMercrediMe/riteMerleMessagerMesureMe/talMe/te/oreMe/thodeMe/tierMeubleMiaulerMicrobeMietteMignonMigrerMilieuMillionMimiqueMinceMine/ralMinimalMinorerMinuteMiracleMiroiterMissileMixteMobileModerneMoelleuxMondialMoniteurMonnaieMonotoneMonstreMontagneMonumentMoqueurMorceauMorsureMortierMoteurMotifMoucheMoufleMoulinMoussonMoutonMouvantMultipleMunitionMurailleMure-neMurmureMuscleMuse/umMusicienMutationMuterMutuelMyriadeMyrtilleMyste-reMythiqueNageurNappeNarquoisNarrerNatationNationNatureNaufrageNautiqueNavireNe/buleuxNectarNe/fasteNe/gationNe/gligerNe/gocierNeigeNerveuxNettoyerNeuroneNeutronNeveuNicheNickelNitrateNiveauNobleNocifNocturneNoirceurNoisetteNomadeNombreuxNommerNormatifNotableNotifierNotoireNourrirNouveauNovateurNovembreNoviceNuageNuancerNuireNuisibleNume/roNuptialNuqueNutritifObe/irObjectifObligerObscurObserverObstacleObtenirObturerOccasionOccuperOce/anOctobreOctroyerOctuplerOculaireOdeurOdorantOffenserOfficierOffrirOgiveOiseauOisillonOlfactifOlivierOmbrageOmettreOnctueuxOndulerOne/reuxOniriqueOpaleOpaqueOpe/rerOpinionOpportunOpprimerOpterOptiqueOrageuxOrangeOrbiteOrdonnerOreilleOrganeOrgueilOrificeOrnementOrqueOrtieOscillerOsmoseOssatureOtarieOuraganOursonOutilOutragerOuvrageOvationOxydeOxyge-neOzonePaisiblePalacePalmare-sPalourdePalperPanachePandaPangolinPaniquerPanneauPanoramaPantalonPapayePapierPapoterPapyrusParadoxeParcelleParesseParfumerParlerParoleParrainParsemerPartagerParureParvenirPassionPaste-quePaternelPatiencePatronPavillonPavoiserPayerPaysagePeignePeintrePelagePe/licanPellePelousePeluchePendulePe/ne/trerPe/niblePensifPe/nuriePe/pitePe/plumPerdrixPerforerPe/riodePermuterPerplexePersilPertePeserPe/talePetitPe/trirPeuplePharaonPhobiePhoquePhotonPhrasePhysiquePianoPicturalPie-cePierrePieuvrePilotePinceauPipettePiquerPiroguePiscinePistonPivoterPixelPizzaPlacardPlafondPlaisirPlanerPlaquePlastronPlateauPleurerPlexusPliagePlombPlongerPluiePlumagePochettePoe/siePoe-tePointePoirierPoissonPoivrePolairePolicierPollenPolygonePommadePompierPonctuelPonde/rerPoneyPortiquePositionPosse/derPosturePotagerPoteauPotionPoucePoulainPoumonPourprePoussinPouvoirPrairiePratiquePre/cieuxPre/direPre/fixePre/ludePre/nomPre/sencePre/textePre/voirPrimitifPrincePrisonPriverProble-meProce/derProdigeProfondProgre-sProieProjeterProloguePromenerPropreProspe-reProte/gerProuesseProverbePrudencePruneauPsychosePublicPuceronPuiserPulpePulsarPunaisePunitifPupitrePurifierPuzzlePyramideQuasarQuerelleQuestionQuie/tudeQuitterQuotientRacineRaconterRadieuxRagondinRaideurRaisinRalentirRallongeRamasserRapideRasageRatisserRavagerRavinRayonnerRe/actifRe/agirRe/aliserRe/animerRecevoirRe/citerRe/clamerRe/colterRecruterReculerRecyclerRe/digerRedouterRefaireRe/flexeRe/formerRefrainRefugeRe/galienRe/gionRe/glageRe/gulierRe/ite/rerRejeterRejouerRelatifReleverReliefRemarqueReme-deRemiseRemonterRemplirRemuerRenardRenfortReniflerRenoncerRentrerRenvoiReplierReporterRepriseReptileRequinRe/serveRe/sineuxRe/soudreRespectResterRe/sultatRe/tablirRetenirRe/ticuleRetomberRetracerRe/unionRe/ussirRevancheRevivreRe/volteRe/vulsifRichesseRideauRieurRigideRigolerRincerRiposterRisibleRisqueRituelRivalRivie-reRocheuxRomanceRompreRonceRondinRoseauRosierRotatifRotorRotuleRougeRouilleRouleauRoutineRoyaumeRubanRubisRucheRuelleRugueuxRuinerRuisseauRuserRustiqueRythmeSablerSaboterSabreSacocheSafariSagesseSaisirSaladeSaliveSalonSaluerSamediSanctionSanglierSarcasmeSardineSaturerSaugrenuSaumonSauterSauvageSavantSavonnerScalpelScandaleSce/le/ratSce/narioSceptreSche/maScienceScinderScoreScrutinSculpterSe/anceSe/cableSe/cherSecouerSe/cre/terSe/datifSe/duireSeigneurSe/jourSe/lectifSemaineSemblerSemenceSe/minalSe/nateurSensibleSentenceSe/parerSe/quenceSereinSergentSe/rieuxSerrureSe/rumServiceSe/sameSe/virSevrageSextupleSide/ralSie-cleSie/gerSifflerSigleSignalSilenceSiliciumSimpleSince-reSinistreSiphonSiropSismiqueSituerSkierSocialSocleSodiumSoigneuxSoldatSoleilSolitudeSolubleSombreSommeilSomnolerSondeSongeurSonnetteSonoreSorcierSortirSosieSottiseSoucieuxSoudureSouffleSouleverSoupapeSourceSoutirerSouvenirSpacieuxSpatialSpe/cialSphe-reSpiralStableStationSternumStimulusStipulerStrictStudieuxStupeurStylisteSublimeSubstratSubtilSubvenirSucce-sSucreSuffixeSugge/rerSuiveurSulfateSuperbeSupplierSurfaceSuricateSurmenerSurpriseSursautSurvieSuspectSyllabeSymboleSyme/trieSynapseSyntaxeSyste-meTabacTablierTactileTaillerTalentTalismanTalonnerTambourTamiserTangibleTapisTaquinerTarderTarifTartineTasseTatamiTatouageTaupeTaureauTaxerTe/moinTemporelTenailleTendreTeneurTenirTensionTerminerTerneTerribleTe/tineTexteThe-meThe/orieThe/rapieThoraxTibiaTie-deTimideTirelireTiroirTissuTitaneTitreTituberTobogganTole/rantTomateToniqueTonneauToponymeTorcheTordreTornadeTorpilleTorrentTorseTortueTotemToucherTournageTousserToxineTractionTraficTragiqueTrahirTrainTrancherTravailTre-fleTremperTre/sorTreuilTriageTribunalTricoterTrilogieTriompheTriplerTriturerTrivialTromboneTroncTropicalTroupeauTuileTulipeTumulteTunnelTurbineTuteurTutoyerTuyauTympanTyphonTypiqueTyranUbuesqueUltimeUltrasonUnanimeUnifierUnionUniqueUnitaireUniversUraniumUrbainUrticantUsageUsineUsuelUsureUtileUtopieVacarmeVaccinVagabondVagueVaillantVaincreVaisseauValableValiseVallonValveVampireVanilleVapeurVarierVaseuxVassalVasteVecteurVedetteVe/ge/talVe/hiculeVeinardVe/loceVendrediVe/ne/rerVengerVenimeuxVentouseVerdureVe/rinVernirVerrouVerserVertuVestonVe/te/ranVe/tusteVexantVexerViaducViandeVictoireVidangeVide/oVignetteVigueurVilainVillageVinaigreViolonVipe-reVirementVirtuoseVirusVisageViseurVisionVisqueuxVisuelVitalVitesseViticoleVitrineVivaceVivipareVocationVoguerVoileVoisinVoitureVolailleVolcanVoltigerVolumeVoraceVortexVoterVouloirVoyageVoyelleWagonXe/nonYachtZe-breZe/nithZesteZoologie";
  var wordlist = null;
  var lookup = {};
  var LangFr = function(_super) {
    __extends(LangFr2, _super);
    function LangFr2() {
      return _super.call(this, "fr") || this;
    }
    LangFr2.prototype.getWord = function(index) {
      loadWords(this);
      return wordlist[index];
    };
    LangFr2.prototype.getWordIndex = function(word) {
      loadWords(this);
      return lookup[dropDiacritic(word)];
    };
    return LangFr2;
  }(wordlist_1.Wordlist);
  var langFr = new LangFr;
  exports.langFr = langFr;
  wordlist_1.Wordlist.register(langFr);
});

// node_modules/@ethersproject/wordlists/lib/lang-ja.js
var require_lang_ja = __commonJS((exports) => {
  var hex = function(word) {
    return (0, bytes_1.hexlify)((0, strings_1.toUtf8Bytes)(word));
  };
  var loadWords = function(lang) {
    if (wordlist !== null) {
      return;
    }
    wordlist = [];
    var transform = {};
    transform[(0, strings_1.toUtf8String)([227, 130, 154])] = false;
    transform[(0, strings_1.toUtf8String)([227, 130, 153])] = false;
    transform[(0, strings_1.toUtf8String)([227, 130, 133])] = (0, strings_1.toUtf8String)([227, 130, 134]);
    transform[(0, strings_1.toUtf8String)([227, 129, 163])] = (0, strings_1.toUtf8String)([227, 129, 164]);
    transform[(0, strings_1.toUtf8String)([227, 130, 131])] = (0, strings_1.toUtf8String)([227, 130, 132]);
    transform[(0, strings_1.toUtf8String)([227, 130, 135])] = (0, strings_1.toUtf8String)([227, 130, 136]);
    function normalize(word2) {
      var result = "";
      for (var i3 = 0;i3 < word2.length; i3++) {
        var kana = word2[i3];
        var target = transform[kana];
        if (target === false) {
          continue;
        }
        if (target) {
          kana = target;
        }
        result += kana;
      }
      return result;
    }
    function sortJapanese(a, b3) {
      a = normalize(a);
      b3 = normalize(b3);
      if (a < b3) {
        return -1;
      }
      if (a > b3) {
        return 1;
      }
      return 0;
    }
    for (var length_1 = 3;length_1 <= 9; length_1++) {
      var d = data[length_1 - 3];
      for (var offset = 0;offset < d.length; offset += length_1) {
        var word = [];
        for (var i = 0;i < length_1; i++) {
          var k = mapping.indexOf(d[offset + i]);
          word.push(227);
          word.push(k & 64 ? 130 : 129);
          word.push((k & 63) + 128);
        }
        wordlist.push((0, strings_1.toUtf8String)(word));
      }
    }
    wordlist.sort(sortJapanese);
    if (hex(wordlist[442]) === KiYoKu && hex(wordlist[443]) === KyoKu) {
      var tmp = wordlist[442];
      wordlist[442] = wordlist[443];
      wordlist[443] = tmp;
    }
    if (wordlist_1.Wordlist.check(lang) !== "0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600") {
      wordlist = null;
      throw new Error("BIP39 Wordlist for ja (Japanese) FAILED");
    }
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
        d2.__proto__ = b4;
      } || function(d2, b4) {
        for (var p in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p))
            d2[p] = b4[p];
      };
      return extendStatics(d, b3);
    };
    return function(d, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d, b3);
      function __() {
        this.constructor = d;
      }
      d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.langJa = undefined;
  var bytes_1 = require_lib2();
  var strings_1 = require_lib9();
  var wordlist_1 = require_wordlist();
  var data = [
    "AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR",
    "ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR",
    "AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm",
    "ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC",
    "BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD",
    "QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD",
    "IJBEJqXZJ"
  ];
  var mapping = "~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt";
  var wordlist = null;
  var KiYoKu = "0xe3818de38284e3818f";
  var KyoKu = "0xe3818de38283e3818f";
  var LangJa = function(_super) {
    __extends(LangJa2, _super);
    function LangJa2() {
      return _super.call(this, "ja") || this;
    }
    LangJa2.prototype.getWord = function(index) {
      loadWords(this);
      return wordlist[index];
    };
    LangJa2.prototype.getWordIndex = function(word) {
      loadWords(this);
      return wordlist.indexOf(word);
    };
    LangJa2.prototype.split = function(mnemonic) {
      wordlist_1.logger.checkNormalize();
      return mnemonic.split(/(?:\u3000| )+/g);
    };
    LangJa2.prototype.join = function(words) {
      return words.join("\u3000");
    };
    return LangJa2;
  }(wordlist_1.Wordlist);
  var langJa = new LangJa;
  exports.langJa = langJa;
  wordlist_1.Wordlist.register(langJa);
});

// node_modules/@ethersproject/wordlists/lib/lang-ko.js
var require_lang_ko = __commonJS((exports) => {
  var getHangul = function(code) {
    if (code >= 40) {
      code = code + 168 - 40;
    } else if (code >= 19) {
      code = code + 97 - 19;
    }
    return (0, strings_1.toUtf8String)([225, (code >> 6) + 132, (code & 63) + 128]);
  };
  var loadWords = function(lang) {
    if (wordlist != null) {
      return;
    }
    wordlist = [];
    data.forEach(function(data2, length) {
      length += 4;
      for (var i = 0;i < data2.length; i += length) {
        var word = "";
        for (var j = 0;j < length; j++) {
          word += getHangul(codes.indexOf(data2[i + j]));
        }
        wordlist.push(word);
      }
    });
    wordlist.sort();
    if (wordlist_1.Wordlist.check(lang) !== "0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a") {
      wordlist = null;
      throw new Error("BIP39 Wordlist for ko (Korean) FAILED");
    }
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
        d2.__proto__ = b4;
      } || function(d2, b4) {
        for (var p in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p))
            d2[p] = b4[p];
      };
      return extendStatics(d, b3);
    };
    return function(d, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d, b3);
      function __() {
        this.constructor = d;
      }
      d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.langKo = undefined;
  var strings_1 = require_lib9();
  var wordlist_1 = require_wordlist();
  var data = [
    "OYAa",
    "ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@HgLnrHgMT8HgMX8HgMboHgOnrHgQToHgRg3HgoHgHgrCbHgrFnHgrLVHgvAcHgvAfHnAloHnCTrHnCnvHnGTrHnGZ8HnGnvHnJT8HnLf8HnLkvHnMg8HnRTrITvFUITvFnJTAXrJTCV8JTFT3JTFT8JTFn4JTGgvJTHT8JTJT8JTJXvJTJl3JTJnvJTLX4JTLf8JTLhvJTMT8JTMXrJTMnrJTObrJTQT8JTSlvJT8DUJT8FkJT8MTJT8OXJT8OgJT8QUJT8RfJUHZoJXFT4JXFlrJXGZ8JXGnrJXLV8JXLgvJXMXoJXMX3JXNboJXPlvJXoJTJXoLkJXrAXJXrHUJXrJgJXvJTJXvOnJX4KnJYAl3JYJT8JYLhvJYQToJYrQXJY6NUJbAl3JbCZrJbDloJbGT8JbGgrJbJXvJbJboJbLf8JbLhrJbLl3JbMnvJbRg8JbSZ8JboDbJbrCZJbrSUJb3KnJb8LnJfRn8JgAXrJgCZrJgDTrJgGZrJgGZ8JgHToJgJT8JgJXoJgJgvJgLX4JgLZ3JgLZ8JgLn4JgMgrJgMn4JgOgvJgPX6JgRnvJgSToJgoCZJgoJbJgoMYJgrJXJgrJgJgrLjJg6MTJlCn3JlGgvJlJl8Jl4AnJl8FnJl8HgJnAToJnATrJnAbvJnDUoJnGnrJnJXrJnJXvJnLhvJnLnrJnLnvJnMToJnMT8JnMXvJnMX3JnMg8JnMlrJnMn4JnOX8JnST4JnSX3JnoAgJnoAnJnoJTJnoObJnrAbJnrAkJnrHnJnrJTJnrJYJnrOYJnrScJnvCUJnvFaJnvJgJnvJnJnvOYJnvQUJnvRUJn3FnJn3JTKnFl3KnLT6LTDlvLTMnoLTOn3LTRl3LTSb4LTSlrLToAnLToJgLTrAULTrAcLTrCULTrHgLTrMgLT3JnLULnrLUMX8LUoJgLVATrLVDTrLVLb8LVoJgLV8MgLV8RTLXDg3LXFlrLXrCnLXrLXLX3GTLX4GgLX4OYLZAXrLZAcrLZAgrLZAhrLZDXyLZDlrLZFbrLZFl3LZJX6LZJX8LZLc8LZLnrLZSU8LZoJTLZoJnLZrAgLZrAnLZrJYLZrLULZrMgLZrSkLZvAnLZvGULZvJeLZvOTLZ3FZLZ4JXLZ8STLZ8ScLaAT3LaAl3LaHT8LaJTrLaJT8LaJXrLaJgvLaJl4LaLVoLaMXrLaMXvLaMX8LbClvLbFToLbHlrLbJn4LbLZ3LbLhvLbMXrLbMnoLbvSULcLnrLc8HnLc8MTLdrMnLeAgoLeOgvLeOn3LfAl3LfLnvLfMl3LfOX8Lf8AnLf8JXLf8LXLgJTrLgJXrLgJl8LgMX8LgRZrLhCToLhrAbLhrFULhrJXLhvJYLjHTrLjHX4LjJX8LjLhrLjSX3LjSZ4LkFX4LkGZ8LkGgvLkJTrLkMXoLkSToLkSU8LkSZ8LkoOYLl3FfLl3MgLmAZrLmCbrLmGgrLmHboLmJnoLmJn3LmLfoLmLhrLmSToLnAX6LnAb6LnCZ3LnCb3LnDTvLnDb8LnFl3LnGnrLnHZvLnHgvLnITvLnJT8LnJX8LnJlvLnLf8LnLg6LnLhvLnLnoLnMXrLnMg8LnQlvLnSbrLnrAgLnrAnLnrDbLnrFkLnrJdLnrMULnrOYLnrSTLnvAnLnvDULnvHgLnvOYLnvOnLn3GgLn4DULn4JTLn4JnMTAZoMTAloMTDb8MTFT8MTJnoMTJnrMTLZrMTLhrMTLkvMTMX8MTRTrMToATMTrDnMTrOnMT3JnMT4MnMT8FUMT8FaMT8FlMT8GTMT8GbMT8GnMT8HnMT8JTMT8JbMT8OTMUCl8MUJTrMUJU8MUMX8MURTrMUSToMXAX6MXAb6MXCZoMXFXrMXHXrMXLgvMXOgoMXrAUMXrAnMXrHgMXrJYMXrJnMXrMTMXrMgMXrOYMXrSZMXrSgMXvDUMXvOTMX3JgMX3OTMX4JnMX8DbMX8FnMX8HbMX8HgMX8HnMX8LbMX8MnMX8OnMYAb8MYGboMYHTvMYHX4MYLTrMYLnvMYMToMYOgvMYRg3MYSTrMbAToMbAXrMbAl3MbAn8MbGZ8MbJT8MbJXrMbMXvMbMX8MbMnoMbrMUMb8AfMb8FbMb8FkMcJXoMeLnrMgFl3MgGTvMgGXoMgGgrMgGnrMgHT8MgHZrMgJnoMgLnrMgLnvMgMT8MgQUoMgrHnMgvAnMg8HgMg8JYMg8LfMloJnMl8ATMl8AXMl8JYMnAToMnAT4MnAZ8MnAl3MnAl4MnCl8MnHT8MnHg8MnJnoMnLZoMnLhrMnMXoMnMX3MnMnrMnOgvMnrFbMnrFfMnrFnMnrNTMnvJXNTMl8OTCT3OTFV8OTFn3OTHZvOTJXrOTOl3OT3ATOT3JUOT3LZOT3LeOT3MbOT8ATOT8AbOT8AgOT8MbOUCXvOUMX3OXHXvOXLl3OXrMUOXvDbOX6NUOX8JbOYFZoOYLbrOYLkoOYMg8OYSX3ObHTrObHT4ObJgrObLhrObMX3ObOX8Ob8FnOeAlrOeJT8OeJXrOeJnrOeLToOeMb8OgJXoOgLXoOgMnrOgOXrOgOloOgoAgOgoJbOgoMYOgoSTOg8AbOjLX4OjMnoOjSV8OnLVoOnrAgOn3DUPXQlrPXvFXPbvFTPdAT3PlFn3PnvFbQTLn4QToAgQToMTQULV8QURg8QUoJnQXCXvQbFbrQb8AaQb8AcQb8FbQb8MYQb8ScQeAlrQeLhrQjAn3QlFXoQloJgQloSnRTLnvRTrGURTrJTRUJZrRUoJlRUrQnRZrLmRZrMnRZrSnRZ8ATRZ8JbRZ8ScRbMT8RbST3RfGZrRfMX8RfMgrRfSZrRnAbrRnGT8RnvJgRnvLfRnvMTRn8AaSTClvSTJgrSTOXrSTRg3STRnvSToAcSToAfSToAnSToHnSToLjSToMTSTrAaSTrEUST3BYST8AgST8LmSUAZvSUAgrSUDT4SUDT8SUGgvSUJXoSUJXvSULTrSU8JTSU8LjSV8AnSV8JgSXFToSXLf8SYvAnSZrDUSZrMUSZrMnSZ8HgSZ8JTSZ8JgSZ8MYSZ8QUSaQUoSbCT3SbHToSbQYvSbSl4SboJnSbvFbSb8HbSb8JgSb8OTScGZrScHgrScJTvScMT8ScSToScoHbScrMTScvAnSeAZrSeAcrSeHboSeJUoSeLhrSeMT8SeMXrSe6JgSgHTrSkJnoSkLnvSk8CUSlFl3SlrSnSl8GnSmAboSmGT8SmJU8",
    "ATLnDlATrAZoATrJX4ATrMT8ATrMX4ATrRTrATvDl8ATvJUoATvMl8AT3AToAT3MX8AT8CT3AT8DT8AT8HZrAT8HgoAUAgFnAUCTFnAXoMX8AXrAT8AXrGgvAXrJXvAXrOgoAXvLl3AZvAgoAZvFbrAZvJXoAZvJl8AZvJn3AZvMX8AZvSbrAZ8FZoAZ8LZ8AZ8MU8AZ8OTvAZ8SV8AZ8SX3AbAgFZAboJnoAbvGboAb8ATrAb8AZoAb8AgrAb8Al4Ab8Db8Ab8JnoAb8LX4Ab8LZrAb8LhrAb8MT8Ab8OUoAb8Qb8Ab8ST8AcrAUoAcrAc8AcrCZ3AcrFT3AcrFZrAcrJl4AcrJn3AcrMX3AcrOTvAc8AZ8Ac8MT8AfAcJXAgoFn4AgoGgvAgoGnrAgoLc8AgoMXoAgrLnrAkrSZ8AlFXCTAloHboAlrHbrAlrLhrAlrLkoAl3CZrAl3LUoAl3LZrAnrAl4AnrMT8An3HT4BT3IToBX4MnvBb!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6",
    "ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv",
    "AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo",
    "AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg",
    "HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb",
    "AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"
  ];
  var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
  var wordlist = null;
  var LangKo = function(_super) {
    __extends(LangKo2, _super);
    function LangKo2() {
      return _super.call(this, "ko") || this;
    }
    LangKo2.prototype.getWord = function(index) {
      loadWords(this);
      return wordlist[index];
    };
    LangKo2.prototype.getWordIndex = function(word) {
      loadWords(this);
      return wordlist.indexOf(word);
    };
    return LangKo2;
  }(wordlist_1.Wordlist);
  var langKo = new LangKo;
  exports.langKo = langKo;
  wordlist_1.Wordlist.register(langKo);
});

// node_modules/@ethersproject/wordlists/lib/lang-it.js
var require_lang_it = __commonJS((exports) => {
  var loadWords = function(lang) {
    if (wordlist != null) {
      return;
    }
    wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
    if (wordlist_1.Wordlist.check(lang) !== "0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620") {
      wordlist = null;
      throw new Error("BIP39 Wordlist for it (Italian) FAILED");
    }
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
        d2.__proto__ = b4;
      } || function(d2, b4) {
        for (var p in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p))
            d2[p] = b4[p];
      };
      return extendStatics(d, b3);
    };
    return function(d, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d, b3);
      function __() {
        this.constructor = d;
      }
      d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.langIt = undefined;
  var wordlist_1 = require_wordlist();
  var words = "AbacoAbbaglioAbbinatoAbeteAbissoAbolireAbrasivoAbrogatoAccadereAccennoAccusatoAcetoneAchilleAcidoAcquaAcreAcrilicoAcrobataAcutoAdagioAddebitoAddomeAdeguatoAderireAdipeAdottareAdulareAffabileAffettoAffissoAffrantoAforismaAfosoAfricanoAgaveAgenteAgevoleAggancioAgireAgitareAgonismoAgricoloAgrumetoAguzzoAlabardaAlatoAlbatroAlberatoAlboAlbumeAlceAlcolicoAlettoneAlfaAlgebraAlianteAlibiAlimentoAllagatoAllegroAllievoAllodolaAllusivoAlmenoAlogenoAlpacaAlpestreAltalenaAlternoAlticcioAltroveAlunnoAlveoloAlzareAmalgamaAmanitaAmarenaAmbitoAmbratoAmebaAmericaAmetistaAmicoAmmassoAmmendaAmmirareAmmonitoAmoreAmpioAmpliareAmuletoAnacardoAnagrafeAnalistaAnarchiaAnatraAncaAncellaAncoraAndareAndreaAnelloAngeloAngolareAngustoAnimaAnnegareAnnidatoAnnoAnnuncioAnonimoAnticipoAnziApaticoAperturaApodeApparireAppetitoAppoggioApprodoAppuntoAprileArabicaArachideAragostaAraldicaArancioAraturaArazzoArbitroArchivioArditoArenileArgentoArgineArgutoAriaArmoniaArneseArredatoArringaArrostoArsenicoArsoArteficeArzilloAsciuttoAscoltoAsepsiAsetticoAsfaltoAsinoAsolaAspiratoAsproAssaggioAsseAssolutoAssurdoAstaAstenutoAsticeAstrattoAtavicoAteismoAtomicoAtonoAttesaAttivareAttornoAttritoAttualeAusilioAustriaAutistaAutonomoAutunnoAvanzatoAvereAvvenireAvvisoAvvolgereAzioneAzotoAzzimoAzzurroBabeleBaccanoBacinoBacoBadessaBadilataBagnatoBaitaBalconeBaldoBalenaBallataBalzanoBambinoBandireBaraondaBarbaroBarcaBaritonoBarlumeBaroccoBasilicoBassoBatostaBattutoBauleBavaBavosaBeccoBeffaBelgioBelvaBendaBenevoleBenignoBenzinaBereBerlinaBetaBibitaBiciBidoneBifidoBigaBilanciaBimboBinocoloBiologoBipedeBipolareBirbanteBirraBiscottoBisestoBisnonnoBisonteBisturiBizzarroBlandoBlattaBollitoBonificoBordoBoscoBotanicoBottinoBozzoloBraccioBradipoBramaBrancaBravuraBretellaBrevettoBrezzaBrigliaBrillanteBrindareBroccoloBrodoBronzinaBrulloBrunoBubboneBucaBudinoBuffoneBuioBulboBuonoBurloneBurrascaBussolaBustaCadettoCaducoCalamaroCalcoloCalesseCalibroCalmoCaloriaCambusaCamerataCamiciaCamminoCamolaCampaleCanapaCandelaCaneCaninoCanottoCantinaCapaceCapelloCapitoloCapogiroCapperoCapraCapsulaCarapaceCarcassaCardoCarismaCarovanaCarrettoCartolinaCasaccioCascataCasermaCasoCassoneCastelloCasualeCatastaCatenaCatrameCautoCavilloCedibileCedrataCefaloCelebreCellulareCenaCenoneCentesimoCeramicaCercareCertoCerumeCervelloCesoiaCespoCetoChelaChiaroChiccaChiedereChimeraChinaChirurgoChitarraCiaoCiclismoCifrareCignoCilindroCiottoloCircaCirrosiCitricoCittadinoCiuffoCivettaCivileClassicoClinicaCloroCoccoCodardoCodiceCoerenteCognomeCollareColmatoColoreColposoColtivatoColzaComaCometaCommandoComodoComputerComuneConcisoCondurreConfermaCongelareConiugeConnessoConoscereConsumoContinuoConvegnoCopertoCopioneCoppiaCopricapoCorazzaCordataCoricatoCorniceCorollaCorpoCorredoCorsiaCorteseCosmicoCostanteCotturaCovatoCratereCravattaCreatoCredereCremosoCrescitaCretaCricetoCrinaleCrisiCriticoCroceCronacaCrostataCrucialeCruscaCucireCuculoCuginoCullatoCupolaCuratoreCursoreCurvoCuscinoCustodeDadoDainoDalmataDamerinoDanielaDannosoDanzareDatatoDavantiDavveroDebuttoDecennioDecisoDeclinoDecolloDecretoDedicatoDefinitoDeformeDegnoDelegareDelfinoDelirioDeltaDemenzaDenotatoDentroDepositoDerapataDerivareDerogaDescrittoDesertoDesiderioDesumereDetersivoDevotoDiametroDicembreDiedroDifesoDiffusoDigerireDigitaleDiluvioDinamicoDinnanziDipintoDiplomaDipoloDiradareDireDirottoDirupoDisagioDiscretoDisfareDisgeloDispostoDistanzaDisumanoDitoDivanoDiveltoDividereDivoratoDobloneDocenteDoganaleDogmaDolceDomatoDomenicaDominareDondoloDonoDormireDoteDottoreDovutoDozzinaDragoDruidoDubbioDubitareDucaleDunaDuomoDupliceDuraturoEbanoEccessoEccoEclissiEconomiaEderaEdicolaEdileEditoriaEducareEgemoniaEgliEgoismoEgregioElaboratoElargireEleganteElencatoElettoElevareElficoElicaElmoElsaElusoEmanatoEmblemaEmessoEmiroEmotivoEmozioneEmpiricoEmuloEndemicoEnduroEnergiaEnfasiEnotecaEntrareEnzimaEpatiteEpilogoEpisodioEpocaleEppureEquatoreErarioErbaErbosoEredeEremitaErigereErmeticoEroeErosivoErranteEsagonoEsameEsanimeEsaudireEscaEsempioEsercitoEsibitoEsigenteEsistereEsitoEsofagoEsortatoEsosoEspansoEspressoEssenzaEssoEstesoEstimareEstoniaEstrosoEsultareEtilicoEtnicoEtruscoEttoEuclideoEuropaEvasoEvidenzaEvitatoEvolutoEvvivaFabbricaFaccendaFachiroFalcoFamigliaFanaleFanfaraFangoFantasmaFareFarfallaFarinosoFarmacoFasciaFastosoFasulloFaticareFatoFavolosoFebbreFecolaFedeFegatoFelpaFeltroFemminaFendereFenomenoFermentoFerroFertileFessuraFestivoFettaFeudoFiabaFiduciaFifaFiguratoFiloFinanzaFinestraFinireFioreFiscaleFisicoFiumeFlaconeFlamencoFleboFlemmaFloridoFluenteFluoroFobicoFocacciaFocosoFoderatoFoglioFolataFolcloreFolgoreFondenteFoneticoFoniaFontanaForbitoForchettaForestaFormicaFornaioForoFortezzaForzareFosfatoFossoFracassoFranaFrassinoFratelloFreccettaFrenataFrescoFrigoFrollinoFrondeFrugaleFruttaFucilataFucsiaFuggenteFulmineFulvoFumanteFumettoFumosoFuneFunzioneFuocoFurboFurgoneFuroreFusoFutileGabbianoGaffeGalateoGallinaGaloppoGamberoGammaGaranziaGarboGarofanoGarzoneGasdottoGasolioGastricoGattoGaudioGazeboGazzellaGecoGelatinaGelsoGemelloGemmatoGeneGenitoreGennaioGenotipoGergoGhepardoGhiaccioGhisaGialloGildaGineproGiocareGioielloGiornoGioveGiratoGironeGittataGiudizioGiuratoGiustoGlobuloGlutineGnomoGobbaGolfGomitoGommoneGonfioGonnaGovernoGracileGradoGraficoGrammoGrandeGrattareGravosoGraziaGrecaGreggeGrifoneGrigioGrinzaGrottaGruppoGuadagnoGuaioGuantoGuardareGufoGuidareIbernatoIconaIdenticoIdillioIdoloIdraIdricoIdrogenoIgieneIgnaroIgnoratoIlareIllesoIllogicoIlludereImballoImbevutoImboccoImbutoImmaneImmersoImmolatoImpaccoImpetoImpiegoImportoImprontaInalareInarcareInattivoIncantoIncendioInchinoIncisivoInclusoIncontroIncrocioIncuboIndagineIndiaIndoleIneditoInfattiInfilareInflittoIngaggioIngegnoIngleseIngordoIngrossoInnescoInodoreInoltrareInondatoInsanoInsettoInsiemeInsonniaInsulinaIntasatoInteroIntonacoIntuitoInumidireInvalidoInveceInvitoIperboleIpnoticoIpotesiIppicaIrideIrlandaIronicoIrrigatoIrrorareIsolatoIsotopoIstericoIstitutoIstriceItaliaIterareLabbroLabirintoLaccaLaceratoLacrimaLacunaLaddoveLagoLampoLancettaLanternaLardosoLargaLaringeLastraLatenzaLatinoLattugaLavagnaLavoroLegaleLeggeroLemboLentezzaLenzaLeoneLepreLesivoLessatoLestoLetteraleLevaLevigatoLiberoLidoLievitoLillaLimaturaLimitareLimpidoLineareLinguaLiquidoLiraLiricaLiscaLiteLitigioLivreaLocandaLodeLogicaLombareLondraLongevoLoquaceLorenzoLotoLotteriaLuceLucidatoLumacaLuminosoLungoLupoLuppoloLusingaLussoLuttoMacabroMacchinaMaceroMacinatoMadamaMagicoMagliaMagneteMagroMaiolicaMalafedeMalgradoMalintesoMalsanoMaltoMalumoreManaManciaMandorlaMangiareManifestoMannaroManovraMansardaMantideManubrioMappaMaratonaMarcireMarettaMarmoMarsupioMascheraMassaiaMastinoMaterassoMatricolaMattoneMaturoMazurcaMeandroMeccanicoMecenateMedesimoMeditareMegaMelassaMelisMelodiaMeningeMenoMensolaMercurioMerendaMerloMeschinoMeseMessereMestoloMetalloMetodoMettereMiagolareMicaMicelioMicheleMicroboMidolloMieleMiglioreMilanoMiliteMimosaMineraleMiniMinoreMirinoMirtilloMiscelaMissivaMistoMisurareMitezzaMitigareMitraMittenteMnemonicoModelloModificaModuloMoganoMogioMoleMolossoMonasteroMoncoMondinaMonetarioMonileMonotonoMonsoneMontatoMonvisoMoraMordereMorsicatoMostroMotivatoMotosegaMottoMovenzaMovimentoMozzoMuccaMucosaMuffaMughettoMugnaioMulattoMulinelloMultiploMummiaMuntoMuovereMuraleMusaMuscoloMusicaMutevoleMutoNababboNaftaNanometroNarcisoNariceNarratoNascereNastrareNaturaleNauticaNaviglioNebulosaNecrosiNegativoNegozioNemmenoNeofitaNerettoNervoNessunoNettunoNeutraleNeveNevroticoNicchiaNinfaNitidoNobileNocivoNodoNomeNominaNordicoNormaleNorvegeseNostranoNotareNotiziaNotturnoNovellaNucleoNullaNumeroNuovoNutrireNuvolaNuzialeOasiObbedireObbligoObeliscoOblioOboloObsoletoOccasioneOcchioOccidenteOccorrereOccultareOcraOculatoOdiernoOdorareOffertaOffrireOffuscatoOggettoOggiOgnunoOlandeseOlfattoOliatoOlivaOlogrammaOltreOmaggioOmbelicoOmbraOmegaOmissioneOndosoOnereOniceOnnivoroOnorevoleOntaOperatoOpinioneOppostoOracoloOrafoOrdineOrecchinoOreficeOrfanoOrganicoOrigineOrizzonteOrmaOrmeggioOrnativoOrologioOrrendoOrribileOrtensiaOrticaOrzataOrzoOsareOscurareOsmosiOspedaleOspiteOssaOssidareOstacoloOsteOtiteOtreOttagonoOttimoOttobreOvaleOvestOvinoOviparoOvocitoOvunqueOvviareOzioPacchettoPacePacificoPadellaPadronePaesePagaPaginaPalazzinaPalesarePallidoPaloPaludePandoroPannelloPaoloPaonazzoPapricaParabolaParcellaParerePargoloPariParlatoParolaPartireParvenzaParzialePassivoPasticcaPataccaPatologiaPattumePavonePeccatoPedalarePedonalePeggioPelosoPenarePendicePenisolaPennutoPenombraPensarePentolaPepePepitaPerbenePercorsoPerdonatoPerforarePergamenaPeriodoPermessoPernoPerplessoPersuasoPertugioPervasoPesatorePesistaPesoPestiferoPetaloPettinePetulantePezzoPiacerePiantaPiattinoPiccinoPicozzaPiegaPietraPifferoPigiamaPigolioPigroPilaPiliferoPillolaPilotaPimpantePinetaPinnaPinoloPioggiaPiomboPiramidePireticoPiritePirolisiPitonePizzicoPlaceboPlanarePlasmaPlatanoPlenarioPochezzaPoderosoPodismoPoesiaPoggiarePolentaPoligonoPollicePolmonitePolpettaPolsoPoltronaPolverePomicePomodoroPontePopolosoPorfidoPorosoPorporaPorrePortataPosaPositivoPossessoPostulatoPotassioPoterePranzoPrassiPraticaPreclusoPredicaPrefissoPregiatoPrelievoPremerePrenotarePreparatoPresenzaPretestoPrevalsoPrimaPrincipePrivatoProblemaProcuraProdurreProfumoProgettoProlungaPromessaPronomePropostaProrogaProtesoProvaPrudentePrugnaPruritoPsichePubblicoPudicaPugilatoPugnoPulcePulitoPulsantePuntarePupazzoPupillaPuroQuadroQualcosaQuasiQuerelaQuotaRaccoltoRaddoppioRadicaleRadunatoRafficaRagazzoRagioneRagnoRamarroRamingoRamoRandagioRantolareRapatoRapinaRappresoRasaturaRaschiatoRasenteRassegnaRastrelloRataRavvedutoRealeRecepireRecintoReclutaReconditoRecuperoRedditoRedimereRegalatoRegistroRegolaRegressoRelazioneRemareRemotoRennaReplicaReprimereReputareResaResidenteResponsoRestauroReteRetinaRetoricaRettificaRevocatoRiassuntoRibadireRibelleRibrezzoRicaricaRiccoRicevereRiciclatoRicordoRicredutoRidicoloRidurreRifasareRiflessoRiformaRifugioRigareRigettatoRighelloRilassatoRilevatoRimanereRimbalzoRimedioRimorchioRinascitaRincaroRinforzoRinnovoRinomatoRinsavitoRintoccoRinunciaRinvenireRiparatoRipetutoRipienoRiportareRipresaRipulireRisataRischioRiservaRisibileRisoRispettoRistoroRisultatoRisvoltoRitardoRitegnoRitmicoRitrovoRiunioneRivaRiversoRivincitaRivoltoRizomaRobaRoboticoRobustoRocciaRocoRodaggioRodereRoditoreRogitoRollioRomanticoRompereRonzioRosolareRospoRotanteRotondoRotulaRovescioRubizzoRubricaRugaRullinoRumineRumorosoRuoloRupeRussareRusticoSabatoSabbiareSabotatoSagomaSalassoSaldaturaSalgemmaSalivareSalmoneSaloneSaltareSalutoSalvoSapereSapidoSaporitoSaracenoSarcasmoSartoSassosoSatelliteSatiraSatolloSaturnoSavanaSavioSaziatoSbadiglioSbalzoSbancatoSbarraSbattereSbavareSbendareSbirciareSbloccatoSbocciatoSbrinareSbruffoneSbuffareScabrosoScadenzaScalaScambiareScandaloScapolaScarsoScatenareScavatoSceltoScenicoScettroSchedaSchienaSciarpaScienzaScindereScippoSciroppoScivoloSclerareScodellaScolpitoScompartoSconfortoScoprireScortaScossoneScozzeseScribaScrollareScrutinioScuderiaScultoreScuolaScuroScusareSdebitareSdoganareSeccaturaSecondoSedanoSeggiolaSegnalatoSegregatoSeguitoSelciatoSelettivoSellaSelvaggioSemaforoSembrareSemeSeminatoSempreSensoSentireSepoltoSequenzaSerataSerbatoSerenoSerioSerpenteSerraglioServireSestinaSetolaSettimanaSfaceloSfaldareSfamatoSfarzosoSfaticatoSferaSfidaSfilatoSfingeSfocatoSfoderareSfogoSfoltireSforzatoSfrattoSfruttatoSfuggitoSfumareSfusoSgabelloSgarbatoSgonfiareSgorbioSgrassatoSguardoSibiloSiccomeSierraSiglaSignoreSilenzioSillabaSimboloSimpaticoSimulatoSinfoniaSingoloSinistroSinoSintesiSinusoideSiparioSismaSistoleSituatoSlittaSlogaturaSlovenoSmarritoSmemoratoSmentitoSmeraldoSmilzoSmontareSmottatoSmussatoSnellireSnervatoSnodoSobbalzoSobrioSoccorsoSocialeSodaleSoffittoSognoSoldatoSolenneSolidoSollazzoSoloSolubileSolventeSomaticoSommaSondaSonettoSonniferoSopireSoppesoSopraSorgereSorpassoSorrisoSorsoSorteggioSorvolatoSospiroSostaSottileSpadaSpallaSpargereSpatolaSpaventoSpazzolaSpecieSpedireSpegnereSpelaturaSperanzaSpessoreSpettraleSpezzatoSpiaSpigolosoSpillatoSpinosoSpiraleSplendidoSportivoSposoSprangaSprecareSpronatoSpruzzoSpuntinoSquilloSradicareSrotolatoStabileStaccoStaffaStagnareStampatoStantioStarnutoStaseraStatutoSteloSteppaSterzoStilettoStimaStirpeStivaleStizzosoStonatoStoricoStrappoStregatoStriduloStrozzareStruttoStuccareStufoStupendoSubentroSuccosoSudoreSuggeritoSugoSultanoSuonareSuperboSupportoSurgelatoSurrogatoSussurroSuturaSvagareSvedeseSveglioSvelareSvenutoSveziaSviluppoSvistaSvizzeraSvoltaSvuotareTabaccoTabulatoTacciareTaciturnoTaleTalismanoTamponeTanninoTaraTardivoTargatoTariffaTarpareTartarugaTastoTatticoTavernaTavolataTazzaTecaTecnicoTelefonoTemerarioTempoTemutoTendoneTeneroTensioneTentacoloTeoremaTermeTerrazzoTerzettoTesiTesseratoTestatoTetroTettoiaTifareTigellaTimbroTintoTipicoTipografoTiraggioTiroTitanioTitoloTitubanteTizioTizzoneToccareTollerareToltoTombolaTomoTonfoTonsillaTopazioTopologiaToppaTorbaTornareTorroneTortoraToscanoTossireTostaturaTotanoTraboccoTracheaTrafilaTragediaTralcioTramontoTransitoTrapanoTrarreTraslocoTrattatoTraveTrecciaTremolioTrespoloTributoTrichecoTrifoglioTrilloTrinceaTrioTristezzaTrituratoTrivellaTrombaTronoTroppoTrottolaTrovareTruccatoTubaturaTuffatoTulipanoTumultoTunisiaTurbareTurchinoTutaTutelaUbicatoUccelloUccisoreUdireUditivoUffaUfficioUgualeUlisseUltimatoUmanoUmileUmorismoUncinettoUngereUnghereseUnicornoUnificatoUnisonoUnitarioUnteUovoUpupaUraganoUrgenzaUrloUsanzaUsatoUscitoUsignoloUsuraioUtensileUtilizzoUtopiaVacanteVaccinatoVagabondoVagliatoValangaValgoValicoVallettaValorosoValutareValvolaVampataVangareVanitosoVanoVantaggioVanveraVaporeVaranoVarcatoVarianteVascaVedettaVedovaVedutoVegetaleVeicoloVelcroVelinaVellutoVeloceVenatoVendemmiaVentoVeraceVerbaleVergognaVerificaVeroVerrucaVerticaleVescicaVessilloVestaleVeteranoVetrinaVetustoViandanteVibranteVicendaVichingoVicinanzaVidimareVigiliaVignetoVigoreVileVillanoViminiVincitoreViolaViperaVirgolaVirologoVirulentoViscosoVisioneVispoVissutoVisuraVitaVitelloVittimaVivandaVividoViziareVoceVogaVolatileVolereVolpeVoragineVulcanoZampognaZannaZappatoZatteraZavorraZefiroZelanteZeloZenzeroZerbinoZibettoZincoZirconeZittoZollaZoticoZuccheroZufoloZuluZuppa";
  var wordlist = null;
  var LangIt = function(_super) {
    __extends(LangIt2, _super);
    function LangIt2() {
      return _super.call(this, "it") || this;
    }
    LangIt2.prototype.getWord = function(index) {
      loadWords(this);
      return wordlist[index];
    };
    LangIt2.prototype.getWordIndex = function(word) {
      loadWords(this);
      return wordlist.indexOf(word);
    };
    return LangIt2;
  }(wordlist_1.Wordlist);
  var langIt = new LangIt;
  exports.langIt = langIt;
  wordlist_1.Wordlist.register(langIt);
});

// node_modules/@ethersproject/wordlists/lib/lang-zh.js
var require_lang_zh = __commonJS((exports) => {
  var loadWords = function(lang) {
    if (wordlist[lang.locale] !== null) {
      return;
    }
    wordlist[lang.locale] = [];
    var deltaOffset = 0;
    for (var i = 0;i < 2048; i++) {
      var s = style.indexOf(data[i * 3]);
      var bytes = [
        228 + (s >> 2),
        128 + codes.indexOf(data[i * 3 + 1]),
        128 + codes.indexOf(data[i * 3 + 2])
      ];
      if (lang.locale === "zh_tw") {
        var common = s % 4;
        for (var i_1 = common;i_1 < 3; i_1++) {
          bytes[i_1] = codes.indexOf(deltaData[deltaOffset++]) + (i_1 == 0 ? 228 : 128);
        }
      }
      wordlist[lang.locale].push((0, strings_1.toUtf8String)(bytes));
    }
    if (wordlist_1.Wordlist.check(lang) !== Checks[lang.locale]) {
      wordlist[lang.locale] = null;
      throw new Error("BIP39 Wordlist for " + lang.locale + " (Chinese) FAILED");
    }
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
        d2.__proto__ = b4;
      } || function(d2, b4) {
        for (var p in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p))
            d2[p] = b4[p];
      };
      return extendStatics(d, b3);
    };
    return function(d, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d, b3);
      function __() {
        this.constructor = d;
      }
      d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.langZhTw = exports.langZhCn = undefined;
  var strings_1 = require_lib9();
  var wordlist_1 = require_wordlist();
  var data = "}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH";
  var deltaData = "FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL";
  var wordlist = {
    zh_cn: null,
    zh_tw: null
  };
  var Checks = {
    zh_cn: "0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1",
    zh_tw: "0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d"
  };
  var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var style = "~!@#$%^&*_-=[]{}|;:,.()<>?";
  var LangZh = function(_super) {
    __extends(LangZh2, _super);
    function LangZh2(country) {
      return _super.call(this, "zh_" + country) || this;
    }
    LangZh2.prototype.getWord = function(index) {
      loadWords(this);
      return wordlist[this.locale][index];
    };
    LangZh2.prototype.getWordIndex = function(word) {
      loadWords(this);
      return wordlist[this.locale].indexOf(word);
    };
    LangZh2.prototype.split = function(mnemonic) {
      mnemonic = mnemonic.replace(/(?:\u3000| )+/g, "");
      return mnemonic.split("");
    };
    return LangZh2;
  }(wordlist_1.Wordlist);
  var langZhCn = new LangZh("cn");
  exports.langZhCn = langZhCn;
  wordlist_1.Wordlist.register(langZhCn);
  wordlist_1.Wordlist.register(langZhCn, "zh");
  var langZhTw = new LangZh("tw");
  exports.langZhTw = langZhTw;
  wordlist_1.Wordlist.register(langZhTw);
});

// node_modules/@ethersproject/wordlists/lib/wordlists.js
var require_wordlists = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wordlists = undefined;
  var lang_cz_1 = require_lang_cz();
  var lang_en_1 = require_lang_en();
  var lang_es_1 = require_lang_es();
  var lang_fr_1 = require_lang_fr();
  var lang_ja_1 = require_lang_ja();
  var lang_ko_1 = require_lang_ko();
  var lang_it_1 = require_lang_it();
  var lang_zh_1 = require_lang_zh();
  exports.wordlists = {
    cz: lang_cz_1.langCz,
    en: lang_en_1.langEn,
    es: lang_es_1.langEs,
    fr: lang_fr_1.langFr,
    it: lang_it_1.langIt,
    ja: lang_ja_1.langJa,
    ko: lang_ko_1.langKo,
    zh: lang_zh_1.langZhCn,
    zh_cn: lang_zh_1.langZhCn,
    zh_tw: lang_zh_1.langZhTw
  };
});

// node_modules/@ethersproject/wordlists/lib/index.js
var require_lib19 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wordlists = exports.Wordlist = exports.logger = undefined;
  var wordlist_1 = require_wordlist();
  Object.defineProperty(exports, "logger", { enumerable: true, get: function() {
    return wordlist_1.logger;
  } });
  Object.defineProperty(exports, "Wordlist", { enumerable: true, get: function() {
    return wordlist_1.Wordlist;
  } });
  var wordlists_1 = require_wordlists();
  Object.defineProperty(exports, "wordlists", { enumerable: true, get: function() {
    return wordlists_1.wordlists;
  } });
});

// node_modules/@ethersproject/hdnode/lib/_version.js
var require__version14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "hdnode/5.7.0";
});

// node_modules/@ethersproject/hdnode/lib/index.js
var require_lib20 = __commonJS((exports) => {
  var getUpperMask = function(bits) {
    return (1 << bits) - 1 << 8 - bits;
  };
  var getLowerMask = function(bits) {
    return (1 << bits) - 1;
  };
  var bytes32 = function(value) {
    return (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(value), 32);
  };
  var base58check = function(data) {
    return basex_1.Base58.encode((0, bytes_1.concat)([data, (0, bytes_1.hexDataSlice)((0, sha2_1.sha256)((0, sha2_1.sha256)(data)), 0, 4)]));
  };
  var getWordlist = function(wordlist) {
    if (wordlist == null) {
      return wordlists_1.wordlists["en"];
    }
    if (typeof wordlist === "string") {
      var words = wordlists_1.wordlists[wordlist];
      if (words == null) {
        logger.throwArgumentError("unknown locale", "wordlist", wordlist);
      }
      return words;
    }
    return wordlist;
  };
  var mnemonicToSeed = function(mnemonic, password) {
    if (!password) {
      password = "";
    }
    var salt = (0, strings_1.toUtf8Bytes)("mnemonic" + password, strings_1.UnicodeNormalizationForm.NFKD);
    return (0, pbkdf2_1.pbkdf2)((0, strings_1.toUtf8Bytes)(mnemonic, strings_1.UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
  };
  var mnemonicToEntropy = function(mnemonic, wordlist) {
    wordlist = getWordlist(wordlist);
    logger.checkNormalize();
    var words = wordlist.split(mnemonic);
    if (words.length % 3 !== 0) {
      throw new Error("invalid mnemonic");
    }
    var entropy = (0, bytes_1.arrayify)(new Uint8Array(Math.ceil(11 * words.length / 8)));
    var offset = 0;
    for (var i = 0;i < words.length; i++) {
      var index = wordlist.getWordIndex(words[i].normalize("NFKD"));
      if (index === -1) {
        throw new Error("invalid mnemonic");
      }
      for (var bit = 0;bit < 11; bit++) {
        if (index & 1 << 10 - bit) {
          entropy[offset >> 3] |= 1 << 7 - offset % 8;
        }
        offset++;
      }
    }
    var entropyBits = 32 * words.length / 3;
    var checksumBits = words.length / 3;
    var checksumMask = getUpperMask(checksumBits);
    var checksum = (0, bytes_1.arrayify)((0, sha2_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
      throw new Error("invalid checksum");
    }
    return (0, bytes_1.hexlify)(entropy.slice(0, entropyBits / 8));
  };
  var entropyToMnemonic = function(entropy, wordlist) {
    wordlist = getWordlist(wordlist);
    entropy = (0, bytes_1.arrayify)(entropy);
    if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
      throw new Error("invalid entropy");
    }
    var indices = [0];
    var remainingBits = 11;
    for (var i = 0;i < entropy.length; i++) {
      if (remainingBits > 8) {
        indices[indices.length - 1] <<= 8;
        indices[indices.length - 1] |= entropy[i];
        remainingBits -= 8;
      } else {
        indices[indices.length - 1] <<= remainingBits;
        indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
        indices.push(entropy[i] & getLowerMask(8 - remainingBits));
        remainingBits += 3;
      }
    }
    var checksumBits = entropy.length / 4;
    var checksum = (0, bytes_1.arrayify)((0, sha2_1.sha256)(entropy))[0] & getUpperMask(checksumBits);
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= checksum >> 8 - checksumBits;
    return wordlist.join(indices.map(function(index) {
      return wordlist.getWord(index);
    }));
  };
  var isValidMnemonic = function(mnemonic, wordlist) {
    try {
      mnemonicToEntropy(mnemonic, wordlist);
      return true;
    } catch (error) {
    }
    return false;
  };
  var getAccountPath = function(index) {
    if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
      logger.throwArgumentError("invalid account index", "index", index);
    }
    return "m/44'/60'/" + index + "'/0/0";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAccountPath = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.mnemonicToSeed = exports.HDNode = exports.defaultPath = undefined;
  var basex_1 = require_lib14();
  var bytes_1 = require_lib2();
  var bignumber_1 = require_lib3();
  var strings_1 = require_lib9();
  var pbkdf2_1 = require_lib16();
  var properties_1 = require_lib4();
  var signing_key_1 = require_lib17();
  var sha2_1 = require_lib15();
  var transactions_1 = require_lib18();
  var wordlists_1 = require_lib19();
  var logger_1 = require_lib();
  var _version_1 = require__version14();
  var logger = new logger_1.Logger(_version_1.version);
  var N = bignumber_1.BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  var MasterSecret = (0, strings_1.toUtf8Bytes)("Bitcoin seed");
  var HardenedBit = 2147483648;
  var _constructorGuard = {};
  exports.defaultPath = "m/44'/60'/0'/0/0";
  var HDNode = function() {
    function HDNode2(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
      if (constructorGuard !== _constructorGuard) {
        throw new Error("HDNode constructor cannot be called directly");
      }
      if (privateKey) {
        var signingKey = new signing_key_1.SigningKey(privateKey);
        (0, properties_1.defineReadOnly)(this, "privateKey", signingKey.privateKey);
        (0, properties_1.defineReadOnly)(this, "publicKey", signingKey.compressedPublicKey);
      } else {
        (0, properties_1.defineReadOnly)(this, "privateKey", null);
        (0, properties_1.defineReadOnly)(this, "publicKey", (0, bytes_1.hexlify)(publicKey));
      }
      (0, properties_1.defineReadOnly)(this, "parentFingerprint", parentFingerprint);
      (0, properties_1.defineReadOnly)(this, "fingerprint", (0, bytes_1.hexDataSlice)((0, sha2_1.ripemd160)((0, sha2_1.sha256)(this.publicKey)), 0, 4));
      (0, properties_1.defineReadOnly)(this, "address", (0, transactions_1.computeAddress)(this.publicKey));
      (0, properties_1.defineReadOnly)(this, "chainCode", chainCode);
      (0, properties_1.defineReadOnly)(this, "index", index);
      (0, properties_1.defineReadOnly)(this, "depth", depth);
      if (mnemonicOrPath == null) {
        (0, properties_1.defineReadOnly)(this, "mnemonic", null);
        (0, properties_1.defineReadOnly)(this, "path", null);
      } else if (typeof mnemonicOrPath === "string") {
        (0, properties_1.defineReadOnly)(this, "mnemonic", null);
        (0, properties_1.defineReadOnly)(this, "path", mnemonicOrPath);
      } else {
        (0, properties_1.defineReadOnly)(this, "mnemonic", mnemonicOrPath);
        (0, properties_1.defineReadOnly)(this, "path", mnemonicOrPath.path);
      }
    }
    Object.defineProperty(HDNode2.prototype, "extendedKey", {
      get: function() {
        if (this.depth >= 256) {
          throw new Error("Depth too large!");
        }
        return base58check((0, bytes_1.concat)([
          this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
          (0, bytes_1.hexlify)(this.depth),
          this.parentFingerprint,
          (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(this.index), 4),
          this.chainCode,
          this.privateKey != null ? (0, bytes_1.concat)(["0x00", this.privateKey]) : this.publicKey
        ]));
      },
      enumerable: false,
      configurable: true
    });
    HDNode2.prototype.neuter = function() {
      return new HDNode2(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
    };
    HDNode2.prototype._derive = function(index) {
      if (index > 4294967295) {
        throw new Error("invalid index - " + String(index));
      }
      var path = this.path;
      if (path) {
        path += "/" + (index & ~HardenedBit);
      }
      var data = new Uint8Array(37);
      if (index & HardenedBit) {
        if (!this.privateKey) {
          throw new Error("cannot derive child of neutered node");
        }
        data.set((0, bytes_1.arrayify)(this.privateKey), 1);
        if (path) {
          path += "'";
        }
      } else {
        data.set((0, bytes_1.arrayify)(this.publicKey));
      }
      for (var i = 24;i >= 0; i -= 8) {
        data[33 + (i >> 3)] = index >> 24 - i & 255;
      }
      var I = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(sha2_1.SupportedAlgorithm.sha512, this.chainCode, data));
      var IL = I.slice(0, 32);
      var IR = I.slice(32);
      var ki2 = null;
      var Ki = null;
      if (this.privateKey) {
        ki2 = bytes32(bignumber_1.BigNumber.from(IL).add(this.privateKey).mod(N));
      } else {
        var ek = new signing_key_1.SigningKey((0, bytes_1.hexlify)(IL));
        Ki = ek._addPoint(this.publicKey);
      }
      var mnemonicOrPath = path;
      var srcMnemonic = this.mnemonic;
      if (srcMnemonic) {
        mnemonicOrPath = Object.freeze({
          phrase: srcMnemonic.phrase,
          path,
          locale: srcMnemonic.locale || "en"
        });
      }
      return new HDNode2(_constructorGuard, ki2, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
    };
    HDNode2.prototype.derivePath = function(path) {
      var components = path.split("/");
      if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
        throw new Error("invalid path - " + path);
      }
      if (components[0] === "m") {
        components.shift();
      }
      var result = this;
      for (var i = 0;i < components.length; i++) {
        var component = components[i];
        if (component.match(/^[0-9]+'$/)) {
          var index = parseInt(component.substring(0, component.length - 1));
          if (index >= HardenedBit) {
            throw new Error("invalid path index - " + component);
          }
          result = result._derive(HardenedBit + index);
        } else if (component.match(/^[0-9]+$/)) {
          var index = parseInt(component);
          if (index >= HardenedBit) {
            throw new Error("invalid path index - " + component);
          }
          result = result._derive(index);
        } else {
          throw new Error("invalid path component - " + component);
        }
      }
      return result;
    };
    HDNode2._fromSeed = function(seed, mnemonic) {
      var seedArray = (0, bytes_1.arrayify)(seed);
      if (seedArray.length < 16 || seedArray.length > 64) {
        throw new Error("invalid seed");
      }
      var I = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(sha2_1.SupportedAlgorithm.sha512, MasterSecret, seedArray));
      return new HDNode2(_constructorGuard, bytes32(I.slice(0, 32)), null, "0x00000000", bytes32(I.slice(32)), 0, 0, mnemonic);
    };
    HDNode2.fromMnemonic = function(mnemonic, password, wordlist) {
      wordlist = getWordlist(wordlist);
      mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);
      return HDNode2._fromSeed(mnemonicToSeed(mnemonic, password), {
        phrase: mnemonic,
        path: "m",
        locale: wordlist.locale
      });
    };
    HDNode2.fromSeed = function(seed) {
      return HDNode2._fromSeed(seed, null);
    };
    HDNode2.fromExtendedKey = function(extendedKey) {
      var bytes = basex_1.Base58.decode(extendedKey);
      if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
        logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
      }
      var depth = bytes[4];
      var parentFingerprint = (0, bytes_1.hexlify)(bytes.slice(5, 9));
      var index = parseInt((0, bytes_1.hexlify)(bytes.slice(9, 13)).substring(2), 16);
      var chainCode = (0, bytes_1.hexlify)(bytes.slice(13, 45));
      var key = bytes.slice(45, 78);
      switch ((0, bytes_1.hexlify)(bytes.slice(0, 4))) {
        case "0x0488b21e":
        case "0x043587cf":
          return new HDNode2(_constructorGuard, null, (0, bytes_1.hexlify)(key), parentFingerprint, chainCode, index, depth, null);
        case "0x0488ade4":
        case "0x04358394 ":
          if (key[0] !== 0) {
            break;
          }
          return new HDNode2(_constructorGuard, (0, bytes_1.hexlify)(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
      }
      return logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    };
    return HDNode2;
  }();
  exports.HDNode = HDNode;
  exports.mnemonicToSeed = mnemonicToSeed;
  exports.mnemonicToEntropy = mnemonicToEntropy;
  exports.entropyToMnemonic = entropyToMnemonic;
  exports.isValidMnemonic = isValidMnemonic;
  exports.getAccountPath = getAccountPath;
});

// node_modules/aes-js/index.js
var require_aes_js = __commonJS((exports, module) => {
  (function(root) {
    function checkInt(value) {
      return parseInt(value) === value;
    }
    function checkInts(arrayish) {
      if (!checkInt(arrayish.length)) {
        return false;
      }
      for (var i = 0;i < arrayish.length; i++) {
        if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
          return false;
        }
      }
      return true;
    }
    function coerceArray(arg, copy) {
      if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
        if (copy) {
          if (arg.slice) {
            arg = arg.slice();
          } else {
            arg = Array.prototype.slice.call(arg);
          }
        }
        return arg;
      }
      if (Array.isArray(arg)) {
        if (!checkInts(arg)) {
          throw new Error("Array contains invalid value: " + arg);
        }
        return new Uint8Array(arg);
      }
      if (checkInt(arg.length) && checkInts(arg)) {
        return new Uint8Array(arg);
      }
      throw new Error("unsupported array-like object");
    }
    function createArray(length) {
      return new Uint8Array(length);
    }
    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
      if (sourceStart != null || sourceEnd != null) {
        if (sourceArray.slice) {
          sourceArray = sourceArray.slice(sourceStart, sourceEnd);
        } else {
          sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
        }
      }
      targetArray.set(sourceArray, targetStart);
    }
    var convertUtf8 = function() {
      function toBytes(text) {
        var result = [], i = 0;
        text = encodeURI(text);
        while (i < text.length) {
          var c = text.charCodeAt(i++);
          if (c === 37) {
            result.push(parseInt(text.substr(i, 2), 16));
            i += 2;
          } else {
            result.push(c);
          }
        }
        return coerceArray(result);
      }
      function fromBytes(bytes) {
        var result = [], i = 0;
        while (i < bytes.length) {
          var c = bytes[i];
          if (c < 128) {
            result.push(String.fromCharCode(c));
            i++;
          } else if (c > 191 && c < 224) {
            result.push(String.fromCharCode((c & 31) << 6 | bytes[i + 1] & 63));
            i += 2;
          } else {
            result.push(String.fromCharCode((c & 15) << 12 | (bytes[i + 1] & 63) << 6 | bytes[i + 2] & 63));
            i += 3;
          }
        }
        return result.join("");
      }
      return {
        toBytes,
        fromBytes
      };
    }();
    var convertHex = function() {
      function toBytes(text) {
        var result = [];
        for (var i = 0;i < text.length; i += 2) {
          result.push(parseInt(text.substr(i, 2), 16));
        }
        return result;
      }
      var Hex = "0123456789abcdef";
      function fromBytes(bytes) {
        var result = [];
        for (var i = 0;i < bytes.length; i++) {
          var v2 = bytes[i];
          result.push(Hex[(v2 & 240) >> 4] + Hex[v2 & 15]);
        }
        return result.join("");
      }
      return {
        toBytes,
        fromBytes
      };
    }();
    var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
    var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
    var S2 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
    var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
    var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
    var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
    var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
    var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
    var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
    var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
    var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239000, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
    var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998000, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
    var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
    var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
    var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239000, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
    var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998000, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function convertToInt32(bytes) {
      var result = [];
      for (var i = 0;i < bytes.length; i += 4) {
        result.push(bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]);
      }
      return result;
    }
    var AES = function(key) {
      if (!(this instanceof AES)) {
        throw Error("AES must be instanitated with `new`");
      }
      Object.defineProperty(this, "key", {
        value: coerceArray(key, true)
      });
      this._prepare();
    };
    AES.prototype._prepare = function() {
      var rounds = numberOfRounds[this.key.length];
      if (rounds == null) {
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      }
      this._Ke = [];
      this._Kd = [];
      for (var i = 0;i <= rounds; i++) {
        this._Ke.push([0, 0, 0, 0]);
        this._Kd.push([0, 0, 0, 0]);
      }
      var roundKeyCount = (rounds + 1) * 4;
      var KC = this.key.length / 4;
      var tk = convertToInt32(this.key);
      var index;
      for (var i = 0;i < KC; i++) {
        index = i >> 2;
        this._Ke[index][i % 4] = tk[i];
        this._Kd[rounds - index][i % 4] = tk[i];
      }
      var rconpointer = 0;
      var t = KC, tt;
      while (t < roundKeyCount) {
        tt = tk[KC - 1];
        tk[0] ^= S2[tt >> 16 & 255] << 24 ^ S2[tt >> 8 & 255] << 16 ^ S2[tt & 255] << 8 ^ S2[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
        rconpointer += 1;
        if (KC != 8) {
          for (var i = 1;i < KC; i++) {
            tk[i] ^= tk[i - 1];
          }
        } else {
          for (var i = 1;i < KC / 2; i++) {
            tk[i] ^= tk[i - 1];
          }
          tt = tk[KC / 2 - 1];
          tk[KC / 2] ^= S2[tt & 255] ^ S2[tt >> 8 & 255] << 8 ^ S2[tt >> 16 & 255] << 16 ^ S2[tt >> 24 & 255] << 24;
          for (var i = KC / 2 + 1;i < KC; i++) {
            tk[i] ^= tk[i - 1];
          }
        }
        var i = 0, r, c;
        while (i < KC && t < roundKeyCount) {
          r = t >> 2;
          c = t % 4;
          this._Ke[r][c] = tk[i];
          this._Kd[rounds - r][c] = tk[i++];
          t++;
        }
      }
      for (var r = 1;r < rounds; r++) {
        for (var c = 0;c < 4; c++) {
          tt = this._Kd[r][c];
          this._Kd[r][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
        }
      }
    };
    AES.prototype.encrypt = function(plaintext) {
      if (plaintext.length != 16) {
        throw new Error("invalid plaintext size (must be 16 bytes)");
      }
      var rounds = this._Ke.length - 1;
      var a = [0, 0, 0, 0];
      var t = convertToInt32(plaintext);
      for (var i = 0;i < 4; i++) {
        t[i] ^= this._Ke[0][i];
      }
      for (var r = 1;r < rounds; r++) {
        for (var i = 0;i < 4; i++) {
          a[i] = T1[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ this._Ke[r][i];
        }
        t = a.slice();
      }
      var result = createArray(16), tt;
      for (var i = 0;i < 4; i++) {
        tt = this._Ke[rounds][i];
        result[4 * i] = (S2[t[i] >> 24 & 255] ^ tt >> 24) & 255;
        result[4 * i + 1] = (S2[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
        result[4 * i + 2] = (S2[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
        result[4 * i + 3] = (S2[t[(i + 3) % 4] & 255] ^ tt) & 255;
      }
      return result;
    };
    AES.prototype.decrypt = function(ciphertext) {
      if (ciphertext.length != 16) {
        throw new Error("invalid ciphertext size (must be 16 bytes)");
      }
      var rounds = this._Kd.length - 1;
      var a = [0, 0, 0, 0];
      var t = convertToInt32(ciphertext);
      for (var i = 0;i < 4; i++) {
        t[i] ^= this._Kd[0][i];
      }
      for (var r = 1;r < rounds; r++) {
        for (var i = 0;i < 4; i++) {
          a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ this._Kd[r][i];
        }
        t = a.slice();
      }
      var result = createArray(16), tt;
      for (var i = 0;i < 4; i++) {
        tt = this._Kd[rounds][i];
        result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
        result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
        result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
        result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
      }
      return result;
    };
    var ModeOfOperationECB = function(key) {
      if (!(this instanceof ModeOfOperationECB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Electronic Code Block";
      this.name = "ecb";
      this._aes = new AES(key);
    };
    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i = 0;i < plaintext.length; i += 16) {
        copyArray(plaintext, block, 0, i, i + 16);
        block = this._aes.encrypt(block);
        copyArray(block, ciphertext, i);
      }
      return ciphertext;
    };
    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i = 0;i < ciphertext.length; i += 16) {
        copyArray(ciphertext, block, 0, i, i + 16);
        block = this._aes.decrypt(block);
        copyArray(block, plaintext, i);
      }
      return plaintext;
    };
    var ModeOfOperationCBC = function(key, iv) {
      if (!(this instanceof ModeOfOperationCBC)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Cipher Block Chaining";
      this.name = "cbc";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      }
      this._lastCipherblock = coerceArray(iv, true);
      this._aes = new AES(key);
    };
    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i = 0;i < plaintext.length; i += 16) {
        copyArray(plaintext, block, 0, i, i + 16);
        for (var j = 0;j < 16; j++) {
          block[j] ^= this._lastCipherblock[j];
        }
        this._lastCipherblock = this._aes.encrypt(block);
        copyArray(this._lastCipherblock, ciphertext, i);
      }
      return ciphertext;
    };
    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i = 0;i < ciphertext.length; i += 16) {
        copyArray(ciphertext, block, 0, i, i + 16);
        block = this._aes.decrypt(block);
        for (var j = 0;j < 16; j++) {
          plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
        }
        copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
      }
      return plaintext;
    };
    var ModeOfOperationCFB = function(key, iv, segmentSize) {
      if (!(this instanceof ModeOfOperationCFB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Cipher Feedback";
      this.name = "cfb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 size)");
      }
      if (!segmentSize) {
        segmentSize = 1;
      }
      this.segmentSize = segmentSize;
      this._shiftRegister = coerceArray(iv, true);
      this._aes = new AES(key);
    };
    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
      if (plaintext.length % this.segmentSize != 0) {
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      }
      var encrypted = coerceArray(plaintext, true);
      var xorSegment;
      for (var i = 0;i < encrypted.length; i += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j = 0;j < this.segmentSize; j++) {
          encrypted[i + j] ^= xorSegment[j];
        }
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
      }
      return encrypted;
    };
    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
      if (ciphertext.length % this.segmentSize != 0) {
        throw new Error("invalid ciphertext size (must be segmentSize bytes)");
      }
      var plaintext = coerceArray(ciphertext, true);
      var xorSegment;
      for (var i = 0;i < plaintext.length; i += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j = 0;j < this.segmentSize; j++) {
          plaintext[i + j] ^= xorSegment[j];
        }
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
      }
      return plaintext;
    };
    var ModeOfOperationOFB = function(key, iv) {
      if (!(this instanceof ModeOfOperationOFB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Output Feedback";
      this.name = "ofb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      }
      this._lastPrecipher = coerceArray(iv, true);
      this._lastPrecipherIndex = 16;
      this._aes = new AES(key);
    };
    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i = 0;i < encrypted.length; i++) {
        if (this._lastPrecipherIndex === 16) {
          this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
          this._lastPrecipherIndex = 0;
        }
        encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      }
      return encrypted;
    };
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
    var Counter = function(initialValue) {
      if (!(this instanceof Counter)) {
        throw Error("Counter must be instanitated with `new`");
      }
      if (initialValue !== 0 && !initialValue) {
        initialValue = 1;
      }
      if (typeof initialValue === "number") {
        this._counter = createArray(16);
        this.setValue(initialValue);
      } else {
        this.setBytes(initialValue);
      }
    };
    Counter.prototype.setValue = function(value) {
      if (typeof value !== "number" || parseInt(value) != value) {
        throw new Error("invalid counter value (must be an integer)");
      }
      for (var index = 15;index >= 0; --index) {
        this._counter[index] = value % 256;
        value = value >> 8;
      }
    };
    Counter.prototype.setBytes = function(bytes) {
      bytes = coerceArray(bytes, true);
      if (bytes.length != 16) {
        throw new Error("invalid counter bytes size (must be 16 bytes)");
      }
      this._counter = bytes;
    };
    Counter.prototype.increment = function() {
      for (var i = 15;i >= 0; i--) {
        if (this._counter[i] === 255) {
          this._counter[i] = 0;
        } else {
          this._counter[i]++;
          break;
        }
      }
    };
    var ModeOfOperationCTR = function(key, counter) {
      if (!(this instanceof ModeOfOperationCTR)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Counter";
      this.name = "ctr";
      if (!(counter instanceof Counter)) {
        counter = new Counter(counter);
      }
      this._counter = counter;
      this._remainingCounter = null;
      this._remainingCounterIndex = 16;
      this._aes = new AES(key);
    };
    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i = 0;i < encrypted.length; i++) {
        if (this._remainingCounterIndex === 16) {
          this._remainingCounter = this._aes.encrypt(this._counter._counter);
          this._remainingCounterIndex = 0;
          this._counter.increment();
        }
        encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
      }
      return encrypted;
    };
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
    function pkcs7pad(data) {
      data = coerceArray(data, true);
      var padder = 16 - data.length % 16;
      var result = createArray(data.length + padder);
      copyArray(data, result);
      for (var i = data.length;i < result.length; i++) {
        result[i] = padder;
      }
      return result;
    }
    function pkcs7strip(data) {
      data = coerceArray(data, true);
      if (data.length < 16) {
        throw new Error("PKCS#7 invalid length");
      }
      var padder = data[data.length - 1];
      if (padder > 16) {
        throw new Error("PKCS#7 padding byte out of range");
      }
      var length = data.length - padder;
      for (var i = 0;i < padder; i++) {
        if (data[length + i] !== padder) {
          throw new Error("PKCS#7 invalid padding byte");
        }
      }
      var result = createArray(length);
      copyArray(data, result, 0, 0, length);
      return result;
    }
    var aesjs = {
      AES,
      Counter,
      ModeOfOperation: {
        ecb: ModeOfOperationECB,
        cbc: ModeOfOperationCBC,
        cfb: ModeOfOperationCFB,
        ofb: ModeOfOperationOFB,
        ctr: ModeOfOperationCTR
      },
      utils: {
        hex: convertHex,
        utf8: convertUtf8
      },
      padding: {
        pkcs7: {
          pad: pkcs7pad,
          strip: pkcs7strip
        }
      },
      _arrayTest: {
        coerceArray,
        createArray,
        copyArray
      }
    };
    if (typeof exports !== "undefined") {
      module.exports = aesjs;
    } else if (typeof define === "function" && define.amd) {
      define(aesjs);
    } else {
      if (root.aesjs) {
        aesjs._aesjs = root.aesjs;
      }
      root.aesjs = aesjs;
    }
  })(exports);
});

// node_modules/@ethersproject/json-wallets/lib/_version.js
var require__version15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "json-wallets/5.7.0";
});

// node_modules/@ethersproject/json-wallets/lib/utils.js
var require_utils4 = __commonJS((exports) => {
  var looseArrayify = function(hexString) {
    if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
      hexString = "0x" + hexString;
    }
    return (0, bytes_1.arrayify)(hexString);
  };
  var zpad = function(value, length) {
    value = String(value);
    while (value.length < length) {
      value = "0" + value;
    }
    return value;
  };
  var getPassword = function(password) {
    if (typeof password === "string") {
      return (0, strings_1.toUtf8Bytes)(password, strings_1.UnicodeNormalizationForm.NFKC);
    }
    return (0, bytes_1.arrayify)(password);
  };
  var searchPath = function(object, path) {
    var currentChild = object;
    var comps = path.toLowerCase().split("/");
    for (var i = 0;i < comps.length; i++) {
      var matchingChild = null;
      for (var key in currentChild) {
        if (key.toLowerCase() === comps[i]) {
          matchingChild = currentChild[key];
          break;
        }
      }
      if (matchingChild === null) {
        return null;
      }
      currentChild = matchingChild;
    }
    return currentChild;
  };
  var uuidV4 = function(randomBytes) {
    var bytes = (0, bytes_1.arrayify)(randomBytes);
    bytes[6] = bytes[6] & 15 | 64;
    bytes[8] = bytes[8] & 63 | 128;
    var value = (0, bytes_1.hexlify)(bytes);
    return [
      value.substring(2, 10),
      value.substring(10, 14),
      value.substring(14, 18),
      value.substring(18, 22),
      value.substring(22, 34)
    ].join("-");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uuidV4 = exports.searchPath = exports.getPassword = exports.zpad = exports.looseArrayify = undefined;
  var bytes_1 = require_lib2();
  var strings_1 = require_lib9();
  exports.looseArrayify = looseArrayify;
  exports.zpad = zpad;
  exports.getPassword = getPassword;
  exports.searchPath = searchPath;
  exports.uuidV4 = uuidV4;
});

// node_modules/@ethersproject/json-wallets/lib/crowdsale.js
var require_crowdsale = __commonJS((exports) => {
  var decrypt = function(json, password) {
    var data = JSON.parse(json);
    password = (0, utils_1.getPassword)(password);
    var ethaddr = (0, address_1.getAddress)((0, utils_1.searchPath)(data, "ethaddr"));
    var encseed = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "encseed"));
    if (!encseed || encseed.length % 16 !== 0) {
      logger.throwArgumentError("invalid encseed", "json", json);
    }
    var key = (0, bytes_1.arrayify)((0, pbkdf2_1.pbkdf2)(password, password, 2000, 32, "sha256")).slice(0, 16);
    var iv = encseed.slice(0, 16);
    var encryptedSeed = encseed.slice(16);
    var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);
    var seed = aes_js_1.default.padding.pkcs7.strip((0, bytes_1.arrayify)(aesCbc.decrypt(encryptedSeed)));
    var seedHex = "";
    for (var i = 0;i < seed.length; i++) {
      seedHex += String.fromCharCode(seed[i]);
    }
    var seedHexBytes = (0, strings_1.toUtf8Bytes)(seedHex);
    var privateKey = (0, keccak256_1.keccak256)(seedHexBytes);
    return new CrowdsaleAccount({
      _isCrowdsaleAccount: true,
      address: ethaddr,
      privateKey
    });
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
        d2.__proto__ = b4;
      } || function(d2, b4) {
        for (var p in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p))
            d2[p] = b4[p];
      };
      return extendStatics(d, b3);
    };
    return function(d, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d, b3);
      function __() {
        this.constructor = d;
      }
      d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __);
    };
  }();
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decrypt = exports.CrowdsaleAccount = undefined;
  var aes_js_1 = __importDefault(require_aes_js());
  var address_1 = require_lib7();
  var bytes_1 = require_lib2();
  var keccak256_1 = require_lib5();
  var pbkdf2_1 = require_lib16();
  var strings_1 = require_lib9();
  var properties_1 = require_lib4();
  var logger_1 = require_lib();
  var _version_1 = require__version15();
  var logger = new logger_1.Logger(_version_1.version);
  var utils_1 = require_utils4();
  var CrowdsaleAccount = function(_super) {
    __extends(CrowdsaleAccount2, _super);
    function CrowdsaleAccount2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CrowdsaleAccount2.prototype.isCrowdsaleAccount = function(value) {
      return !!(value && value._isCrowdsaleAccount);
    };
    return CrowdsaleAccount2;
  }(properties_1.Description);
  exports.CrowdsaleAccount = CrowdsaleAccount;
  exports.decrypt = decrypt;
});

// node_modules/@ethersproject/json-wallets/lib/inspect.js
var require_inspect = __commonJS((exports) => {
  var isCrowdsaleWallet = function(json) {
    var data = null;
    try {
      data = JSON.parse(json);
    } catch (error) {
      return false;
    }
    return data.encseed && data.ethaddr;
  };
  var isKeystoreWallet = function(json) {
    var data = null;
    try {
      data = JSON.parse(json);
    } catch (error) {
      return false;
    }
    if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
      return false;
    }
    return true;
  };
  var getJsonWalletAddress = function(json) {
    if (isCrowdsaleWallet(json)) {
      try {
        return (0, address_1.getAddress)(JSON.parse(json).ethaddr);
      } catch (error) {
        return null;
      }
    }
    if (isKeystoreWallet(json)) {
      try {
        return (0, address_1.getAddress)(JSON.parse(json).address);
      } catch (error) {
        return null;
      }
    }
    return null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getJsonWalletAddress = exports.isKeystoreWallet = exports.isCrowdsaleWallet = undefined;
  var address_1 = require_lib7();
  exports.isCrowdsaleWallet = isCrowdsaleWallet;
  exports.isKeystoreWallet = isKeystoreWallet;
  exports.getJsonWalletAddress = getJsonWalletAddress;
});

// node_modules/scrypt-js/scrypt.js
var require_scrypt = __commonJS((exports, module) => {
  (function(root) {
    const MAX_VALUE = 2147483647;
    function SHA256(m) {
      const K = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      let h02 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762;
      let h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
      const w = new Uint32Array(64);
      function blocks(p2) {
        let off = 0, len = p2.length;
        while (len >= 64) {
          let a = h02, b3 = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i3, j, t1, t22;
          for (i3 = 0;i3 < 16; i3++) {
            j = off + i3 * 4;
            w[i3] = (p2[j] & 255) << 24 | (p2[j + 1] & 255) << 16 | (p2[j + 2] & 255) << 8 | p2[j + 3] & 255;
          }
          for (i3 = 16;i3 < 64; i3++) {
            u = w[i3 - 2];
            t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
            u = w[i3 - 15];
            t22 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
            w[i3] = (t1 + w[i3 - 7] | 0) + (t22 + w[i3 - 16] | 0) | 0;
          }
          for (i3 = 0;i3 < 64; i3++) {
            t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i3] + w[i3] | 0) | 0) | 0;
            t22 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b3 ^ a & c ^ b3 & c) | 0;
            h = g;
            g = f;
            f = e;
            e = d + t1 | 0;
            d = c;
            c = b3;
            b3 = a;
            a = t1 + t22 | 0;
          }
          h02 = h02 + a | 0;
          h1 = h1 + b3 | 0;
          h2 = h2 + c | 0;
          h3 = h3 + d | 0;
          h4 = h4 + e | 0;
          h5 = h5 + f | 0;
          h6 = h6 + g | 0;
          h7 = h7 + h | 0;
          off += 64;
          len -= 64;
        }
      }
      blocks(m);
      let i, bytesLeft = m.length % 64, bitLenHi = m.length / 536870912 | 0, bitLenLo = m.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p = m.slice(m.length - bytesLeft, m.length);
      p.push(128);
      for (i = bytesLeft + 1;i < numZeros; i++) {
        p.push(0);
      }
      p.push(bitLenHi >>> 24 & 255);
      p.push(bitLenHi >>> 16 & 255);
      p.push(bitLenHi >>> 8 & 255);
      p.push(bitLenHi >>> 0 & 255);
      p.push(bitLenLo >>> 24 & 255);
      p.push(bitLenLo >>> 16 & 255);
      p.push(bitLenLo >>> 8 & 255);
      p.push(bitLenLo >>> 0 & 255);
      blocks(p);
      return [
        h02 >>> 24 & 255,
        h02 >>> 16 & 255,
        h02 >>> 8 & 255,
        h02 >>> 0 & 255,
        h1 >>> 24 & 255,
        h1 >>> 16 & 255,
        h1 >>> 8 & 255,
        h1 >>> 0 & 255,
        h2 >>> 24 & 255,
        h2 >>> 16 & 255,
        h2 >>> 8 & 255,
        h2 >>> 0 & 255,
        h3 >>> 24 & 255,
        h3 >>> 16 & 255,
        h3 >>> 8 & 255,
        h3 >>> 0 & 255,
        h4 >>> 24 & 255,
        h4 >>> 16 & 255,
        h4 >>> 8 & 255,
        h4 >>> 0 & 255,
        h5 >>> 24 & 255,
        h5 >>> 16 & 255,
        h5 >>> 8 & 255,
        h5 >>> 0 & 255,
        h6 >>> 24 & 255,
        h6 >>> 16 & 255,
        h6 >>> 8 & 255,
        h6 >>> 0 & 255,
        h7 >>> 24 & 255,
        h7 >>> 16 & 255,
        h7 >>> 8 & 255,
        h7 >>> 0 & 255
      ];
    }
    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
      password = password.length <= 64 ? password : SHA256(password);
      const innerLen = 64 + salt.length + 4;
      const inner = new Array(innerLen);
      const outerKey = new Array(64);
      let i;
      let dk = [];
      for (i = 0;i < 64; i++) {
        inner[i] = 54;
      }
      for (i = 0;i < password.length; i++) {
        inner[i] ^= password[i];
      }
      for (i = 0;i < salt.length; i++) {
        inner[64 + i] = salt[i];
      }
      for (i = innerLen - 4;i < innerLen; i++) {
        inner[i] = 0;
      }
      for (i = 0;i < 64; i++)
        outerKey[i] = 92;
      for (i = 0;i < password.length; i++)
        outerKey[i] ^= password[i];
      function incrementCounter() {
        for (let i3 = innerLen - 1;i3 >= innerLen - 4; i3--) {
          inner[i3]++;
          if (inner[i3] <= 255)
            return;
          inner[i3] = 0;
        }
      }
      while (dkLen >= 32) {
        incrementCounter();
        dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
        dkLen -= 32;
      }
      if (dkLen > 0) {
        incrementCounter();
        dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
      }
      return dk;
    }
    function blockmix_salsa8(BY, Yi, r, x, _X) {
      let i;
      arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);
      for (i = 0;i < 2 * r; i++) {
        blockxor(BY, i * 16, _X, 16);
        salsa20_8(_X, x);
        arraycopy(_X, 0, BY, Yi + i * 16, 16);
      }
      for (i = 0;i < r; i++) {
        arraycopy(BY, Yi + i * 2 * 16, BY, i * 16, 16);
      }
      for (i = 0;i < r; i++) {
        arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
      }
    }
    function R(a, b3) {
      return a << b3 | a >>> 32 - b3;
    }
    function salsa20_8(B, x) {
      arraycopy(B, 0, x, 0, 16);
      for (let i = 8;i > 0; i -= 2) {
        x[4] ^= R(x[0] + x[12], 7);
        x[8] ^= R(x[4] + x[0], 9);
        x[12] ^= R(x[8] + x[4], 13);
        x[0] ^= R(x[12] + x[8], 18);
        x[9] ^= R(x[5] + x[1], 7);
        x[13] ^= R(x[9] + x[5], 9);
        x[1] ^= R(x[13] + x[9], 13);
        x[5] ^= R(x[1] + x[13], 18);
        x[14] ^= R(x[10] + x[6], 7);
        x[2] ^= R(x[14] + x[10], 9);
        x[6] ^= R(x[2] + x[14], 13);
        x[10] ^= R(x[6] + x[2], 18);
        x[3] ^= R(x[15] + x[11], 7);
        x[7] ^= R(x[3] + x[15], 9);
        x[11] ^= R(x[7] + x[3], 13);
        x[15] ^= R(x[11] + x[7], 18);
        x[1] ^= R(x[0] + x[3], 7);
        x[2] ^= R(x[1] + x[0], 9);
        x[3] ^= R(x[2] + x[1], 13);
        x[0] ^= R(x[3] + x[2], 18);
        x[6] ^= R(x[5] + x[4], 7);
        x[7] ^= R(x[6] + x[5], 9);
        x[4] ^= R(x[7] + x[6], 13);
        x[5] ^= R(x[4] + x[7], 18);
        x[11] ^= R(x[10] + x[9], 7);
        x[8] ^= R(x[11] + x[10], 9);
        x[9] ^= R(x[8] + x[11], 13);
        x[10] ^= R(x[9] + x[8], 18);
        x[12] ^= R(x[15] + x[14], 7);
        x[13] ^= R(x[12] + x[15], 9);
        x[14] ^= R(x[13] + x[12], 13);
        x[15] ^= R(x[14] + x[13], 18);
      }
      for (let i = 0;i < 16; ++i) {
        B[i] += x[i];
      }
    }
    function blockxor(S2, Si, D2, len) {
      for (let i = 0;i < len; i++) {
        D2[i] ^= S2[Si + i];
      }
    }
    function arraycopy(src, srcPos, dest, destPos, length) {
      while (length--) {
        dest[destPos++] = src[srcPos++];
      }
    }
    function checkBufferish(o) {
      if (!o || typeof o.length !== "number") {
        return false;
      }
      for (let i = 0;i < o.length; i++) {
        const v2 = o[i];
        if (typeof v2 !== "number" || v2 % 1 || v2 < 0 || v2 >= 256) {
          return false;
        }
      }
      return true;
    }
    function ensureInteger(value, name) {
      if (typeof value !== "number" || value % 1) {
        throw new Error("invalid " + name);
      }
      return value;
    }
    function _scrypt(password, salt, N, r, p, dkLen, callback) {
      N = ensureInteger(N, "N");
      r = ensureInteger(r, "r");
      p = ensureInteger(p, "p");
      dkLen = ensureInteger(dkLen, "dkLen");
      if (N === 0 || (N & N - 1) !== 0) {
        throw new Error("N must be power of 2");
      }
      if (N > MAX_VALUE / 128 / r) {
        throw new Error("N too large");
      }
      if (r > MAX_VALUE / 128 / p) {
        throw new Error("r too large");
      }
      if (!checkBufferish(password)) {
        throw new Error("password must be an array or buffer");
      }
      password = Array.prototype.slice.call(password);
      if (!checkBufferish(salt)) {
        throw new Error("salt must be an array or buffer");
      }
      salt = Array.prototype.slice.call(salt);
      let b3 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
      const B = new Uint32Array(p * 32 * r);
      for (let i = 0;i < B.length; i++) {
        const j = i * 4;
        B[i] = (b3[j + 3] & 255) << 24 | (b3[j + 2] & 255) << 16 | (b3[j + 1] & 255) << 8 | (b3[j + 0] & 255) << 0;
      }
      const XY = new Uint32Array(64 * r);
      const V = new Uint32Array(32 * r * N);
      const Yi = 32 * r;
      const x = new Uint32Array(16);
      const _X = new Uint32Array(16);
      const totalOps = p * N * 2;
      let currentOp = 0;
      let lastPercent10 = null;
      let stop = false;
      let state = 0;
      let i0 = 0, i1;
      let Bi;
      const limit = callback ? parseInt(1000 / r) : 4294967295;
      const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
      const incrementalSMix = function() {
        if (stop) {
          return callback(new Error("cancelled"), currentOp / totalOps);
        }
        let steps;
        switch (state) {
          case 0:
            Bi = i0 * 32 * r;
            arraycopy(B, Bi, XY, 0, Yi);
            state = 1;
            i1 = 0;
          case 1:
            steps = N - i1;
            if (steps > limit) {
              steps = limit;
            }
            for (let i = 0;i < steps; i++) {
              arraycopy(XY, 0, V, (i1 + i) * Yi, Yi);
              blockmix_salsa8(XY, Yi, r, x, _X);
            }
            i1 += steps;
            currentOp += steps;
            if (callback) {
              const percent10 = parseInt(1000 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N) {
              break;
            }
            i1 = 0;
            state = 2;
          case 2:
            steps = N - i1;
            if (steps > limit) {
              steps = limit;
            }
            for (let i = 0;i < steps; i++) {
              const offset = (2 * r - 1) * 16;
              const j = XY[offset] & N - 1;
              blockxor(V, j * Yi, XY, Yi);
              blockmix_salsa8(XY, Yi, r, x, _X);
            }
            i1 += steps;
            currentOp += steps;
            if (callback) {
              const percent10 = parseInt(1000 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N) {
              break;
            }
            arraycopy(XY, 0, B, Bi, Yi);
            i0++;
            if (i0 < p) {
              state = 0;
              break;
            }
            b3 = [];
            for (let i = 0;i < B.length; i++) {
              b3.push(B[i] >> 0 & 255);
              b3.push(B[i] >> 8 & 255);
              b3.push(B[i] >> 16 & 255);
              b3.push(B[i] >> 24 & 255);
            }
            const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b3, dkLen);
            if (callback) {
              callback(null, 1, derivedKey);
            }
            return derivedKey;
        }
        if (callback) {
          nextTick(incrementalSMix);
        }
      };
      if (!callback) {
        while (true) {
          const derivedKey = incrementalSMix();
          if (derivedKey != null) {
            return derivedKey;
          }
        }
      }
      incrementalSMix();
    }
    const lib = {
      scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {
        return new Promise(function(resolve, reject) {
          let lastProgress = 0;
          if (progressCallback) {
            progressCallback(0);
          }
          _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {
            if (error) {
              reject(error);
            } else if (key) {
              if (progressCallback && lastProgress !== 1) {
                progressCallback(1);
              }
              resolve(new Uint8Array(key));
            } else if (progressCallback && progress !== lastProgress) {
              lastProgress = progress;
              return progressCallback(progress);
            }
          });
        });
      },
      syncScrypt: function(password, salt, N, r, p, dkLen) {
        return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));
      }
    };
    if (typeof exports !== "undefined") {
      module.exports = lib;
    } else if (typeof define === "function" && define.amd) {
      define(lib);
    } else if (root) {
      if (root.scrypt) {
        root._scrypt = root.scrypt;
      }
      root.scrypt = lib;
    }
  })(exports);
});

// node_modules/@ethersproject/random/lib/_version.js
var require__version16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "random/5.7.0";
});

// node_modules/@ethersproject/random/lib/browser-random.js
var require_browser_random = __commonJS((exports) => {
  var getGlobal = function() {
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    throw new Error("unable to locate global object");
  };
  var randomBytes = function(length) {
    if (length <= 0 || length > 1024 || length % 1 || length != length) {
      logger.throwArgumentError("invalid length", "length", length);
    }
    var result = new Uint8Array(length);
    crypto2.getRandomValues(result);
    return (0, bytes_1.arrayify)(result);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomBytes = undefined;
  var bytes_1 = require_lib2();
  var logger_1 = require_lib();
  var _version_1 = require__version16();
  var logger = new logger_1.Logger(_version_1.version);
  var anyGlobal = getGlobal();
  var crypto2 = anyGlobal.crypto || anyGlobal.msCrypto;
  if (!crypto2 || !crypto2.getRandomValues) {
    logger.warn("WARNING: Missing strong random number source");
    crypto2 = {
      getRandomValues: function(buffer) {
        return logger.throwError("no secure random source avaialble", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "crypto.getRandomValues"
        });
      }
    };
  }
  exports.randomBytes = randomBytes;
});

// node_modules/@ethersproject/random/lib/shuffle.js
var require_shuffle = __commonJS((exports) => {
  var shuffled = function(array) {
    array = array.slice();
    for (var i = array.length - 1;i > 0; i--) {
      var j = Math.floor(Math.random() * (i + 1));
      var tmp = array[i];
      array[i] = array[j];
      array[j] = tmp;
    }
    return array;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shuffled = undefined;
  exports.shuffled = shuffled;
});

// node_modules/@ethersproject/random/lib/index.js
var require_lib21 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shuffled = exports.randomBytes = undefined;
  var random_1 = require_browser_random();
  Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
    return random_1.randomBytes;
  } });
  var shuffle_1 = require_shuffle();
  Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
    return shuffle_1.shuffled;
  } });
});

// node_modules/@ethersproject/json-wallets/lib/keystore.js
var require_keystore = __commonJS((exports) => {
  var hasMnemonic = function(value) {
    return value != null && value.mnemonic && value.mnemonic.phrase;
  };
  var _decrypt = function(data, key, ciphertext) {
    var cipher = (0, utils_1.searchPath)(data, "crypto/cipher");
    if (cipher === "aes-128-ctr") {
      var iv = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/cipherparams/iv"));
      var counter = new aes_js_1.default.Counter(iv);
      var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(key, counter);
      return (0, bytes_1.arrayify)(aesCtr.decrypt(ciphertext));
    }
    return null;
  };
  var _getAccount = function(data, key) {
    var ciphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/ciphertext"));
    var computedMAC = (0, bytes_1.hexlify)((0, keccak256_1.keccak256)((0, bytes_1.concat)([key.slice(16, 32), ciphertext]))).substring(2);
    if (computedMAC !== (0, utils_1.searchPath)(data, "crypto/mac").toLowerCase()) {
      throw new Error("invalid password");
    }
    var privateKey = _decrypt(data, key.slice(0, 16), ciphertext);
    if (!privateKey) {
      logger.throwError("unsupported cipher", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "decrypt"
      });
    }
    var mnemonicKey = key.slice(32, 64);
    var address = (0, transactions_1.computeAddress)(privateKey);
    if (data.address) {
      var check = data.address.toLowerCase();
      if (check.substring(0, 2) !== "0x") {
        check = "0x" + check;
      }
      if ((0, address_1.getAddress)(check) !== address) {
        throw new Error("address mismatch");
      }
    }
    var account = {
      _isKeystoreAccount: true,
      address,
      privateKey: (0, bytes_1.hexlify)(privateKey)
    };
    if ((0, utils_1.searchPath)(data, "x-ethers/version") === "0.1") {
      var mnemonicCiphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "x-ethers/mnemonicCiphertext"));
      var mnemonicIv = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "x-ethers/mnemonicCounter"));
      var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);
      var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      var path = (0, utils_1.searchPath)(data, "x-ethers/path") || hdnode_1.defaultPath;
      var locale = (0, utils_1.searchPath)(data, "x-ethers/locale") || "en";
      var entropy = (0, bytes_1.arrayify)(mnemonicAesCtr.decrypt(mnemonicCiphertext));
      try {
        var mnemonic = (0, hdnode_1.entropyToMnemonic)(entropy, locale);
        var node = hdnode_1.HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
        if (node.privateKey != account.privateKey) {
          throw new Error("mnemonic mismatch");
        }
        account.mnemonic = node.mnemonic;
      } catch (error) {
        if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
          throw error;
        }
      }
    }
    return new KeystoreAccount(account);
  };
  var pbkdf2Sync = function(passwordBytes, salt, count, dkLen, prfFunc) {
    return (0, bytes_1.arrayify)((0, pbkdf2_1.pbkdf2)(passwordBytes, salt, count, dkLen, prfFunc));
  };
  var pbkdf2 = function(passwordBytes, salt, count, dkLen, prfFunc) {
    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
  };
  var _computeKdfKey = function(data, password, pbkdf2Func, scryptFunc, progressCallback) {
    var passwordBytes = (0, utils_1.getPassword)(password);
    var kdf = (0, utils_1.searchPath)(data, "crypto/kdf");
    if (kdf && typeof kdf === "string") {
      var throwError = function(name, value) {
        return logger.throwArgumentError("invalid key-derivation function parameters", name, value);
      };
      if (kdf.toLowerCase() === "scrypt") {
        var salt = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/kdfparams/salt"));
        var N = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/n"));
        var r = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/r"));
        var p = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/p"));
        if (!N || !r || !p) {
          throwError("kdf", kdf);
        }
        if ((N & N - 1) !== 0) {
          throwError("N", N);
        }
        var dkLen = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/dklen"));
        if (dkLen !== 32) {
          throwError("dklen", dkLen);
        }
        return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);
      } else if (kdf.toLowerCase() === "pbkdf2") {
        var salt = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/kdfparams/salt"));
        var prfFunc = null;
        var prf = (0, utils_1.searchPath)(data, "crypto/kdfparams/prf");
        if (prf === "hmac-sha256") {
          prfFunc = "sha256";
        } else if (prf === "hmac-sha512") {
          prfFunc = "sha512";
        } else {
          throwError("prf", prf);
        }
        var count = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/c"));
        var dkLen = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/dklen"));
        if (dkLen !== 32) {
          throwError("dklen", dkLen);
        }
        return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
      }
    }
    return logger.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
  };
  var decryptSync = function(json, password) {
    var data = JSON.parse(json);
    var key = _computeKdfKey(data, password, pbkdf2Sync, scrypt_js_1.default.syncScrypt);
    return _getAccount(data, key);
  };
  var decrypt = function(json, password, progressCallback) {
    return __awaiter(this, undefined, undefined, function() {
      var data, key;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            data = JSON.parse(json);
            return [4, _computeKdfKey(data, password, pbkdf2, scrypt_js_1.default.scrypt, progressCallback)];
          case 1:
            key = _a.sent();
            return [2, _getAccount(data, key)];
        }
      });
    });
  };
  var encrypt = function(account, password, options, progressCallback) {
    try {
      if ((0, address_1.getAddress)(account.address) !== (0, transactions_1.computeAddress)(account.privateKey)) {
        throw new Error("address/privateKey mismatch");
      }
      if (hasMnemonic(account)) {
        var mnemonic = account.mnemonic;
        var node = hdnode_1.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || hdnode_1.defaultPath);
        if (node.privateKey != account.privateKey) {
          throw new Error("mnemonic mismatch");
        }
      }
    } catch (e) {
      return Promise.reject(e);
    }
    if (typeof options === "function" && !progressCallback) {
      progressCallback = options;
      options = {};
    }
    if (!options) {
      options = {};
    }
    var privateKey = (0, bytes_1.arrayify)(account.privateKey);
    var passwordBytes = (0, utils_1.getPassword)(password);
    var entropy = null;
    var path = null;
    var locale = null;
    if (hasMnemonic(account)) {
      var srcMnemonic = account.mnemonic;
      entropy = (0, bytes_1.arrayify)((0, hdnode_1.mnemonicToEntropy)(srcMnemonic.phrase, srcMnemonic.locale || "en"));
      path = srcMnemonic.path || hdnode_1.defaultPath;
      locale = srcMnemonic.locale || "en";
    }
    var client = options.client;
    if (!client) {
      client = "ethers.js";
    }
    var salt = null;
    if (options.salt) {
      salt = (0, bytes_1.arrayify)(options.salt);
    } else {
      salt = (0, random_1.randomBytes)(32);
    }
    var iv = null;
    if (options.iv) {
      iv = (0, bytes_1.arrayify)(options.iv);
      if (iv.length !== 16) {
        throw new Error("invalid iv");
      }
    } else {
      iv = (0, random_1.randomBytes)(16);
    }
    var uuidRandom = null;
    if (options.uuid) {
      uuidRandom = (0, bytes_1.arrayify)(options.uuid);
      if (uuidRandom.length !== 16) {
        throw new Error("invalid uuid");
      }
    } else {
      uuidRandom = (0, random_1.randomBytes)(16);
    }
    var N = 1 << 17, r = 8, p = 1;
    if (options.scrypt) {
      if (options.scrypt.N) {
        N = options.scrypt.N;
      }
      if (options.scrypt.r) {
        r = options.scrypt.r;
      }
      if (options.scrypt.p) {
        p = options.scrypt.p;
      }
    }
    return scrypt_js_1.default.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(function(key) {
      key = (0, bytes_1.arrayify)(key);
      var derivedKey = key.slice(0, 16);
      var macPrefix = key.slice(16, 32);
      var mnemonicKey = key.slice(32, 64);
      var counter = new aes_js_1.default.Counter(iv);
      var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(derivedKey, counter);
      var ciphertext = (0, bytes_1.arrayify)(aesCtr.encrypt(privateKey));
      var mac = (0, keccak256_1.keccak256)((0, bytes_1.concat)([macPrefix, ciphertext]));
      var data = {
        address: account.address.substring(2).toLowerCase(),
        id: (0, utils_1.uuidV4)(uuidRandom),
        version: 3,
        crypto: {
          cipher: "aes-128-ctr",
          cipherparams: {
            iv: (0, bytes_1.hexlify)(iv).substring(2)
          },
          ciphertext: (0, bytes_1.hexlify)(ciphertext).substring(2),
          kdf: "scrypt",
          kdfparams: {
            salt: (0, bytes_1.hexlify)(salt).substring(2),
            n: N,
            dklen: 32,
            p,
            r
          },
          mac: mac.substring(2)
        }
      };
      if (entropy) {
        var mnemonicIv = (0, random_1.randomBytes)(16);
        var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);
        var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
        var mnemonicCiphertext = (0, bytes_1.arrayify)(mnemonicAesCtr.encrypt(entropy));
        var now = new Date;
        var timestamp = now.getUTCFullYear() + "-" + (0, utils_1.zpad)(now.getUTCMonth() + 1, 2) + "-" + (0, utils_1.zpad)(now.getUTCDate(), 2) + "T" + (0, utils_1.zpad)(now.getUTCHours(), 2) + "-" + (0, utils_1.zpad)(now.getUTCMinutes(), 2) + "-" + (0, utils_1.zpad)(now.getUTCSeconds(), 2) + ".0Z";
        data["x-ethers"] = {
          client,
          gethFilename: "UTC--" + timestamp + "--" + data.address,
          mnemonicCounter: (0, bytes_1.hexlify)(mnemonicIv).substring(2),
          mnemonicCiphertext: (0, bytes_1.hexlify)(mnemonicCiphertext).substring(2),
          path,
          locale,
          version: "0.1"
        };
      }
      return JSON.stringify(data);
    });
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
        d2.__proto__ = b4;
      } || function(d2, b4) {
        for (var p in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p))
            d2[p] = b4[p];
      };
      return extendStatics(d, b3);
    };
    return function(d, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d, b3);
      function __() {
        this.constructor = d;
      }
      d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __);
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _4 = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v2) {
        return step([n, v2]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_4)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _4.label++;
              return { value: op[1], done: false };
            case 5:
              _4.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _4.ops.pop();
              _4.trys.pop();
              continue;
            default:
              if (!(t = _4.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _4 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _4.label = op[1];
                break;
              }
              if (op[0] === 6 && _4.label < t[1]) {
                _4.label = t[1];
                t = op;
                break;
              }
              if (t && _4.label < t[2]) {
                _4.label = t[2];
                _4.ops.push(op);
                break;
              }
              if (t[2])
                _4.ops.pop();
              _4.trys.pop();
              continue;
          }
          op = body.call(thisArg, _4);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encrypt = exports.decrypt = exports.decryptSync = exports.KeystoreAccount = undefined;
  var aes_js_1 = __importDefault(require_aes_js());
  var scrypt_js_1 = __importDefault(require_scrypt());
  var address_1 = require_lib7();
  var bytes_1 = require_lib2();
  var hdnode_1 = require_lib20();
  var keccak256_1 = require_lib5();
  var pbkdf2_1 = require_lib16();
  var random_1 = require_lib21();
  var properties_1 = require_lib4();
  var transactions_1 = require_lib18();
  var utils_1 = require_utils4();
  var logger_1 = require_lib();
  var _version_1 = require__version15();
  var logger = new logger_1.Logger(_version_1.version);
  var KeystoreAccount = function(_super) {
    __extends(KeystoreAccount2, _super);
    function KeystoreAccount2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    KeystoreAccount2.prototype.isKeystoreAccount = function(value) {
      return !!(value && value._isKeystoreAccount);
    };
    return KeystoreAccount2;
  }(properties_1.Description);
  exports.KeystoreAccount = KeystoreAccount;
  exports.decryptSync = decryptSync;
  exports.decrypt = decrypt;
  exports.encrypt = encrypt;
});

// node_modules/@ethersproject/json-wallets/lib/index.js
var require_lib22 = __commonJS((exports) => {
  var decryptJsonWallet = function(json, password, progressCallback) {
    if ((0, inspect_1.isCrowdsaleWallet)(json)) {
      if (progressCallback) {
        progressCallback(0);
      }
      var account = (0, crowdsale_1.decrypt)(json, password);
      if (progressCallback) {
        progressCallback(1);
      }
      return Promise.resolve(account);
    }
    if ((0, inspect_1.isKeystoreWallet)(json)) {
      return (0, keystore_1.decrypt)(json, password, progressCallback);
    }
    return Promise.reject(new Error("invalid JSON wallet"));
  };
  var decryptJsonWalletSync = function(json, password) {
    if ((0, inspect_1.isCrowdsaleWallet)(json)) {
      return (0, crowdsale_1.decrypt)(json, password);
    }
    if ((0, inspect_1.isKeystoreWallet)(json)) {
      return (0, keystore_1.decryptSync)(json, password);
    }
    throw new Error("invalid JSON wallet");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decryptJsonWalletSync = exports.decryptJsonWallet = exports.getJsonWalletAddress = exports.isKeystoreWallet = exports.isCrowdsaleWallet = exports.encryptKeystore = exports.decryptKeystoreSync = exports.decryptKeystore = exports.decryptCrowdsale = undefined;
  var crowdsale_1 = require_crowdsale();
  Object.defineProperty(exports, "decryptCrowdsale", { enumerable: true, get: function() {
    return crowdsale_1.decrypt;
  } });
  var inspect_1 = require_inspect();
  Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
    return inspect_1.getJsonWalletAddress;
  } });
  Object.defineProperty(exports, "isCrowdsaleWallet", { enumerable: true, get: function() {
    return inspect_1.isCrowdsaleWallet;
  } });
  Object.defineProperty(exports, "isKeystoreWallet", { enumerable: true, get: function() {
    return inspect_1.isKeystoreWallet;
  } });
  var keystore_1 = require_keystore();
  Object.defineProperty(exports, "decryptKeystore", { enumerable: true, get: function() {
    return keystore_1.decrypt;
  } });
  Object.defineProperty(exports, "decryptKeystoreSync", { enumerable: true, get: function() {
    return keystore_1.decryptSync;
  } });
  Object.defineProperty(exports, "encryptKeystore", { enumerable: true, get: function() {
    return keystore_1.encrypt;
  } });
  exports.decryptJsonWallet = decryptJsonWallet;
  exports.decryptJsonWalletSync = decryptJsonWalletSync;
});

// node_modules/@ethersproject/solidity/lib/_version.js
var require__version17 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "solidity/5.7.0";
});

// node_modules/@ethersproject/solidity/lib/index.js
var require_lib23 = __commonJS((exports) => {
  var _pack = function(type, value, isArray) {
    switch (type) {
      case "address":
        if (isArray) {
          return (0, bytes_1.zeroPad)(value, 32);
        }
        return (0, bytes_1.arrayify)(value);
      case "string":
        return (0, strings_1.toUtf8Bytes)(value);
      case "bytes":
        return (0, bytes_1.arrayify)(value);
      case "bool":
        value = value ? "0x01" : "0x00";
        if (isArray) {
          return (0, bytes_1.zeroPad)(value, 32);
        }
        return (0, bytes_1.arrayify)(value);
    }
    var match = type.match(regexNumber);
    if (match) {
      var size = parseInt(match[2] || "256");
      if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
        logger.throwArgumentError("invalid number type", "type", type);
      }
      if (isArray) {
        size = 256;
      }
      value = bignumber_1.BigNumber.from(value).toTwos(size);
      return (0, bytes_1.zeroPad)(value, size / 8);
    }
    match = type.match(regexBytes);
    if (match) {
      var size = parseInt(match[1]);
      if (String(size) !== match[1] || size === 0 || size > 32) {
        logger.throwArgumentError("invalid bytes type", "type", type);
      }
      if ((0, bytes_1.arrayify)(value).byteLength !== size) {
        logger.throwArgumentError("invalid value for " + type, "value", value);
      }
      if (isArray) {
        return (0, bytes_1.arrayify)((value + Zeros).substring(0, 66));
      }
      return value;
    }
    match = type.match(regexArray);
    if (match && Array.isArray(value)) {
      var baseType_1 = match[1];
      var count = parseInt(match[2] || String(value.length));
      if (count != value.length) {
        logger.throwArgumentError("invalid array length for " + type, "value", value);
      }
      var result_1 = [];
      value.forEach(function(value2) {
        result_1.push(_pack(baseType_1, value2, true));
      });
      return (0, bytes_1.concat)(result_1);
    }
    return logger.throwArgumentError("invalid type", "type", type);
  };
  var pack = function(types, values) {
    if (types.length != values.length) {
      logger.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
    }
    var tight = [];
    types.forEach(function(type, index) {
      tight.push(_pack(type, values[index]));
    });
    return (0, bytes_1.hexlify)((0, bytes_1.concat)(tight));
  };
  var keccak256 = function(types, values) {
    return (0, keccak256_1.keccak256)(pack(types, values));
  };
  var sha256 = function(types, values) {
    return (0, sha2_1.sha256)(pack(types, values));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha256 = exports.keccak256 = exports.pack = undefined;
  var bignumber_1 = require_lib3();
  var bytes_1 = require_lib2();
  var keccak256_1 = require_lib5();
  var sha2_1 = require_lib15();
  var strings_1 = require_lib9();
  var regexBytes = new RegExp("^bytes([0-9]+)$");
  var regexNumber = new RegExp("^(u?int)([0-9]*)$");
  var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
  var Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
  var logger_1 = require_lib();
  var _version_1 = require__version17();
  var logger = new logger_1.Logger(_version_1.version);
  exports.pack = pack;
  exports.keccak256 = keccak256;
  exports.sha256 = sha256;
});

// node_modules/@ethersproject/units/lib/_version.js
var require__version18 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "units/5.7.0";
});

// node_modules/@ethersproject/units/lib/index.js
var require_lib24 = __commonJS((exports) => {
  var commify = function(value) {
    var comps = String(value).split(".");
    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
      logger.throwArgumentError("invalid value", "value", value);
    }
    var whole = comps[0];
    var negative = "";
    if (whole.substring(0, 1) === "-") {
      negative = "-";
      whole = whole.substring(1);
    }
    while (whole.substring(0, 1) === "0") {
      whole = whole.substring(1);
    }
    if (whole === "") {
      whole = "0";
    }
    var suffix = "";
    if (comps.length === 2) {
      suffix = "." + (comps[1] || "0");
    }
    while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
      suffix = suffix.substring(0, suffix.length - 1);
    }
    var formatted = [];
    while (whole.length) {
      if (whole.length <= 3) {
        formatted.unshift(whole);
        break;
      } else {
        var index = whole.length - 3;
        formatted.unshift(whole.substring(index));
        whole = whole.substring(0, index);
      }
    }
    return negative + formatted.join(",") + suffix;
  };
  var formatUnits = function(value, unitName) {
    if (typeof unitName === "string") {
      var index = names.indexOf(unitName);
      if (index !== -1) {
        unitName = 3 * index;
      }
    }
    return (0, bignumber_1.formatFixed)(value, unitName != null ? unitName : 18);
  };
  var parseUnits = function(value, unitName) {
    if (typeof value !== "string") {
      logger.throwArgumentError("value must be a string", "value", value);
    }
    if (typeof unitName === "string") {
      var index = names.indexOf(unitName);
      if (index !== -1) {
        unitName = 3 * index;
      }
    }
    return (0, bignumber_1.parseFixed)(value, unitName != null ? unitName : 18);
  };
  var formatEther = function(wei) {
    return formatUnits(wei, 18);
  };
  var parseEther = function(ether) {
    return parseUnits(ether, 18);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseEther = exports.formatEther = exports.parseUnits = exports.formatUnits = exports.commify = undefined;
  var bignumber_1 = require_lib3();
  var logger_1 = require_lib();
  var _version_1 = require__version18();
  var logger = new logger_1.Logger(_version_1.version);
  var names = [
    "wei",
    "kwei",
    "mwei",
    "gwei",
    "szabo",
    "finney",
    "ether"
  ];
  exports.commify = commify;
  exports.formatUnits = formatUnits;
  exports.parseUnits = parseUnits;
  exports.formatEther = formatEther;
  exports.parseEther = parseEther;
});

// node_modules/@ethersproject/abstract-provider/lib/_version.js
var require__version19 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "abstract-provider/5.7.0";
});

// node_modules/@ethersproject/abstract-provider/lib/index.js
var require_lib25 = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
        d2.__proto__ = b4;
      } || function(d2, b4) {
        for (var p in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p))
            d2[p] = b4[p];
      };
      return extendStatics(d, b3);
    };
    return function(d, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d, b3);
      function __() {
        this.constructor = d;
      }
      d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __);
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _4 = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v2) {
        return step([n, v2]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_4)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _4.label++;
              return { value: op[1], done: false };
            case 5:
              _4.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _4.ops.pop();
              _4.trys.pop();
              continue;
            default:
              if (!(t = _4.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _4 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _4.label = op[1];
                break;
              }
              if (op[0] === 6 && _4.label < t[1]) {
                _4.label = t[1];
                t = op;
                break;
              }
              if (t && _4.label < t[2]) {
                _4.label = t[2];
                _4.ops.push(op);
                break;
              }
              if (t[2])
                _4.ops.pop();
              _4.trys.pop();
              continue;
          }
          op = body.call(thisArg, _4);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Provider = exports.TransactionOrderForkEvent = exports.TransactionForkEvent = exports.BlockForkEvent = exports.ForkEvent = undefined;
  var bignumber_1 = require_lib3();
  var bytes_1 = require_lib2();
  var properties_1 = require_lib4();
  var logger_1 = require_lib();
  var _version_1 = require__version19();
  var logger = new logger_1.Logger(_version_1.version);
  var ForkEvent = function(_super) {
    __extends(ForkEvent2, _super);
    function ForkEvent2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ForkEvent2.isForkEvent = function(value) {
      return !!(value && value._isForkEvent);
    };
    return ForkEvent2;
  }(properties_1.Description);
  exports.ForkEvent = ForkEvent;
  var BlockForkEvent = function(_super) {
    __extends(BlockForkEvent2, _super);
    function BlockForkEvent2(blockHash, expiry) {
      var _this = this;
      if (!(0, bytes_1.isHexString)(blockHash, 32)) {
        logger.throwArgumentError("invalid blockHash", "blockHash", blockHash);
      }
      _this = _super.call(this, {
        _isForkEvent: true,
        _isBlockForkEvent: true,
        expiry: expiry || 0,
        blockHash
      }) || this;
      return _this;
    }
    return BlockForkEvent2;
  }(ForkEvent);
  exports.BlockForkEvent = BlockForkEvent;
  var TransactionForkEvent = function(_super) {
    __extends(TransactionForkEvent2, _super);
    function TransactionForkEvent2(hash, expiry) {
      var _this = this;
      if (!(0, bytes_1.isHexString)(hash, 32)) {
        logger.throwArgumentError("invalid transaction hash", "hash", hash);
      }
      _this = _super.call(this, {
        _isForkEvent: true,
        _isTransactionForkEvent: true,
        expiry: expiry || 0,
        hash
      }) || this;
      return _this;
    }
    return TransactionForkEvent2;
  }(ForkEvent);
  exports.TransactionForkEvent = TransactionForkEvent;
  var TransactionOrderForkEvent = function(_super) {
    __extends(TransactionOrderForkEvent2, _super);
    function TransactionOrderForkEvent2(beforeHash, afterHash, expiry) {
      var _this = this;
      if (!(0, bytes_1.isHexString)(beforeHash, 32)) {
        logger.throwArgumentError("invalid transaction hash", "beforeHash", beforeHash);
      }
      if (!(0, bytes_1.isHexString)(afterHash, 32)) {
        logger.throwArgumentError("invalid transaction hash", "afterHash", afterHash);
      }
      _this = _super.call(this, {
        _isForkEvent: true,
        _isTransactionOrderForkEvent: true,
        expiry: expiry || 0,
        beforeHash,
        afterHash
      }) || this;
      return _this;
    }
    return TransactionOrderForkEvent2;
  }(ForkEvent);
  exports.TransactionOrderForkEvent = TransactionOrderForkEvent;
  var Provider = function() {
    function Provider2() {
      var _newTarget = this.constructor;
      logger.checkAbstract(_newTarget, Provider2);
      (0, properties_1.defineReadOnly)(this, "_isProvider", true);
    }
    Provider2.prototype.getFeeData = function() {
      return __awaiter(this, undefined, undefined, function() {
        var _a, block, gasPrice, lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, (0, properties_1.resolveProperties)({
                block: this.getBlock("latest"),
                gasPrice: this.getGasPrice().catch(function(error) {
                  return null;
                })
              })];
            case 1:
              _a = _b.sent(), block = _a.block, gasPrice = _a.gasPrice;
              lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
              if (block && block.baseFeePerGas) {
                lastBaseFeePerGas = block.baseFeePerGas;
                maxPriorityFeePerGas = bignumber_1.BigNumber.from("1500000000");
                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
              }
              return [2, { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice }];
          }
        });
      });
    };
    Provider2.prototype.addListener = function(eventName, listener) {
      return this.on(eventName, listener);
    };
    Provider2.prototype.removeListener = function(eventName, listener) {
      return this.off(eventName, listener);
    };
    Provider2.isProvider = function(value) {
      return !!(value && value._isProvider);
    };
    return Provider2;
  }();
  exports.Provider = Provider;
});

// node_modules/@ethersproject/abstract-signer/lib/_version.js
var require__version20 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "abstract-signer/5.7.0";
});

// node_modules/@ethersproject/abstract-signer/lib/index.js
var require_lib26 = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
        d2.__proto__ = b4;
      } || function(d2, b4) {
        for (var p in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p))
            d2[p] = b4[p];
      };
      return extendStatics(d, b3);
    };
    return function(d, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d, b3);
      function __() {
        this.constructor = d;
      }
      d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __);
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _4 = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v2) {
        return step([n, v2]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_4)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _4.label++;
              return { value: op[1], done: false };
            case 5:
              _4.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _4.ops.pop();
              _4.trys.pop();
              continue;
            default:
              if (!(t = _4.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _4 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _4.label = op[1];
                break;
              }
              if (op[0] === 6 && _4.label < t[1]) {
                _4.label = t[1];
                t = op;
                break;
              }
              if (t && _4.label < t[2]) {
                _4.label = t[2];
                _4.ops.push(op);
                break;
              }
              if (t[2])
                _4.ops.pop();
              _4.trys.pop();
              continue;
          }
          op = body.call(thisArg, _4);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VoidSigner = exports.Signer = undefined;
  var properties_1 = require_lib4();
  var logger_1 = require_lib();
  var _version_1 = require__version20();
  var logger = new logger_1.Logger(_version_1.version);
  var allowedTransactionKeys = [
    "accessList",
    "ccipReadEnabled",
    "chainId",
    "customData",
    "data",
    "from",
    "gasLimit",
    "gasPrice",
    "maxFeePerGas",
    "maxPriorityFeePerGas",
    "nonce",
    "to",
    "type",
    "value"
  ];
  var forwardErrors = [
    logger_1.Logger.errors.INSUFFICIENT_FUNDS,
    logger_1.Logger.errors.NONCE_EXPIRED,
    logger_1.Logger.errors.REPLACEMENT_UNDERPRICED
  ];
  var Signer = function() {
    function Signer2() {
      var _newTarget = this.constructor;
      logger.checkAbstract(_newTarget, Signer2);
      (0, properties_1.defineReadOnly)(this, "_isSigner", true);
    }
    Signer2.prototype.getBalance = function(blockTag) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              this._checkProvider("getBalance");
              return [4, this.provider.getBalance(this.getAddress(), blockTag)];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    };
    Signer2.prototype.getTransactionCount = function(blockTag) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              this._checkProvider("getTransactionCount");
              return [4, this.provider.getTransactionCount(this.getAddress(), blockTag)];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    };
    Signer2.prototype.estimateGas = function(transaction) {
      return __awaiter(this, undefined, undefined, function() {
        var tx;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              this._checkProvider("estimateGas");
              return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
            case 1:
              tx = _a.sent();
              return [4, this.provider.estimateGas(tx)];
            case 2:
              return [2, _a.sent()];
          }
        });
      });
    };
    Signer2.prototype.call = function(transaction, blockTag) {
      return __awaiter(this, undefined, undefined, function() {
        var tx;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              this._checkProvider("call");
              return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
            case 1:
              tx = _a.sent();
              return [4, this.provider.call(tx, blockTag)];
            case 2:
              return [2, _a.sent()];
          }
        });
      });
    };
    Signer2.prototype.sendTransaction = function(transaction) {
      return __awaiter(this, undefined, undefined, function() {
        var tx, signedTx;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              this._checkProvider("sendTransaction");
              return [4, this.populateTransaction(transaction)];
            case 1:
              tx = _a.sent();
              return [4, this.signTransaction(tx)];
            case 2:
              signedTx = _a.sent();
              return [4, this.provider.sendTransaction(signedTx)];
            case 3:
              return [2, _a.sent()];
          }
        });
      });
    };
    Signer2.prototype.getChainId = function() {
      return __awaiter(this, undefined, undefined, function() {
        var network;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              this._checkProvider("getChainId");
              return [4, this.provider.getNetwork()];
            case 1:
              network = _a.sent();
              return [2, network.chainId];
          }
        });
      });
    };
    Signer2.prototype.getGasPrice = function() {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              this._checkProvider("getGasPrice");
              return [4, this.provider.getGasPrice()];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    };
    Signer2.prototype.getFeeData = function() {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              this._checkProvider("getFeeData");
              return [4, this.provider.getFeeData()];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    };
    Signer2.prototype.resolveName = function(name) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              this._checkProvider("resolveName");
              return [4, this.provider.resolveName(name)];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    };
    Signer2.prototype.checkTransaction = function(transaction) {
      for (var key in transaction) {
        if (allowedTransactionKeys.indexOf(key) === -1) {
          logger.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
        }
      }
      var tx = (0, properties_1.shallowCopy)(transaction);
      if (tx.from == null) {
        tx.from = this.getAddress();
      } else {
        tx.from = Promise.all([
          Promise.resolve(tx.from),
          this.getAddress()
        ]).then(function(result) {
          if (result[0].toLowerCase() !== result[1].toLowerCase()) {
            logger.throwArgumentError("from address mismatch", "transaction", transaction);
          }
          return result[0];
        });
      }
      return tx;
    };
    Signer2.prototype.populateTransaction = function(transaction) {
      return __awaiter(this, undefined, undefined, function() {
        var tx, hasEip1559, feeData, gasPrice;
        var _this = this;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
            case 1:
              tx = _a.sent();
              if (tx.to != null) {
                tx.to = Promise.resolve(tx.to).then(function(to) {
                  return __awaiter(_this, undefined, undefined, function() {
                    var address;
                    return __generator(this, function(_a2) {
                      switch (_a2.label) {
                        case 0:
                          if (to == null) {
                            return [2, null];
                          }
                          return [4, this.resolveName(to)];
                        case 1:
                          address = _a2.sent();
                          if (address == null) {
                            logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                          }
                          return [2, address];
                      }
                    });
                  });
                });
                tx.to.catch(function(error) {
                });
              }
              hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
              if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
                logger.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
              } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
                logger.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
              }
              if (!((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)))
                return [3, 2];
              tx.type = 2;
              return [3, 5];
            case 2:
              if (!(tx.type === 0 || tx.type === 1))
                return [3, 3];
              if (tx.gasPrice == null) {
                tx.gasPrice = this.getGasPrice();
              }
              return [3, 5];
            case 3:
              return [4, this.getFeeData()];
            case 4:
              feeData = _a.sent();
              if (tx.type == null) {
                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                  tx.type = 2;
                  if (tx.gasPrice != null) {
                    gasPrice = tx.gasPrice;
                    delete tx.gasPrice;
                    tx.maxFeePerGas = gasPrice;
                    tx.maxPriorityFeePerGas = gasPrice;
                  } else {
                    if (tx.maxFeePerGas == null) {
                      tx.maxFeePerGas = feeData.maxFeePerGas;
                    }
                    if (tx.maxPriorityFeePerGas == null) {
                      tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                    }
                  }
                } else if (feeData.gasPrice != null) {
                  if (hasEip1559) {
                    logger.throwError("network does not support EIP-1559", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                      operation: "populateTransaction"
                    });
                  }
                  if (tx.gasPrice == null) {
                    tx.gasPrice = feeData.gasPrice;
                  }
                  tx.type = 0;
                } else {
                  logger.throwError("failed to get consistent fee data", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "signer.getFeeData"
                  });
                }
              } else if (tx.type === 2) {
                if (tx.maxFeePerGas == null) {
                  tx.maxFeePerGas = feeData.maxFeePerGas;
                }
                if (tx.maxPriorityFeePerGas == null) {
                  tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                }
              }
              _a.label = 5;
            case 5:
              if (tx.nonce == null) {
                tx.nonce = this.getTransactionCount("pending");
              }
              if (tx.gasLimit == null) {
                tx.gasLimit = this.estimateGas(tx).catch(function(error) {
                  if (forwardErrors.indexOf(error.code) >= 0) {
                    throw error;
                  }
                  return logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                    error,
                    tx
                  });
                });
              }
              if (tx.chainId == null) {
                tx.chainId = this.getChainId();
              } else {
                tx.chainId = Promise.all([
                  Promise.resolve(tx.chainId),
                  this.getChainId()
                ]).then(function(results) {
                  if (results[1] !== 0 && results[0] !== results[1]) {
                    logger.throwArgumentError("chainId address mismatch", "transaction", transaction);
                  }
                  return results[0];
                });
              }
              return [4, (0, properties_1.resolveProperties)(tx)];
            case 6:
              return [2, _a.sent()];
          }
        });
      });
    };
    Signer2.prototype._checkProvider = function(operation) {
      if (!this.provider) {
        logger.throwError("missing provider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: operation || "_checkProvider"
        });
      }
    };
    Signer2.isSigner = function(value) {
      return !!(value && value._isSigner);
    };
    return Signer2;
  }();
  exports.Signer = Signer;
  var VoidSigner = function(_super) {
    __extends(VoidSigner2, _super);
    function VoidSigner2(address, provider) {
      var _this = _super.call(this) || this;
      (0, properties_1.defineReadOnly)(_this, "address", address);
      (0, properties_1.defineReadOnly)(_this, "provider", provider || null);
      return _this;
    }
    VoidSigner2.prototype.getAddress = function() {
      return Promise.resolve(this.address);
    };
    VoidSigner2.prototype._fail = function(message, operation) {
      return Promise.resolve().then(function() {
        logger.throwError(message, logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation });
      });
    };
    VoidSigner2.prototype.signMessage = function(message) {
      return this._fail("VoidSigner cannot sign messages", "signMessage");
    };
    VoidSigner2.prototype.signTransaction = function(transaction) {
      return this._fail("VoidSigner cannot sign transactions", "signTransaction");
    };
    VoidSigner2.prototype._signTypedData = function(domain, types, value) {
      return this._fail("VoidSigner cannot sign typed data", "signTypedData");
    };
    VoidSigner2.prototype.connect = function(provider) {
      return new VoidSigner2(this.address, provider);
    };
    return VoidSigner2;
  }(Signer);
  exports.VoidSigner = VoidSigner;
});

// node_modules/@ethersproject/wallet/lib/_version.js
var require__version21 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "wallet/5.7.0";
});

// node_modules/@ethersproject/wallet/lib/index.js
var require_lib27 = __commonJS((exports) => {
  var isAccount = function(value) {
    return value != null && (0, bytes_1.isHexString)(value.privateKey, 32) && value.address != null;
  };
  var hasMnemonic = function(value) {
    var mnemonic = value.mnemonic;
    return mnemonic && mnemonic.phrase;
  };
  var verifyMessage = function(message, signature) {
    return (0, transactions_1.recoverAddress)((0, hash_1.hashMessage)(message), signature);
  };
  var verifyTypedData = function(domain, types, value, signature) {
    return (0, transactions_1.recoverAddress)(hash_1._TypedDataEncoder.hash(domain, types, value), signature);
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b3) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
        d2.__proto__ = b4;
      } || function(d2, b4) {
        for (var p in b4)
          if (Object.prototype.hasOwnProperty.call(b4, p))
            d2[p] = b4[p];
      };
      return extendStatics(d, b3);
    };
    return function(d, b3) {
      if (typeof b3 !== "function" && b3 !== null)
        throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
      extendStatics(d, b3);
      function __() {
        this.constructor = d;
      }
      d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __);
    };
  }();
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _4 = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v2) {
        return step([n, v2]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_4)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _4.label++;
              return { value: op[1], done: false };
            case 5:
              _4.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _4.ops.pop();
              _4.trys.pop();
              continue;
            default:
              if (!(t = _4.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _4 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _4.label = op[1];
                break;
              }
              if (op[0] === 6 && _4.label < t[1]) {
                _4.label = t[1];
                t = op;
                break;
              }
              if (t && _4.label < t[2]) {
                _4.label = t[2];
                _4.ops.push(op);
                break;
              }
              if (t[2])
                _4.ops.pop();
              _4.trys.pop();
              continue;
          }
          op = body.call(thisArg, _4);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.verifyTypedData = exports.verifyMessage = exports.Wallet = undefined;
  var address_1 = require_lib7();
  var abstract_provider_1 = require_lib25();
  var abstract_signer_1 = require_lib26();
  var bytes_1 = require_lib2();
  var hash_1 = require_lib12();
  var hdnode_1 = require_lib20();
  var keccak256_1 = require_lib5();
  var properties_1 = require_lib4();
  var random_1 = require_lib21();
  var signing_key_1 = require_lib17();
  var json_wallets_1 = require_lib22();
  var transactions_1 = require_lib18();
  var logger_1 = require_lib();
  var _version_1 = require__version21();
  var logger = new logger_1.Logger(_version_1.version);
  var Wallet = function(_super) {
    __extends(Wallet2, _super);
    function Wallet2(privateKey, provider) {
      var _this = _super.call(this) || this;
      if (isAccount(privateKey)) {
        var signingKey_1 = new signing_key_1.SigningKey(privateKey.privateKey);
        (0, properties_1.defineReadOnly)(_this, "_signingKey", function() {
          return signingKey_1;
        });
        (0, properties_1.defineReadOnly)(_this, "address", (0, transactions_1.computeAddress)(_this.publicKey));
        if (_this.address !== (0, address_1.getAddress)(privateKey.address)) {
          logger.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
        }
        if (hasMnemonic(privateKey)) {
          var srcMnemonic_1 = privateKey.mnemonic;
          (0, properties_1.defineReadOnly)(_this, "_mnemonic", function() {
            return {
              phrase: srcMnemonic_1.phrase,
              path: srcMnemonic_1.path || hdnode_1.defaultPath,
              locale: srcMnemonic_1.locale || "en"
            };
          });
          var mnemonic = _this.mnemonic;
          var node = hdnode_1.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
          if ((0, transactions_1.computeAddress)(node.privateKey) !== _this.address) {
            logger.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
          }
        } else {
          (0, properties_1.defineReadOnly)(_this, "_mnemonic", function() {
            return null;
          });
        }
      } else {
        if (signing_key_1.SigningKey.isSigningKey(privateKey)) {
          if (privateKey.curve !== "secp256k1") {
            logger.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
          }
          (0, properties_1.defineReadOnly)(_this, "_signingKey", function() {
            return privateKey;
          });
        } else {
          if (typeof privateKey === "string") {
            if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
              privateKey = "0x" + privateKey;
            }
          }
          var signingKey_2 = new signing_key_1.SigningKey(privateKey);
          (0, properties_1.defineReadOnly)(_this, "_signingKey", function() {
            return signingKey_2;
          });
        }
        (0, properties_1.defineReadOnly)(_this, "_mnemonic", function() {
          return null;
        });
        (0, properties_1.defineReadOnly)(_this, "address", (0, transactions_1.computeAddress)(_this.publicKey));
      }
      if (provider && !abstract_provider_1.Provider.isProvider(provider)) {
        logger.throwArgumentError("invalid provider", "provider", provider);
      }
      (0, properties_1.defineReadOnly)(_this, "provider", provider || null);
      return _this;
    }
    Object.defineProperty(Wallet2.prototype, "mnemonic", {
      get: function() {
        return this._mnemonic();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Wallet2.prototype, "privateKey", {
      get: function() {
        return this._signingKey().privateKey;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Wallet2.prototype, "publicKey", {
      get: function() {
        return this._signingKey().publicKey;
      },
      enumerable: false,
      configurable: true
    });
    Wallet2.prototype.getAddress = function() {
      return Promise.resolve(this.address);
    };
    Wallet2.prototype.connect = function(provider) {
      return new Wallet2(this, provider);
    };
    Wallet2.prototype.signTransaction = function(transaction) {
      var _this = this;
      return (0, properties_1.resolveProperties)(transaction).then(function(tx) {
        if (tx.from != null) {
          if ((0, address_1.getAddress)(tx.from) !== _this.address) {
            logger.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
          }
          delete tx.from;
        }
        var signature = _this._signingKey().signDigest((0, keccak256_1.keccak256)((0, transactions_1.serialize)(tx)));
        return (0, transactions_1.serialize)(tx, signature);
      });
    };
    Wallet2.prototype.signMessage = function(message) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a) {
          return [2, (0, bytes_1.joinSignature)(this._signingKey().signDigest((0, hash_1.hashMessage)(message)))];
        });
      });
    };
    Wallet2.prototype._signTypedData = function(domain, types, value) {
      return __awaiter(this, undefined, undefined, function() {
        var populated;
        var _this = this;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, hash_1._TypedDataEncoder.resolveNames(domain, types, value, function(name) {
                if (_this.provider == null) {
                  logger.throwError("cannot resolve ENS names without a provider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "resolveName",
                    value: name
                  });
                }
                return _this.provider.resolveName(name);
              })];
            case 1:
              populated = _a.sent();
              return [2, (0, bytes_1.joinSignature)(this._signingKey().signDigest(hash_1._TypedDataEncoder.hash(populated.domain, types, populated.value)))];
          }
        });
      });
    };
    Wallet2.prototype.encrypt = function(password, options, progressCallback) {
      if (typeof options === "function" && !progressCallback) {
        progressCallback = options;
        options = {};
      }
      if (progressCallback && typeof progressCallback !== "function") {
        throw new Error("invalid callback");
      }
      if (!options) {
        options = {};
      }
      return (0, json_wallets_1.encryptKeystore)(this, password, options, progressCallback);
    };
    Wallet2.createRandom = function(options) {
      var entropy = (0, random_1.randomBytes)(16);
      if (!options) {
        options = {};
      }
      if (options.extraEntropy) {
        entropy = (0, bytes_1.arrayify)((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)([entropy, options.extraEntropy])), 0, 16));
      }
      var mnemonic = (0, hdnode_1.entropyToMnemonic)(entropy, options.locale);
      return Wallet2.fromMnemonic(mnemonic, options.path, options.locale);
    };
    Wallet2.fromEncryptedJson = function(json, password, progressCallback) {
      return (0, json_wallets_1.decryptJsonWallet)(json, password, progressCallback).then(function(account) {
        return new Wallet2(account);
      });
    };
    Wallet2.fromEncryptedJsonSync = function(json, password) {
      return new Wallet2((0, json_wallets_1.decryptJsonWalletSync)(json, password));
    };
    Wallet2.fromMnemonic = function(mnemonic, path, wordlist) {
      if (!path) {
        path = hdnode_1.defaultPath;
      }
      return new Wallet2(hdnode_1.HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));
    };
    return Wallet2;
  }(abstract_signer_1.Signer);
  exports.Wallet = Wallet;
  exports.verifyMessage = verifyMessage;
  exports.verifyTypedData = verifyTypedData;
});

// node_modules/@ethersproject/web/lib/_version.js
var require__version22 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  exports.version = "web/5.7.1";
});

// node_modules/@ethersproject/web/lib/browser-geturl.js
var require_browser_geturl = __commonJS((exports) => {
  var getUrl = function(href, options) {
    return __awaiter(this, undefined, undefined, function() {
      var request, opts, response, body, headers;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (options == null) {
              options = {};
            }
            request = {
              method: options.method || "GET",
              headers: options.headers || {},
              body: options.body || undefined
            };
            if (options.skipFetchSetup !== true) {
              request.mode = "cors";
              request.cache = "no-cache";
              request.credentials = "same-origin";
              request.redirect = "follow";
              request.referrer = "client";
            }
            ;
            if (options.fetchOptions != null) {
              opts = options.fetchOptions;
              if (opts.mode) {
                request.mode = opts.mode;
              }
              if (opts.cache) {
                request.cache = opts.cache;
              }
              if (opts.credentials) {
                request.credentials = opts.credentials;
              }
              if (opts.redirect) {
                request.redirect = opts.redirect;
              }
              if (opts.referrer) {
                request.referrer = opts.referrer;
              }
            }
            return [4, fetch(href, request)];
          case 1:
            response = _a.sent();
            return [4, response.arrayBuffer()];
          case 2:
            body = _a.sent();
            headers = {};
            if (response.headers.forEach) {
              response.headers.forEach(function(value, key) {
                headers[key.toLowerCase()] = value;
              });
            } else {
              response.headers.keys().forEach(function(key) {
                headers[key.toLowerCase()] = response.headers.get(key);
              });
            }
            return [2, {
              headers,
              statusCode: response.status,
              statusMessage: response.statusText,
              body: (0, bytes_1.arrayify)(new Uint8Array(body))
            }];
        }
      });
    });
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _4 = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v2) {
        return step([n, v2]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_4)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _4.label++;
              return { value: op[1], done: false };
            case 5:
              _4.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _4.ops.pop();
              _4.trys.pop();
              continue;
            default:
              if (!(t = _4.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _4 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _4.label = op[1];
                break;
              }
              if (op[0] === 6 && _4.label < t[1]) {
                _4.label = t[1];
                t = op;
                break;
              }
              if (t && _4.label < t[2]) {
                _4.label = t[2];
                _4.ops.push(op);
                break;
              }
              if (t[2])
                _4.ops.pop();
              _4.trys.pop();
              continue;
          }
          op = body.call(thisArg, _4);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUrl = undefined;
  var bytes_1 = require_lib2();
  exports.getUrl = getUrl;
});

// node_modules/@ethersproject/web/lib/index.js
var require_lib28 = __commonJS((exports) => {
  var staller = function(duration) {
    return new Promise(function(resolve) {
      setTimeout(resolve, duration);
    });
  };
  var bodyify = function(value, type) {
    if (value == null) {
      return null;
    }
    if (typeof value === "string") {
      return value;
    }
    if ((0, bytes_1.isBytesLike)(value)) {
      if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
        try {
          return (0, strings_1.toUtf8String)(value);
        } catch (error) {
        }
      }
      return (0, bytes_1.hexlify)(value);
    }
    return value;
  };
  var unpercent = function(value) {
    return (0, strings_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, function(all, code) {
      return String.fromCharCode(parseInt(code, 16));
    }));
  };
  var _fetchData = function(connection, body, processFunc) {
    var attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
    logger.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
    var throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
    var throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
    logger.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
    var errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
    var headers = {};
    var url = null;
    var options = {
      method: "GET"
    };
    var allow304 = false;
    var timeout = 2 * 60 * 1000;
    if (typeof connection === "string") {
      url = connection;
    } else if (typeof connection === "object") {
      if (connection == null || connection.url == null) {
        logger.throwArgumentError("missing URL", "connection.url", connection);
      }
      url = connection.url;
      if (typeof connection.timeout === "number" && connection.timeout > 0) {
        timeout = connection.timeout;
      }
      if (connection.headers) {
        for (var key in connection.headers) {
          headers[key.toLowerCase()] = { key, value: String(connection.headers[key]) };
          if (["if-none-match", "if-modified-since"].indexOf(key.toLowerCase()) >= 0) {
            allow304 = true;
          }
        }
      }
      options.allowGzip = !!connection.allowGzip;
      if (connection.user != null && connection.password != null) {
        if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
          logger.throwError("basic authentication requires a secure https url", logger_1.Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
        }
        var authorization = connection.user + ":" + connection.password;
        headers["authorization"] = {
          key: "Authorization",
          value: "Basic " + (0, base64_1.encode)((0, strings_1.toUtf8Bytes)(authorization))
        };
      }
      if (connection.skipFetchSetup != null) {
        options.skipFetchSetup = !!connection.skipFetchSetup;
      }
      if (connection.fetchOptions != null) {
        options.fetchOptions = (0, properties_1.shallowCopy)(connection.fetchOptions);
      }
    }
    var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
    var dataMatch = url ? url.match(reData) : null;
    if (dataMatch) {
      try {
        var response = {
          statusCode: 200,
          statusMessage: "OK",
          headers: { "content-type": dataMatch[1] || "text/plain" },
          body: dataMatch[2] ? (0, base64_1.decode)(dataMatch[3]) : unpercent(dataMatch[3])
        };
        var result = response.body;
        if (processFunc) {
          result = processFunc(response.body, response);
        }
        return Promise.resolve(result);
      } catch (error) {
        logger.throwError("processing response error", logger_1.Logger.errors.SERVER_ERROR, {
          body: bodyify(dataMatch[1], dataMatch[2]),
          error,
          requestBody: null,
          requestMethod: "GET",
          url
        });
      }
    }
    if (body) {
      options.method = "POST";
      options.body = body;
      if (headers["content-type"] == null) {
        headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
      }
      if (headers["content-length"] == null) {
        headers["content-length"] = { key: "Content-Length", value: String(body.length) };
      }
    }
    var flatHeaders = {};
    Object.keys(headers).forEach(function(key2) {
      var header = headers[key2];
      flatHeaders[header.key] = header.value;
    });
    options.headers = flatHeaders;
    var runningTimeout = function() {
      var timer = null;
      var promise = new Promise(function(resolve, reject) {
        if (timeout) {
          timer = setTimeout(function() {
            if (timer == null) {
              return;
            }
            timer = null;
            reject(logger.makeError("timeout", logger_1.Logger.errors.TIMEOUT, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              timeout,
              url
            }));
          }, timeout);
        }
      });
      var cancel = function() {
        if (timer == null) {
          return;
        }
        clearTimeout(timer);
        timer = null;
      };
      return { promise, cancel };
    }();
    var runningFetch = function() {
      return __awaiter(this, undefined, undefined, function() {
        var attempt, response2, location_1, tryAgain, stall, retryAfter, error_1, body_1, result2, error_2, tryAgain, timeout_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              attempt = 0;
              _a.label = 1;
            case 1:
              if (!(attempt < attemptLimit))
                return [3, 20];
              response2 = null;
              _a.label = 2;
            case 2:
              _a.trys.push([2, 9, , 10]);
              return [4, (0, geturl_1.getUrl)(url, options)];
            case 3:
              response2 = _a.sent();
              if (!(attempt < attemptLimit))
                return [3, 8];
              if (!(response2.statusCode === 301 || response2.statusCode === 302))
                return [3, 4];
              location_1 = response2.headers.location || "";
              if (options.method === "GET" && location_1.match(/^https:/)) {
                url = response2.headers.location;
                return [3, 19];
              }
              return [3, 8];
            case 4:
              if (!(response2.statusCode === 429))
                return [3, 8];
              tryAgain = true;
              if (!throttleCallback)
                return [3, 6];
              return [4, throttleCallback(attempt, url)];
            case 5:
              tryAgain = _a.sent();
              _a.label = 6;
            case 6:
              if (!tryAgain)
                return [3, 8];
              stall = 0;
              retryAfter = response2.headers["retry-after"];
              if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                stall = parseInt(retryAfter) * 1000;
              } else {
                stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
              }
              return [4, staller(stall)];
            case 7:
              _a.sent();
              return [3, 19];
            case 8:
              return [3, 10];
            case 9:
              error_1 = _a.sent();
              response2 = error_1.response;
              if (response2 == null) {
                runningTimeout.cancel();
                logger.throwError("missing response", logger_1.Logger.errors.SERVER_ERROR, {
                  requestBody: bodyify(options.body, flatHeaders["content-type"]),
                  requestMethod: options.method,
                  serverError: error_1,
                  url
                });
              }
              return [3, 10];
            case 10:
              body_1 = response2.body;
              if (allow304 && response2.statusCode === 304) {
                body_1 = null;
              } else if (!errorPassThrough && (response2.statusCode < 200 || response2.statusCode >= 300)) {
                runningTimeout.cancel();
                logger.throwError("bad response", logger_1.Logger.errors.SERVER_ERROR, {
                  status: response2.statusCode,
                  headers: response2.headers,
                  body: bodyify(body_1, response2.headers ? response2.headers["content-type"] : null),
                  requestBody: bodyify(options.body, flatHeaders["content-type"]),
                  requestMethod: options.method,
                  url
                });
              }
              if (!processFunc)
                return [3, 18];
              _a.label = 11;
            case 11:
              _a.trys.push([11, 13, , 18]);
              return [4, processFunc(body_1, response2)];
            case 12:
              result2 = _a.sent();
              runningTimeout.cancel();
              return [2, result2];
            case 13:
              error_2 = _a.sent();
              if (!(error_2.throttleRetry && attempt < attemptLimit))
                return [3, 17];
              tryAgain = true;
              if (!throttleCallback)
                return [3, 15];
              return [4, throttleCallback(attempt, url)];
            case 14:
              tryAgain = _a.sent();
              _a.label = 15;
            case 15:
              if (!tryAgain)
                return [3, 17];
              timeout_1 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
              return [4, staller(timeout_1)];
            case 16:
              _a.sent();
              return [3, 19];
            case 17:
              runningTimeout.cancel();
              logger.throwError("processing response error", logger_1.Logger.errors.SERVER_ERROR, {
                body: bodyify(body_1, response2.headers ? response2.headers["content-type"] : null),
                error: error_2,
                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                requestMethod: options.method,
                url
              });
              return [3, 18];
            case 18:
              runningTimeout.cancel();
              return [2, body_1];
            case 19:
              attempt++;
              return [3, 1];
            case 20:
              return [2, logger.throwError("failed response", logger_1.Logger.errors.SERVER_ERROR, {
                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                requestMethod: options.method,
                url
              })];
          }
        });
      });
    }();
    return Promise.race([runningTimeout.promise, runningFetch]);
  };
  var fetchJson = function(connection, json, processFunc) {
    var processJsonFunc = function(value, response) {
      var result = null;
      if (value != null) {
        try {
          result = JSON.parse((0, strings_1.toUtf8String)(value));
        } catch (error) {
          logger.throwError("invalid JSON", logger_1.Logger.errors.SERVER_ERROR, {
            body: value,
            error
          });
        }
      }
      if (processFunc) {
        result = processFunc(result, response);
      }
      return result;
    };
    var body = null;
    if (json != null) {
      body = (0, strings_1.toUtf8Bytes)(json);
      var updated = typeof connection === "string" ? { url: connection } : (0, properties_1.shallowCopy)(connection);
      if (updated.headers) {
        var hasContentType = Object.keys(updated.headers).filter(function(k) {
          return k.toLowerCase() === "content-type";
        }).length !== 0;
        if (!hasContentType) {
          updated.headers = (0, properties_1.shallowCopy)(updated.headers);
          updated.headers["content-type"] = "application/json";
        }
      } else {
        updated.headers = { "content-type": "application/json" };
      }
      connection = updated;
    }
    return _fetchData(connection, body, processJsonFunc);
  };
  var poll = function(func, options) {
    if (!options) {
      options = {};
    }
    options = (0, properties_1.shallowCopy)(options);
    if (options.floor == null) {
      options.floor = 0;
    }
    if (options.ceiling == null) {
      options.ceiling = 1e4;
    }
    if (options.interval == null) {
      options.interval = 250;
    }
    return new Promise(function(resolve, reject) {
      var timer = null;
      var done = false;
      var cancel = function() {
        if (done) {
          return false;
        }
        done = true;
        if (timer) {
          clearTimeout(timer);
        }
        return true;
      };
      if (options.timeout) {
        timer = setTimeout(function() {
          if (cancel()) {
            reject(new Error("timeout"));
          }
        }, options.timeout);
      }
      var retryLimit = options.retryLimit;
      var attempt = 0;
      function check() {
        return func().then(function(result) {
          if (result !== undefined) {
            if (cancel()) {
              resolve(result);
            }
          } else if (options.oncePoll) {
            options.oncePoll.once("poll", check);
          } else if (options.onceBlock) {
            options.onceBlock.once("block", check);
          } else if (!done) {
            attempt++;
            if (attempt > retryLimit) {
              if (cancel()) {
                reject(new Error("retry limit reached"));
              }
              return;
            }
            var timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
            if (timeout < options.floor) {
              timeout = options.floor;
            }
            if (timeout > options.ceiling) {
              timeout = options.ceiling;
            }
            setTimeout(check, timeout);
          }
          return null;
        }, function(error) {
          if (cancel()) {
            reject(error);
          }
        });
      }
      check();
    });
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _4 = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v2) {
        return step([n, v2]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_4)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _4.label++;
              return { value: op[1], done: false };
            case 5:
              _4.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _4.ops.pop();
              _4.trys.pop();
              continue;
            default:
              if (!(t = _4.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _4 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _4.label = op[1];
                break;
              }
              if (op[0] === 6 && _4.label < t[1]) {
                _4.label = t[1];
                t = op;
                break;
              }
              if (t && _4.label < t[2]) {
                _4.label = t[2];
                _4.ops.push(op);
                break;
              }
              if (t[2])
                _4.ops.pop();
              _4.trys.pop();
              continue;
          }
          op = body.call(thisArg, _4);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.poll = exports.fetchJson = exports._fetchData = undefined;
  var base64_1 = require_lib10();
  var bytes_1 = require_lib2();
  var properties_1 = require_lib4();
  var strings_1 = require_lib9();
  var logger_1 = require_lib();
  var _version_1 = require__version22();
  var logger = new logger_1.Logger(_version_1.version);
  var geturl_1 = require_browser_geturl();
  exports._fetchData = _fetchData;
  exports.fetchJson = fetchJson;
  exports.poll = poll;
});

// node_modules/ethers/lib/utils.js
var require_utils5 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
    Object.defineProperty(o, "default", { enumerable: true, value: v2 });
  } : function(o, v2) {
    o["default"] = v2;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = undefined;
  exports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.dnsEncode = exports.parseBytes32String = undefined;
  var abi_1 = require_lib13();
  Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
    return abi_1.AbiCoder;
  } });
  Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
    return abi_1.checkResultErrors;
  } });
  Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
    return abi_1.ConstructorFragment;
  } });
  Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
    return abi_1.defaultAbiCoder;
  } });
  Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
    return abi_1.ErrorFragment;
  } });
  Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
    return abi_1.EventFragment;
  } });
  Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
    return abi_1.FormatTypes;
  } });
  Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
    return abi_1.Fragment;
  } });
  Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
    return abi_1.FunctionFragment;
  } });
  Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
    return abi_1.Indexed;
  } });
  Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
    return abi_1.Interface;
  } });
  Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
    return abi_1.LogDescription;
  } });
  Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
    return abi_1.ParamType;
  } });
  Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
    return abi_1.TransactionDescription;
  } });
  var address_1 = require_lib7();
  Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
    return address_1.getAddress;
  } });
  Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
    return address_1.getCreate2Address;
  } });
  Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
    return address_1.getContractAddress;
  } });
  Object.defineProperty(exports, "getIcapAddress", { enumerable: true, get: function() {
    return address_1.getIcapAddress;
  } });
  Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
    return address_1.isAddress;
  } });
  var base64 = __importStar(require_lib10());
  exports.base64 = base64;
  var basex_1 = require_lib14();
  Object.defineProperty(exports, "base58", { enumerable: true, get: function() {
    return basex_1.Base58;
  } });
  var bytes_1 = require_lib2();
  Object.defineProperty(exports, "arrayify", { enumerable: true, get: function() {
    return bytes_1.arrayify;
  } });
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return bytes_1.concat;
  } });
  Object.defineProperty(exports, "hexConcat", { enumerable: true, get: function() {
    return bytes_1.hexConcat;
  } });
  Object.defineProperty(exports, "hexDataSlice", { enumerable: true, get: function() {
    return bytes_1.hexDataSlice;
  } });
  Object.defineProperty(exports, "hexDataLength", { enumerable: true, get: function() {
    return bytes_1.hexDataLength;
  } });
  Object.defineProperty(exports, "hexlify", { enumerable: true, get: function() {
    return bytes_1.hexlify;
  } });
  Object.defineProperty(exports, "hexStripZeros", { enumerable: true, get: function() {
    return bytes_1.hexStripZeros;
  } });
  Object.defineProperty(exports, "hexValue", { enumerable: true, get: function() {
    return bytes_1.hexValue;
  } });
  Object.defineProperty(exports, "hexZeroPad", { enumerable: true, get: function() {
    return bytes_1.hexZeroPad;
  } });
  Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
    return bytes_1.isBytes;
  } });
  Object.defineProperty(exports, "isBytesLike", { enumerable: true, get: function() {
    return bytes_1.isBytesLike;
  } });
  Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
    return bytes_1.isHexString;
  } });
  Object.defineProperty(exports, "joinSignature", { enumerable: true, get: function() {
    return bytes_1.joinSignature;
  } });
  Object.defineProperty(exports, "zeroPad", { enumerable: true, get: function() {
    return bytes_1.zeroPad;
  } });
  Object.defineProperty(exports, "splitSignature", { enumerable: true, get: function() {
    return bytes_1.splitSignature;
  } });
  Object.defineProperty(exports, "stripZeros", { enumerable: true, get: function() {
    return bytes_1.stripZeros;
  } });
  var hash_1 = require_lib12();
  Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
    return hash_1._TypedDataEncoder;
  } });
  Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
    return hash_1.dnsEncode;
  } });
  Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
    return hash_1.hashMessage;
  } });
  Object.defineProperty(exports, "id", { enumerable: true, get: function() {
    return hash_1.id;
  } });
  Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
    return hash_1.isValidName;
  } });
  Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
    return hash_1.namehash;
  } });
  var hdnode_1 = require_lib20();
  Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
    return hdnode_1.defaultPath;
  } });
  Object.defineProperty(exports, "entropyToMnemonic", { enumerable: true, get: function() {
    return hdnode_1.entropyToMnemonic;
  } });
  Object.defineProperty(exports, "getAccountPath", { enumerable: true, get: function() {
    return hdnode_1.getAccountPath;
  } });
  Object.defineProperty(exports, "HDNode", { enumerable: true, get: function() {
    return hdnode_1.HDNode;
  } });
  Object.defineProperty(exports, "isValidMnemonic", { enumerable: true, get: function() {
    return hdnode_1.isValidMnemonic;
  } });
  Object.defineProperty(exports, "mnemonicToEntropy", { enumerable: true, get: function() {
    return hdnode_1.mnemonicToEntropy;
  } });
  Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
    return hdnode_1.mnemonicToSeed;
  } });
  var json_wallets_1 = require_lib22();
  Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
    return json_wallets_1.getJsonWalletAddress;
  } });
  var keccak256_1 = require_lib5();
  Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
    return keccak256_1.keccak256;
  } });
  var logger_1 = require_lib();
  Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
    return logger_1.Logger;
  } });
  var sha2_1 = require_lib15();
  Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
    return sha2_1.computeHmac;
  } });
  Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
    return sha2_1.ripemd160;
  } });
  Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
    return sha2_1.sha256;
  } });
  Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
    return sha2_1.sha512;
  } });
  var solidity_1 = require_lib23();
  Object.defineProperty(exports, "solidityKeccak256", { enumerable: true, get: function() {
    return solidity_1.keccak256;
  } });
  Object.defineProperty(exports, "solidityPack", { enumerable: true, get: function() {
    return solidity_1.pack;
  } });
  Object.defineProperty(exports, "soliditySha256", { enumerable: true, get: function() {
    return solidity_1.sha256;
  } });
  var random_1 = require_lib21();
  Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
    return random_1.randomBytes;
  } });
  Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
    return random_1.shuffled;
  } });
  var properties_1 = require_lib4();
  Object.defineProperty(exports, "checkProperties", { enumerable: true, get: function() {
    return properties_1.checkProperties;
  } });
  Object.defineProperty(exports, "deepCopy", { enumerable: true, get: function() {
    return properties_1.deepCopy;
  } });
  Object.defineProperty(exports, "defineReadOnly", { enumerable: true, get: function() {
    return properties_1.defineReadOnly;
  } });
  Object.defineProperty(exports, "getStatic", { enumerable: true, get: function() {
    return properties_1.getStatic;
  } });
  Object.defineProperty(exports, "resolveProperties", { enumerable: true, get: function() {
    return properties_1.resolveProperties;
  } });
  Object.defineProperty(exports, "shallowCopy", { enumerable: true, get: function() {
    return properties_1.shallowCopy;
  } });
  var RLP = __importStar(require_lib6());
  exports.RLP = RLP;
  var signing_key_1 = require_lib17();
  Object.defineProperty(exports, "computePublicKey", { enumerable: true, get: function() {
    return signing_key_1.computePublicKey;
  } });
  Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
    return signing_key_1.recoverPublicKey;
  } });
  Object.defineProperty(exports, "SigningKey", { enumerable: true, get: function() {
    return signing_key_1.SigningKey;
  } });
  var strings_1 = require_lib9();
  Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
    return strings_1.formatBytes32String;
  } });
  Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
    return strings_1.nameprep;
  } });
  Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
    return strings_1.parseBytes32String;
  } });
  Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
    return strings_1._toEscapedUtf8String;
  } });
  Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
    return strings_1.toUtf8Bytes;
  } });
  Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
    return strings_1.toUtf8CodePoints;
  } });
  Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
    return strings_1.toUtf8String;
  } });
  Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
    return strings_1.Utf8ErrorFuncs;
  } });
  var transactions_1 = require_lib18();
  Object.defineProperty(exports, "accessListify", { enumerable: true, get: function() {
    return transactions_1.accessListify;
  } });
  Object.defineProperty(exports, "computeAddress", { enumerable: true, get: function() {
    return transactions_1.computeAddress;
  } });
  Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
    return transactions_1.parse;
  } });
  Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
    return transactions_1.recoverAddress;
  } });
  Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
    return transactions_1.serialize;
  } });
  Object.defineProperty(exports, "TransactionTypes", { enumerable: true, get: function() {
    return transactions_1.TransactionTypes;
  } });
  var units_1 = require_lib24();
  Object.defineProperty(exports, "commify", { enumerable: true, get: function() {
    return units_1.commify;
  } });
  Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
    return units_1.formatEther;
  } });
  Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
    return units_1.parseEther;
  } });
  Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
    return units_1.formatUnits;
  } });
  Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
    return units_1.parseUnits;
  } });
  var wallet_1 = require_lib27();
  Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
    return wallet_1.verifyMessage;
  } });
  Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
    return wallet_1.verifyTypedData;
  } });
  var web_1 = require_lib28();
  Object.defineProperty(exports, "_fetchData", { enumerable: true, get: function() {
    return web_1._fetchData;
  } });
  Object.defineProperty(exports, "fetchJson", { enumerable: true, get: function() {
    return web_1.fetchJson;
  } });
  Object.defineProperty(exports, "poll", { enumerable: true, get: function() {
    return web_1.poll;
  } });
  var sha2_2 = require_lib15();
  Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
    return sha2_2.SupportedAlgorithm;
  } });
  var strings_2 = require_lib9();
  Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
    return strings_2.UnicodeNormalizationForm;
  } });
  Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
    return strings_2.Utf8ErrorReason;
  } });
});

// node_modules/bech32/index.js
var require_bech32 = __commonJS((exports, module) => {
  var polymodStep = function(pre) {
    var b3 = pre >> 25;
    return (pre & 33554431) << 5 ^ -(b3 >> 0 & 1) & 996825010 ^ -(b3 >> 1 & 1) & 642813549 ^ -(b3 >> 2 & 1) & 513874426 ^ -(b3 >> 3 & 1) & 1027748829 ^ -(b3 >> 4 & 1) & 705979059;
  };
  var prefixChk = function(prefix) {
    var chk = 1;
    for (var i = 0;i < prefix.length; ++i) {
      var c = prefix.charCodeAt(i);
      if (c < 33 || c > 126)
        return "Invalid prefix (" + prefix + ")";
      chk = polymodStep(chk) ^ c >> 5;
    }
    chk = polymodStep(chk);
    for (i = 0;i < prefix.length; ++i) {
      var v2 = prefix.charCodeAt(i);
      chk = polymodStep(chk) ^ v2 & 31;
    }
    return chk;
  };
  var encode = function(prefix, words, LIMIT) {
    LIMIT = LIMIT || 90;
    if (prefix.length + 7 + words.length > LIMIT)
      throw new TypeError("Exceeds length limit");
    prefix = prefix.toLowerCase();
    var chk = prefixChk(prefix);
    if (typeof chk === "string")
      throw new Error(chk);
    var result = prefix + "1";
    for (var i = 0;i < words.length; ++i) {
      var x2 = words[i];
      if (x2 >> 5 !== 0)
        throw new Error("Non 5-bit word");
      chk = polymodStep(chk) ^ x2;
      result += ALPHABET.charAt(x2);
    }
    for (i = 0;i < 6; ++i) {
      chk = polymodStep(chk);
    }
    chk ^= 1;
    for (i = 0;i < 6; ++i) {
      var v2 = chk >> (5 - i) * 5 & 31;
      result += ALPHABET.charAt(v2);
    }
    return result;
  };
  var __decode = function(str, LIMIT) {
    LIMIT = LIMIT || 90;
    if (str.length < 8)
      return str + " too short";
    if (str.length > LIMIT)
      return "Exceeds length limit";
    var lowered = str.toLowerCase();
    var uppered = str.toUpperCase();
    if (str !== lowered && str !== uppered)
      return "Mixed-case string " + str;
    str = lowered;
    var split = str.lastIndexOf("1");
    if (split === -1)
      return "No separator character for " + str;
    if (split === 0)
      return "Missing prefix for " + str;
    var prefix = str.slice(0, split);
    var wordChars = str.slice(split + 1);
    if (wordChars.length < 6)
      return "Data too short";
    var chk = prefixChk(prefix);
    if (typeof chk === "string")
      return chk;
    var words = [];
    for (var i = 0;i < wordChars.length; ++i) {
      var c = wordChars.charAt(i);
      var v2 = ALPHABET_MAP[c];
      if (v2 === undefined)
        return "Unknown character " + c;
      chk = polymodStep(chk) ^ v2;
      if (i + 6 >= wordChars.length)
        continue;
      words.push(v2);
    }
    if (chk !== 1)
      return "Invalid checksum for " + str;
    return { prefix, words };
  };
  var decodeUnsafe = function() {
    var res = __decode.apply(null, arguments);
    if (typeof res === "object")
      return res;
  };
  var decode = function(str) {
    var res = __decode.apply(null, arguments);
    if (typeof res === "object")
      return res;
    throw new Error(res);
  };
  var convert = function(data, inBits, outBits, pad) {
    var value = 0;
    var bits = 0;
    var maxV = (1 << outBits) - 1;
    var result = [];
    for (var i = 0;i < data.length; ++i) {
      value = value << inBits | data[i];
      bits += inBits;
      while (bits >= outBits) {
        bits -= outBits;
        result.push(value >> bits & maxV);
      }
    }
    if (pad) {
      if (bits > 0) {
        result.push(value << outBits - bits & maxV);
      }
    } else {
      if (bits >= inBits)
        return "Excess padding";
      if (value << outBits - bits & maxV)
        return "Non-zero padding";
    }
    return result;
  };
  var toWordsUnsafe = function(bytes4) {
    var res = convert(bytes4, 8, 5, true);
    if (Array.isArray(res))
      return res;
  };
  var toWords = function(bytes4) {
    var res = convert(bytes4, 8, 5, true);
    if (Array.isArray(res))
      return res;
    throw new Error(res);
  };
  var fromWordsUnsafe = function(words) {
    var res = convert(words, 5, 8, false);
    if (Array.isArray(res))
      return res;
  };
  var fromWords = function(words) {
    var res = convert(words, 5, 8, false);
    if (Array.isArray(res))
      return res;
    throw new Error(res);
  };
  var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
  var ALPHABET_MAP = {};
  for (z2 = 0;z2 < ALPHABET.length; z2++) {
    x = ALPHABET.charAt(z2);
    if (ALPHABET_MAP[x] !== undefined)
      throw new TypeError(x + " is ambiguous");
    ALPHABET_MAP[x] = z2;
  }
  var x;
  var z2;
  module.exports = {
    decodeUnsafe,
    decode,
    encode,
    toWordsUnsafe,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
});

// node_modules/@bgd-labs/aave-address-book/dist/AaveV3Sepolia.mjs
var exports_AaveV3Sepolia = {};
__export(exports_AaveV3Sepolia, {
  WETH_GATEWAY: () => {
    {
      return WETH_GATEWAY;
    }
  },
  WALLET_BALANCE_PROVIDER: () => {
    {
      return WALLET_BALANCE_PROVIDER;
    }
  },
  UI_POOL_DATA_PROVIDER: () => {
    {
      return UI_POOL_DATA_PROVIDER;
    }
  },
  UI_INCENTIVE_DATA_PROVIDER: () => {
    {
      return UI_INCENTIVE_DATA_PROVIDER;
    }
  },
  UI_GHO_DATA_PROVIDER: () => {
    {
      return UI_GHO_DATA_PROVIDER;
    }
  },
  STATIC_A_TOKEN_FACTORY: () => {
    {
      return STATIC_A_TOKEN_FACTORY;
    }
  },
  PRICE_ORACLE_SENTINEL: () => {
    {
      return PRICE_ORACLE_SENTINEL;
    }
  },
  POOL_CONFIGURATOR: () => {
    {
      return POOL_CONFIGURATOR;
    }
  },
  POOL_ADDRESSES_PROVIDER: () => {
    {
      return POOL_ADDRESSES_PROVIDER;
    }
  },
  POOL: () => {
    {
      return POOL;
    }
  },
  ORACLE: () => {
    {
      return ORACLE;
    }
  },
  FAUCET: () => {
    {
      return FAUCET;
    }
  },
  E_MODES: () => {
    {
      return E_MODES;
    }
  },
  EMISSION_MANAGER: () => {
    {
      return EMISSION_MANAGER;
    }
  },
  DEFAULT_VARIABLE_DEBT_TOKEN_IMPL_REV_1: () => {
    {
      return DEFAULT_VARIABLE_DEBT_TOKEN_IMPL_REV_1;
    }
  },
  DEFAULT_STABLE_DEBT_TOKEN_IMPL_REV_1: () => {
    {
      return DEFAULT_STABLE_DEBT_TOKEN_IMPL_REV_1;
    }
  },
  DEFAULT_INCENTIVES_CONTROLLER: () => {
    {
      return DEFAULT_INCENTIVES_CONTROLLER;
    }
  },
  DEFAULT_A_TOKEN_IMPL_REV_1: () => {
    {
      return DEFAULT_A_TOKEN_IMPL_REV_1;
    }
  },
  COLLECTOR: () => {
    {
      return COLLECTOR;
    }
  },
  CHAIN_ID: () => {
    {
      return CHAIN_ID;
    }
  },
  ASSETS: () => {
    {
      return ASSETS;
    }
  },
  ACL_MANAGER: () => {
    {
      return ACL_MANAGER;
    }
  },
  ACL_ADMIN: () => {
    {
      return ACL_ADMIN;
    }
  },
  AAVE_PROTOCOL_DATA_PROVIDER: () => {
    {
      return AAVE_PROTOCOL_DATA_PROVIDER;
    }
  }
});
var POOL_ADDRESSES_PROVIDER = "0x012bAC54348C0E635dCAc9D5FB99f06F24136C9A";
var POOL = "0x6Ae43d3271ff6888e7Fc43Fd7321a503ff738951";
var POOL_CONFIGURATOR = "0x7Ee60D184C24Ef7AfC1Ec7Be59A0f448A0abd138";
var ORACLE = "0x2da88497588bf89281816106C7259e31AF45a663";
var PRICE_ORACLE_SENTINEL = "0x0000000000000000000000000000000000000000";
var AAVE_PROTOCOL_DATA_PROVIDER = "0x3e9708d80f7B3e43118013075F7e95CE3AB31F31";
var ACL_MANAGER = "0x7F2bE3b178deeFF716CD6Ff03Ef79A1dFf360ddD";
var ACL_ADMIN = "0xfA0e305E0f46AB04f00ae6b5f4560d61a2183E00";
var COLLECTOR = "0x604264f8017fEF3b11B3dD63537CB501560380B5";
var DEFAULT_INCENTIVES_CONTROLLER = "0x4DA5c4da71C5a167171cC839487536d86e083483";
var DEFAULT_A_TOKEN_IMPL_REV_1 = "0x48424f2779be0f03cDF6F02E17A591A9BF7AF89f";
var DEFAULT_VARIABLE_DEBT_TOKEN_IMPL_REV_1 = "0x54bdE009156053108E73E2401aEA755e38f92098";
var DEFAULT_STABLE_DEBT_TOKEN_IMPL_REV_1 = "0xd1CF2FBf4fb82045eE0B116eB107d29246E8DCe9";
var EMISSION_MANAGER = "0x098a890BAfDf6FB4ACD24bF107D20EA15D229C62";
var FAUCET = "0xC959483DBa39aa9E78757139af0e9a2EDEb3f42D";
var UI_INCENTIVE_DATA_PROVIDER = "0xBA25de9a7DC623B30799F33B770d31B44c2C3b77";
var UI_POOL_DATA_PROVIDER = "0x69529987FA4A075D0C00B0128fa848dc9ebbE9CE";
var WALLET_BALANCE_PROVIDER = "0xCD4e0d6D2b1252E2A709B8aE97DBA31164C5a709";
var WETH_GATEWAY = "0x387d311e47e80b498169e6fb51d3193167d89F7D";
var STATIC_A_TOKEN_FACTORY = "0xd210dFB43B694430B8d31762B5199e30c31266C8";
var UI_GHO_DATA_PROVIDER = "0x69B9843A16a6E9933125EBD97659BA3CCbE2Ef8A";
var CHAIN_ID = 11155111;
var ASSETS = {
  DAI: {
    decimals: 18,
    UNDERLYING: "0xFF34B3d4Aee8ddCd6F9AFFFB6Fe49bD371b8a357",
    A_TOKEN: "0x29598b72eb5CeBd806C5dCD549490FdA35B13cD8",
    S_TOKEN: "0xbEF786E742edB13361ff2f005b901A82c23AA491",
    V_TOKEN: "0x22675C506A8FC26447aFFfa33640f6af5d4D4cF0",
    INTEREST_RATE_STRATEGY: "0xA813CC4d67821fbAcF24659e414A1Cf6c551373c",
    ORACLE: "0x9aF11c35c5d3Ae182C0050438972aac4376f9516",
    STATA_TOKEN: "0xDE46e43F46ff74A23a65EBb0580cbe3dFE684a17"
  },
  LINK: {
    decimals: 18,
    UNDERLYING: "0xf8Fb3713D459D7C1018BD0A49D19b4C44290EBE5",
    A_TOKEN: "0x3FfAf50D4F4E96eB78f2407c090b72e86eCaed24",
    S_TOKEN: "0x8f7440aa789924626ab9f5687AF305da2ffB996b",
    V_TOKEN: "0x34a4d932E722b9dFb492B9D8131127690CE2430B",
    INTEREST_RATE_STRATEGY: "0xCA30c502d52F905FB3D04eE60cA48F5A1A89f8dB",
    ORACLE: "0x14fC51b7df22b4D393cD45504B9f0A3002A63F3F",
    STATA_TOKEN: "0x8227a989709a757f25dF251C3C3e71CA38627836"
  },
  USDC: {
    decimals: 6,
    UNDERLYING: "0x94a9D9AC8a22534E3FaCa9F4e7F2E2cf85d5E4C8",
    A_TOKEN: "0x16dA4541aD1807f4443d92D26044C1147406EB80",
    S_TOKEN: "0x42A218F7bd03c63c4835496506492A383EfcF726",
    V_TOKEN: "0x36B5dE936eF1710E1d22EabE5231b28581a92ECc",
    INTEREST_RATE_STRATEGY: "0x5CB1008969a2d5FAcE8eF32732e6A306d0D0EF2A",
    ORACLE: "0x98458D6A99489F15e6eB5aFa67ACFAcf6F211051",
    STATA_TOKEN: "0x8A88124522dbBF1E56352ba3DE1d9F78C143751e"
  },
  WBTC: {
    decimals: 8,
    UNDERLYING: "0x29f2D40B0605204364af54EC677bD022dA425d03",
    A_TOKEN: "0x1804Bf30507dc2EB3bDEbbbdd859991EAeF6EefF",
    S_TOKEN: "0xc7AEA6Cf353b4FA27aBf1b4A8D536A4e87383EB5",
    V_TOKEN: "0xEB016dFd303F19fbDdFb6300eB4AeB2DA7Ceac37",
    INTEREST_RATE_STRATEGY: "0xCA30c502d52F905FB3D04eE60cA48F5A1A89f8dB",
    ORACLE: "0x784B90bA1E9a8cf3C9939c2e072F058B024C4b8a",
    STATA_TOKEN: "0x131a121bda71ED810bCAf2aC9079214925e59C18"
  },
  WETH: {
    decimals: 18,
    UNDERLYING: "0xC558DBdd856501FCd9aaF1E62eae57A9F0629a3c",
    A_TOKEN: "0x5b071b590a59395fE4025A0Ccc1FcC931AAc1830",
    S_TOKEN: "0xEb45D5A0efF06fFb88f6A70811c08375A8de84A3",
    V_TOKEN: "0x22a35DB253f4F6D0029025D6312A3BdAb20C2c6A",
    INTEREST_RATE_STRATEGY: "0xCA30c502d52F905FB3D04eE60cA48F5A1A89f8dB",
    ORACLE: "0xDde0E8E6d3653614878Bf5009EDC317BC129fE2F",
    STATA_TOKEN: "0x162B500569F42D9eCe937e6a61EDfef660A12E98"
  },
  USDT: {
    decimals: 6,
    UNDERLYING: "0xaA8E23Fb1079EA71e0a56F48a2aA51851D8433D0",
    A_TOKEN: "0xAF0F6e8b0Dc5c913bbF4d14c22B4E78Dd14310B6",
    S_TOKEN: "0xEAF54fA3b1C7243033C2893c6B807f9cEaBCf0AF",
    V_TOKEN: "0x9844386d29EEd970B9F6a2B9a676083b0478210e",
    INTEREST_RATE_STRATEGY: "0x5CB1008969a2d5FAcE8eF32732e6A306d0D0EF2A",
    ORACLE: "0x4e86D3Aa271Fa418F38D7262fdBa2989C94aa5Ba",
    STATA_TOKEN: "0x978206fAe13faF5a8d293FB614326B237684B750"
  },
  AAVE: {
    decimals: 18,
    UNDERLYING: "0x88541670E55cC00bEEFD87eB59EDd1b7C511AC9a",
    A_TOKEN: "0x6b8558764d3b7572136F17174Cb9aB1DDc7E1259",
    S_TOKEN: "0x4F15CaD6ebAE920a773bF00C6E941cccCB704915",
    V_TOKEN: "0xf12fdFc4c631F6D361b48723c2F2800b84B519e6",
    INTEREST_RATE_STRATEGY: "0xCA30c502d52F905FB3D04eE60cA48F5A1A89f8dB",
    ORACLE: "0xda678Ef100c13504edDb8a228A1e8e4CB139f189",
    STATA_TOKEN: "0x56771cEF0cb422e125564CcCC98BB05fdc718E77"
  },
  EURS: {
    decimals: 2,
    UNDERLYING: "0x6d906e526a4e2Ca02097BA9d0caA3c382F52278E",
    A_TOKEN: "0xB20691021F9AcED8631eDaa3c0Cd2949EB45662D",
    S_TOKEN: "0x08878209484D8178DD1FFA50AB1689F21aDBB856",
    V_TOKEN: "0x94482C7A7477196259D8a0f74fB853277Fa5a75b",
    INTEREST_RATE_STRATEGY: "0x5CB1008969a2d5FAcE8eF32732e6A306d0D0EF2A",
    ORACLE: "0xCbE15C1f40f1D7eE1De3756D1557d5Fdc2A50bBD",
    STATA_TOKEN: "0x72B49a461900e11632C95dfa563e7173438D4e3E"
  },
  GHO: {
    decimals: 18,
    UNDERLYING: "0xc4bF5CbDaBE595361438F8c6a187bDc330539c60",
    A_TOKEN: "0xd190eF37dB51Bb955A680fF1A85763CC72d083D4",
    S_TOKEN: "0xdCA691FB9609aB814E59c62d70783da1c056A9b6",
    V_TOKEN: "0x67ae46EF043F7A4508BD1d6B94DB6c33F0915844",
    INTEREST_RATE_STRATEGY: "0x521247B4d0a51E71DE580dA2cBF99EB40a44b3Bf",
    ORACLE: "0x00f7fecFAEbEd9499e1f3f9d04E755a21E5fc47C",
    STATA_TOKEN: "0x0000000000000000000000000000000000000000"
  }
};
var E_MODES = {
  NONE: 0,
  STABLECOINS: 1
};

// node_modules/@bgd-labs/aave-address-book/dist/abis/IERC20.mjs
var IERC20_ABI = [
  {
    type: "function",
    name: "allowance",
    inputs: [
      {
        name: "owner",
        type: "address",
        internalType: "address"
      },
      {
        name: "spender",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "approve",
    inputs: [
      {
        name: "spender",
        type: "address",
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "balanceOf",
    inputs: [
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "totalSupply",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "transfer",
    inputs: [
      {
        name: "recipient",
        type: "address",
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "transferFrom",
    inputs: [
      {
        name: "sender",
        type: "address",
        internalType: "address"
      },
      {
        name: "recipient",
        type: "address",
        internalType: "address"
      },
      {
        name: "amount",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        name: "owner",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "spender",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "value",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        name: "from",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "to",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "value",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  }
];

// node_modules/@ethersproject/contracts/lib.esm/index.js
var abi = __toESM(require_lib13(), 1);

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var import_bn = __toESM(require_bn(), 1);

// node_modules/@ethersproject/bytes/lib.esm/index.js
var logger = __toESM(require_lib(), 1);

// node_modules/@ethersproject/bytes/lib.esm/_version.js
var version = "bytes/5.7.0";

// node_modules/@ethersproject/bytes/lib.esm/index.js
var isHexable = function(value) {
  return !!value.toHexString;
};
var addSlice = function(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
};
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
var isInteger = function(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
};
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0;i < value.length; i++) {
    const v2 = value[i];
    if (!isInteger(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger2.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger2.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0;i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger2.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length) {
  value = arrayify(value);
  if (value.length > length) {
    logger2.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice(result);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger2.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger2.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i = 0;i < value.length; i++) {
      let v2 = value[i];
      result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
    }
    return result;
  }
  return logger2.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger2.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger2.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger2.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger2.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature)) {
    let bytes = arrayify(signature);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger2.throwArgumentError("invalid signature string", "signature", signature);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger2.throwArgumentError("signature invalid v byte", "signature", signature);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature.r;
    result.s = signature.s;
    result.v = signature.v;
    result.recoveryParam = signature.recoveryParam;
    result._vs = signature._vs;
    if (result._vs != null) {
      const vs3 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs3);
      const recoveryParam = vs3[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger2.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
      }
      vs3[0] &= 127;
      const s = hexlify(vs3);
      if (result.s == null) {
        result.s = s;
      } else if (result.s !== s) {
        logger2.throwArgumentError("signature v mismatch _vs", "signature", signature);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger2.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger2.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger2.throwArgumentError("signature missing or invalid r", "signature", signature);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger2.throwArgumentError("signature missing or invalid s", "signature", signature);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs2 = arrayify(result.s);
    if (vs2[0] >= 128) {
      logger2.throwArgumentError("signature s out of range", "signature", signature);
    }
    if (result.recoveryParam) {
      vs2[0] |= 128;
    }
    const _vs = hexlify(vs2);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger2.throwArgumentError("signature invalid _vs", "signature", signature);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger2.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
function joinSignature(signature) {
  signature = splitSignature(signature);
  return hexlify(concat([
    signature.r,
    signature.s,
    signature.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
var logger2 = new logger.Logger(version);
var HexCharacters = "0123456789abcdef";

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var logger3 = __toESM(require_lib(), 1);

// node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version2 = "bignumber/5.7.0";

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
var toHex = function(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger4.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
};
var toBigNumber = function(value) {
  return BigNumber.from(toHex(value));
};
var toBN = function(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
};
var throwFault = function(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger4.throwError(fault, logger3.Logger.errors.NUMERIC_FAULT, params);
};
var BN = import_bn.default.BN;
var logger4 = new logger3.Logger(version2);
var _constructorGuard = {};
var MAX_SAFE = 9007199254740991;
var _warnedToStringRadix = false;

class BigNumber {
  constructor(constructorGuard, hex) {
    if (constructorGuard !== _constructorGuard) {
      logger4.throwError("cannot call constructor directly; use BigNumber.from", logger3.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o = BigNumber.from(other);
    if (o.isZero()) {
      throwFault("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {
    }
    return logger4.throwError("this platform does not support BigInt", logger3.Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger4.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger4.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", logger3.Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger4.throwError("BigNumber.toString does not accept parameters", logger3.Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard, toHex(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard, toHex(new BN(value)));
      }
      return logger4.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }
    return logger4.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
}
// node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
var logger5 = __toESM(require_lib(), 1);
var throwFault2 = function(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== undefined) {
    params.value = value;
  }
  return logger6.throwError(message, logger5.Logger.errors.NUMERIC_FAULT, params);
};
var getMultiplier = function(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger6.throwArgumentError("invalid decimal size", "decimals", decimals);
};
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger6.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger6.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger6.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var logger6 = new logger5.Logger(version2);
var _constructorGuard2 = {};
var Zero = BigNumber.from(0);
var NegativeOne = BigNumber.from(-1);
var zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}

class FixedFormat {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard2) {
      logger6.throwError("cannot use FixedFormat constructor; use FixedFormat.from", logger5.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger6.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key, type, defaultValue) => {
        if (value[key] == null) {
          return defaultValue;
        }
        if (typeof value[key] !== type) {
          logger6.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
        }
        return value[key];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger6.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger6.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard2, signed, width, decimals);
  }
}

class FixedNumber {
  constructor(constructorGuard, hex, value, format) {
    if (constructorGuard !== _constructorGuard2) {
      logger6.throwError("cannot use FixedNumber constructor; use FixedNumber.from", logger5.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger6.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b3 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.add(b3), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b3 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.sub(b3), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b3 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(b3).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a = parseFixed(this._value, this.format.decimals);
    const b3 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b3), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger6.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger6.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero)) {
      throwFault2("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format);
    }
    if (isBytes(value)) {
      return FixedNumber.fromBytes(value, format);
    }
    try {
      return FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== logger5.Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger6.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
}
var ONE = FixedNumber.from(1);
var BUMP = FixedNumber.from("0.5");
// node_modules/@ethersproject/abstract-provider/lib.esm/index.js
var properties = __toESM(require_lib4(), 1);
var logger7 = __toESM(require_lib(), 1);

// node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
var version3 = "abstract-provider/5.7.0";

// node_modules/@ethersproject/abstract-provider/lib.esm/index.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger8 = new logger7.Logger(version3);

class ForkEvent extends properties.Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
}
class Provider {
  constructor() {
    logger8.checkAbstract(new.target, Provider);
    properties.defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter(this, undefined, undefined, function* () {
      const { block, gasPrice } = yield properties.resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        lastBaseFeePerGas = block.baseFeePerGas;
        maxPriorityFeePerGas = BigNumber.from("1500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
}

// node_modules/@ethersproject/abstract-signer/lib.esm/index.js
var properties2 = __toESM(require_lib4(), 1);
var logger9 = __toESM(require_lib(), 1);

// node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
var version4 = "abstract-signer/5.7.0";

// node_modules/@ethersproject/abstract-signer/lib.esm/index.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger10 = new logger9.Logger(version4);
var allowedTransactionKeys = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
var forwardErrors = [
  logger9.Logger.errors.INSUFFICIENT_FUNDS,
  logger9.Logger.errors.NONCE_EXPIRED,
  logger9.Logger.errors.REPLACEMENT_UNDERPRICED
];

class Signer {
  constructor() {
    logger10.checkAbstract(new.target, Signer);
    properties2.defineReadOnly(this, "_isSigner", true);
  }
  getBalance(blockTag) {
    return __awaiter2(this, undefined, undefined, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter2(this, undefined, undefined, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  estimateGas(transaction) {
    return __awaiter2(this, undefined, undefined, function* () {
      this._checkProvider("estimateGas");
      const tx = yield properties2.resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  call(transaction, blockTag) {
    return __awaiter2(this, undefined, undefined, function* () {
      this._checkProvider("call");
      const tx = yield properties2.resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  sendTransaction(transaction) {
    return __awaiter2(this, undefined, undefined, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter2(this, undefined, undefined, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter2(this, undefined, undefined, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter2(this, undefined, undefined, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name) {
    return __awaiter2(this, undefined, undefined, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name);
    });
  }
  checkTransaction(transaction) {
    for (const key in transaction) {
      if (allowedTransactionKeys.indexOf(key) === -1) {
        logger10.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
      }
    }
    const tx = properties2.shallowCopy(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger10.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  populateTransaction(transaction) {
    return __awaiter2(this, undefined, undefined, function* () {
      const tx = yield properties2.resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter2(this, undefined, undefined, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger10.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger10.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger10.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger10.throwError("network does not support EIP-1559", logger9.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger10.throwError("failed to get consistent fee data", logger9.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger10.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger9.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger10.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield properties2.resolveProperties(tx);
    });
  }
  _checkProvider(operation) {
    if (!this.provider) {
      logger10.throwError("missing provider", logger9.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
}

class VoidSigner extends Signer {
  constructor(address, provider) {
    super();
    properties2.defineReadOnly(this, "address", address);
    properties2.defineReadOnly(this, "provider", provider || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger10.throwError(message, logger9.Logger.errors.UNSUPPORTED_OPERATION, { operation });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain, types, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider) {
    return new VoidSigner(this.address, provider);
  }
}

// node_modules/@ethersproject/contracts/lib.esm/index.js
var address = __toESM(require_lib7(), 1);
var properties3 = __toESM(require_lib4(), 1);
var transactions = __toESM(require_lib18(), 1);
var logger11 = __toESM(require_lib(), 1);

// node_modules/@ethersproject/contracts/lib.esm/_version.js
var version5 = "contracts/5.7.0";

// node_modules/@ethersproject/contracts/lib.esm/index.js
var resolveName = function(resolver, nameOrPromise) {
  return __awaiter3(this, undefined, undefined, function* () {
    const name = yield nameOrPromise;
    if (typeof name !== "string") {
      logger12.throwArgumentError("invalid address or ENS name", "name", name);
    }
    try {
      return address.getAddress(name);
    } catch (error) {
    }
    if (!resolver) {
      logger12.throwError("a provider or signer is needed to resolve ENS names", logger11.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address2 = yield resolver.resolveName(name);
    if (address2 == null) {
      logger12.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
    }
    return address2;
  });
};
var resolveAddresses = function(resolver, value, paramType) {
  return __awaiter3(this, undefined, undefined, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger12.makeError("invalid value for array", logger11.Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v2) => resolveAddresses(resolver, v2, paramType.arrayChildren)));
    }
    return value;
  });
};
var populateTransaction = function(contract, fragment, args) {
  return __awaiter3(this, undefined, undefined, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = properties3.shallowCopy(args.pop());
    }
    logger12.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = properties3.resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter3(this, undefined, undefined, function* () {
          if (address.getAddress(check.signer) !== check.override) {
            logger12.throwError("Contract with a Signer cannot override from", logger11.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield properties3.resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: properties3.resolveProperties(overrides) || {}
    });
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = transactions.accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21000;
      const bytes4 = arrayify(data);
      for (let i = 0;i < bytes4.length; i++) {
        intrinsic += 4;
        if (bytes4[i]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger12.throwError("non-payable method cannot override value", logger11.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = properties3.shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key) => overrides[key] != null);
    if (leftovers.length) {
      logger12.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(",")}`, logger11.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
};
var buildPopulate = function(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
};
var buildEstimate = function(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter3(this, undefined, undefined, function* () {
      if (!signerOrProvider) {
        logger12.throwError("estimate require a provider or signer", logger11.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
};
var addContractWait = function(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = properties3.deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
};
var buildCall = function(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter3(this, undefined, undefined, function* () {
      let blockTag = undefined;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = properties3.shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === logger11.Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
};
var buildSend = function(contract, fragment) {
  return function(...args) {
    return __awaiter3(this, undefined, undefined, function* () {
      if (!contract.signer) {
        logger12.throwError("sending a transaction requires a signer", logger11.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
};
var buildDefault = function(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
};
var getEventTag = function(filter) {
  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
    return "*";
  }
  return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
};
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger12 = new logger11.Logger(version5);
var allowedTransactionKeys2 = {
  chainId: true,
  data: true,
  from: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true,
  customData: true,
  ccipReadEnabled: true
};

class RunningEvent {
  constructor(tag, filter) {
    properties3.defineReadOnly(this, "tag", tag);
    properties3.defineReadOnly(this, "filter", filter);
    this._listeners = [];
  }
  addListener(listener, once) {
    this._listeners.push({ listener, once });
  }
  removeListener(listener) {
    let done = false;
    this._listeners = this._listeners.filter((item) => {
      if (done || item.listener !== listener) {
        return true;
      }
      done = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i) => i.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount;
  }
  prepareEvent(event) {
  }
  getEmit(event) {
    return [event];
  }
}

class ErrorRunningEvent extends RunningEvent {
  constructor() {
    super("error", null);
  }
}

class FragmentRunningEvent extends RunningEvent {
  constructor(address2, contractInterface, fragment, topics) {
    const filter = {
      address: address2
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger12.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter.topics = topics.slice();
    } else {
      filter.topics = [topic];
    }
    super(getEventTag(filter), filter);
    properties3.defineReadOnly(this, "address", address2);
    properties3.defineReadOnly(this, "interface", contractInterface);
    properties3.defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data, topics) => {
      return this.interface.decodeEventLog(this.fragment, data, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors = abi.checkResultErrors(event.args);
    if (errors.length) {
      throw errors[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
}

class WildcardRunningEvent extends RunningEvent {
  constructor(address2, contractInterface) {
    super("*", { address: address2 });
    properties3.defineReadOnly(this, "address", address2);
    properties3.defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
}

class BaseContract {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    properties3.defineReadOnly(this, "interface", properties3.getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      properties3.defineReadOnly(this, "provider", null);
      properties3.defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      properties3.defineReadOnly(this, "provider", signerOrProvider.provider || null);
      properties3.defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      properties3.defineReadOnly(this, "provider", signerOrProvider);
      properties3.defineReadOnly(this, "signer", null);
    } else {
      logger12.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    properties3.defineReadOnly(this, "callStatic", {});
    properties3.defineReadOnly(this, "estimateGas", {});
    properties3.defineReadOnly(this, "functions", {});
    properties3.defineReadOnly(this, "populateTransaction", {});
    properties3.defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        properties3.defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name) => {
        const filters = uniqueFilters[name];
        if (filters.length === 1) {
          properties3.defineReadOnly(this.filters, name, this.filters[filters[0]]);
        } else {
          logger12.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
        }
      });
    }
    properties3.defineReadOnly(this, "_runningEvents", {});
    properties3.defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger12.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    properties3.defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      properties3.defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        properties3.defineReadOnly(this, "resolvedAddress", Promise.resolve(address.getAddress(addressOrName)));
      } catch (error) {
        logger12.throwError("provider is required to use ENS name as contract address", logger11.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    this.resolvedAddress.catch((e) => {
    });
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature) => {
      const fragment = this.interface.functions[signature];
      if (uniqueSignatures[signature]) {
        logger12.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
        return;
      }
      uniqueSignatures[signature] = true;
      {
        const name = fragment.name;
        if (!uniqueNames[`%${name}`]) {
          uniqueNames[`%${name}`] = [];
        }
        uniqueNames[`%${name}`].push(signature);
      }
      if (this[signature] == null) {
        properties3.defineReadOnly(this, signature, buildDefault(this, fragment, true));
      }
      if (this.functions[signature] == null) {
        properties3.defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature] == null) {
        properties3.defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature] == null) {
        properties3.defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature] == null) {
        properties3.defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name) => {
      const signatures = uniqueNames[name];
      if (signatures.length > 1) {
        return;
      }
      name = name.substring(1);
      const signature = signatures[0];
      try {
        if (this[name] == null) {
          properties3.defineReadOnly(this, name, this[signature]);
        }
      } catch (e) {
      }
      if (this.functions[name] == null) {
        properties3.defineReadOnly(this.functions, name, this.functions[signature]);
      }
      if (this.callStatic[name] == null) {
        properties3.defineReadOnly(this.callStatic, name, this.callStatic[signature]);
      }
      if (this.populateTransaction[name] == null) {
        properties3.defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);
      }
      if (this.estimateGas[name] == null) {
        properties3.defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);
      }
    });
  }
  static getContractAddress(transaction) {
    return address.getContractAddress(transaction);
  }
  static getInterface(contractInterface) {
    if (abi.Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new abi.Interface(contractInterface);
  }
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
          if (code === "0x") {
            logger12.throwError("contract not deployed", logger11.Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  fallback(overrides) {
    if (!this.signer) {
      logger12.throwError("sending a transactions require a signer", logger11.Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = properties3.shallowCopy(overrides || {});
    ["from", "to"].forEach(function(key) {
      if (tx[key] == null) {
        return;
      }
      logger12.throwError("cannot override " + key, logger11.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      properties3.defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return abi.Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent);
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit = this._wrappedEmits[runningEvent.tag];
      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  _wrapEvent(runningEvent, log, listener) {
    const event = properties3.deepCopy(log);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once) {
    if (!this.provider) {
      logger12.throwError("events require a provider or a signer with a provider", logger11.Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log) => {
        let event = this._wrapEvent(runningEvent, log, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter = properties3.shallowCopy(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger12.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter.blockHash = fromBlockOrBlockhash;
    } else {
      filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter).then((logs) => {
      return logs.map((log) => this._wrapEvent(runningEvent, log, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key) => {
        return accum + this._runningEvents[key].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
}

class Contract extends BaseContract {
}

class ContractFactory {
  constructor(contractInterface, bytecode, signer) {
    let bytecodeHex = null;
    if (typeof bytecode === "string") {
      bytecodeHex = bytecode;
    } else if (isBytes(bytecode)) {
      bytecodeHex = hexlify(bytecode);
    } else if (bytecode && typeof bytecode.object === "string") {
      bytecodeHex = bytecode.object;
    } else {
      bytecodeHex = "!";
    }
    if (bytecodeHex.substring(0, 2) !== "0x") {
      bytecodeHex = "0x" + bytecodeHex;
    }
    if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
      logger12.throwArgumentError("invalid bytecode", "bytecode", bytecode);
    }
    if (signer && !Signer.isSigner(signer)) {
      logger12.throwArgumentError("invalid signer", "signer", signer);
    }
    properties3.defineReadOnly(this, "bytecode", bytecodeHex);
    properties3.defineReadOnly(this, "interface", properties3.getStatic(new.target, "getInterface")(contractInterface));
    properties3.defineReadOnly(this, "signer", signer || null);
  }
  getDeployTransaction(...args) {
    let tx = {};
    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      tx = properties3.shallowCopy(args.pop());
      for (const key in tx) {
        if (!allowedTransactionKeys2[key]) {
          throw new Error("unknown transaction override " + key);
        }
      }
    }
    ["data", "from", "to"].forEach((key) => {
      if (tx[key] == null) {
        return;
      }
      logger12.throwError("cannot override " + key, logger11.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
    });
    if (tx.value) {
      const value = BigNumber.from(tx.value);
      if (!value.isZero() && !this.interface.deploy.payable) {
        logger12.throwError("non-payable constructor cannot override value", logger11.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: tx.value
        });
      }
    }
    logger12.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
    tx.data = hexlify(concat([
      this.bytecode,
      this.interface.encodeDeploy(args)
    ]));
    return tx;
  }
  deploy(...args) {
    return __awaiter3(this, undefined, undefined, function* () {
      let overrides = {};
      if (args.length === this.interface.deploy.inputs.length + 1) {
        overrides = args.pop();
      }
      logger12.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
      params.push(overrides);
      const unsignedTx = this.getDeployTransaction(...params);
      const tx = yield this.signer.sendTransaction(unsignedTx);
      const address2 = properties3.getStatic(this.constructor, "getContractAddress")(tx);
      const contract = properties3.getStatic(this.constructor, "getContract")(address2, this.interface, this.signer);
      addContractWait(contract, tx);
      properties3.defineReadOnly(contract, "deployTransaction", tx);
      return contract;
    });
  }
  attach(address2) {
    return this.constructor.getContract(address2, this.interface, this.signer);
  }
  connect(signer) {
    return new this.constructor(this.interface, this.bytecode, signer);
  }
  static fromSolidity(compilerOutput, signer) {
    if (compilerOutput == null) {
      logger12.throwError("missing compiler output", logger11.Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
    }
    if (typeof compilerOutput === "string") {
      compilerOutput = JSON.parse(compilerOutput);
    }
    const abi2 = compilerOutput.abi;
    let bytecode = null;
    if (compilerOutput.bytecode) {
      bytecode = compilerOutput.bytecode;
    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
      bytecode = compilerOutput.evm.bytecode;
    }
    return new this(abi2, bytecode, signer);
  }
  static getInterface(contractInterface) {
    return Contract.getInterface(contractInterface);
  }
  static getContractAddress(tx) {
    return address.getContractAddress(tx);
  }
  static getContract(address2, contractInterface, signer) {
    return new Contract(address2, contractInterface, signer);
  }
}

// node_modules/tslib/tslib.es6.mjs
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1;i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}

// node_modules/@aave/contract-helpers/dist/esm/v3-UiIncentiveDataProvider-contract/index.js
var utils3 = __toESM(require_utils5(), 1);

// node_modules/@aave/contract-helpers/dist/esm/cl-feed-registry/index.js
var utils = __toESM(require_utils5(), 1);

// node_modules/ethers/lib.esm/ethers.js
var exports_ethers = {};
__export(exports_ethers, {
  wordlists: () => {
    {
      return wordlists;
    }
  },
  version: () => {
    {
      return version9;
    }
  },
  utils: () => {
    {
      return exports_utils;
    }
  },
  providers: () => {
    {
      return exports_lib2;
    }
  },
  logger: () => {
    {
      return logger50;
    }
  },
  getDefaultProvider: () => {
    {
      return getDefaultProvider;
    }
  },
  errors: () => {
    {
      return logger49.ErrorCode;
    }
  },
  constants: () => {
    {
      return exports_lib;
    }
  },
  Wordlist: () => {
    {
      return Wordlist;
    }
  },
  Wallet: () => {
    {
      return wallet2.Wallet;
    }
  },
  VoidSigner: () => {
    {
      return VoidSigner;
    }
  },
  Signer: () => {
    {
      return Signer;
    }
  },
  FixedNumber: () => {
    {
      return FixedNumber;
    }
  },
  ContractFactory: () => {
    {
      return ContractFactory;
    }
  },
  Contract: () => {
    {
      return Contract;
    }
  },
  BigNumber: () => {
    {
      return BigNumber;
    }
  },
  BaseContract: () => {
    {
      return BaseContract;
    }
  }
});
var wallet2 = __toESM(require_lib27(), 1);

// node_modules/@ethersproject/constants/lib.esm/index.js
var exports_lib = {};
__export(exports_lib, {
  Zero: () => {
    {
      return Zero2;
    }
  },
  WeiPerEther: () => {
    {
      return WeiPerEther;
    }
  },
  Two: () => {
    {
      return Two;
    }
  },
  One: () => {
    {
      return One;
    }
  },
  NegativeOne: () => {
    {
      return NegativeOne2;
    }
  },
  MinInt256: () => {
    {
      return MinInt256;
    }
  },
  MaxUint256: () => {
    {
      return MaxUint256;
    }
  },
  MaxInt256: () => {
    {
      return MaxInt256;
    }
  },
  HashZero: () => {
    {
      return HashZero;
    }
  },
  EtherSymbol: () => {
    {
      return EtherSymbol;
    }
  },
  AddressZero: () => {
    {
      return AddressZero;
    }
  }
});

// node_modules/@ethersproject/constants/lib.esm/addresses.js
var AddressZero = "0x0000000000000000000000000000000000000000";
// node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne2 = BigNumber.from(-1);
var Zero2 = BigNumber.from(0);
var One = BigNumber.from(1);
var Two = BigNumber.from(2);
var WeiPerEther = BigNumber.from("1000000000000000000");
var MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt256 = BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@ethersproject/constants/lib.esm/hashes.js
var HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
// node_modules/@ethersproject/constants/lib.esm/strings.js
var EtherSymbol = "\u039E";

// node_modules/@ethersproject/providers/lib.esm/index.js
var exports_lib2 = {};
__export(exports_lib2, {
  showThrottleMessage: () => {
    {
      return showThrottleMessage;
    }
  },
  isCommunityResource: () => {
    {
      return isCommunityResource;
    }
  },
  isCommunityResourcable: () => {
    {
      return isCommunityResourcable;
    }
  },
  getNetwork: () => {
    {
      return getNetwork;
    }
  },
  getDefaultProvider: () => {
    {
      return getDefaultProvider;
    }
  },
  WebSocketProvider: () => {
    {
      return WebSocketProvider;
    }
  },
  Web3Provider: () => {
    {
      return Web3Provider;
    }
  },
  UrlJsonRpcProvider: () => {
    {
      return UrlJsonRpcProvider;
    }
  },
  StaticJsonRpcProvider: () => {
    {
      return StaticJsonRpcProvider;
    }
  },
  Resolver: () => {
    {
      return Resolver;
    }
  },
  Provider: () => {
    {
      return Provider;
    }
  },
  PocketProvider: () => {
    {
      return PocketProvider;
    }
  },
  NodesmithProvider: () => {
    {
      return NodesmithProvider;
    }
  },
  JsonRpcSigner: () => {
    {
      return JsonRpcSigner;
    }
  },
  JsonRpcProvider: () => {
    {
      return JsonRpcProvider;
    }
  },
  JsonRpcBatchProvider: () => {
    {
      return JsonRpcBatchProvider;
    }
  },
  IpcProvider: () => {
    {
      return IpcProvider;
    }
  },
  InfuraWebSocketProvider: () => {
    {
      return InfuraWebSocketProvider;
    }
  },
  InfuraProvider: () => {
    {
      return InfuraProvider;
    }
  },
  Formatter: () => {
    {
      return Formatter;
    }
  },
  FallbackProvider: () => {
    {
      return FallbackProvider;
    }
  },
  EtherscanProvider: () => {
    {
      return EtherscanProvider;
    }
  },
  CloudflareProvider: () => {
    {
      return CloudflareProvider;
    }
  },
  BaseProvider: () => {
    {
      return BaseProvider;
    }
  },
  AnkrProvider: () => {
    {
      return AnkrProvider;
    }
  },
  AlchemyWebSocketProvider: () => {
    {
      return AlchemyWebSocketProvider;
    }
  },
  AlchemyProvider: () => {
    {
      return AlchemyProvider;
    }
  }
});

// node_modules/@ethersproject/networks/lib.esm/index.js
var logger13 = __toESM(require_lib(), 1);

// node_modules/@ethersproject/networks/lib.esm/_version.js
var version6 = "networks/5.7.1";

// node_modules/@ethersproject/networks/lib.esm/index.js
var isRenetworkable = function(value) {
  return value && typeof value.renetwork === "function";
};
var ethDefaultProvider = function(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const provider = new providers.PocketProvider(network, options.pocket);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        const skip = ["ropsten"];
        const provider = new providers.AnkrProvider(network, options.ankr);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
};
var etcDefaultProvider = function(url, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name in networks) {
      const standard2 = networks[name];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger14.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger14.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}
var logger14 = new logger13.Logger(version6);
var homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
var ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
var classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
var networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};

// node_modules/@ethersproject/providers/lib.esm/base-provider.js
var base64 = __toESM(require_lib10(), 1);
var basex = __toESM(require_lib14(), 1);
var hash = __toESM(require_lib12(), 1);
var properties5 = __toESM(require_lib4(), 1);
var sha2 = __toESM(require_lib15(), 1);
var strings = __toESM(require_lib9(), 1);
var web = __toESM(require_lib28(), 1);
var import_bech32 = __toESM(require_bech32(), 1);
var logger17 = __toESM(require_lib(), 1);

// node_modules/@ethersproject/providers/lib.esm/_version.js
var version7 = "providers/5.7.2";

// node_modules/@ethersproject/providers/lib.esm/formatter.js
var address2 = __toESM(require_lib7(), 1);
var properties4 = __toESM(require_lib4(), 1);
var transactions2 = __toESM(require_lib18(), 1);
var logger15 = __toESM(require_lib(), 1);
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}
var logger16 = new logger15.Logger(version7);

class Formatter {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address3 = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v2) => {
      return this.data(v2, true);
    };
    formats.transaction = {
      hash,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash, null),
      blockNumber: Formatter.allowNull(number, null),
      transactionIndex: Formatter.allowNull(number, null),
      confirmations: Formatter.allowNull(number, null),
      from: address3,
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address3, null),
      value: bigNumber,
      nonce: number,
      data,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number),
      creates: Formatter.allowNull(address3, null),
      raw: Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address3),
      nonce: Formatter.allowNull(number),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address3),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number,
      blockNumber: number,
      transactionHash: hash,
      address: address3,
      topics: Formatter.arrayOf(hash),
      data,
      logIndex: number,
      blockHash: hash
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address3, null),
      transactionIndex: number,
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data),
      blockHash: hash,
      transactionHash: hash,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number,
      confirmations: Formatter.allowNull(number, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number),
      type
    };
    formats.block = {
      hash: Formatter.allowNull(hash),
      parentHash: hash,
      number,
      timestamp: number,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: Formatter.allowNull(address3),
      extraData: data,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = properties4.shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, undefined),
      toBlock: Formatter.allowNull(blockTag, undefined),
      blockHash: Formatter.allowNull(hash, undefined),
      address: Formatter.allowNull(address3, undefined),
      topics: Formatter.allowNull(this.topics.bind(this), undefined)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number),
      blockHash: Formatter.allowNull(hash),
      transactionIndex: number,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address: address3,
      data: Formatter.allowFalsish(data, "0x"),
      topics: Formatter.arrayOf(hash),
      transactionHash: hash,
      logIndex: number
    };
    return formats;
  }
  accessList(accessList) {
    return transactions2.accessListify(accessList || []);
  }
  number(number) {
    if (number === "0x") {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  type(number) {
    if (number === "0x" || number == null) {
      return 0;
    }
    return BigNumber.from(number).toNumber();
  }
  bigNumber(value) {
    return BigNumber.from(value);
  }
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString(value)) {
        return value.toLowerCase();
      }
    }
    return logger16.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  address(value) {
    return address2.getAddress(value);
  }
  callAddress(value) {
    if (!isHexString(value, 32)) {
      return null;
    }
    const address3 = address2.getAddress(hexDataSlice(value, 12));
    return address3 === AddressZero ? null : address3;
  }
  contractAddress(value) {
    return address2.getContractAddress(value);
  }
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (typeof blockTag === "number" || isHexString(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger16.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v2 = BigNumber.from(value);
    try {
      return v2.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return transactions2.parse(value);
  }
  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger16.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger16.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger16.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v2) => this.topics(v2));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object) {
    const result = {};
    for (const key in format) {
      try {
        const value = format[key](object[key]);
        if (value !== undefined) {
          result[key] = value;
        }
      } catch (error) {
        error.checkKey = key;
        error.checkValue = object[key];
        throw error;
      }
    }
    return result;
  }
  static allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  static allowFalsish(format, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  static arrayOf(format) {
    return function(array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      const result = [];
      array.forEach(function(value) {
        result.push(format(value));
      });
      return result;
    };
  }
}
var throttleMessage = false;

// node_modules/@ethersproject/providers/lib.esm/base-provider.js
var checkTopic = function(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger18.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
};
var serializeTopics = function(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
};
var deserializeTopics = function(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
};
var getEventTag2 = function(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger18.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
};
var getTime = function() {
  return new Date().getTime();
};
var stall = function(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
};
var bytes32ify = function(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
};
var base58Encode = function(data) {
  return basex.Base58.encode(concat([data, hexDataSlice(sha2.sha256(sha2.sha256(data)), 0, 4)]));
};
var _parseString = function(result, start) {
  try {
    return strings.toUtf8String(_parseBytes(result, start));
  } catch (error) {
  }
  return null;
};
var _parseBytes = function(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length);
};
var getIpfsLink = function(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger18.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
};
var numPad = function(value) {
  const result = arrayify(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
};
var bytesPad = function(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
};
var encodeBytes = function(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0;i < datas.length; i++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i = 0;i < datas.length; i++) {
    const data = arrayify(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return hexConcat(result);
};
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger18 = new logger17.Logger(version7);
var MAX_CCIP_REDIRECTS = 10;
var PollableEvents = ["block", "network", "pending", "poll"];

class Event {
  constructor(tag, listener, once) {
    properties5.defineReadOnly(this, "tag", tag);
    properties5.defineReadOnly(this, "listener", listener);
    properties5.defineReadOnly(this, "once", once);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address3 = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter = {};
    if (topics.length > 0) {
      filter.topics = topics;
    }
    if (address3 && address3 !== "*") {
      filter.address = address3;
    }
    return filter;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
}
var coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];

class Resolver {
  constructor(provider, address3, name, resolvedAddress) {
    properties5.defineReadOnly(this, "provider", provider);
    properties5.defineReadOnly(this, "name", name);
    properties5.defineReadOnly(this, "address", provider.formatter.address(address3));
    properties5.defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((result) => {
        return BigNumber.from(result).eq(1);
      }).catch((error) => {
        if (error.code === logger17.Logger.errors.CALL_EXCEPTION) {
          return false;
        }
        this._supportsEip2544 = null;
        throw error;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector, parameters) {
    return __awaiter4(this, undefined, undefined, function* () {
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: hexConcat([selector, hash.namehash(this.name), parameters || "0x"])
      };
      let parseBytes = false;
      if (yield this.supportsWildcard()) {
        parseBytes = true;
        tx.data = hexConcat(["0x9061b923", encodeBytes([hash.dnsEncode(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if (arrayify(result).length % 32 === 4) {
          logger18.throwError("resolver threw error", logger17.Logger.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error) {
        if (error.code === logger17.Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _fetchBytes(selector, parameters) {
    return __awaiter4(this, undefined, undefined, function* () {
      const result = yield this._fetch(selector, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger18.throwError(`unsupported coin type: ${coinType}`, logger17.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes6 = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length = bytes6[1];
      let version8 = bytes6[0];
      if (version8 === 0) {
        if (length !== 20 && length !== 32) {
          version8 = -1;
        }
      } else {
        version8 = -1;
      }
      if (version8 >= 0 && bytes6.length === 2 + length && length >= 1 && length <= 75) {
        const words = import_bech32.default.toWords(bytes6.slice(2));
        words.unshift(version8);
        return import_bech32.default.encode(coinInfo.prefix, words);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter4(this, undefined, undefined, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = yield this._fetch("0x3b3b57de");
          if (result === "0x" || result === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === logger17.Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address3 = this._getAddress(coinType, hexBytes);
      if (address3 == null) {
        logger18.throwError(`invalid or unsupported coin data`, logger17.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address3;
    });
  }
  getAvatar() {
    return __awaiter4(this, undefined, undefined, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i = 0;i < matchers.length; i++) {
          const match = avatar.match(matchers[i]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx), 0);
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield web.fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter4(this, undefined, undefined, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length * 2) {
          return "ipfs://" + basex.Base58.encode("0x" + ipfs[1]);
        }
      }
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length = parseInt(ipns[3], 16);
        if (ipns[4].length === length * 2) {
          return "ipns://" + basex.Base58.encode("0x" + ipns[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
      if (skynet) {
        if (skynet[1].length === 34 * 2) {
          const urlSafe = { "=": "", "+": "-", "/": "_" };
          const hash2 = base64.encode("0x" + skynet[1]).replace(/[=+\/]/g, (a) => urlSafe[a]);
          return "sia://" + hash2;
        }
      }
      return logger18.throwError(`invalid or unsupported content hash data`, logger17.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key) {
    return __awaiter4(this, undefined, undefined, function* () {
      let keyBytes = strings.toUtf8Bytes(key);
      keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return strings.toUtf8String(hexBytes);
    });
  }
}
var defaultFormatter = null;
var nextPollId = 1;

class BaseProvider extends Provider {
  constructor(network) {
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    properties5.defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = properties5.getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        properties5.defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger18.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4000;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter4(this, undefined, undefined, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger18.throwError("no network detected", logger17.Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            properties5.defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  get ready() {
    return web.poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === logger17.Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return;
        }
        throw error;
      });
    });
  }
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter;
    }
    return defaultFormatter;
  }
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter4(this, undefined, undefined, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data = calldata.toLowerCase();
      const errorMessages = [];
      for (let i = 0;i < urls.length; i++) {
        const url = urls[i];
        const href = url.replace("{sender}", sender).replace("{data}", data);
        const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data, sender });
        const result = yield web.fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
          value.status = response.statusCode;
          return value;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        if (result.status >= 400 && result.status < 500) {
          return logger18.throwError(`response not found during CCIP fetch: ${errorMessage}`, logger17.Logger.errors.SERVER_ERROR, { url, errorMessage });
        }
        errorMessages.push(errorMessage);
      }
      return logger18.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, logger17.Logger.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  _getInternalBlockNumber(maxAge) {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = properties5.resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter4(this, undefined, undefined, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1000) {
        logger18.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger18.makeError("network block skew detected", logger17.Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i = this._emitted.block + 1;i <= blockNumber; i++) {
          this.emit("block", i);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key) => {
          if (key === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash2 = event.hash;
            let runner = this.getTransactionReceipt(hash2).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash2] = receipt.blockNumber;
              this.emit(hash2, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            if (!event._inflight) {
              event._inflight = true;
              if (event._lastBlockNumber === -2) {
                event._lastBlockNumber = blockNumber - 1;
              }
              const filter = event.filter;
              filter.fromBlock = event._lastBlockNumber + 1;
              filter.toBlock = blockNumber;
              const minFromBlock = filter.toBlock - this._maxFilterBlockRange;
              if (minFromBlock > filter.fromBlock) {
                filter.fromBlock = minFromBlock;
              }
              if (filter.fromBlock < 0) {
                filter.fromBlock = 0;
              }
              const runner = this.getLogs(filter).then((logs) => {
                event._inflight = false;
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log) => {
                  if (log.blockNumber > event._lastBlockNumber) {
                    event._lastBlockNumber = log.blockNumber;
                  }
                  this._emitted["b:" + log.blockHash] = log.blockNumber;
                  this._emitted["t:" + log.transactionHash] = log.blockNumber;
                  this.emit(filter, log);
                });
              }).catch((error) => {
                this.emit("error", error);
                event._inflight = false;
              });
              runners.push(runner);
            }
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return __awaiter4(this, undefined, undefined, function* () {
      return logger18.throwError("provider does not support network detection", logger17.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter4(this, undefined, undefined, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger18.makeError("underlying network changed", logger17.Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now = getTime();
    if (now - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter4(this, undefined, undefined, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter4(this, undefined, undefined, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter4(this, undefined, undefined, function* () {
            if (done) {
              return;
            }
            yield stall(1000);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter4(this, undefined, undefined, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0;ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger18.makeError("transaction was replaced", logger17.Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout === "number" && timeout > 0) {
          const timer = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger18.makeError("timeout exceeded", logger17.Logger.errors.TIMEOUT, { timeout }));
          }, timeout);
          if (timer.unref) {
            timer.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter4(this, undefined, undefined, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger18.throwError("bad result from backend", logger17.Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this.getNetwork();
      const params = yield properties5.resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger18.throwError("bad result from backend", logger17.Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this.getNetwork();
      const params = yield properties5.resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger18.throwError("bad result from backend", logger17.Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this.getNetwork();
      const params = yield properties5.resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger18.throwError("bad result from backend", logger17.Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this.getNetwork();
      const params = yield properties5.resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p) => hexValue(p))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger18.throwError("bad result from backend", logger17.Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  _wrapTransaction(tx, hash2, startBlock) {
    if (hash2 != null && hexDataLength(hash2) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash2 != null && tx.hash !== hash2) {
      logger18.throwError("Transaction hash mismatch from Provider.sendTransaction.", logger17.Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash2 });
    }
    result.wait = (confirms, timeout) => __awaiter4(this, undefined, undefined, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout == null) {
        timeout = 0;
      }
      let replacement = undefined;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger18.throwError("transaction failed", logger17.Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t) => hexlify(t));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash2 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash2, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter4(this, undefined, undefined, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key) => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then((v2) => v2 ? this._getAddress(v2) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key) => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then((v2) => v2 ? BigNumber.from(v2) : null);
      });
      ["type"].forEach((key) => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then((v2) => v2 != null ? v2 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key) => {
        if (values[key] == null) {
          return;
        }
        tx[key] = Promise.resolve(values[key]).then((v2) => v2 ? hexlify(v2) : null);
      });
      return this.formatter.transactionRequest(yield properties5.resolveProperties(tx));
    });
  }
  _getFilter(filter) {
    return __awaiter4(this, undefined, undefined, function* () {
      filter = yield filter;
      const result = {};
      if (filter.address != null) {
        result.address = this._getAddress(filter.address);
      }
      ["blockHash", "topics"].forEach((key) => {
        if (filter[key] == null) {
          return;
        }
        result[key] = filter[key];
      });
      ["fromBlock", "toBlock"].forEach((key) => {
        if (filter[key] == null) {
          return;
        }
        result[key] = this._getBlockTag(filter[key]);
      });
      return this.formatter.filter(yield properties5.resolveProperties(result));
    });
  }
  _call(transaction, blockTag, attempt) {
    return __awaiter4(this, undefined, undefined, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger18.throwError("CCIP read exceeded maximum redirections", logger17.Logger.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction
        });
      }
      const txSender = transaction.to;
      const result = yield this.perform("call", { transaction, blockTag });
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
        try {
          const data = hexDataSlice(result, 4);
          const sender = hexDataSlice(data, 0, 32);
          if (!BigNumber.from(sender).eq(txSender)) {
            logger18.throwError("CCIP Read sender did not match", logger17.Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const urls = [];
          const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();
          const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = hexDataSlice(data, urlsOffset + 32);
          for (let u = 0;u < urlsLength; u++) {
            const url = _parseString(urlsData, u * 32);
            if (url == null) {
              logger18.throwError("CCIP Read contained corrupt URL string", logger17.Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            urls.push(url);
          }
          const calldata = _parseBytes(data, 64);
          if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {
            logger18.throwError("CCIP Read callback selector included junk", logger17.Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const callbackSelector = hexDataSlice(data, 96, 100);
          const extraData = _parseBytes(data, 128);
          const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
          if (ccipResult == null) {
            logger18.throwError("CCIP Read disabled or provided no URLs", logger17.Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === logger17.Logger.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }
      try {
        return hexlify(result);
      } catch (error) {
        return logger18.throwError("bad result from backend", logger17.Logger.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction, blockTag },
          result,
          error
        });
      }
    });
  }
  call(transaction, blockTag) {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this.getNetwork();
      const resolved = yield properties5.resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction) {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this.getNetwork();
      const params = yield properties5.resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger18.throwError("bad result from backend", logger17.Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter4(this, undefined, undefined, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger18.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address3 = yield this.resolveName(addressOrName);
      if (address3 == null) {
        logger18.throwError("ENS name not configured", logger17.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address3;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger18.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return web.poll(() => __awaiter4(this, undefined, undefined, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i = 0;i < block.transactions.length; i++) {
            const tx = block.transactions[i];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return web.poll(() => __awaiter4(this, undefined, undefined, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return web.poll(() => __awaiter4(this, undefined, undefined, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return;
        }
        if (result.blockHash == null) {
          return;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter) {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this.getNetwork();
      const params = yield properties5.resolveProperties({ filter: this._getFilter(filter) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter4(this, undefined, undefined, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter4(this, undefined, undefined, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger18.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name) {
    return __awaiter4(this, undefined, undefined, function* () {
      let currentName = name;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = yield this._getResolver(currentName, "getResolver");
        if (addr != null) {
          const resolver = new Resolver(this, addr, name);
          if (currentName !== name && !(yield resolver.supportsWildcard())) {
            return null;
          }
          return resolver;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name, operation) {
    return __awaiter4(this, undefined, undefined, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger18.throwError("network does not support ENS", logger17.Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
      }
      try {
        const addrData = yield this.call({
          to: network.ensAddress,
          data: "0x0178b8bf" + hash.namehash(name).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {
      }
      return null;
    });
  }
  resolveName(name) {
    return __awaiter4(this, undefined, undefined, function* () {
      name = yield name;
      try {
        return Promise.resolve(this.formatter.address(name));
      } catch (error) {
        if (isHexString(name)) {
          throw error;
        }
      }
      if (typeof name !== "string") {
        logger18.throwArgumentError("invalid ENS name", "name", name);
      }
      const resolver = yield this.getResolver(name);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address3) {
    return __awaiter4(this, undefined, undefined, function* () {
      address3 = yield address3;
      address3 = this.formatter.address(address3);
      const node = address3.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      const name = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + hash.namehash(node).substring(2)
      }), 0);
      const addr = yield this.resolveName(name);
      if (addr != address3) {
        return null;
      }
      return name;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter4(this, undefined, undefined, function* () {
      let resolver = null;
      if (isHexString(nameOrAddress)) {
        const address3 = this.formatter.address(nameOrAddress);
        const node = address3.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, node);
        try {
          const avatar2 = yield resolver.getAvatar();
          if (avatar2) {
            return avatar2.url;
          }
        } catch (error) {
          if (error.code !== logger17.Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
        }
        try {
          const name = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + hash.namehash(node).substring(2)
          }), 0);
          resolver = yield this.getResolver(name);
        } catch (error) {
          if (error.code !== logger17.Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
          return null;
        }
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger18.throwError(method + " not implemented", logger17.Logger.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e) => e.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e) => e.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once) {
    const event = new Event(getEventTag2(eventName), listener, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag2(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
}

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var properties9 = __toESM(require_lib4(), 1);

// node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
var properties7 = __toESM(require_lib4(), 1);

// node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
var hash2 = __toESM(require_lib12(), 1);
var properties6 = __toESM(require_lib4(), 1);
var strings2 = __toESM(require_lib9(), 1);
var transactions3 = __toESM(require_lib18(), 1);
var web2 = __toESM(require_lib28(), 1);
var logger19 = __toESM(require_lib(), 1);
var spelunk = function(value, requireData) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data = isHexString(value.data) ? value.data : null;
    if (!requireData || data) {
      return { message: value.message, data };
    }
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunk(value[key], requireData);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData);
    } catch (error) {
    }
  }
  return null;
};
var checkError = function(method, error, params) {
  const transaction = params.transaction || params.signedTransaction;
  if (method === "call") {
    const result = spelunk(error, true);
    if (result) {
      return result.data;
    }
    logger20.throwError("missing revert data in call exception; Transaction reverted without a reason string", logger19.Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction,
      error
    });
  }
  if (method === "estimateGas") {
    let result = spelunk(error.body, false);
    if (result == null) {
      result = spelunk(error, false);
    }
    if (result) {
      logger20.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger19.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction,
        error
      });
    }
  }
  let message = error.message;
  if (error.code === logger19.Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
    logger20.throwError("insufficient funds for intrinsic transaction cost", logger19.Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce (is )?too low/i)) {
    logger20.throwError("nonce has already been used", logger19.Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger20.throwError("replacement fee too low", logger19.Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/i)) {
    logger20.throwError("legacy pre-eip-155 transactions not supported", logger19.Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
    logger20.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger19.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
};
var timer = function(timeout) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout);
  });
};
var getResult = function(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
};
var getLowerCase = function(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
};
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger20 = new logger19.Logger(version7);
var errorGas = ["call", "estimateGas"];
var _constructorGuard3 = {};

class JsonRpcSigner extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    super();
    if (constructorGuard !== _constructorGuard3) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    properties6.defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      properties6.defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      properties6.defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      properties6.defineReadOnly(this, "_index", addressOrIndex);
      properties6.defineReadOnly(this, "_address", null);
    } else {
      logger20.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger20.throwError("cannot alter JSON-RPC Signer connection", logger19.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard3, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger20.throwError("unknown account #" + this._index, logger19.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = properties6.shallowCopy(transaction);
    const fromAddress = this.getAddress().then((address3) => {
      if (address3) {
        address3 = address3.toLowerCase();
      }
      return address3;
    });
    if (transaction.gasLimit == null) {
      const estimate = properties6.shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter5(this, undefined, undefined, function* () {
        if (to == null) {
          return null;
        }
        const address3 = yield this.provider.resolveName(to);
        if (address3 == null) {
          logger20.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address3;
      }));
    }
    return properties6.resolveProperties({
      tx: properties6.resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger20.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash3) => {
        return hash3;
      }, (error) => {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger20.throwError("user rejected transaction", logger19.Logger.errors.ACTION_REJECTED, {
            action: "sendTransaction",
            transaction: tx
          });
        }
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger20.throwError("signing transactions is unsupported", logger19.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter5(this, undefined, undefined, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash3 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield web2.poll(() => __awaiter5(this, undefined, undefined, function* () {
          const tx = yield this.provider.getTransaction(hash3);
          if (tx === null) {
            return;
          }
          return this.provider._wrapTransaction(tx, hash3, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash3;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter5(this, undefined, undefined, function* () {
      const data = typeof message === "string" ? strings2.toUtf8Bytes(message) : message;
      const address3 = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(data), address3.toLowerCase()]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger20.throwError("user rejected signing", logger19.Logger.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: address3,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _legacySignMessage(message) {
    return __awaiter5(this, undefined, undefined, function* () {
      const data = typeof message === "string" ? strings2.toUtf8Bytes(message) : message;
      const address3 = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [address3.toLowerCase(), hexlify(data)]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger20.throwError("user rejected signing", logger19.Logger.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: address3,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter5(this, undefined, undefined, function* () {
      const populated = yield hash2._TypedDataEncoder.resolveNames(domain, types, value, (name) => {
        return this.provider.resolveName(name);
      });
      const address3 = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          address3.toLowerCase(),
          JSON.stringify(hash2._TypedDataEncoder.getPayload(populated.domain, types, populated.value))
        ]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger20.throwError("user rejected signing", logger19.Logger.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: address3,
            messageData: { domain: populated.domain, types, value: populated.value }
          });
        }
        throw error;
      }
    });
  }
  unlock(password) {
    return __awaiter5(this, undefined, undefined, function* () {
      const provider = this.provider;
      const address3 = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address3.toLowerCase(), password, null]);
    });
  }
}

class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash3) => {
      return {
        hash: hash3,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash3, confirmations);
        }
      };
    });
  }
}
var allowedTransactionKeys3 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};

class JsonRpcProvider extends BaseProvider {
  constructor(url, network) {
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = properties6.getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      properties6.defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      properties6.defineReadOnly(this, "connection", Object.freeze(properties6.shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter5(this, undefined, undefined, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = properties6.getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger20.throwError("could not detect network", logger19.Logger.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger20.throwError("could not detect network", logger19.Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard3, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a) => this.formatter.address(a));
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: properties6.deepCopy(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = web2.fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = properties6.getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = properties6.getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
      default:
        break;
    }
    return null;
  }
  perform(method, params) {
    return __awaiter5(this, undefined, undefined, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = properties6.shallowCopy(params);
              params.transaction = properties6.shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger20.throwError(method + " not implemented", logger19.Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll3() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash3) {
            self2._emitted["t:" + hash3.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash3).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1000);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll3();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll3();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = properties6.shallowCopy(allowedTransactionKeys3);
    if (allowExtra) {
      for (const key in allowExtra) {
        if (allowExtra[key]) {
          allowed[key] = true;
        }
      }
    }
    properties6.checkProperties(transaction, allowed);
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key) {
      if (transaction[key] == null) {
        return;
      }
      const value = hexValue(BigNumber.from(transaction[key]));
      if (key === "gasLimit") {
        key = "gas";
      }
      result[key] = value;
    });
    ["from", "to", "data"].forEach(function(key) {
      if (transaction[key] == null) {
        return;
      }
      result[key] = hexlify(transaction[key]);
    });
    if (transaction.accessList) {
      result["accessList"] = transactions3.accessListify(transaction.accessList);
    }
    return result;
  }
}

// node_modules/@ethersproject/providers/lib.esm/ws.js
var logger21 = __toESM(require_lib(), 1);
var WS = null;
try {
  WS = WebSocket;
  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger22 = new logger21.Logger(version7);
  WS = function() {
    logger22.throwError("WebSockets not supported in this environment", logger21.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}

// node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
var logger22 = __toESM(require_lib(), 1);
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger23 = new logger22.Logger(version7);
var NextId = 1;

class WebSocketProvider extends JsonRpcProvider {
  constructor(url, network) {
    if (network === "any") {
      logger23.throwError("WebSocketProvider does not support 'any' network yet", logger22.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    if (typeof url === "string") {
      super(url, network);
    } else {
      super("_websocket", network);
    }
    this._pollingInterval = -1;
    this._wsReady = false;
    if (typeof url === "string") {
      properties7.defineReadOnly(this, "_websocket", new WS(this.connection.url));
    } else {
      properties7.defineReadOnly(this, "_websocket", url);
    }
    properties7.defineReadOnly(this, "_requests", {});
    properties7.defineReadOnly(this, "_subs", {});
    properties7.defineReadOnly(this, "_subIds", {});
    properties7.defineReadOnly(this, "_detectNetwork", super.detectNetwork());
    this.websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach((id) => {
        this.websocket.send(this._requests[id].payload);
      });
    };
    this.websocket.onmessage = (messageEvent) => {
      const data = messageEvent.data;
      const result = JSON.parse(data);
      if (result.id != null) {
        const id = String(result.id);
        const request = this._requests[id];
        delete this._requests[id];
        if (result.result !== undefined) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;
          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            properties7.defineReadOnly(error, "code", result.error.code || null);
            properties7.defineReadOnly(error, "response", data);
          } else {
            error = new Error("unknown error");
          }
          request.callback(error, undefined);
          this.emit("debug", {
            action: "response",
            error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        const sub = this._subs[result.params.subscription];
        if (sub) {
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1000);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  get websocket() {
    return this._websocket;
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger23.throwError("cannot reset events block on WebSocketProvider", logger22.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value) {
    logger23.throwError("cannot set polling interval on WebSocketProvider", logger22.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter6(this, undefined, undefined, function* () {
      return null;
    });
  }
  set polling(value) {
    if (!value) {
      return;
    }
    logger23.throwError("cannot set polling on WebSocketProvider", logger22.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }
        return resolve(result);
      }
      const payload = JSON.stringify({
        method,
        params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = { callback, payload };
      if (this._wsReady) {
        this.websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter6(this, undefined, undefined, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then((param2) => {
          return this.send("eth_subscribe", param2);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = { tag, processFunc };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (result) => {
          const blockNumber = BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (result) => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx": {
        const emitReceipt = (event2) => {
          const hash3 = event2.hash;
          this.getTransactionReceipt(hash3).then((receipt) => {
            if (!receipt) {
              return;
            }
            this.emit(hash3, receipt);
          });
        };
        emitReceipt(event);
        this._subscribe("tx", ["newHeads"], (result) => {
          this._events.filter((e) => e.type === "tx").forEach(emitReceipt);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      if (this._events.filter((e) => e.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then((subId2) => {
      if (!this._subs[subId2]) {
        return;
      }
      delete this._subs[subId2];
      this.send("eth_unsubscribe", [subId2]);
    });
  }
  destroy() {
    return __awaiter6(this, undefined, undefined, function* () {
      if (this.websocket.readyState === WS.CONNECTING) {
        yield new Promise((resolve) => {
          this.websocket.onopen = function() {
            resolve(true);
          };
          this.websocket.onerror = function() {
            resolve(false);
          };
        });
      }
      this.websocket.close(1000);
    });
  }
}

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var logger26 = __toESM(require_lib(), 1);

// node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
var properties8 = __toESM(require_lib4(), 1);
var logger24 = __toESM(require_lib(), 1);
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger25 = new logger24.Logger(version7);

class StaticJsonRpcProvider extends JsonRpcProvider {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter7(this, undefined, undefined, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          logger25.throwError("no network detected", logger24.Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          properties8.defineReadOnly(this, "_network", network);
          this.emit("network", network, null);
        }
      }
      return network;
    });
  }
}

class UrlJsonRpcProvider extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger25.checkAbstract(new.target, UrlJsonRpcProvider);
    network = properties8.getStatic(new.target, "getNetwork")(network);
    apiKey = properties8.getStatic(new.target, "getApiKey")(apiKey);
    const connection = properties8.getStatic(new.target, "getUrl")(network, apiKey);
    super(connection, network);
    if (typeof apiKey === "string") {
      properties8.defineReadOnly(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach((key) => {
        properties8.defineReadOnly(this, key, apiKey[key]);
      });
    }
  }
  _startPending() {
    logger25.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address3) {
    return logger25.throwError("API provider does not support signing", logger24.Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  static getApiKey(apiKey) {
    return apiKey;
  }
  static getUrl(network, apiKey) {
    return logger25.throwError("not implemented; sub-classes must override getUrl", logger24.Logger.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
}

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var logger27 = new logger26.Logger(version7);
var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";

class AlchemyWebSocketProvider extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new AlchemyProvider(network, apiKey);
    const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider.network);
    properties9.defineReadOnly(this, "apiKey", provider.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
}

class AlchemyProvider extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new AlchemyWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey;
    }
    if (apiKey && typeof apiKey !== "string") {
      logger27.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "goerli":
        host = "eth-goerli.g.alchemy.com/v2/";
        break;
      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-goerli":
        host = "arb-goerli.g.alchemy.com/v2/";
        break;
      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-goerli":
        host = "opt-goerli.g.alchemy.com/v2/";
        break;
      default:
        logger27.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: true,
      url: "https://" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
}

// node_modules/@ethersproject/providers/lib.esm/ankr-provider.js
var logger28 = __toESM(require_lib(), 1);
var getHost = function(name) {
  switch (name) {
    case "homestead":
      return "rpc.ankr.com/eth/";
    case "ropsten":
      return "rpc.ankr.com/eth_ropsten/";
    case "rinkeby":
      return "rpc.ankr.com/eth_rinkeby/";
    case "goerli":
      return "rpc.ankr.com/eth_goerli/";
    case "matic":
      return "rpc.ankr.com/polygon/";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }
  return logger29.throwArgumentError("unsupported network", "name", name);
};
var logger29 = new logger28.Logger(version7);
var defaultApiKey2 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";

class AnkrProvider extends UrlJsonRpcProvider {
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey2;
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const connection = {
      allowGzip: true,
      url: "https://" + getHost(network.name) + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey.apiKey === defaultApiKey2) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
}

// node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
var logger30 = __toESM(require_lib(), 1);
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger31 = new logger30.Logger(version7);

class CloudflareProvider extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger31.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }
    return null;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;
      default:
        logger31.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host;
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter8(this, undefined, undefined, function* () {
      if (method === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
        return block.number;
      }
      return _super.perform.call(this, method, params);
    });
  }
}

// node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
var properties10 = __toESM(require_lib4(), 1);
var transactions4 = __toESM(require_lib18(), 1);
var web3 = __toESM(require_lib28(), 1);
var logger32 = __toESM(require_lib(), 1);
var getTransactionPostData = function(transaction) {
  const result = {};
  for (let key in transaction) {
    if (transaction[key] == null) {
      continue;
    }
    let value = transaction[key];
    if (key === "type" && value === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
      value = hexValue(hexlify(value));
    } else if (key === "accessList") {
      value = "[" + transactions4.accessListify(value).map((set) => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = hexlify(value);
    }
    result[key] = value;
  }
  return result;
};
var getResult2 = function(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
};
var getJsonResult = function(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
};
var checkLogTag = function(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
};
var checkError2 = function(method, error, transaction) {
  if (method === "call" && error.code === logger32.Logger.errors.SERVER_ERROR) {
    const e = error.error;
    if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
      let data = e.data;
      if (data) {
        data = "0x" + data.replace(/^.*0x/i, "");
      }
      if (isHexString(data)) {
        return data;
      }
      logger33.throwError("missing revert data in call exception", logger32.Logger.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  let message = error.message;
  if (error.code === logger32.Logger.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger33.throwError("insufficient funds for intrinsic transaction cost", logger32.Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger33.throwError("nonce has already been used", logger32.Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger33.throwError("replacement fee too low", logger32.Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger33.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger32.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
};
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger33 = new logger32.Logger(version7);

class EtherscanProvider extends BaseProvider {
  constructor(network, apiKey) {
    super(network);
    properties10.defineReadOnly(this, "baseUrl", this.getBaseUrl());
    properties10.defineReadOnly(this, "apiKey", apiKey || null);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "matic":
        return "https://api.polygonscan.com";
      case "maticmum":
        return "https://api-testnet.polygonscan.com";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
      default:
    }
    return logger33.throwArgumentError("unsupported network", "network", this.network.name);
  }
  getUrl(module, params) {
    const query = Object.keys(params).reduce((accum, key) => {
      const value = params[key];
      if (value != null) {
        accum += `&${key}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }
  fetch(module, params, post) {
    return __awaiter9(this, undefined, undefined, function* () {
      const url = post ? this.getPostUrl() : this.getUrl(module, params);
      const payload = post ? this.getPostData(module, params) : null;
      const procFunc = module === "proxy" ? getJsonResult : getResult2;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url,
        throttleSlotInterval: 1000,
        throttleCallback: (attempt, url2) => {
          if (this.isCommunityResource()) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      let payloadStr = null;
      if (payload) {
        connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
        payloadStr = Object.keys(payload).map((key) => {
          return `${key}=${payload[key]}`;
        }).join("&");
      }
      const result = yield web3.fetchJson(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: properties10.deepCopy(result),
        provider: this
      });
      return result;
    });
  }
  detectNetwork() {
    return __awaiter9(this, undefined, undefined, function* () {
      return this.network;
    });
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter9(this, undefined, undefined, function* () {
      switch (method) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch((error) => {
            return checkError2("sendTransaction", error, params.signedTransaction);
          });
        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });
        case "call": {
          if (params.blockTag !== "latest") {
            throw new Error("EtherscanProvider does not support blockTag for call");
          }
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_call";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("call", error, params.transaction);
          }
        }
        case "estimateGas": {
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_estimateGas";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("estimateGas", error, params.transaction);
          }
        }
        case "getLogs": {
          const args = { action: "getLogs" };
          if (params.filter.fromBlock) {
            args.fromBlock = checkLogTag(params.filter.fromBlock);
          }
          if (params.filter.toBlock) {
            args.toBlock = checkLogTag(params.filter.toBlock);
          }
          if (params.filter.address) {
            args.address = params.filter.address;
          }
          if (params.filter.topics && params.filter.topics.length > 0) {
            if (params.filter.topics.length > 1) {
              logger33.throwError("unsupported topic count", logger32.Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
            }
            if (params.filter.topics.length === 1) {
              const topic0 = params.filter.topics[0];
              if (typeof topic0 !== "string" || topic0.length !== 66) {
                logger33.throwError("unsupported topic format", logger32.Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
              }
              args.topic0 = topic0;
            }
          }
          const logs = yield this.fetch("logs", args);
          let blocks = {};
          for (let i = 0;i < logs.length; i++) {
            const log = logs[i];
            if (log.blockHash != null) {
              continue;
            }
            if (blocks[log.blockNumber] == null) {
              const block = yield this.getBlock(log.blockNumber);
              if (block) {
                blocks[log.blockNumber] = block.hash;
              }
            }
            log.blockHash = blocks[log.blockNumber];
          }
          return logs;
        }
        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0;
          }
          return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
        default:
          break;
      }
      return _super.perform.call(this, method, params);
    });
  }
  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter9(this, undefined, undefined, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map((tx) => {
        ["contractAddress", "to"].forEach(function(key) {
          if (tx[key] == "") {
            delete tx[key];
          }
        });
        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }
        const item = this.formatter.transactionResponse(tx);
        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }
        return item;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
}

// node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
var properties11 = __toESM(require_lib4(), 1);
var random = __toESM(require_lib21(), 1);
var web4 = __toESM(require_lib28(), 1);
var logger34 = __toESM(require_lib(), 1);
var now = function() {
  return new Date().getTime();
};
var checkNetworks = function(networks3) {
  let result = null;
  for (let i = 0;i < networks3.length; i++) {
    const network = networks3[i];
    if (network == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger35.throwArgumentError("provider mismatch", "networks", networks3);
      }
    } else {
      result = network;
    }
  }
  return result;
};
var median = function(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a = values[middle - 1], b3 = values[middle];
  if (maxDelta != null && Math.abs(a - b3) > maxDelta) {
    return null;
  }
  return (a + b3) / 2;
};
var serialize = function(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i) => serialize(i)));
  } else if (typeof value === "object") {
    const keys = Object.keys(value);
    keys.sort();
    return "{" + keys.map((key) => {
      let v2 = value[key];
      if (typeof v2 === "function") {
        v2 = "[function]";
      } else {
        v2 = serialize(v2);
      }
      return JSON.stringify(key) + ":" + v2;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
};
var stall2 = function(duration) {
  let cancel = null;
  let timer2 = null;
  let promise = new Promise((resolve) => {
    cancel = function() {
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
      }
      resolve();
    };
    timer2 = setTimeout(cancel, duration);
  });
  const wait = (func) => {
    promise = promise.then(func);
    return promise;
  };
  function getPromise() {
    return promise;
  }
  return { cancel, getPromise, wait };
};
var exposeDebugConfig = function(config, now2) {
  const result = {
    weight: config.weight
  };
  Object.defineProperty(result, "provider", { get: () => config.provider });
  if (config.start) {
    result.start = config.start;
  }
  if (now2) {
    result.duration = now2 - config.start;
  }
  if (config.done) {
    if (config.error) {
      result.error = config.error;
    } else {
      result.result = config.result || null;
    }
  }
  return result;
};
var normalizedTally = function(normalize, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c) => {
      const value = normalize(c.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c.result };
      }
      tally[value].count++;
    });
    const keys = Object.keys(tally);
    for (let i = 0;i < keys.length; i++) {
      const check = tally[keys[i]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return;
  };
};
var getProcessFunc = function(provider, method, params) {
  let normalize = serialize;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c) => c.result);
        let blockNumber = median(configs.map((c) => c.result), 2);
        if (blockNumber == null) {
          return;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c) => c.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c) => c.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = properties11.shallowCopy(tx);
        tx.confirmations = -1;
        return serialize(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          block = properties11.shallowCopy(block);
          block.transactions = block.transactions.map((tx) => {
            tx = properties11.shallowCopy(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize(block);
        };
      } else {
        normalize = function(block) {
          if (block == null) {
            return null;
          }
          return serialize(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize, provider.quorum);
};
var waitForSync = function(config, blockNumber) {
  return __awaiter10(this, undefined, undefined, function* () {
    const provider = config.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return web4.poll(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          }
          if (config.cancelled) {
            return resolve(null);
          }
          return resolve(undefined);
        }, 0);
      });
    }, { oncePoll: provider });
  });
};
var getRunner = function(config, currentBlockNumber, method, params) {
  return __awaiter10(this, undefined, undefined, function* () {
    let provider = config.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        if (method === "call" && params.blockTag) {
          return provider[method](params.transaction, params.blockTag);
        }
        return provider[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);
      case "getLogs": {
        let filter = params.filter;
        if (filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider.getLogs(filter);
      }
    }
    return logger35.throwError("unknown method error", logger34.Logger.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
};
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger35 = new logger34.Logger(version7);
var nextRid = 1;
var ForwardErrors = [
  logger34.Logger.errors.CALL_EXCEPTION,
  logger34.Logger.errors.INSUFFICIENT_FUNDS,
  logger34.Logger.errors.NONCE_EXPIRED,
  logger34.Logger.errors.REPLACEMENT_UNDERPRICED,
  logger34.Logger.errors.UNPREDICTABLE_GAS_LIMIT
];
var ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];

class FallbackProvider extends BaseProvider {
  constructor(providers, quorum) {
    if (providers.length === 0) {
      logger35.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index) => {
      if (Provider.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;
        const priority = 1;
        return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
      }
      const config = properties11.shallowCopy(configOrProvider);
      if (config.priority == null) {
        config.priority = 1;
      }
      if (config.stallTimeout == null) {
        config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;
      }
      if (config.weight == null) {
        config.weight = 1;
      }
      const weight = config.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger35.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
      }
      return Object.freeze(config);
    });
    const total = providerConfigs.reduce((accum, c) => accum + c.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger35.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    let networkOrReady = checkNetworks(providerConfigs.map((c) => c.provider.network));
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    properties11.defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
    properties11.defineReadOnly(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter10(this, undefined, undefined, function* () {
      const networks3 = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));
      return checkNetworks(networks3);
    });
  }
  perform(method, params) {
    return __awaiter10(this, undefined, undefined, function* () {
      if (method === "sendTransaction") {
        const results = yield Promise.all(this.providerConfigs.map((c) => {
          return c.provider.sendTransaction(params.signedTransaction).then((result) => {
            return result.hash;
          }, (error) => {
            return error;
          });
        }));
        for (let i3 = 0;i3 < results.length; i3++) {
          const result = results[i3];
          if (typeof result === "string") {
            return result;
          }
        }
        throw results[0];
      }
      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method, params);
      const configs = random.shuffled(this.providerConfigs.map(properties11.shallowCopy));
      configs.sort((a, b3) => a.priority - b3.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i = 0;
      let first = true;
      while (true) {
        const t02 = now();
        let inflightWeight = configs.filter((c) => c.runner && t02 - c.start < c.stallTimeout).reduce((accum, c) => accum + c.weight, 0);
        while (inflightWeight < this.quorum && i < configs.length) {
          const config = configs[i++];
          const rid = nextRid++;
          config.start = now();
          config.staller = stall2(config.stallTimeout);
          config.staller.wait(() => {
            config.staller = null;
          });
          config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {
            config.done = true;
            config.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config, now()),
                request: { method, params: properties11.deepCopy(params) },
                provider: this
              });
            }
          }, (error) => {
            config.done = true;
            config.error = error;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config, now()),
                request: { method, params: properties11.deepCopy(params) },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid,
              backend: exposeDebugConfig(config, null),
              request: { method, params: properties11.deepCopy(params) },
              provider: this
            });
          }
          inflightWeight += config.weight;
        }
        const waiting = [];
        configs.forEach((c) => {
          if (c.done || !c.runner) {
            return;
          }
          waiting.push(c.runner);
          if (c.staller) {
            waiting.push(c.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        const results = configs.filter((c) => c.done && c.error == null);
        if (results.length >= this.quorum) {
          const result = processFunc(results);
          if (result !== undefined) {
            configs.forEach((c) => {
              if (c.staller) {
                c.staller.cancel();
              }
              c.cancelled = true;
            });
            return result;
          }
          if (!first) {
            yield stall2(100).getPromise();
          }
          first = false;
        }
        const errors = configs.reduce((accum, c) => {
          if (!c.done || c.error == null) {
            return accum;
          }
          const code = c.error.code;
          if (ForwardErrors.indexOf(code) >= 0) {
            if (!accum[code]) {
              accum[code] = { error: c.error, weight: 0 };
            }
            accum[code].weight += c.weight;
          }
          return accum;
        }, {});
        Object.keys(errors).forEach((errorCode) => {
          const tally = errors[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          configs.forEach((c) => {
            if (c.staller) {
              c.staller.cancel();
            }
            c.cancelled = true;
          });
          const e = tally.error;
          const props = {};
          ForwardProperties.forEach((name) => {
            if (e[name] == null) {
              return;
            }
            props[name] = e[name];
          });
          logger35.throwError(e.reason || e.message, errorCode, props);
        });
        if (configs.filter((c) => !c.done).length === 0) {
          break;
        }
      }
      configs.forEach((c) => {
        if (c.staller) {
          c.staller.cancel();
        }
        c.cancelled = true;
      });
      return logger35.throwError("failed to meet quorum", logger34.Logger.errors.SERVER_ERROR, {
        method,
        params,
        results: configs.map((c) => exposeDebugConfig(c)),
        provider: this
      });
    });
  }
}

// node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
var IpcProvider = null;

// node_modules/@ethersproject/providers/lib.esm/infura-provider.js
var properties12 = __toESM(require_lib4(), 1);
var logger36 = __toESM(require_lib(), 1);
var logger37 = new logger36.Logger(version7);
var defaultProjectId = "84842078b09946638c03157f83405213";

class InfuraWebSocketProvider extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new InfuraProvider(network, apiKey);
    const connection = provider.connection;
    if (connection.password) {
      logger37.throwError("INFURA WebSocket project secrets unsupported", logger36.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    properties12.defineReadOnly(this, "apiKey", provider.projectId);
    properties12.defineReadOnly(this, "projectId", provider.projectId);
    properties12.defineReadOnly(this, "projectSecret", provider.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}

class InfuraProvider extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger37.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger37.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;
      case "goerli":
        host = "goerli.infura.io";
        break;
      case "sepolia":
        host = "sepolia.infura.io";
        break;
      case "matic":
        host = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;
      case "optimism-goerli":
        host = "optimism-goerli.infura.io";
        break;
      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-goerli":
        host = "arbitrum-goerli.infura.io";
        break;
      default:
        logger37.throwError("unsupported network", logger36.Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const connection = {
      allowGzip: true,
      url: "https://" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}

// node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
var properties13 = __toESM(require_lib4(), 1);
var web5 = __toESM(require_lib28(), 1);
class JsonRpcBatchProvider extends JsonRpcProvider {
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }
    const inflightRequest = { request, resolve: null, reject: null };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        const batch = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null;
        const request2 = batch.map((inflight) => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: properties13.deepCopy(request2),
          provider: this
        });
        return web5.fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
          this.emit("debug", {
            action: "response",
            request: request2,
            response: result,
            provider: this
          });
          batch.forEach((inflightRequest2, index) => {
            const payload = result[index];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest2.reject(error);
            } else {
              inflightRequest2.resolve(payload.result);
            }
          });
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request: request2,
            provider: this
          });
          batch.forEach((inflightRequest2) => {
            inflightRequest2.reject(error);
          });
        });
      }, 10);
    }
    return promise;
  }
}

// node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
var logger38 = __toESM(require_lib(), 1);
var logger39 = new logger38.Logger(version7);
var defaultApiKey3 = "ETHERS_JS_SHARED";

class NodesmithProvider extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger39.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey || defaultApiKey3;
  }
  static getUrl(network, apiKey) {
    logger39.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger39.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host + "?apiKey=" + apiKey;
  }
}

// node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
var logger40 = __toESM(require_lib(), 1);
var logger41 = new logger40.Logger(version7);
var defaultApplicationId = "62e1ad51b37b8e00394bda3b";

class PocketProvider extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    const apiKeyObj = {
      applicationId: null,
      loadBalancer: true,
      applicationSecretKey: null
    };
    if (apiKey == null) {
      apiKeyObj.applicationId = defaultApplicationId;
    } else if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
    } else if (apiKey.applicationId) {
      apiKeyObj.applicationId = apiKey.applicationId;
    } else {
      logger41.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;
      case "kovan":
        host = "poa-kovan.gateway.pokt.network";
        break;
      case "matic":
        host = "poly-mainnet.gateway.pokt.network";
        break;
      case "maticmum":
        host = "polygon-mumbai-rpc.gateway.pokt.network";
        break;
      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;
      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;
      default:
        logger41.throwError("unsupported network", logger40.Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const url = `https://${host}/v1/lb/${apiKey.applicationId}`;
    const connection = { headers: {}, url };
    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }
    return connection;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
}

// node_modules/@ethersproject/providers/lib.esm/web3-provider.js
var properties14 = __toESM(require_lib4(), 1);
var logger42 = __toESM(require_lib(), 1);
var buildWeb3LegacyFetcher = function(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: properties14.deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
};
var buildEip1193Fetcher = function(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: properties14.deepCopy(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
};
var logger43 = new logger42.Logger(version7);
var _nextId = 1;

class Web3Provider extends JsonRpcProvider {
  constructor(provider, network) {
    if (provider == null) {
      logger43.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger43.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    properties14.defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    properties14.defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
}

// node_modules/@ethersproject/providers/lib.esm/index.js
var logger44 = __toESM(require_lib(), 1);
var getDefaultProvider = function(network, options) {
  if (network == null) {
    network = "homestead";
  }
  if (typeof network === "string") {
    const match = network.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1].toLowerCase()) {
        case "http":
        case "https":
          return new JsonRpcProvider(network);
        case "ws":
        case "wss":
          return new WebSocketProvider(network);
        default:
          logger45.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n = getNetwork(network);
  if (!n || !n._defaultProvider) {
    logger45.throwError("unsupported getDefaultProvider network", logger44.Logger.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network
    });
  }
  return n._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    AnkrProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
};
var logger45 = new logger44.Logger(version7);

// node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var hash3 = __toESM(require_lib12(), 1);
var properties15 = __toESM(require_lib4(), 1);
var logger46 = __toESM(require_lib(), 1);

// node_modules/@ethersproject/wordlists/lib.esm/_version.js
var version8 = "wordlists/5.7.0";

// node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var exportWordlist = false;
var logger47 = new logger46.Logger(version8);

class Wordlist {
  constructor(locale) {
    logger47.checkAbstract(new.target, Wordlist);
    properties15.defineReadOnly(this, "locale", locale);
  }
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  join(words) {
    return words.join(" ");
  }
  static check(wordlist) {
    const words = [];
    for (let i = 0;i < 2048; i++) {
      const word = wordlist.getWord(i);
      if (i !== wordlist.getWordIndex(word)) {
        return "0x";
      }
      words.push(word);
    }
    return hash3.id(words.join("\n") + "\n");
  }
  static register(lang, name) {
    if (!name) {
      name = lang.locale;
    }
    if (exportWordlist) {
      try {
        const anyGlobal = window;
        if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {
          if (!anyGlobal._ethers.wordlists[name]) {
            properties15.defineReadOnly(anyGlobal._ethers.wordlists, name, lang);
          }
        }
      } catch (error) {
      }
    }
  }
}

// node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
var loadWords = function(lang) {
  if (wordlist2 != null) {
    return;
  }
  wordlist2 = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist2 = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
};
var words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
var wordlist2 = null;

class LangEn extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(index) {
    loadWords(this);
    return wordlist2[index];
  }
  getWordIndex(word) {
    loadWords(this);
    return wordlist2.indexOf(word);
  }
}
var langEn = new LangEn;
Wordlist.register(langEn);

// node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
var wordlists = {
  en: langEn
};

// node_modules/ethers/lib.esm/utils.js
var exports_utils = {};
__export(exports_utils, {
  zeroPad: () => {
    {
      return zeroPad;
    }
  },
  verifyTypedData: () => {
    {
      return wallet.verifyTypedData;
    }
  },
  verifyMessage: () => {
    {
      return wallet.verifyMessage;
    }
  },
  toUtf8String: () => {
    {
      return strings3.toUtf8String;
    }
  },
  toUtf8CodePoints: () => {
    {
      return strings3.toUtf8CodePoints;
    }
  },
  toUtf8Bytes: () => {
    {
      return strings3.toUtf8Bytes;
    }
  },
  stripZeros: () => {
    {
      return stripZeros;
    }
  },
  splitSignature: () => {
    {
      return splitSignature;
    }
  },
  soliditySha256: () => {
    {
      return solidity.sha256;
    }
  },
  solidityPack: () => {
    {
      return solidity.pack;
    }
  },
  solidityKeccak256: () => {
    {
      return solidity.keccak256;
    }
  },
  shuffled: () => {
    {
      return random2.shuffled;
    }
  },
  shallowCopy: () => {
    {
      return properties16.shallowCopy;
    }
  },
  sha512: () => {
    {
      return sha22.sha512;
    }
  },
  sha256: () => {
    {
      return sha22.sha256;
    }
  },
  serializeTransaction: () => {
    {
      return transactions5.serialize;
    }
  },
  ripemd160: () => {
    {
      return sha22.ripemd160;
    }
  },
  resolveProperties: () => {
    {
      return properties16.resolveProperties;
    }
  },
  recoverPublicKey: () => {
    {
      return signing_key.recoverPublicKey;
    }
  },
  recoverAddress: () => {
    {
      return transactions5.recoverAddress;
    }
  },
  randomBytes: () => {
    {
      return random2.randomBytes;
    }
  },
  poll: () => {
    {
      return web6.poll;
    }
  },
  parseUnits: () => {
    {
      return units.parseUnits;
    }
  },
  parseTransaction: () => {
    {
      return transactions5.parse;
    }
  },
  parseEther: () => {
    {
      return units.parseEther;
    }
  },
  parseBytes32String: () => {
    {
      return strings3.parseBytes32String;
    }
  },
  nameprep: () => {
    {
      return strings3.nameprep;
    }
  },
  namehash: () => {
    {
      return hash4.namehash;
    }
  },
  mnemonicToSeed: () => {
    {
      return hdnode.mnemonicToSeed;
    }
  },
  mnemonicToEntropy: () => {
    {
      return hdnode.mnemonicToEntropy;
    }
  },
  keccak256: () => {
    {
      return keccak256.keccak256;
    }
  },
  joinSignature: () => {
    {
      return joinSignature;
    }
  },
  isValidName: () => {
    {
      return hash4.isValidName;
    }
  },
  isValidMnemonic: () => {
    {
      return hdnode.isValidMnemonic;
    }
  },
  isHexString: () => {
    {
      return isHexString;
    }
  },
  isBytesLike: () => {
    {
      return isBytesLike;
    }
  },
  isBytes: () => {
    {
      return isBytes;
    }
  },
  isAddress: () => {
    {
      return address3.isAddress;
    }
  },
  id: () => {
    {
      return hash4.id;
    }
  },
  hexlify: () => {
    {
      return hexlify;
    }
  },
  hexZeroPad: () => {
    {
      return hexZeroPad;
    }
  },
  hexValue: () => {
    {
      return hexValue;
    }
  },
  hexStripZeros: () => {
    {
      return hexStripZeros;
    }
  },
  hexDataSlice: () => {
    {
      return hexDataSlice;
    }
  },
  hexDataLength: () => {
    {
      return hexDataLength;
    }
  },
  hexConcat: () => {
    {
      return hexConcat;
    }
  },
  hashMessage: () => {
    {
      return hash4.hashMessage;
    }
  },
  getStatic: () => {
    {
      return properties16.getStatic;
    }
  },
  getJsonWalletAddress: () => {
    {
      return json_wallets.getJsonWalletAddress;
    }
  },
  getIcapAddress: () => {
    {
      return address3.getIcapAddress;
    }
  },
  getCreate2Address: () => {
    {
      return address3.getCreate2Address;
    }
  },
  getContractAddress: () => {
    {
      return address3.getContractAddress;
    }
  },
  getAddress: () => {
    {
      return address3.getAddress;
    }
  },
  getAccountPath: () => {
    {
      return hdnode.getAccountPath;
    }
  },
  formatUnits: () => {
    {
      return units.formatUnits;
    }
  },
  formatEther: () => {
    {
      return units.formatEther;
    }
  },
  formatBytes32String: () => {
    {
      return strings3.formatBytes32String;
    }
  },
  fetchJson: () => {
    {
      return web6.fetchJson;
    }
  },
  entropyToMnemonic: () => {
    {
      return hdnode.entropyToMnemonic;
    }
  },
  dnsEncode: () => {
    {
      return hash4.dnsEncode;
    }
  },
  defineReadOnly: () => {
    {
      return properties16.defineReadOnly;
    }
  },
  defaultPath: () => {
    {
      return hdnode.defaultPath;
    }
  },
  defaultAbiCoder: () => {
    {
      return abi2.defaultAbiCoder;
    }
  },
  deepCopy: () => {
    {
      return properties16.deepCopy;
    }
  },
  concat: () => {
    {
      return concat;
    }
  },
  computePublicKey: () => {
    {
      return signing_key.computePublicKey;
    }
  },
  computeHmac: () => {
    {
      return sha22.computeHmac;
    }
  },
  computeAddress: () => {
    {
      return transactions5.computeAddress;
    }
  },
  commify: () => {
    {
      return units.commify;
    }
  },
  checkResultErrors: () => {
    {
      return abi2.checkResultErrors;
    }
  },
  checkProperties: () => {
    {
      return properties16.checkProperties;
    }
  },
  base64: () => {
    {
      return base642;
    }
  },
  base58: () => {
    {
      return basex2.Base58;
    }
  },
  arrayify: () => {
    {
      return arrayify;
    }
  },
  accessListify: () => {
    {
      return transactions5.accessListify;
    }
  },
  _toEscapedUtf8String: () => {
    {
      return strings3._toEscapedUtf8String;
    }
  },
  _fetchData: () => {
    {
      return web6._fetchData;
    }
  },
  _TypedDataEncoder: () => {
    {
      return hash4._TypedDataEncoder;
    }
  },
  Utf8ErrorReason: () => {
    {
      return strings4.Utf8ErrorReason;
    }
  },
  Utf8ErrorFuncs: () => {
    {
      return strings3.Utf8ErrorFuncs;
    }
  },
  UnicodeNormalizationForm: () => {
    {
      return strings4.UnicodeNormalizationForm;
    }
  },
  TransactionTypes: () => {
    {
      return transactions5.TransactionTypes;
    }
  },
  TransactionDescription: () => {
    {
      return abi2.TransactionDescription;
    }
  },
  SupportedAlgorithm: () => {
    {
      return sha23.SupportedAlgorithm;
    }
  },
  SigningKey: () => {
    {
      return signing_key.SigningKey;
    }
  },
  RLP: () => {
    {
      return RLP;
    }
  },
  ParamType: () => {
    {
      return abi2.ParamType;
    }
  },
  Logger: () => {
    {
      return logger48.Logger;
    }
  },
  LogDescription: () => {
    {
      return abi2.LogDescription;
    }
  },
  Interface: () => {
    {
      return abi2.Interface;
    }
  },
  Indexed: () => {
    {
      return abi2.Indexed;
    }
  },
  HDNode: () => {
    {
      return hdnode.HDNode;
    }
  },
  FunctionFragment: () => {
    {
      return abi2.FunctionFragment;
    }
  },
  Fragment: () => {
    {
      return abi2.Fragment;
    }
  },
  FormatTypes: () => {
    {
      return abi2.FormatTypes;
    }
  },
  EventFragment: () => {
    {
      return abi2.EventFragment;
    }
  },
  ErrorFragment: () => {
    {
      return abi2.ErrorFragment;
    }
  },
  ConstructorFragment: () => {
    {
      return abi2.ConstructorFragment;
    }
  },
  AbiCoder: () => {
    {
      return abi2.AbiCoder;
    }
  }
});
var abi2 = __toESM(require_lib13(), 1);
var address3 = __toESM(require_lib7(), 1);
var base642 = __toESM(require_lib10(), 1);
var basex2 = __toESM(require_lib14(), 1);
var hash4 = __toESM(require_lib12(), 1);
var hdnode = __toESM(require_lib20(), 1);
var json_wallets = __toESM(require_lib22(), 1);
var keccak256 = __toESM(require_lib5(), 1);
var logger48 = __toESM(require_lib(), 1);
var sha22 = __toESM(require_lib15(), 1);
var solidity = __toESM(require_lib23(), 1);
var random2 = __toESM(require_lib21(), 1);
var properties16 = __toESM(require_lib4(), 1);
var RLP = __toESM(require_lib6(), 1);
var signing_key = __toESM(require_lib17(), 1);
var strings3 = __toESM(require_lib9(), 1);
var transactions5 = __toESM(require_lib18(), 1);
var units = __toESM(require_lib24(), 1);
var wallet = __toESM(require_lib27(), 1);
var web6 = __toESM(require_lib28(), 1);
var sha23 = __toESM(require_lib15(), 1);
var strings4 = __toESM(require_lib9(), 1);

// node_modules/ethers/lib.esm/ethers.js
var logger49 = __toESM(require_lib(), 1);

// node_modules/ethers/lib.esm/_version.js
var version9 = "ethers/5.7.2";

// node_modules/ethers/lib.esm/ethers.js
var logger50 = new logger49.Logger(version9);

// node_modules/ethers/lib.esm/index.js
try {
  const anyGlobal = window;
  if (anyGlobal._ethers == null) {
    anyGlobal._ethers = exports_ethers;
  }
} catch (error) {
}

// node_modules/@aave/contract-helpers/dist/esm/cl-feed-registry/typechain/FeedRegistryInterface__factory.js
class FeedRegistryInterface__factory {
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi, signerOrProvider);
  }
}
var _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "base",
        type: "address"
      },
      {
        internalType: "address",
        name: "quote",
        type: "address"
      }
    ],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "base",
        type: "address"
      },
      {
        internalType: "address",
        name: "quote",
        type: "address"
      }
    ],
    name: "description",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "base",
        type: "address"
      },
      {
        internalType: "address",
        name: "quote",
        type: "address"
      }
    ],
    name: "latestRoundData",
    outputs: [
      {
        internalType: "uint80",
        name: "roundId",
        type: "uint80"
      },
      {
        internalType: "int256",
        name: "answer",
        type: "int256"
      },
      {
        internalType: "uint256",
        name: "startedAt",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "updatedAt",
        type: "uint256"
      },
      {
        internalType: "uint80",
        name: "answeredInRound",
        type: "uint80"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@aave/contract-helpers/dist/esm/cl-feed-registry/types/ChainlinkFeedsRegistryTypes.js
var Denominations;
(function(Denominations2) {
  Denominations2["eth"] = "eth";
  Denominations2["usd"] = "usd";
})(Denominations || (Denominations = {}));
var DenominationAddresses;
(function(DenominationAddresses2) {
  DenominationAddresses2["eth"] = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
  DenominationAddresses2["usd"] = "0x0000000000000000000000000000000000000348";
})(DenominationAddresses || (DenominationAddresses = {}));

// node_modules/@aave/contract-helpers/dist/esm/cl-feed-registry/index.js
class ChainlinkFeedsRegistry {
  constructor({ provider, chainlinkFeedsRegistry }) {
    this.latestRoundData = async (tokenAddress, quote) => {
      if (!utils.isAddress(tokenAddress)) {
        throw new Error("tokenAddress is not valid");
      }
      return this._registryContract.latestRoundData(tokenAddress, DenominationAddresses[quote]);
    };
    this.decimals = async (tokenAddress, quote) => {
      if (!utils.isAddress(tokenAddress)) {
        throw new Error("tokenAddress is not valid");
      }
      return this._registryContract.decimals(tokenAddress, DenominationAddresses[quote]);
    };
    this.getPriceFeed = async (tokenAddress, quote) => {
      const rawFeed = await this.latestRoundData(tokenAddress, quote);
      const feedDecimals = await this.decimals(tokenAddress, quote);
      return {
        answer: rawFeed[1].toString(),
        updatedAt: rawFeed[3].toNumber(),
        decimals: feedDecimals
      };
    };
    if (!utils.isAddress(chainlinkFeedsRegistry)) {
      throw new Error("contract address is not valid");
    }
    this._registryContract = FeedRegistryInterface__factory.connect(chainlinkFeedsRegistry, provider);
  }
}

// node_modules/@aave/contract-helpers/dist/esm/commons/types.js
var InterestRate;
(function(InterestRate2) {
  InterestRate2["None"] = "None";
  InterestRate2["Stable"] = "Stable";
  InterestRate2["Variable"] = "Variable";
})(InterestRate || (InterestRate = {}));
var ChainId;
(function(ChainId2) {
  ChainId2[ChainId2["mainnet"] = 1] = "mainnet";
  ChainId2[ChainId2["ropsten"] = 3] = "ropsten";
  ChainId2[ChainId2["rinkeby"] = 4] = "rinkeby";
  ChainId2[ChainId2["goerli"] = 5] = "goerli";
  ChainId2[ChainId2["kovan"] = 42] = "kovan";
  ChainId2[ChainId2["xdai"] = 100] = "xdai";
  ChainId2[ChainId2["polygon"] = 137] = "polygon";
  ChainId2[ChainId2["mumbai"] = 80001] = "mumbai";
  ChainId2[ChainId2["avalanche"] = 43114] = "avalanche";
  ChainId2[ChainId2["fuji"] = 43113] = "fuji";
  ChainId2[ChainId2["arbitrum_one"] = 42161] = "arbitrum_one";
  ChainId2[ChainId2["arbitrum_rinkeby"] = 421611] = "arbitrum_rinkeby";
  ChainId2[ChainId2["arbitrum_goerli"] = 421613] = "arbitrum_goerli";
  ChainId2[ChainId2["fantom"] = 250] = "fantom";
  ChainId2[ChainId2["fantom_testnet"] = 4002] = "fantom_testnet";
  ChainId2[ChainId2["optimism"] = 10] = "optimism";
  ChainId2[ChainId2["optimism_kovan"] = 69] = "optimism_kovan";
  ChainId2[ChainId2["optimism_goerli"] = 420] = "optimism_goerli";
  ChainId2[ChainId2["harmony"] = 1666600000] = "harmony";
  ChainId2[ChainId2["harmony_testnet"] = 1666700000] = "harmony_testnet";
  ChainId2[ChainId2["zkevm_testnet"] = 1402] = "zkevm_testnet";
  ChainId2[ChainId2["sepolia"] = 11155111] = "sepolia";
  ChainId2[ChainId2["scroll_alpha"] = 534353] = "scroll_alpha";
  ChainId2[ChainId2["scroll_sepolia"] = 534351] = "scroll_sepolia";
  ChainId2[ChainId2["scroll"] = 534352] = "scroll";
  ChainId2[ChainId2["metis_andromeda"] = 1088] = "metis_andromeda";
  ChainId2[ChainId2["base"] = 8453] = "base";
  ChainId2[ChainId2["bnb"] = 56] = "bnb";
})(ChainId || (ChainId = {}));
var eEthereumTxType;
(function(eEthereumTxType2) {
  eEthereumTxType2["ERC20_APPROVAL"] = "ERC20_APPROVAL";
  eEthereumTxType2["DLP_ACTION"] = "DLP_ACTION";
  eEthereumTxType2["GOVERNANCE_ACTION"] = "GOVERNANCE_ACTION";
  eEthereumTxType2["GOV_DELEGATION_ACTION"] = "GOV_DELEGATION_ACTION";
  eEthereumTxType2["STAKE_ACTION"] = "STAKE_ACTION";
  eEthereumTxType2["MIGRATION_LEND_AAVE"] = "MIGRATION_LEND_AAVE";
  eEthereumTxType2["FAUCET_MINT"] = "FAUCET_MINT";
  eEthereumTxType2["REWARD_ACTION"] = "REWARD_ACTION";
  eEthereumTxType2["V3_MIGRATION_ACTION"] = "V3_MIGRATION_ACTION";
  eEthereumTxType2["FAUCET_V2_MINT"] = "FAUCET_V2_MINT";
})(eEthereumTxType || (eEthereumTxType = {}));
var ProtocolAction;
(function(ProtocolAction2) {
  ProtocolAction2["default"] = "default";
  ProtocolAction2["supply"] = "supply";
  ProtocolAction2["borrow"] = "borrow";
  ProtocolAction2["withdraw"] = "withdraw";
  ProtocolAction2["deposit"] = "deposit";
  ProtocolAction2["liquidationCall"] = "liquidationCall";
  ProtocolAction2["liquidationFlash"] = "liquidationFlash";
  ProtocolAction2["repay"] = "repay";
  ProtocolAction2["repayETH"] = "repayETH";
  ProtocolAction2["repayWithATokens"] = "repayWithATokens";
  ProtocolAction2["swapCollateral"] = "swapCollateral";
  ProtocolAction2["repayCollateral"] = "repayCollateral";
  ProtocolAction2["withdrawETH"] = "withdrawETH";
  ProtocolAction2["borrowETH"] = "borrwoETH";
  ProtocolAction2["migrateV3"] = "migrateV3";
  ProtocolAction2["supplyWithPermit"] = "supplyWithPermit";
  ProtocolAction2["repayWithPermit"] = "repayWithPermit";
  ProtocolAction2["stakeWithPermit"] = "stakeWithPermit";
  ProtocolAction2["vote"] = "vote";
  ProtocolAction2["approval"] = "approval";
  ProtocolAction2["creditDelegationApproval"] = "creditDelegationApproval";
  ProtocolAction2["stake"] = "stake";
  ProtocolAction2["stakeCooldown"] = "stakeCooldown";
  ProtocolAction2["unstake"] = "unstake";
  ProtocolAction2["switchBorrowRateMode"] = "switchBorrowRateMode";
  ProtocolAction2["setEModeUsage"] = "setEModeUsage";
  ProtocolAction2["governanceDelegation"] = "governanceDelegation";
  ProtocolAction2["claimRewards"] = "claimRewards";
  ProtocolAction2["claimRewardsAndStake"] = "claimRewardsAndStake";
  ProtocolAction2["setUsageAsCollateral"] = "setUsageAsCollateral";
  ProtocolAction2["withdrawAndSwitch"] = "withdrawAndSwitch";
  ProtocolAction2["batchMetaDelegate"] = "batchMetaDelegate";
  ProtocolAction2["updateRepresentatives"] = "updateRepresentatives";
})(ProtocolAction || (ProtocolAction = {}));
var GovernanceVote;
(function(GovernanceVote2) {
  GovernanceVote2[GovernanceVote2["Abstain"] = 0] = "Abstain";
  GovernanceVote2[GovernanceVote2["Yes"] = 1] = "Yes";
  GovernanceVote2[GovernanceVote2["No"] = 2] = "No";
})(GovernanceVote || (GovernanceVote = {}));
var Stake;
(function(Stake2) {
  Stake2["aave"] = "aave";
  Stake2["bpt"] = "bpt";
})(Stake || (Stake = {}));
var DEFAULT_DEADLINE = Math.floor(Date.now() / 1000 + 3600).toString();

// node_modules/@aave/contract-helpers/dist/esm/commons/gasStation.js
var DEFAULT_SURPLUS = 30;
var POLYGON_SURPLUS = 60;
var estimateGasByNetwork = async (tx, provider, gasSurplus) => {
  const estimatedGas = await provider.estimateGas(tx);
  const providerNework = await provider.getNetwork();
  if (providerNework.chainId === ChainId.polygon) {
    return estimatedGas.add(estimatedGas.mul(POLYGON_SURPLUS).div(100));
  }
  return estimatedGas.add(estimatedGas.mul(gasSurplus !== null && gasSurplus !== undefined ? gasSurplus : DEFAULT_SURPLUS).div(100));
};

// node_modules/bignumber.js/bignumber.mjs
var clone = function(configObject) {
  var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE2 = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "\xA0",
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v2, b3) {
    var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
    if (!(x instanceof BigNumber2))
      return new BigNumber2(v2, b3);
    if (b3 == null) {
      if (v2 && v2._isBigNumber === true) {
        x.s = v2.s;
        if (!v2.c || v2.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v2.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v2.e;
          x.c = v2.c.slice();
        }
        return;
      }
      if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
        x.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
        if (v2 === ~~v2) {
          for (e = 0, i = v2;i >= 10; i /= 10, e++)
            ;
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v2];
          }
          return;
        }
        str = String(v2);
      } else {
        if (!isNumeric.test(str = String(v2)))
          return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0)
          e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b3, 2, ALPHABET.length, "Base");
      if (b3 == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v2);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str = String(v2);
      if (isNum = typeof v2 == "number") {
        if (v2 * 0 != 0)
          return parseNumeric(x, str, isNum, b3);
        x.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v2);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b3);
      e = i = 0;
      for (len = str.length;i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v2), isNum, b3);
        }
      }
      isNum = false;
      str = convertBase(str, b3, 10, x.s);
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e = str.length;
    }
    for (i = 0;str.charCodeAt(i) === 48; i++)
      ;
    for (len = str.length;str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
        throw Error(tooManyDigits + x.s * v2);
      }
      if ((e = e - i - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0)
          i += LOG_BASE;
        if (i < len) {
          if (i)
            x.c.push(+str.slice(0, i));
          for (len -= LOG_BASE;i < len; ) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (;i--; str += "0")
          ;
        x.c.push(+str);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v2;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v2 = obj[p];
          intCheck(v2, 0, MAX, p);
          DECIMAL_PLACES = v2;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v2 = obj[p];
          intCheck(v2, 0, 8, p);
          ROUNDING_MODE = v2;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v2 = obj[p];
          if (v2 && v2.pop) {
            intCheck(v2[0], -MAX, 0, p);
            intCheck(v2[1], 0, MAX, p);
            TO_EXP_NEG = v2[0];
            TO_EXP_POS = v2[1];
          } else {
            intCheck(v2, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v2 = obj[p];
          if (v2 && v2.pop) {
            intCheck(v2[0], -MAX, -1, p);
            intCheck(v2[1], 1, MAX, p);
            MIN_EXP = v2[0];
            MAX_EXP = v2[1];
          } else {
            intCheck(v2, -MAX, MAX, p);
            if (v2) {
              MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v2);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v2 = obj[p];
          if (v2 === !!v2) {
            if (v2) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v2;
              } else {
                CRYPTO = !v2;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v2;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v2);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v2 = obj[p];
          intCheck(v2, 0, 9, p);
          MODULO_MODE = v2;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v2 = obj[p];
          intCheck(v2, 0, MAX, p);
          POW_PRECISION = v2;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v2 = obj[p];
          if (typeof v2 == "object")
            FORMAT = v2;
          else
            throw Error(bignumberError + p + " not an object: " + v2);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v2 = obj[p];
          if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
            alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
            ALPHABET = v2;
          } else {
            throw Error(bignumberError + p + " invalid: " + v2);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v2) {
    if (!v2 || v2._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i, n, c = v2.c, e = v2.e, s = v2.s;
    out:
      if ({}.toString.call(c) == "[object Array]") {
        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
          if (c[0] === 0) {
            if (e === 0 && c.length === 1)
              return true;
            break out;
          }
          i = (e + 1) % LOG_BASE;
          if (i < 1)
            i += LOG_BASE;
          if (String(c[0]).length == i) {
            for (i = 0;i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n))
                break out;
            }
            if (n !== 0)
              return true;
          }
        }
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v2);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b3, e, k, v2, i = 0, c = [], rand = new BigNumber2(ONE2);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (;i < k; ) {
            v2 = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v2 >= 9000000000000000) {
              b3 = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b3[0];
              a[i + 1] = b3[1];
            } else {
              c.push(v2 % 100000000000000);
              i += 2;
            }
          }
          i = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (;i < k; ) {
            v2 = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v2 >= 9000000000000000) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v2 % 100000000000000);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (;i < k; ) {
          v2 = random53bitInt();
          if (v2 < 9000000000000000)
            c[i++] = v2 % 100000000000000;
        }
      }
      k = c[--i];
      dp %= LOG_BASE;
      if (k && dp) {
        v2 = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v2) * v2;
      }
      for (;c[i] === 0; c.pop(), i--)
        ;
      if (i < 0) {
        c = [e = 0];
      } else {
        for (e = -1;c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
          ;
        for (i = 1, v2 = c[0];v2 >= 10; v2 /= 10, i++)
          ;
        if (i < LOG_BASE)
          e -= LOG_BASE - i;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (;i < args.length; )
      sum = sum.plus(args[i++]);
    return sum;
  };
  convertBase = function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j, arr = [0], arrL, i = 0, len = str.length;
      for (;i < len; ) {
        for (arrL = arr.length;arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet.indexOf(str.charAt(i++));
        for (j = 0;j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null)
              arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y = new BigNumber2(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;
        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
        y.e = y.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e = k = xc.length;
      for (;xc[--k] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet.charAt(0);
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }
      d = e + dp + 1;
      i = xc[d];
      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d;
        if (r) {
          for (--baseOut;++xc[--d] > baseOut; ) {
            xc[d] = 0;
            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length;!xc[--k]; )
          ;
        for (i = 0, str = "";i <= k; str += alphabet.charAt(xc[i++]))
          ;
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply(x, k, base) {
      var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice();i--; ) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }
      if (carry)
        x = [carry].concat(x);
      return x;
    }
    function compare(a, b3, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0;i < aL; i++) {
          if (a[i] != b3[i]) {
            cmp = a[i] > b3[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b3, aL, base) {
      var i = 0;
      for (;aL--; ) {
        a[aL] -= i;
        i = a[aL] < b3[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b3[aL];
      }
      for (;!a[0] && a.length > 1; a.splice(0, 1))
        ;
    }
    return function(x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0;yc[i] == (xc[i] || 0); i++)
        ;
      if (yc[i] > (xc[i] || 0))
        e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n = mathfloor(base / (yc[0] + 1));
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (;remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n = 0;
          cmp = compare(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base)
                n = base - 1;
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare(prod, rem, prodL, remL) == 1) {
                n--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare(yc, rem, yL, remL) < 1) {
                n++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i = 1, s = qc[0];s >= 10; s /= 10, i++)
          ;
        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  }();
  function format(n, i, rm, id3) {
    var c02, e, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n.c)
      return n.toString();
    c02 = n.c[0];
    ne = n.e;
    if (i == null) {
      str = coeffToString(n.c);
      str = id3 == 1 || id3 == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n = round(new BigNumber2(n), i, rm);
      e = n.e;
      str = coeffToString(n.c);
      len = str.length;
      if (id3 == 1 || id3 == 2 && (i <= e || e <= TO_EXP_NEG)) {
        for (;len < i; str += "0", len++)
          ;
        str = toExponential(str, e);
      } else {
        i -= ne;
        str = toFixedPoint(str, e, "0");
        if (e + 1 > len) {
          if (--i > 0)
            for (str += ".";i--; str += "0")
              ;
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len)
              str += ".";
            for (;i--; str += "0")
              ;
          }
        }
      }
    }
    return n.s < 0 && c02 ? "-" + str : str;
  }
  function maxOrMin(args, n) {
    var k, y, i = 1, x = new BigNumber2(args[0]);
    for (;i < args.length; i++) {
      y = new BigNumber2(args[i]);
      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
        x = y;
      }
    }
    return x;
  }
  function normalise(n, c, e) {
    var i = 1, j = c.length;
    for (;!c[--j]; c.pop())
      ;
    for (j = c[0];j >= 10; j /= 10, i++)
      ;
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }
    return n;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str, isNum, b3) {
      var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b3 || b3 == base ? p1 : m;
          });
          if (b3) {
            base = b3;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s)
            return new BigNumber2(s, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b3 ? " base " + b3 : "") + " number: " + str);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  }();
  function round(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0];k >= 10; k /= 10, d++)
          ;
        i = sd - d;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];
          rd = mathfloor(n / pows10[d - j - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (;xc.length <= ni; xc.push(0))
                ;
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];
            for (d = 1;k >= 10; k /= 10, d++)
              ;
            i %= LOG_BASE;
            j = i - LOG_BASE + d;
            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
          }
        }
        r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r) {
          for (;; ) {
            if (ni == 0) {
              for (i = 1, j = xc[0];j >= 10; j /= 10, i++)
                ;
              j = xc[0] += k;
              for (k = 1;j >= 10; j /= 10, k++)
                ;
              if (i != k) {
                x.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i = xc.length;xc[--i] === 0; xc.pop())
          ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n) {
    var str, e = n.e;
    if (e === null)
      return n.toString();
    str = coeffToString(n.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
    return n.s < 0 ? "-" + str : str;
  }
  P.absoluteValue = P.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0)
      x.s = 1;
    return x;
  };
  P.comparedTo = function(y, b3) {
    return compare(this, new BigNumber2(y, b3));
  };
  P.decimalPlaces = P.dp = function(dp, rm) {
    var c, n, v2, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c))
      return null;
    n = ((v2 = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v2 = c[v2])
      for (;v2 % 10 == 0; v2 /= 10, n--)
        ;
    if (n < 0)
      n = 0;
    return n;
  };
  P.dividedBy = P.div = function(y, b3) {
    return div(this, new BigNumber2(y, b3), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P.dividedToIntegerBy = P.idiv = function(y, b3) {
    return div(this, new BigNumber2(y, b3), 0, 1);
  };
  P.exponentiatedBy = P.pow = function(n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
    n = new BigNumber2(n);
    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
    }
    if (m != null)
      m = new BigNumber2(m);
    nIsBig = n.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp)
        x = x.mod(m);
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 240000000 : x.c[0] < 80000000000000 || nIsBig && x.c[0] <= 99999750000000))) {
      k = x.s < 0 && isOdd(n) ? -0 : 0;
      if (x.e > -1)
        k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y = new BigNumber2(ONE2);
    for (;; ) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c)
          break;
        if (k) {
          if (y.c.length > k)
            y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0)
          break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0)
            break;
          nIsOdd = i % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k)
          x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp)
      return y;
    if (nIsNeg)
      y = ONE2.div(y);
    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P.integerValue = function(rm) {
    var n = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };
  P.isEqualTo = P.eq = function(y, b3) {
    return compare(this, new BigNumber2(y, b3)) === 0;
  };
  P.isFinite = function() {
    return !!this.c;
  };
  P.isGreaterThan = P.gt = function(y, b3) {
    return compare(this, new BigNumber2(y, b3)) > 0;
  };
  P.isGreaterThanOrEqualTo = P.gte = function(y, b3) {
    return (b3 = compare(this, new BigNumber2(y, b3))) === 1 || b3 === 0;
  };
  P.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P.isLessThan = P.lt = function(y, b3) {
    return compare(this, new BigNumber2(y, b3)) < 0;
  };
  P.isLessThanOrEqualTo = P.lte = function(y, b3) {
    return (b3 = compare(this, new BigNumber2(y, b3))) === -1 || b3 === 0;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = function() {
    return this.s < 0;
  };
  P.isPositive = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P.minus = function(y, b3) {
    var i, j, t, xLTy, x = this, a = x.s;
    y = new BigNumber2(y, b3);
    b3 = y.s;
    if (!a || !b3)
      return new BigNumber2(NaN);
    if (a != b3) {
      y.s = -b3;
      return x.plus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y.s = -b3, y) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b3, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b3 = a;b3--; t.push(0))
        ;
      t.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b3 = yc.length)) ? a : b3;
      for (a = b3 = 0;b3 < j; b3++) {
        if (xc[b3] != yc[b3]) {
          xLTy = xc[b3] < yc[b3];
          break;
        }
      }
    }
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }
    b3 = (j = yc.length) - (i = xc.length);
    if (b3 > 0)
      for (;b3--; xc[i++] = 0)
        ;
    b3 = BASE - 1;
    for (;j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j;i && !xc[--i]; xc[i] = b3)
          ;
        --xc[i];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (;xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P.modulo = P.mod = function(y, b3) {
    var q, s, x = this;
    y = new BigNumber2(y, b3);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1)
      y.s = x.s;
    return y;
  };
  P.multipliedBy = P.times = function(y, b3) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b3)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }
    for (i = xcL + ycL, zc = [];i--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL;--i >= 0; ) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k = xcL, j = i + k;j > i; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e);
  };
  P.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P.plus = function(y, b3) {
    var t, x = this, a = x.s;
    y = new BigNumber2(y, b3);
    b3 = y.s;
    if (!a || !b3)
      return new BigNumber2(NaN);
    if (a != b3) {
      y.s = -b3;
      return x.minus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (;a--; t.push(0))
        ;
      t.reverse();
    }
    a = xc.length;
    b3 = yc.length;
    if (a - b3 < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b3 = a;
    }
    for (a = 0;b3; ) {
      a = (xc[--b3] = xc[b3] + yc[b3] + a) / BASE | 0;
      xc[b3] = BASE === xc[b3] ? 0 : xc[b3] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P.precision = P.sd = function(sd, rm) {
    var c, n, v2, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c))
      return null;
    v2 = c.length - 1;
    n = v2 * LOG_BASE + 1;
    if (v2 = c[v2]) {
      for (;v2 % 10 == 0; v2 /= 10, n--)
        ;
      for (v2 = c[0];v2 >= 10; v2 /= 10, n++)
        ;
    }
    if (sd && x.e + 1 > n)
      n = x.e + 1;
    return n;
  };
  P.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0)
        n += "0";
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new BigNumber2(n);
    } else {
      r = new BigNumber2(s + "");
    }
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3)
        s = 0;
      for (;; ) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e)
            --s;
          n = n.slice(s - 3, s + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P.toFormat = function(dp, rm, format2) {
    var str, x = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x.toFixed(dp, rm);
    if (x.c) {
      var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (;i < len; i += g1)
          intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0)
          intPart += groupSeparator + intDigits.slice(i);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P.toFraction = function(md) {
    var d, d02, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
    if (md != null) {
      n = new BigNumber2(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE2)) {
        throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
      }
    }
    if (!xc)
      return new BigNumber2(x);
    d = new BigNumber2(ONE2);
    n1 = d02 = new BigNumber2(ONE2);
    d1 = n0 = new BigNumber2(ONE2);
    s = coeffToString(xc);
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber2(s);
    n0.c[0] = 0;
    for (;; ) {
      q = div(n, d, 0, 1);
      d2 = d02.plus(q.times(d1));
      if (d2.comparedTo(md) == 1)
        break;
      d02 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }
    d2 = div(md.minus(d02), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d02 = d02.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d02, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d02];
    MAX_EXP = exp;
    return r;
  };
  P.toNumber = function() {
    return +valueOf(this);
  };
  P.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P.toString = function(b3) {
    var str, n = this, s = n.s, e = n.e;
    if (e === null) {
      if (s) {
        str = "Infinity";
        if (s < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b3 == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
      } else if (b3 === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, "0");
      } else {
        intCheck(b3, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b3, s, true);
      }
      if (s < 0 && n.c[0])
        str = "-" + str;
    }
    return str;
  };
  P.valueOf = P.toJSON = function() {
    return valueOf(this);
  };
  P._isBigNumber = true;
  P[Symbol.toStringTag] = "BigNumber";
  P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
};
var bitFloor = function(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
};
var coeffToString = function(a) {
  var s, z2, i = 1, j = a.length, r = a[0] + "";
  for (;i < j; ) {
    s = a[i++] + "";
    z2 = LOG_BASE - s.length;
    for (;z2--; s = "0" + s)
      ;
    r += s;
  }
  for (j = r.length;r.charCodeAt(--j) === 48; )
    ;
  return r.slice(0, j + 1 || 1);
};
var compare = function(x, y) {
  var a, b3, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!i || !j)
    return null;
  a = xc && !xc[0];
  b3 = yc && !yc[0];
  if (a || b3)
    return a ? b3 ? 0 : -j : i;
  if (i != j)
    return i;
  a = i < 0;
  b3 = k == l;
  if (!xc || !yc)
    return b3 ? 0 : !xc ^ a ? 1 : -1;
  if (!b3)
    return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = 0;i < j; i++)
    if (xc[i] != yc[i])
      return xc[i] > yc[i] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
};
var intCheck = function(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
  }
};
var isOdd = function(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
};
var toExponential = function(str, e) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
};
var toFixedPoint = function(str, e, z2) {
  var len, zs;
  if (e < 0) {
    for (zs = z2 + ".";++e; zs += z2)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs = z2, e -= len;--e; zs += z2)
        ;
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + "." + str.slice(e);
    }
  }
  return str;
};
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 100000000000000;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1000, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 10000000000, 100000000000, 1000000000000, 10000000000000];
var SQRT_BASE = 1e7;
var MAX = 1e9;
var BigNumber2 = clone();
var bignumber_default = BigNumber2;

// node_modules/@aave/contract-helpers/dist/esm/commons/utils.js
var valueToWei = (value, decimals) => {
  return new BigNumber2(value).shiftedBy(decimals).toFixed(0);
};
var getTxValue = (reserve, amount) => {
  return reserve.toLowerCase() === API_ETH_MOCK_ADDRESS.toLowerCase() ? amount : DEFAULT_NULL_VALUE_ON_TX;
};
var DEFAULT_NULL_VALUE_ON_TX = BigNumber.from(0).toHexString();
var DEFAULT_APPROVE_AMOUNT = exports_lib.MaxUint256.toString();
var MAX_UINT_AMOUNT = "115792089237316195423570985008687907853269984665640564039457584007913129639935";
var SUPER_BIG_ALLOWANCE_NUMBER = "11579208923731619542357098500868790785326998466564056403945758400791";
var API_ETH_MOCK_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
var uniswapEthAmount = "0.1";
var SURPLUS = "0.05";
var gasLimitRecommendations = {
  [ProtocolAction.default]: {
    limit: "210000",
    recommended: "210000"
  },
  [ProtocolAction.approval]: {
    limit: "65000",
    recommended: "65000"
  },
  [ProtocolAction.creditDelegationApproval]: {
    limit: "55000",
    recommended: "55000"
  },
  [ProtocolAction.supply]: {
    limit: "300000",
    recommended: "300000"
  },
  [ProtocolAction.deposit]: {
    limit: "300000",
    recommended: "300000"
  },
  [ProtocolAction.borrow]: {
    limit: "400000",
    recommended: "400000"
  },
  [ProtocolAction.withdraw]: {
    limit: "230000",
    recommended: "300000"
  },
  [ProtocolAction.liquidationCall]: {
    limit: "700000",
    recommended: "700000"
  },
  [ProtocolAction.liquidationFlash]: {
    limit: "995000",
    recommended: "995000"
  },
  [ProtocolAction.repay]: {
    limit: "300000",
    recommended: "300000"
  },
  [ProtocolAction.repayETH]: {
    limit: "350000",
    recommended: "300000"
  },
  [ProtocolAction.borrowETH]: {
    limit: "450000",
    recommended: "450000"
  },
  [ProtocolAction.withdrawETH]: {
    limit: "640000",
    recommended: "640000"
  },
  [ProtocolAction.swapCollateral]: {
    limit: "1000000",
    recommended: "1000000"
  },
  [ProtocolAction.repayCollateral]: {
    limit: "700000",
    recommended: "700000"
  },
  [ProtocolAction.migrateV3]: {
    limit: "700000",
    recommended: "700000"
  },
  [ProtocolAction.supplyWithPermit]: {
    limit: "350000",
    recommended: "350000"
  },
  [ProtocolAction.repayWithPermit]: {
    limit: "350000",
    recommended: "350000"
  },
  [ProtocolAction.stake]: {
    limit: "350000",
    recommended: "350000"
  },
  [ProtocolAction.stakeWithPermit]: {
    limit: "400000",
    recommended: "400000"
  },
  [ProtocolAction.vote]: {
    limit: "125000",
    recommended: "125000"
  },
  [ProtocolAction.claimRewards]: {
    limit: "275000",
    recommended: "275000"
  },
  [ProtocolAction.setUsageAsCollateral]: {
    limit: "138000",
    recommended: "138000"
  },
  [ProtocolAction.repayWithATokens]: {
    limit: "300000",
    recommended: "300000"
  },
  [ProtocolAction.withdrawAndSwitch]: {
    limit: "1000000",
    recommended: "1000000"
  },
  [ProtocolAction.batchMetaDelegate]: {
    limit: "200000",
    recommended: "200000"
  },
  [ProtocolAction.updateRepresentatives]: {
    limit: "60000",
    recommended: "60000"
  }
};
var mintAmountsPerToken = {
  AAVE: valueToWei("100", 18),
  BAT: valueToWei("100000", 18),
  BUSD: valueToWei("10000", 18),
  DAI: valueToWei("10000", 18),
  ENJ: valueToWei("100000", 18),
  KNC: valueToWei("10000", 18),
  LEND: valueToWei("1000", 18),
  LINK: valueToWei("1000", 18),
  MANA: valueToWei("100000", 18),
  MKR: valueToWei("10", 18),
  WETH: valueToWei("10", 18),
  REN: valueToWei("10000", 18),
  REP: valueToWei("1000", 18),
  SNX: valueToWei("100", 18),
  SUSD: valueToWei("10000", 18),
  TUSD: "0",
  UNI: valueToWei("1000", 18),
  USDC: valueToWei("10000", 6),
  USDT: valueToWei("10000", 6),
  WBTC: valueToWei("1", 8),
  YFI: valueToWei("1", 18),
  ZRX: valueToWei("100000", 18),
  UNIUSDC: valueToWei(uniswapEthAmount, 6),
  UNIDAI: valueToWei(uniswapEthAmount, 18),
  UNIUSDT: valueToWei(uniswapEthAmount, 6),
  UNIDAIETH: valueToWei(uniswapEthAmount, 18),
  UNIUSDCETH: valueToWei(uniswapEthAmount, 18),
  UNISETHETH: valueToWei(uniswapEthAmount, 18),
  UNILENDETH: valueToWei(uniswapEthAmount, 18),
  UNILINKETH: valueToWei(uniswapEthAmount, 18),
  UNIMKRETH: valueToWei(uniswapEthAmount, 18),
  EURS: valueToWei("10000", 2),
  AGEUR: valueToWei("10000", 18),
  BAL: valueToWei("10000", 18),
  CRV: valueToWei("10000", 18),
  DPI: valueToWei("10000", 18),
  GHST: valueToWei("10000", 18),
  JEUR: valueToWei("10000", 18),
  SUSHI: valueToWei("10000", 18)
};
var augustusToAmountOffsetFromCalldata = (calldata) => {
  switch (calldata.slice(0, 10)) {
    case "0x935fb84b":
      return 36;
    case "0xc03786b0":
      return 100;
    case "0xb2f1e6db":
      return 68;
    case "0xb66bcbac":
    case "0x35326910":
      return 164;
    case "0x87a63926":
      return 68;
    default:
      throw new Error("Unrecognized function selector for Augustus");
  }
};

// node_modules/@aave/contract-helpers/dist/esm/commons/BaseService.js
class BaseService {
  constructor(provider, contractFactory) {
    this.getContractInstance = (address4) => {
      if (!this.contractInstances[address4]) {
        this.contractInstances[address4] = this.contractFactory.connect(address4, this.provider);
      }
      return this.contractInstances[address4];
    };
    this.generateTxCallback = ({ rawTxMethod, from, value, gasSurplus, action }) => async () => {
      const txRaw = await rawTxMethod();
      const tx = Object.assign(Object.assign({}, txRaw), { from, value: value !== null && value !== undefined ? value : DEFAULT_NULL_VALUE_ON_TX });
      tx.gasLimit = await estimateGasByNetwork(tx, this.provider, gasSurplus);
      if (action && gasLimitRecommendations[action] && tx.gasLimit.lte(BigNumber.from(gasLimitRecommendations[action].limit))) {
        tx.gasLimit = BigNumber.from(gasLimitRecommendations[action].recommended);
      }
      return tx;
    };
    this.generateTxPriceEstimation = (txs, txCallback, action = ProtocolAction.default) => async (force = false) => {
      const gasPrice = await this.provider.getGasPrice();
      const hasPendingApprovals = txs.find((tx) => tx.txType === eEthereumTxType.ERC20_APPROVAL);
      if (!hasPendingApprovals || force) {
        const { gasLimit, gasPrice: gasPriceProv } = await txCallback();
        if (!gasLimit) {
          throw new Error("Transaction calculation error");
        }
        return {
          gasLimit: gasLimit.toString(),
          gasPrice: gasPriceProv ? gasPriceProv.toString() : gasPrice.toString()
        };
      }
      return {
        gasLimit: gasLimitRecommendations[action].recommended,
        gasPrice: gasPrice.toString()
      };
    };
    this.estimateGasLimit = async ({ tx, gasSurplus, action, skipGasEstimation }) => {
      const gasLimit = action ? BigNumber.from(gasLimitRecommendations[action].limit) : BigNumber.from(gasLimitRecommendations[ProtocolAction.default].limit);
      if (skipGasEstimation) {
        tx.gasLimit = gasLimit;
        return tx;
      }
      let estimatedGasLimit = BigNumber.from("0");
      try {
        estimatedGasLimit = await estimateGasByNetwork(Object.assign(Object.assign({}, tx), { value: tx.value ? tx.value.toHexString() : DEFAULT_NULL_VALUE_ON_TX }), this.provider, gasSurplus);
      } catch (_4) {
      }
      if (estimatedGasLimit.gt(gasLimit)) {
        tx.gasLimit = estimatedGasLimit;
      } else {
        tx.gasLimit = gasLimit;
      }
      return tx;
    };
    this.contractFactory = contractFactory;
    this.provider = provider;
    this.contractInstances = {};
  }
}

// node_modules/reflect-metadata/Reflect.js
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect2;
(function(Reflect3) {
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
    var exporter = makeExporter(Reflect3);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect3;
    } else {
      exporter = makeExporter(root.Reflect, exporter);
    }
    factory(exporter);
    function makeExporter(target, previous) {
      return function(key, value) {
        if (typeof target[key] !== "function") {
          Object.defineProperty(target, key, { configurable: true, writable: true, value });
        }
        if (previous)
          previous(key, value);
      };
    }
  })(function(exporter) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      create: supportsCreate ? function() {
        return MakeDictionary(Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map, key) {
        return hasOwn.call(map, key);
      } : function(map, key) {
        return key in map;
      },
      get: downLevel ? function(map, key) {
        return hasOwn.call(map, key) ? map[key] : undefined;
      } : function(map, key) {
        return map[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var usePolyfill = typeof process === "object" && process["env"] && process["env"]["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
    var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var Metadata = new _WeakMap;
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError;
        if (!IsObject(target))
          throw new TypeError;
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError;
        if (IsNull(attributes))
          attributes = undefined;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError;
        if (!IsConstructor(target))
          throw new TypeError;
        return DecorateConstructor(decorators, target);
      }
    }
    exporter("decorate", decorate);
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError;
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError;
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError;
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError;
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError;
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError;
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError;
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError;
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError;
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError;
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var metadataMap = GetOrCreateMetadataMap(target, propertyKey, false);
      if (IsUndefined(metadataMap))
        return false;
      if (!metadataMap.delete(metadataKey))
        return false;
      if (metadataMap.size > 0)
        return true;
      var targetMetadata = Metadata.get(target);
      targetMetadata.delete(propertyKey);
      if (targetMetadata.size > 0)
        return true;
      Metadata.delete(target);
      return true;
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i = decorators.length - 1;i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError;
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i = decorators.length - 1;i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError;
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function GetOrCreateMetadataMap(O, P, Create) {
      var targetMetadata = Metadata.get(O);
      if (IsUndefined(targetMetadata)) {
        if (!Create)
          return;
        targetMetadata = new _Map;
        Metadata.set(O, targetMetadata);
      }
      var metadataMap = targetMetadata.get(P);
      if (IsUndefined(metadataMap)) {
        if (!Create)
          return;
        metadataMap = new _Map;
        targetMetadata.set(P, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn2)
        return true;
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, false);
      if (IsUndefined(metadataMap))
        return false;
      return ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn2)
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P);
      return;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, false);
      if (IsUndefined(metadataMap))
        return;
      return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, true);
      metadataMap.set(MetadataKey, MetadataValue);
    }
    function OrdinaryMetadataKeys(O, P) {
      var ownKeys = OrdinaryOwnMetadataKeys(O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (parent === null)
        return ownKeys;
      var parentKeys = OrdinaryMetadataKeys(parent, P);
      if (parentKeys.length <= 0)
        return ownKeys;
      if (ownKeys.length <= 0)
        return parentKeys;
      var set = new _Set;
      var keys = [];
      for (var _i = 0, ownKeys_1 = ownKeys;_i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a = 0, parentKeys_1 = parentKeys;_a < parentKeys_1.length; _a++) {
        var key = parentKeys_1[_a];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(O, P) {
      var keys = [];
      var metadataMap = GetOrCreateMetadataMap(O, P, false);
      if (IsUndefined(metadataMap))
        return keys;
      var keysObj = metadataMap.keys();
      var iterator = GetIterator(keysObj);
      var k = 0;
      while (true) {
        var next = IteratorStep(iterator);
        if (!next) {
          keys.length = k;
          return keys;
        }
        var nextValue = IteratorValue(next);
        try {
          keys[k] = nextValue;
        } catch (e) {
          try {
            IteratorClose(iterator);
          } finally {
            throw e;
          }
        }
        k++;
      }
    }
    function Type(x) {
      if (x === null)
        return 1;
      switch (typeof x) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x) {
      return x === undefined;
    }
    function IsNull(x) {
      return x === null;
    }
    function IsSymbol(x) {
      return typeof x === "symbol";
    }
    function IsObject(x) {
      return typeof x === "object" ? x !== null : typeof x === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== undefined) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError;
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if (hint === "string") {
        var toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError;
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(argument, 3);
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function GetMethod(V, P) {
      var func = V[P];
      if (func === undefined || func === null)
        return;
      if (!IsCallable(func))
        throw new TypeError;
      return func;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError;
      var iterator = method.call(obj);
      if (!IsObject(iterator))
        throw new TypeError;
      return iterator;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator) {
      var result = iterator.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator) {
      var f = iterator["return"];
      if (f)
        f.call(iterator);
    }
    function OrdinaryGetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O);
      if (typeof O !== "function" || O === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype = O.prototype;
      var prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O)
        return proto;
      return constructor;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = function() {
        function MapIterator2(keys, values, selector) {
          this._index = 0;
          this._keys = keys;
          this._values = values;
          this._selector = selector;
        }
        MapIterator2.prototype["@@iterator"] = function() {
          return this;
        };
        MapIterator2.prototype[iteratorSymbol] = function() {
          return this;
        };
        MapIterator2.prototype.next = function() {
          var index = this._index;
          if (index >= 0 && index < this._keys.length) {
            var result = this._selector(this._keys[index], this._values[index]);
            if (index + 1 >= this._keys.length) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            } else {
              this._index++;
            }
            return { value: result, done: false };
          }
          return { value: undefined, done: true };
        };
        MapIterator2.prototype.throw = function(error) {
          if (this._index >= 0) {
            this._index = -1;
            this._keys = arraySentinel;
            this._values = arraySentinel;
          }
          throw error;
        };
        MapIterator2.prototype.return = function(value) {
          if (this._index >= 0) {
            this._index = -1;
            this._keys = arraySentinel;
            this._values = arraySentinel;
          }
          return { value, done: true };
        };
        return MapIterator2;
      }();
      return function() {
        function Map2() {
          this._keys = [];
          this._values = [];
          this._cacheKey = cacheSentinel;
          this._cacheIndex = -2;
        }
        Object.defineProperty(Map2.prototype, "size", {
          get: function() {
            return this._keys.length;
          },
          enumerable: true,
          configurable: true
        });
        Map2.prototype.has = function(key) {
          return this._find(key, false) >= 0;
        };
        Map2.prototype.get = function(key) {
          var index = this._find(key, false);
          return index >= 0 ? this._values[index] : undefined;
        };
        Map2.prototype.set = function(key, value) {
          var index = this._find(key, true);
          this._values[index] = value;
          return this;
        };
        Map2.prototype.delete = function(key) {
          var index = this._find(key, false);
          if (index >= 0) {
            var size = this._keys.length;
            for (var i = index + 1;i < size; i++) {
              this._keys[i - 1] = this._keys[i];
              this._values[i - 1] = this._values[i];
            }
            this._keys.length--;
            this._values.length--;
            if (key === this._cacheKey) {
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            }
            return true;
          }
          return false;
        };
        Map2.prototype.clear = function() {
          this._keys.length = 0;
          this._values.length = 0;
          this._cacheKey = cacheSentinel;
          this._cacheIndex = -2;
        };
        Map2.prototype.keys = function() {
          return new MapIterator(this._keys, this._values, getKey);
        };
        Map2.prototype.values = function() {
          return new MapIterator(this._keys, this._values, getValue);
        };
        Map2.prototype.entries = function() {
          return new MapIterator(this._keys, this._values, getEntry);
        };
        Map2.prototype["@@iterator"] = function() {
          return this.entries();
        };
        Map2.prototype[iteratorSymbol] = function() {
          return this.entries();
        };
        Map2.prototype._find = function(key, insert) {
          if (this._cacheKey !== key) {
            this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
          }
          if (this._cacheIndex < 0 && insert) {
            this._cacheIndex = this._keys.length;
            this._keys.push(key);
            this._values.push(undefined);
          }
          return this._cacheIndex;
        };
        return Map2;
      }();
      function getKey(key, _4) {
        return key;
      }
      function getValue(_4, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      return function() {
        function Set2() {
          this._map = new _Map;
        }
        Object.defineProperty(Set2.prototype, "size", {
          get: function() {
            return this._map.size;
          },
          enumerable: true,
          configurable: true
        });
        Set2.prototype.has = function(value) {
          return this._map.has(value);
        };
        Set2.prototype.add = function(value) {
          return this._map.set(value, value), this;
        };
        Set2.prototype.delete = function(value) {
          return this._map.delete(value);
        };
        Set2.prototype.clear = function() {
          this._map.clear();
        };
        Set2.prototype.keys = function() {
          return this._map.keys();
        };
        Set2.prototype.values = function() {
          return this._map.values();
        };
        Set2.prototype.entries = function() {
          return this._map.entries();
        };
        Set2.prototype["@@iterator"] = function() {
          return this.keys();
        };
        Set2.prototype[iteratorSymbol] = function() {
          return this.keys();
        };
        return Set2;
      }();
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return function() {
        function WeakMap2() {
          this._key = CreateUniqueKey();
        }
        WeakMap2.prototype.has = function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          return table !== undefined ? HashMap.has(table, this._key) : false;
        };
        WeakMap2.prototype.get = function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          return table !== undefined ? HashMap.get(table, this._key) : undefined;
        };
        WeakMap2.prototype.set = function(target, value) {
          var table = GetOrCreateWeakMapTable(target, true);
          table[this._key] = value;
          return this;
        };
        WeakMap2.prototype.delete = function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          return table !== undefined ? delete table[this._key] : false;
        };
        WeakMap2.prototype.clear = function() {
          this._key = CreateUniqueKey();
        };
        return WeakMap2;
      }();
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create)
            return;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer, size) {
        for (var i = 0;i < size; ++i)
          buffer[i] = Math.random() * 255 | 0;
        return buffer;
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          if (typeof crypto !== "undefined")
            return crypto.getRandomValues(new Uint8Array(size));
          if (typeof msCrypto !== "undefined")
            return msCrypto.getRandomValues(new Uint8Array(size));
          return FillRandomBytes(new Uint8Array(size), size);
        }
        return FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 79 | 64;
        data[8] = data[8] & 191 | 128;
        var result = "";
        for (var offset = 0;offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = undefined;
      delete obj.__;
      return obj;
    }
  });
})(Reflect2 || (Reflect2 = {}));

// node_modules/@aave/contract-helpers/dist/esm/commons/validators/paramValidators.js
function isDeadline32Bytes(field) {
  return function(target, propertyKey, parameterIndex) {
    const existingPossibleAddresses = Reflect.getOwnMetadata(isPermitDeadline32Bytes, target, propertyKey) || [];
    existingPossibleAddresses.push({
      index: parameterIndex,
      field
    });
    Reflect.defineMetadata(isPermitDeadline32Bytes, existingPossibleAddresses, target, propertyKey);
  };
}
function isEthAddress(field) {
  return function(target, propertyKey, parameterIndex) {
    const existingPossibleAddresses = Reflect.getOwnMetadata(isEthAddressMetadataKey, target, propertyKey) || [];
    existingPossibleAddresses.push({
      index: parameterIndex,
      field
    });
    Reflect.defineMetadata(isEthAddressMetadataKey, existingPossibleAddresses, target, propertyKey);
  };
}
function isEthAddressArray(field) {
  return function(target, propertyKey, parameterIndex) {
    const existingPossibleAddresses = Reflect.getOwnMetadata(isEthAddressArrayMetadataKey, target, propertyKey) || [];
    existingPossibleAddresses.push({
      index: parameterIndex,
      field
    });
    Reflect.defineMetadata(isEthAddressArrayMetadataKey, existingPossibleAddresses, target, propertyKey);
  };
}
function isPositiveAmount(field) {
  return function(target, propertyKey, parameterIndex) {
    const params = Reflect.getOwnMetadata(isPositiveMetadataKey, target, propertyKey) || [];
    params.push({ index: parameterIndex, field });
    Reflect.defineMetadata(isPositiveMetadataKey, params, target, propertyKey);
  };
}
function is0OrPositiveAmount(field) {
  return function(target, propertyKey, parameterIndex) {
    const params = Reflect.getOwnMetadata(is0OrPositiveMetadataKey, target, propertyKey) || [];
    params.push({ index: parameterIndex, field });
    Reflect.defineMetadata(is0OrPositiveMetadataKey, params, target, propertyKey);
  };
}
function isPositiveOrMinusOneAmount(field) {
  return function(target, propertyKey, parameterIndex) {
    const params = Reflect.getOwnMetadata(isPositiveOrMinusOneMetadataKey, target, propertyKey) || [];
    params.push({ index: parameterIndex, field });
    Reflect.defineMetadata(isPositiveOrMinusOneMetadataKey, params, target, propertyKey);
  };
}
var isEthAddressMetadataKey = Symbol("ethAddress");
var isPermitDeadline32Bytes = Symbol("deadline32Bytes");
var isEthAddressArrayMetadataKey = Symbol("ethAddressArray");
var isEthAddressOrENSMetadataKey = Symbol("ethOrENSAddress");
var isPositiveMetadataKey = Symbol("isPositive");
var isPositiveOrMinusOneMetadataKey = Symbol("isPositiveOrMinusOne");
var is0OrPositiveMetadataKey = Symbol("is0OrPositiveMetadataKey");
var optionalMetadataKey = Symbol("Optional");
var isEthAddressArrayMetadataKeyNotEmpty = Symbol("isEthAddressArrayMetadataKeyNotEmpty");

// node_modules/@aave/contract-helpers/dist/esm/commons/validators/validations.js
function isDeadline32BytesValidator(target, propertyName, methodArguments, isParamOptional) {
  const addressParameters = Reflect.getOwnMetadata(isPermitDeadline32Bytes, target, propertyName);
  if (addressParameters) {
    addressParameters.forEach((storedParams) => {
      if (storedParams.field) {
        if (methodArguments[0][storedParams.field] && Buffer.byteLength(methodArguments[0][storedParams.field], "utf8") > 32) {
          throw new Error(`Deadline: ${methodArguments[0][storedParams.field]} is bigger than 32 bytes`);
        }
      } else {
        const isOptional = isParamOptional === null || isParamOptional === undefined ? undefined : isParamOptional[storedParams.index];
        if (methodArguments[storedParams.index] && !isOptional && Buffer.byteLength(methodArguments[storedParams.index], "utf8") > 32) {
          throw new Error(`Deadline: ${methodArguments[storedParams.index]} is bigger than 32 bytes`);
        }
      }
    });
  }
}
function isEthAddressValidator(target, propertyName, methodArguments, isParamOptional) {
  const addressParameters = Reflect.getOwnMetadata(isEthAddressMetadataKey, target, propertyName);
  if (addressParameters) {
    addressParameters.forEach((storedParams) => {
      if (storedParams.field) {
        if (methodArguments[0][storedParams.field] && !exports_utils.isAddress(methodArguments[0][storedParams.field])) {
          throw new Error(`Address: ${methodArguments[0][storedParams.field]} is not a valid ethereum Address`);
        }
      } else {
        const isOptional = isParamOptional === null || isParamOptional === undefined ? undefined : isParamOptional[storedParams.index];
        if (methodArguments[storedParams.index] && !isOptional && !exports_utils.isAddress(methodArguments[storedParams.index])) {
          throw new Error(`Address: ${methodArguments[storedParams.index]} is not a valid ethereum Address`);
        }
      }
    });
  }
}
function isEthAddressArrayValidator(target, propertyName, methodArguments, isParamOptional) {
  const addressParameters = Reflect.getOwnMetadata(isEthAddressArrayMetadataKey, target, propertyName);
  if (addressParameters) {
    addressParameters.forEach((storedParams) => {
      if (storedParams.field) {
        if (methodArguments[0][storedParams.field]) {
          if (methodArguments[0][storedParams.field].length > 0) {
            const fieldArray = methodArguments[0][storedParams.field];
            fieldArray.forEach((address4) => {
              if (!exports_utils.isAddress(address4)) {
                throw new Error(`Address: ${address4} is not a valid ethereum Address`);
              }
            });
          }
        }
      } else {
        const isOptional = isParamOptional === null || isParamOptional === undefined ? undefined : isParamOptional[storedParams.index];
        if (methodArguments[storedParams.index] && !isOptional) {
          if (methodArguments[storedParams.index].length > 0) {
            const fieldArray = methodArguments[storedParams.index];
            fieldArray.forEach((address4) => {
              if (!exports_utils.isAddress(address4)) {
                throw new Error(`Address: ${address4} is not a valid ethereum Address`);
              }
            });
          }
        }
      }
    });
  }
}
function amountGtThan0Validator(target, propertyName, methodArguments, isParamOptional) {
  const amountParameters = Reflect.getOwnMetadata(isPositiveMetadataKey, target, propertyName);
  if (amountParameters) {
    amountParameters.forEach((storedParams) => {
      if (storedParams.field) {
        if (methodArguments[0][storedParams.field] && !(Number(methodArguments[0][storedParams.field]) > 0)) {
          throw new Error(`Amount: ${methodArguments[0][storedParams.field]} needs to be greater than 0`);
        }
      } else {
        const isOptional = isParamOptional === null || isParamOptional === undefined ? undefined : isParamOptional[storedParams.index];
        if (!isOptional && !(Number(methodArguments[storedParams.index]) > 0)) {
          throw new Error(`Amount: ${methodArguments[storedParams.index]} needs to be greater than 0`);
        }
      }
    });
  }
}
function amount0OrPositiveValidator(target, propertyName, methodArguments, isParamOptional) {
  const amountParameters = Reflect.getOwnMetadata(is0OrPositiveMetadataKey, target, propertyName);
  if (amountParameters) {
    amountParameters.forEach((storedParams) => {
      if (storedParams.field) {
        if (methodArguments[0][storedParams.field] && !(Number(methodArguments[0][storedParams.field]) >= 0)) {
          throw new Error(`Amount: ${methodArguments[0][storedParams.field]} needs to be greater or equal than 0`);
        }
      } else {
        const isOptional = isParamOptional === null || isParamOptional === undefined ? undefined : isParamOptional[storedParams.index];
        if (!isOptional && !(Number(methodArguments[storedParams.index]) >= 0)) {
          throw new Error(`Amount: ${methodArguments[storedParams.index]} needs to be greater or equal than 0`);
        }
      }
    });
  }
}
function amountGtThan0OrMinus1(target, propertyName, methodArguments, isParamOptional) {
  const amountMinusOneParameters = Reflect.getOwnMetadata(isPositiveOrMinusOneMetadataKey, target, propertyName);
  if (amountMinusOneParameters) {
    amountMinusOneParameters.forEach((storedParams) => {
      if (storedParams.field) {
        if (methodArguments[0][storedParams.field] && !(Number(methodArguments[0][storedParams.field]) > 0 || methodArguments[0][storedParams.field] === "-1")) {
          throw new Error(`Amount: ${methodArguments[0][storedParams.field]} needs to be greater than 0 or -1`);
        }
      } else {
        const isOptional = isParamOptional === null || isParamOptional === undefined ? undefined : isParamOptional[storedParams.index];
        if (!isOptional && !(Number(methodArguments[storedParams.index]) > 0 || methodArguments[storedParams.index] === "-1")) {
          throw new Error(`Amount: ${methodArguments[storedParams.index]} needs to be greater than 0 or -1`);
        }
      }
    });
  }
}

// node_modules/@aave/contract-helpers/dist/esm/commons/validators/methodValidators.js
function LPFlashLiquidationValidatorV3(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function() {
    if (!exports_utils.isAddress(this.poolAddress) || !exports_utils.isAddress(this.flashLiquidationAddress)) {
      console.error(`[LPFlahsLiquidationValidator] You need to pass valid addresses`);
      return [];
    }
    isEthAddressValidator(target, propertyName, arguments);
    amountGtThan0Validator(target, propertyName, arguments);
    amountGtThan0OrMinus1(target, propertyName, arguments);
    return method.apply(this, arguments);
  };
}
function LPRepayWithCollateralValidatorV3(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function() {
    if (!exports_utils.isAddress(this.poolAddress) || !exports_utils.isAddress(this.repayWithCollateralAddress)) {
      console.error(`[LPRepayWithCollateralValidator] You need to pass valid addresses`);
      return [];
    }
    isEthAddressValidator(target, propertyName, arguments);
    amountGtThan0Validator(target, propertyName, arguments);
    return method.apply(this, arguments);
  };
}
function LPSwapCollateralValidatorV3(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function() {
    if (!exports_utils.isAddress(this.poolAddress) || !exports_utils.isAddress(this.swapCollateralAddress)) {
      console.error(`[LPSwapCollateralValidator] You need to pass valid addresses`);
      return [];
    }
    isEthAddressValidator(target, propertyName, arguments);
    amountGtThan0Validator(target, propertyName, arguments);
    return method.apply(this, arguments);
  };
}
function L2PValidator(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function() {
    if (!exports_utils.isAddress(this.l2PoolAddress) || !exports_utils.isAddress(this.encoderAddress)) {
      console.error(`[L2PoolValidator] You need to pass valid addresses: l2pool: ${this.l2PoolAddress} encoder: ${this.encoderAddress}`);
      return [];
    }
    isDeadline32BytesValidator(target, propertyName, arguments);
    return method.apply(this, arguments);
  };
}
function LPValidatorV3(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function() {
    if (!exports_utils.isAddress(this.poolAddress)) {
      console.error(`[PoolValidator] You need to pass valid addresses`);
      return [];
    }
    isEthAddressValidator(target, propertyName, arguments);
    amountGtThan0Validator(target, propertyName, arguments);
    amountGtThan0OrMinus1(target, propertyName, arguments);
    amount0OrPositiveValidator(target, propertyName, arguments);
    isEthAddressArrayValidator(target, propertyName, arguments);
    return method.apply(this, arguments);
  };
}
function UiIncentiveDataProviderValidator(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function() {
    if (!exports_utils.isAddress(this.uiIncentiveDataProviderAddress)) {
      console.error(`[UiIncentiveDataProviderValidator] You need to pass valid addresses`);
      throw new Error("UiIncentiveDataProviderAddress must be an eth valid address");
    }
    isEthAddressValidator(target, propertyName, arguments);
    return method.apply(this, arguments);
  };
}
function DebtTokenValidator(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function() {
    isEthAddressValidator(target, propertyName, arguments);
    amountGtThan0Validator(target, propertyName, arguments);
    return method.apply(this, arguments);
  };
}
function SynthetixValidator(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function() {
    isEthAddressValidator(target, propertyName, arguments);
    amountGtThan0Validator(target, propertyName, arguments);
    return method.apply(this, arguments);
  };
}
function ERC20Validator(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function() {
    isEthAddressValidator(target, propertyName, arguments);
    amountGtThan0Validator(target, propertyName, arguments);
    amountGtThan0OrMinus1(target, propertyName, arguments);
    return method.apply(this, arguments);
  };
}
function LiquiditySwapValidator(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function() {
    if (!exports_utils.isAddress(this.liquiditySwapAdapterAddress)) {
      console.error(`[LiquiditySwapValidator] You need to pass valid addresses`);
      return [];
    }
    isEthAddressValidator(target, propertyName, arguments);
    amountGtThan0Validator(target, propertyName, arguments);
    amountGtThan0OrMinus1(target, propertyName, arguments);
    return method.apply(this, arguments);
  };
}
function RepayWithCollateralValidator(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function() {
    if (!exports_utils.isAddress(this.repayWithCollateralAddress)) {
      console.error(`[RepayWithCollateralValidator] You need to pass valid addresses`);
      return [];
    }
    isEthAddressValidator(target, propertyName, arguments);
    amountGtThan0Validator(target, propertyName, arguments);
    amountGtThan0OrMinus1(target, propertyName, arguments);
    return method.apply(this, arguments);
  };
}
function WETHValidator(target, propertyName, descriptor) {
  const method = descriptor.value;
  descriptor.value = function() {
    if (!exports_utils.isAddress(this.wethGatewayAddress)) {
      console.error(`[WethGatewayValidator] You need to pass valid addresses`);
      return [];
    }
    isEthAddressValidator(target, propertyName, arguments);
    amountGtThan0Validator(target, propertyName, arguments);
    amountGtThan0OrMinus1(target, propertyName, arguments);
    amount0OrPositiveValidator(target, propertyName, arguments);
    return method.apply(this, arguments);
  };
}

// node_modules/@aave/contract-helpers/dist/esm/v3-UiIncentiveDataProvider-contract/typechain/IUiIncentiveDataProviderV3__factory.js
var _abi2 = [
  {
    inputs: [
      {
        internalType: "contract IPoolAddressesProvider",
        name: "provider",
        type: "address"
      },
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "getFullReservesIncentiveData",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "underlyingAsset",
            type: "address"
          },
          {
            components: [
              {
                internalType: "address",
                name: "tokenAddress",
                type: "address"
              },
              {
                internalType: "address",
                name: "incentiveControllerAddress",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "string",
                    name: "rewardTokenSymbol",
                    type: "string"
                  },
                  {
                    internalType: "address",
                    name: "rewardTokenAddress",
                    type: "address"
                  },
                  {
                    internalType: "address",
                    name: "rewardOracleAddress",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "emissionPerSecond",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "incentivesLastUpdateTimestamp",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "tokenIncentivesIndex",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "emissionEndTimestamp",
                    type: "uint256"
                  },
                  {
                    internalType: "int256",
                    name: "rewardPriceFeed",
                    type: "int256"
                  },
                  {
                    internalType: "uint8",
                    name: "rewardTokenDecimals",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "precision",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "priceFeedDecimals",
                    type: "uint8"
                  }
                ],
                internalType: "struct IUiIncentiveDataProviderV3.RewardInfo[]",
                name: "rewardsTokenInformation",
                type: "tuple[]"
              }
            ],
            internalType: "struct IUiIncentiveDataProviderV3.IncentiveData",
            name: "aIncentiveData",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "tokenAddress",
                type: "address"
              },
              {
                internalType: "address",
                name: "incentiveControllerAddress",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "string",
                    name: "rewardTokenSymbol",
                    type: "string"
                  },
                  {
                    internalType: "address",
                    name: "rewardTokenAddress",
                    type: "address"
                  },
                  {
                    internalType: "address",
                    name: "rewardOracleAddress",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "emissionPerSecond",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "incentivesLastUpdateTimestamp",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "tokenIncentivesIndex",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "emissionEndTimestamp",
                    type: "uint256"
                  },
                  {
                    internalType: "int256",
                    name: "rewardPriceFeed",
                    type: "int256"
                  },
                  {
                    internalType: "uint8",
                    name: "rewardTokenDecimals",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "precision",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "priceFeedDecimals",
                    type: "uint8"
                  }
                ],
                internalType: "struct IUiIncentiveDataProviderV3.RewardInfo[]",
                name: "rewardsTokenInformation",
                type: "tuple[]"
              }
            ],
            internalType: "struct IUiIncentiveDataProviderV3.IncentiveData",
            name: "vIncentiveData",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "tokenAddress",
                type: "address"
              },
              {
                internalType: "address",
                name: "incentiveControllerAddress",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "string",
                    name: "rewardTokenSymbol",
                    type: "string"
                  },
                  {
                    internalType: "address",
                    name: "rewardTokenAddress",
                    type: "address"
                  },
                  {
                    internalType: "address",
                    name: "rewardOracleAddress",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "emissionPerSecond",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "incentivesLastUpdateTimestamp",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "tokenIncentivesIndex",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "emissionEndTimestamp",
                    type: "uint256"
                  },
                  {
                    internalType: "int256",
                    name: "rewardPriceFeed",
                    type: "int256"
                  },
                  {
                    internalType: "uint8",
                    name: "rewardTokenDecimals",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "precision",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "priceFeedDecimals",
                    type: "uint8"
                  }
                ],
                internalType: "struct IUiIncentiveDataProviderV3.RewardInfo[]",
                name: "rewardsTokenInformation",
                type: "tuple[]"
              }
            ],
            internalType: "struct IUiIncentiveDataProviderV3.IncentiveData",
            name: "sIncentiveData",
            type: "tuple"
          }
        ],
        internalType: "struct IUiIncentiveDataProviderV3.AggregatedReserveIncentiveData[]",
        name: "",
        type: "tuple[]"
      },
      {
        components: [
          {
            internalType: "address",
            name: "underlyingAsset",
            type: "address"
          },
          {
            components: [
              {
                internalType: "address",
                name: "tokenAddress",
                type: "address"
              },
              {
                internalType: "address",
                name: "incentiveControllerAddress",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "string",
                    name: "rewardTokenSymbol",
                    type: "string"
                  },
                  {
                    internalType: "address",
                    name: "rewardOracleAddress",
                    type: "address"
                  },
                  {
                    internalType: "address",
                    name: "rewardTokenAddress",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "userUnclaimedRewards",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "tokenIncentivesUserIndex",
                    type: "uint256"
                  },
                  {
                    internalType: "int256",
                    name: "rewardPriceFeed",
                    type: "int256"
                  },
                  {
                    internalType: "uint8",
                    name: "priceFeedDecimals",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "rewardTokenDecimals",
                    type: "uint8"
                  }
                ],
                internalType: "struct IUiIncentiveDataProviderV3.UserRewardInfo[]",
                name: "userRewardsInformation",
                type: "tuple[]"
              }
            ],
            internalType: "struct IUiIncentiveDataProviderV3.UserIncentiveData",
            name: "aTokenIncentivesUserData",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "tokenAddress",
                type: "address"
              },
              {
                internalType: "address",
                name: "incentiveControllerAddress",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "string",
                    name: "rewardTokenSymbol",
                    type: "string"
                  },
                  {
                    internalType: "address",
                    name: "rewardOracleAddress",
                    type: "address"
                  },
                  {
                    internalType: "address",
                    name: "rewardTokenAddress",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "userUnclaimedRewards",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "tokenIncentivesUserIndex",
                    type: "uint256"
                  },
                  {
                    internalType: "int256",
                    name: "rewardPriceFeed",
                    type: "int256"
                  },
                  {
                    internalType: "uint8",
                    name: "priceFeedDecimals",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "rewardTokenDecimals",
                    type: "uint8"
                  }
                ],
                internalType: "struct IUiIncentiveDataProviderV3.UserRewardInfo[]",
                name: "userRewardsInformation",
                type: "tuple[]"
              }
            ],
            internalType: "struct IUiIncentiveDataProviderV3.UserIncentiveData",
            name: "vTokenIncentivesUserData",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "tokenAddress",
                type: "address"
              },
              {
                internalType: "address",
                name: "incentiveControllerAddress",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "string",
                    name: "rewardTokenSymbol",
                    type: "string"
                  },
                  {
                    internalType: "address",
                    name: "rewardOracleAddress",
                    type: "address"
                  },
                  {
                    internalType: "address",
                    name: "rewardTokenAddress",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "userUnclaimedRewards",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "tokenIncentivesUserIndex",
                    type: "uint256"
                  },
                  {
                    internalType: "int256",
                    name: "rewardPriceFeed",
                    type: "int256"
                  },
                  {
                    internalType: "uint8",
                    name: "priceFeedDecimals",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "rewardTokenDecimals",
                    type: "uint8"
                  }
                ],
                internalType: "struct IUiIncentiveDataProviderV3.UserRewardInfo[]",
                name: "userRewardsInformation",
                type: "tuple[]"
              }
            ],
            internalType: "struct IUiIncentiveDataProviderV3.UserIncentiveData",
            name: "sTokenIncentivesUserData",
            type: "tuple"
          }
        ],
        internalType: "struct IUiIncentiveDataProviderV3.UserReserveIncentiveData[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IPoolAddressesProvider",
        name: "provider",
        type: "address"
      }
    ],
    name: "getReservesIncentivesData",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "underlyingAsset",
            type: "address"
          },
          {
            components: [
              {
                internalType: "address",
                name: "tokenAddress",
                type: "address"
              },
              {
                internalType: "address",
                name: "incentiveControllerAddress",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "string",
                    name: "rewardTokenSymbol",
                    type: "string"
                  },
                  {
                    internalType: "address",
                    name: "rewardTokenAddress",
                    type: "address"
                  },
                  {
                    internalType: "address",
                    name: "rewardOracleAddress",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "emissionPerSecond",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "incentivesLastUpdateTimestamp",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "tokenIncentivesIndex",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "emissionEndTimestamp",
                    type: "uint256"
                  },
                  {
                    internalType: "int256",
                    name: "rewardPriceFeed",
                    type: "int256"
                  },
                  {
                    internalType: "uint8",
                    name: "rewardTokenDecimals",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "precision",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "priceFeedDecimals",
                    type: "uint8"
                  }
                ],
                internalType: "struct IUiIncentiveDataProviderV3.RewardInfo[]",
                name: "rewardsTokenInformation",
                type: "tuple[]"
              }
            ],
            internalType: "struct IUiIncentiveDataProviderV3.IncentiveData",
            name: "aIncentiveData",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "tokenAddress",
                type: "address"
              },
              {
                internalType: "address",
                name: "incentiveControllerAddress",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "string",
                    name: "rewardTokenSymbol",
                    type: "string"
                  },
                  {
                    internalType: "address",
                    name: "rewardTokenAddress",
                    type: "address"
                  },
                  {
                    internalType: "address",
                    name: "rewardOracleAddress",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "emissionPerSecond",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "incentivesLastUpdateTimestamp",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "tokenIncentivesIndex",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "emissionEndTimestamp",
                    type: "uint256"
                  },
                  {
                    internalType: "int256",
                    name: "rewardPriceFeed",
                    type: "int256"
                  },
                  {
                    internalType: "uint8",
                    name: "rewardTokenDecimals",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "precision",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "priceFeedDecimals",
                    type: "uint8"
                  }
                ],
                internalType: "struct IUiIncentiveDataProviderV3.RewardInfo[]",
                name: "rewardsTokenInformation",
                type: "tuple[]"
              }
            ],
            internalType: "struct IUiIncentiveDataProviderV3.IncentiveData",
            name: "vIncentiveData",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "tokenAddress",
                type: "address"
              },
              {
                internalType: "address",
                name: "incentiveControllerAddress",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "string",
                    name: "rewardTokenSymbol",
                    type: "string"
                  },
                  {
                    internalType: "address",
                    name: "rewardTokenAddress",
                    type: "address"
                  },
                  {
                    internalType: "address",
                    name: "rewardOracleAddress",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "emissionPerSecond",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "incentivesLastUpdateTimestamp",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "tokenIncentivesIndex",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "emissionEndTimestamp",
                    type: "uint256"
                  },
                  {
                    internalType: "int256",
                    name: "rewardPriceFeed",
                    type: "int256"
                  },
                  {
                    internalType: "uint8",
                    name: "rewardTokenDecimals",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "precision",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "priceFeedDecimals",
                    type: "uint8"
                  }
                ],
                internalType: "struct IUiIncentiveDataProviderV3.RewardInfo[]",
                name: "rewardsTokenInformation",
                type: "tuple[]"
              }
            ],
            internalType: "struct IUiIncentiveDataProviderV3.IncentiveData",
            name: "sIncentiveData",
            type: "tuple"
          }
        ],
        internalType: "struct IUiIncentiveDataProviderV3.AggregatedReserveIncentiveData[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IPoolAddressesProvider",
        name: "provider",
        type: "address"
      },
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "getUserReservesIncentivesData",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "underlyingAsset",
            type: "address"
          },
          {
            components: [
              {
                internalType: "address",
                name: "tokenAddress",
                type: "address"
              },
              {
                internalType: "address",
                name: "incentiveControllerAddress",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "string",
                    name: "rewardTokenSymbol",
                    type: "string"
                  },
                  {
                    internalType: "address",
                    name: "rewardOracleAddress",
                    type: "address"
                  },
                  {
                    internalType: "address",
                    name: "rewardTokenAddress",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "userUnclaimedRewards",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "tokenIncentivesUserIndex",
                    type: "uint256"
                  },
                  {
                    internalType: "int256",
                    name: "rewardPriceFeed",
                    type: "int256"
                  },
                  {
                    internalType: "uint8",
                    name: "priceFeedDecimals",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "rewardTokenDecimals",
                    type: "uint8"
                  }
                ],
                internalType: "struct IUiIncentiveDataProviderV3.UserRewardInfo[]",
                name: "userRewardsInformation",
                type: "tuple[]"
              }
            ],
            internalType: "struct IUiIncentiveDataProviderV3.UserIncentiveData",
            name: "aTokenIncentivesUserData",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "tokenAddress",
                type: "address"
              },
              {
                internalType: "address",
                name: "incentiveControllerAddress",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "string",
                    name: "rewardTokenSymbol",
                    type: "string"
                  },
                  {
                    internalType: "address",
                    name: "rewardOracleAddress",
                    type: "address"
                  },
                  {
                    internalType: "address",
                    name: "rewardTokenAddress",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "userUnclaimedRewards",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "tokenIncentivesUserIndex",
                    type: "uint256"
                  },
                  {
                    internalType: "int256",
                    name: "rewardPriceFeed",
                    type: "int256"
                  },
                  {
                    internalType: "uint8",
                    name: "priceFeedDecimals",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "rewardTokenDecimals",
                    type: "uint8"
                  }
                ],
                internalType: "struct IUiIncentiveDataProviderV3.UserRewardInfo[]",
                name: "userRewardsInformation",
                type: "tuple[]"
              }
            ],
            internalType: "struct IUiIncentiveDataProviderV3.UserIncentiveData",
            name: "vTokenIncentivesUserData",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "tokenAddress",
                type: "address"
              },
              {
                internalType: "address",
                name: "incentiveControllerAddress",
                type: "address"
              },
              {
                components: [
                  {
                    internalType: "string",
                    name: "rewardTokenSymbol",
                    type: "string"
                  },
                  {
                    internalType: "address",
                    name: "rewardOracleAddress",
                    type: "address"
                  },
                  {
                    internalType: "address",
                    name: "rewardTokenAddress",
                    type: "address"
                  },
                  {
                    internalType: "uint256",
                    name: "userUnclaimedRewards",
                    type: "uint256"
                  },
                  {
                    internalType: "uint256",
                    name: "tokenIncentivesUserIndex",
                    type: "uint256"
                  },
                  {
                    internalType: "int256",
                    name: "rewardPriceFeed",
                    type: "int256"
                  },
                  {
                    internalType: "uint8",
                    name: "priceFeedDecimals",
                    type: "uint8"
                  },
                  {
                    internalType: "uint8",
                    name: "rewardTokenDecimals",
                    type: "uint8"
                  }
                ],
                internalType: "struct IUiIncentiveDataProviderV3.UserRewardInfo[]",
                name: "userRewardsInformation",
                type: "tuple[]"
              }
            ],
            internalType: "struct IUiIncentiveDataProviderV3.UserIncentiveData",
            name: "sTokenIncentivesUserData",
            type: "tuple"
          }
        ],
        internalType: "struct IUiIncentiveDataProviderV3.UserReserveIncentiveData[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

class IUiIncentiveDataProviderV3__factory {
  static createInterface() {
    return new exports_utils.Interface(_abi2);
  }
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi2, signerOrProvider);
  }
}
IUiIncentiveDataProviderV3__factory.abi = _abi2;

// node_modules/@aave/contract-helpers/dist/esm/v3-UiIncentiveDataProvider-contract/index.js
class UiIncentiveDataProvider extends BaseService {
  constructor({ provider, uiIncentiveDataProviderAddress, chainId }) {
    super(provider, IUiIncentiveDataProviderV3__factory);
    this._getFeed = async (rewardToken, chainlinkFeedsRegistry, quote) => {
      const feed = await this._chainlinkFeedsRegistries[chainlinkFeedsRegistry].getPriceFeed(rewardToken, quote);
      return Object.assign(Object.assign({}, feed), { rewardTokenAddress: rewardToken });
    };
    this.uiIncentiveDataProviderAddress = uiIncentiveDataProviderAddress;
    this._chainlinkFeedsRegistries = {};
    this.chainId = chainId;
  }
  async getFullReservesIncentiveData({ user, lendingPoolAddressProvider }) {
    const uiIncentiveContract = this.getContractInstance(this.uiIncentiveDataProviderAddress);
    return uiIncentiveContract.getFullReservesIncentiveData(lendingPoolAddressProvider, user);
  }
  async getReservesIncentivesData({ lendingPoolAddressProvider }) {
    const uiIncentiveContract = this.getContractInstance(this.uiIncentiveDataProviderAddress);
    return uiIncentiveContract.getReservesIncentivesData(lendingPoolAddressProvider);
  }
  async getUserReservesIncentivesData({ user, lendingPoolAddressProvider }) {
    const uiIncentiveContract = this.getContractInstance(this.uiIncentiveDataProviderAddress);
    return uiIncentiveContract.getUserReservesIncentivesData(lendingPoolAddressProvider, user);
  }
  async getReservesIncentivesDataHumanized({ lendingPoolAddressProvider }) {
    const response = await this.getReservesIncentivesData({ lendingPoolAddressProvider });
    return response.map((r) => ({
      id: `${this.chainId}-${r.underlyingAsset}-${lendingPoolAddressProvider}`.toLowerCase(),
      underlyingAsset: r.underlyingAsset.toLowerCase(),
      aIncentiveData: this._formatIncentiveData(r.aIncentiveData),
      vIncentiveData: this._formatIncentiveData(r.vIncentiveData),
      sIncentiveData: this._formatIncentiveData(r.sIncentiveData)
    }));
  }
  async getUserReservesIncentivesDataHumanized({ user, lendingPoolAddressProvider }) {
    const response = await this.getUserReservesIncentivesData({
      user,
      lendingPoolAddressProvider
    });
    return response.map((r) => ({
      id: `${this.chainId}-${user}-${r.underlyingAsset}-${lendingPoolAddressProvider}`.toLowerCase(),
      underlyingAsset: r.underlyingAsset.toLowerCase(),
      aTokenIncentivesUserData: this._formatUserIncentiveData(r.aTokenIncentivesUserData),
      vTokenIncentivesUserData: this._formatUserIncentiveData(r.vTokenIncentivesUserData),
      sTokenIncentivesUserData: this._formatUserIncentiveData(r.sTokenIncentivesUserData)
    }));
  }
  async getIncentivesDataWithPriceLegacy({ lendingPoolAddressProvider, chainlinkFeedsRegistry, quote = Denominations.eth }) {
    const incentives = await this.getReservesIncentivesDataHumanized({
      lendingPoolAddressProvider
    });
    const feeds = [];
    if (chainlinkFeedsRegistry && utils3.isAddress(chainlinkFeedsRegistry)) {
      if (!this._chainlinkFeedsRegistries[chainlinkFeedsRegistry]) {
        this._chainlinkFeedsRegistries[chainlinkFeedsRegistry] = new ChainlinkFeedsRegistry({
          provider: this.provider,
          chainlinkFeedsRegistry
        });
      }
      const allIncentiveRewardTokens = new Set;
      incentives.forEach((incentive) => {
        incentive.aIncentiveData.rewardsTokenInformation.map((rewardInfo) => allIncentiveRewardTokens.add(rewardInfo.rewardTokenAddress));
        incentive.vIncentiveData.rewardsTokenInformation.map((rewardInfo) => allIncentiveRewardTokens.add(rewardInfo.rewardTokenAddress));
        incentive.sIncentiveData.rewardsTokenInformation.map((rewardInfo) => allIncentiveRewardTokens.add(rewardInfo.rewardTokenAddress));
      });
      const incentiveRewardTokens = Array.from(allIncentiveRewardTokens);
      const rewardFeedPromises = incentiveRewardTokens.map((rewardToken) => this._getFeed(rewardToken, chainlinkFeedsRegistry, quote));
      const feedResults = await Promise.allSettled(rewardFeedPromises);
      feedResults.forEach((feedResult) => {
        if (feedResult.status === "fulfilled")
          feeds.push(feedResult.value);
      });
    }
    return incentives.map((incentive) => {
      return {
        id: `${this.chainId}-${incentive.underlyingAsset}-${lendingPoolAddressProvider}`.toLowerCase(),
        underlyingAsset: incentive.underlyingAsset,
        aIncentiveData: Object.assign(Object.assign({}, incentive.aIncentiveData), { rewardsTokenInformation: incentive.aIncentiveData.rewardsTokenInformation.map((rewardTokenInfo) => {
          const feed = feeds.find((feed2) => feed2.rewardTokenAddress === rewardTokenInfo.rewardTokenAddress);
          return Object.assign(Object.assign({}, rewardTokenInfo), { rewardPriceFeed: (feed === null || feed === undefined ? undefined : feed.answer) ? feed.answer : rewardTokenInfo.rewardPriceFeed, priceFeedDecimals: (feed === null || feed === undefined ? undefined : feed.decimals) ? feed.decimals : rewardTokenInfo.priceFeedDecimals });
        }) }),
        vIncentiveData: Object.assign(Object.assign({}, incentive.vIncentiveData), { rewardsTokenInformation: incentive.vIncentiveData.rewardsTokenInformation.map((rewardTokenInfo) => {
          const feed = feeds.find((feed2) => feed2.rewardTokenAddress === rewardTokenInfo.rewardTokenAddress);
          return Object.assign(Object.assign({}, rewardTokenInfo), { rewardPriceFeed: (feed === null || feed === undefined ? undefined : feed.answer) ? feed.answer : rewardTokenInfo.rewardPriceFeed, priceFeedDecimals: (feed === null || feed === undefined ? undefined : feed.decimals) ? feed.decimals : rewardTokenInfo.priceFeedDecimals });
        }) }),
        sIncentiveData: Object.assign(Object.assign({}, incentive.sIncentiveData), { rewardsTokenInformation: incentive.sIncentiveData.rewardsTokenInformation.map((rewardTokenInfo) => {
          const feed = feeds.find((feed2) => feed2.rewardTokenAddress === rewardTokenInfo.rewardTokenAddress);
          return Object.assign(Object.assign({}, rewardTokenInfo), { rewardPriceFeed: (feed === null || feed === undefined ? undefined : feed.answer) ? feed.answer : rewardTokenInfo.rewardPriceFeed, priceFeedDecimals: (feed === null || feed === undefined ? undefined : feed.decimals) ? feed.decimals : rewardTokenInfo.priceFeedDecimals });
        }) })
      };
    });
  }
  _formatIncentiveData(data) {
    return {
      tokenAddress: data.tokenAddress,
      incentiveControllerAddress: data.incentiveControllerAddress,
      rewardsTokenInformation: data.rewardsTokenInformation.map((rawRewardInfo) => ({
        precision: rawRewardInfo.precision,
        rewardTokenAddress: rawRewardInfo.rewardTokenAddress,
        rewardTokenDecimals: rawRewardInfo.rewardTokenDecimals,
        emissionPerSecond: rawRewardInfo.emissionPerSecond.toString(),
        incentivesLastUpdateTimestamp: rawRewardInfo.incentivesLastUpdateTimestamp.toNumber(),
        tokenIncentivesIndex: rawRewardInfo.tokenIncentivesIndex.toString(),
        emissionEndTimestamp: rawRewardInfo.emissionEndTimestamp.toNumber(),
        rewardTokenSymbol: rawRewardInfo.rewardTokenSymbol,
        rewardOracleAddress: rawRewardInfo.rewardOracleAddress,
        rewardPriceFeed: rawRewardInfo.rewardPriceFeed.toString(),
        priceFeedDecimals: rawRewardInfo.priceFeedDecimals
      }))
    };
  }
  _formatUserIncentiveData(data) {
    return {
      tokenAddress: data.tokenAddress,
      incentiveControllerAddress: data.incentiveControllerAddress,
      userRewardsInformation: data.userRewardsInformation.map((userRewardInformation) => ({
        rewardTokenAddress: userRewardInformation.rewardTokenAddress,
        rewardTokenDecimals: userRewardInformation.rewardTokenDecimals,
        tokenIncentivesUserIndex: userRewardInformation.tokenIncentivesUserIndex.toString(),
        userUnclaimedRewards: userRewardInformation.userUnclaimedRewards.toString(),
        rewardTokenSymbol: userRewardInformation.rewardTokenSymbol,
        rewardOracleAddress: userRewardInformation.rewardOracleAddress,
        rewardPriceFeed: userRewardInformation.rewardPriceFeed.toString(),
        priceFeedDecimals: userRewardInformation.priceFeedDecimals
      }))
    };
  }
}
__decorate([
  UiIncentiveDataProviderValidator,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("lendingPoolAddressProvider")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], UiIncentiveDataProvider.prototype, "getFullReservesIncentiveData", null);
__decorate([
  UiIncentiveDataProviderValidator,
  __param(0, isEthAddress("lendingPoolAddressProvider")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], UiIncentiveDataProvider.prototype, "getReservesIncentivesData", null);
__decorate([
  UiIncentiveDataProviderValidator,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("lendingPoolAddressProvider")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], UiIncentiveDataProvider.prototype, "getUserReservesIncentivesData", null);
__decorate([
  UiIncentiveDataProviderValidator,
  __param(0, isEthAddress("lendingPoolAddressProvider")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], UiIncentiveDataProvider.prototype, "getReservesIncentivesDataHumanized", null);
__decorate([
  UiIncentiveDataProviderValidator,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("lendingPoolAddressProvider")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], UiIncentiveDataProvider.prototype, "getUserReservesIncentivesDataHumanized", null);
__decorate([
  UiIncentiveDataProviderValidator,
  __param(0, isEthAddress("lendingPoolAddressProvider")),
  __param(0, isEthAddress("chainlinkFeedsRegistry")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], UiIncentiveDataProvider.prototype, "getIncentivesDataWithPriceLegacy", null);

// node_modules/@aave/contract-helpers/dist/esm/v3-UiPoolDataProvider-contract/index.js
var utils4 = __toESM(require_utils5(), 1);

// node_modules/@aave/contract-helpers/dist/esm/v3-UiPoolDataProvider-contract/typechain/IUiPoolDataProviderV3__factory.js
var _abi3 = [
  {
    inputs: [
      {
        internalType: "contract IPoolAddressesProvider",
        name: "provider",
        type: "address"
      }
    ],
    name: "getReservesData",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "underlyingAsset",
            type: "address"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "decimals",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseLTVasCollateral",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "reserveLiquidationThreshold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "reserveLiquidationBonus",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "reserveFactor",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "usageAsCollateralEnabled",
            type: "bool"
          },
          {
            internalType: "bool",
            name: "borrowingEnabled",
            type: "bool"
          },
          {
            internalType: "bool",
            name: "stableBorrowRateEnabled",
            type: "bool"
          },
          {
            internalType: "bool",
            name: "isActive",
            type: "bool"
          },
          {
            internalType: "bool",
            name: "isFrozen",
            type: "bool"
          },
          {
            internalType: "uint128",
            name: "liquidityIndex",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "variableBorrowIndex",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "liquidityRate",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "variableBorrowRate",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "stableBorrowRate",
            type: "uint128"
          },
          {
            internalType: "uint40",
            name: "lastUpdateTimestamp",
            type: "uint40"
          },
          {
            internalType: "address",
            name: "aTokenAddress",
            type: "address"
          },
          {
            internalType: "address",
            name: "stableDebtTokenAddress",
            type: "address"
          },
          {
            internalType: "address",
            name: "variableDebtTokenAddress",
            type: "address"
          },
          {
            internalType: "address",
            name: "interestRateStrategyAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "availableLiquidity",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalPrincipalStableDebt",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "averageStableRate",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "stableDebtLastUpdateTimestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "totalScaledVariableDebt",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "priceInMarketReferenceCurrency",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "priceOracle",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "variableRateSlope1",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "variableRateSlope2",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "stableRateSlope1",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "stableRateSlope2",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseStableBorrowRate",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseVariableBorrowRate",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "optimalUsageRatio",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "isPaused",
            type: "bool"
          },
          {
            internalType: "bool",
            name: "isSiloedBorrowing",
            type: "bool"
          },
          {
            internalType: "uint128",
            name: "accruedToTreasury",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "unbacked",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "isolationModeTotalDebt",
            type: "uint128"
          },
          {
            internalType: "bool",
            name: "flashLoanEnabled",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "debtCeiling",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "debtCeilingDecimals",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "eModeCategoryId",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "borrowCap",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "supplyCap",
            type: "uint256"
          },
          {
            internalType: "uint16",
            name: "eModeLtv",
            type: "uint16"
          },
          {
            internalType: "uint16",
            name: "eModeLiquidationThreshold",
            type: "uint16"
          },
          {
            internalType: "uint16",
            name: "eModeLiquidationBonus",
            type: "uint16"
          },
          {
            internalType: "address",
            name: "eModePriceSource",
            type: "address"
          },
          {
            internalType: "string",
            name: "eModeLabel",
            type: "string"
          },
          {
            internalType: "bool",
            name: "borrowableInIsolation",
            type: "bool"
          }
        ],
        internalType: "struct IUiPoolDataProviderV3.AggregatedReserveData[]",
        name: "",
        type: "tuple[]"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "marketReferenceCurrencyUnit",
            type: "uint256"
          },
          {
            internalType: "int256",
            name: "marketReferenceCurrencyPriceInUsd",
            type: "int256"
          },
          {
            internalType: "int256",
            name: "networkBaseTokenPriceInUsd",
            type: "int256"
          },
          {
            internalType: "uint8",
            name: "networkBaseTokenPriceDecimals",
            type: "uint8"
          }
        ],
        internalType: "struct IUiPoolDataProviderV3.BaseCurrencyInfo",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IPoolAddressesProvider",
        name: "provider",
        type: "address"
      }
    ],
    name: "getReservesList",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IPoolAddressesProvider",
        name: "provider",
        type: "address"
      },
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "getUserReservesData",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "underlyingAsset",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "scaledATokenBalance",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "usageAsCollateralEnabledOnUser",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "stableBorrowRate",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "scaledVariableDebt",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "principalStableDebt",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "stableBorrowLastUpdateTimestamp",
            type: "uint256"
          }
        ],
        internalType: "struct IUiPoolDataProviderV3.UserReserveData[]",
        name: "",
        type: "tuple[]"
      },
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

class IUiPoolDataProviderV3__factory {
  static createInterface() {
    return new exports_utils.Interface(_abi3);
  }
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi3, signerOrProvider);
  }
}
IUiPoolDataProviderV3__factory.abi = _abi3;

// node_modules/@aave/contract-helpers/dist/esm/v3-UiPoolDataProvider-contract/index.js
var ammSymbolMap = {
  "0xae461ca67b15dc8dc81ce7615e0320da1a9ab8d5": "UNIDAIUSDC",
  "0x004375dff511095cc5a197a54140a24efef3a416": "UNIWBTCUSDC",
  "0xa478c2975ab1ea89e8196811f51a7b7ade33eb11": "UNIDAIWETH",
  "0xb4e16d0168e52d35cacd2c6185b44281ec28c9dc": "UNIUSDCWETH",
  "0xdfc14d2af169b0d36c4eff567ada9b2e0cae044f": "UNIAAVEWETH",
  "0xb6909b960dbbe7392d405429eb2b3649752b4838": "UNIBATWETH",
  "0x3da1313ae46132a397d90d95b1424a9a7e3e0fce": "UNICRVWETH",
  "0xa2107fa5b38d9bbd2c461d6edf11b11a50f6b974": "UNILINKWETH",
  "0xc2adda861f89bbb333c90c492cb837741916a225": "UNIMKRWETH",
  "0x8bd1661da98ebdd3bd080f0be4e6d9be8ce9858c": "UNIRENWETH",
  "0x43ae24960e5534731fc831386c07755a2dc33d47": "UNISNXWETH",
  "0xd3d2e2692501a5c9ca623199d38826e513033a17": "UNIUNIWETH",
  "0xbb2b8038a1640196fbe3e38816f3e67cba72d940": "UNIWBTCWETH",
  "0x2fdbadf3c4d5a8666bc06645b8358ab803996e28": "UNIYFIWETH",
  "0x1eff8af5d577060ba4ac8a29a13525bb0ee2a3d5": "BPTWBTCWETH",
  "0x59a19d8c652fa0284f44113d0ff9aba70bd46fb4": "BPTBALWETH"
};

class UiPoolDataProvider {
  constructor(context) {
    if (!utils4.isAddress(context.uiPoolDataProviderAddress)) {
      throw new Error("contract address is not valid");
    }
    this._contract = IUiPoolDataProviderV3__factory.connect(context.uiPoolDataProviderAddress, context.provider);
    this.chainId = context.chainId;
  }
  async getReservesList({ lendingPoolAddressProvider }) {
    if (!utils4.isAddress(lendingPoolAddressProvider)) {
      throw new Error("Lending pool address is not valid");
    }
    return this._contract.getReservesList(lendingPoolAddressProvider);
  }
  async getReservesData({ lendingPoolAddressProvider }) {
    if (!utils4.isAddress(lendingPoolAddressProvider)) {
      throw new Error("Lending pool address is not valid");
    }
    return this._contract.getReservesData(lendingPoolAddressProvider);
  }
  async getUserReservesData({ lendingPoolAddressProvider, user }) {
    if (!utils4.isAddress(lendingPoolAddressProvider)) {
      throw new Error("Lending pool address is not valid");
    }
    if (!utils4.isAddress(user)) {
      throw new Error("User address is not a valid ethereum address");
    }
    return this._contract.getUserReservesData(lendingPoolAddressProvider, user);
  }
  async getReservesHumanized({ lendingPoolAddressProvider }) {
    const { 0: reservesRaw, 1: poolBaseCurrencyRaw } = await this.getReservesData({ lendingPoolAddressProvider });
    const reservesData = reservesRaw.map((reserveRaw) => ({
      id: `${this.chainId}-${reserveRaw.underlyingAsset}-${lendingPoolAddressProvider}`.toLowerCase(),
      underlyingAsset: reserveRaw.underlyingAsset.toLowerCase(),
      name: reserveRaw.name,
      symbol: ammSymbolMap[reserveRaw.underlyingAsset.toLowerCase()] ? ammSymbolMap[reserveRaw.underlyingAsset.toLowerCase()] : reserveRaw.symbol,
      decimals: reserveRaw.decimals.toNumber(),
      baseLTVasCollateral: reserveRaw.baseLTVasCollateral.toString(),
      reserveLiquidationThreshold: reserveRaw.reserveLiquidationThreshold.toString(),
      reserveLiquidationBonus: reserveRaw.reserveLiquidationBonus.toString(),
      reserveFactor: reserveRaw.reserveFactor.toString(),
      usageAsCollateralEnabled: reserveRaw.usageAsCollateralEnabled,
      borrowingEnabled: reserveRaw.borrowingEnabled,
      stableBorrowRateEnabled: reserveRaw.stableBorrowRateEnabled,
      isActive: reserveRaw.isActive,
      isFrozen: reserveRaw.isFrozen,
      liquidityIndex: reserveRaw.liquidityIndex.toString(),
      variableBorrowIndex: reserveRaw.variableBorrowIndex.toString(),
      liquidityRate: reserveRaw.liquidityRate.toString(),
      variableBorrowRate: reserveRaw.variableBorrowRate.toString(),
      stableBorrowRate: reserveRaw.stableBorrowRate.toString(),
      lastUpdateTimestamp: reserveRaw.lastUpdateTimestamp,
      aTokenAddress: reserveRaw.aTokenAddress.toString(),
      stableDebtTokenAddress: reserveRaw.stableDebtTokenAddress.toString(),
      variableDebtTokenAddress: reserveRaw.variableDebtTokenAddress.toString(),
      interestRateStrategyAddress: reserveRaw.interestRateStrategyAddress.toString(),
      availableLiquidity: reserveRaw.availableLiquidity.toString(),
      totalPrincipalStableDebt: reserveRaw.totalPrincipalStableDebt.toString(),
      averageStableRate: reserveRaw.averageStableRate.toString(),
      stableDebtLastUpdateTimestamp: reserveRaw.stableDebtLastUpdateTimestamp.toNumber(),
      totalScaledVariableDebt: reserveRaw.totalScaledVariableDebt.toString(),
      priceInMarketReferenceCurrency: reserveRaw.priceInMarketReferenceCurrency.toString(),
      priceOracle: reserveRaw.priceOracle,
      variableRateSlope1: reserveRaw.variableRateSlope1.toString(),
      variableRateSlope2: reserveRaw.variableRateSlope2.toString(),
      stableRateSlope1: reserveRaw.stableRateSlope1.toString(),
      stableRateSlope2: reserveRaw.stableRateSlope2.toString(),
      baseStableBorrowRate: reserveRaw.baseStableBorrowRate.toString(),
      baseVariableBorrowRate: reserveRaw.baseVariableBorrowRate.toString(),
      optimalUsageRatio: reserveRaw.optimalUsageRatio.toString(),
      isPaused: reserveRaw.isPaused,
      debtCeiling: reserveRaw.debtCeiling.toString(),
      eModeCategoryId: reserveRaw.eModeCategoryId,
      borrowCap: reserveRaw.borrowCap.toString(),
      supplyCap: reserveRaw.supplyCap.toString(),
      eModeLtv: reserveRaw.eModeLtv,
      eModeLiquidationThreshold: reserveRaw.eModeLiquidationThreshold,
      eModeLiquidationBonus: reserveRaw.eModeLiquidationBonus,
      eModePriceSource: reserveRaw.eModePriceSource.toString(),
      eModeLabel: reserveRaw.eModeLabel.toString(),
      borrowableInIsolation: reserveRaw.borrowableInIsolation,
      accruedToTreasury: reserveRaw.accruedToTreasury.toString(),
      unbacked: reserveRaw.unbacked.toString(),
      isolationModeTotalDebt: reserveRaw.isolationModeTotalDebt.toString(),
      debtCeilingDecimals: reserveRaw.debtCeilingDecimals.toNumber(),
      isSiloedBorrowing: reserveRaw.isSiloedBorrowing,
      flashLoanEnabled: reserveRaw.flashLoanEnabled
    }));
    const baseCurrencyData = {
      marketReferenceCurrencyDecimals: poolBaseCurrencyRaw.marketReferenceCurrencyUnit.toString().length - 1,
      marketReferenceCurrencyPriceInUsd: poolBaseCurrencyRaw.marketReferenceCurrencyPriceInUsd.toString(),
      networkBaseTokenPriceInUsd: poolBaseCurrencyRaw.networkBaseTokenPriceInUsd.toString(),
      networkBaseTokenPriceDecimals: poolBaseCurrencyRaw.networkBaseTokenPriceDecimals
    };
    return {
      reservesData,
      baseCurrencyData
    };
  }
  async getUserReservesHumanized({ lendingPoolAddressProvider, user }) {
    const { 0: userReservesRaw, 1: userEmodeCategoryId } = await this.getUserReservesData({ lendingPoolAddressProvider, user });
    return {
      userReserves: userReservesRaw.map((userReserveRaw) => ({
        id: `${this.chainId}-${user}-${userReserveRaw.underlyingAsset}-${lendingPoolAddressProvider}`.toLowerCase(),
        underlyingAsset: userReserveRaw.underlyingAsset.toLowerCase(),
        scaledATokenBalance: userReserveRaw.scaledATokenBalance.toString(),
        usageAsCollateralEnabledOnUser: userReserveRaw.usageAsCollateralEnabledOnUser,
        stableBorrowRate: userReserveRaw.stableBorrowRate.toString(),
        scaledVariableDebt: userReserveRaw.scaledVariableDebt.toString(),
        principalStableDebt: userReserveRaw.principalStableDebt.toString(),
        stableBorrowLastUpdateTimestamp: userReserveRaw.stableBorrowLastUpdateTimestamp.toNumber()
      })),
      userEmodeCategoryId
    };
  }
}

// node_modules/@aave/contract-helpers/dist/esm/wallet-balance-provider/index.js
var utils5 = __toESM(require_utils5(), 1);

// node_modules/@aave/contract-helpers/dist/esm/wallet-balance-provider/typechain/WalletBalanceProviderFactory.js
class WalletBalanceProviderFactory extends ContractFactory {
  constructor(signer) {
    super(_abi4, _bytecode, signer);
  }
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi4, signerOrProvider);
  }
}
var _abi4 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "users",
        type: "address[]"
      },
      {
        internalType: "address[]",
        name: "tokens",
        type: "address[]"
      }
    ],
    name: "batchBalanceOf",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "provider",
        type: "address"
      },
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "getUserWalletBalances",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];
var _bytecode = "0x608060405234801561001057600080fd5b50610a63806100206000396000f3fe6080604052600436106100385760003560e01c80630240534314610072578063b59b28ef146100a9578063f7888aec146100d65761006d565b3661006d5761004633610103565b61006b5760405162461bcd60e51b8152600401610062906109c9565b60405180910390fd5b005b600080fd5b34801561007e57600080fd5b5061009261008d366004610758565b61013f565b6040516100a092919061092f565b60405180910390f35b3480156100b557600080fd5b506100c96100c4366004610790565b6104b1565b6040516100a0919061098f565b3480156100e257600080fd5b506100f66100f1366004610758565b61058d565b6040516100a091906109e5565b6000813f7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47081811480159061013757508115155b949350505050565b6060806000846001600160a01b0316630261bf8b6040518163ffffffff1660e01b815260040160206040518083038186803b15801561017d57600080fd5b505afa158015610191573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101b5919061073c565b90506060816001600160a01b031663d1946dbc6040518163ffffffff1660e01b815260040160006040518083038186803b1580156101f257600080fd5b505afa158015610206573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261022e91908101906107f9565b90506060815160010167ffffffffffffffff8111801561024d57600080fd5b50604051908082528060200260200182016040528015610277578160200160208202803683370190505b50905060005b82518110156102c65782818151811061029257fe5b60200260200101518282815181106102a657fe5b6001600160a01b039092166020928302919091019091015260010161027d565b5073eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee818351815181106102e957fe5b60200260200101906001600160a01b031690816001600160a01b0316815250506060815167ffffffffffffffff8111801561032357600080fd5b5060405190808252806020026020018201604052801561034d578160200160208202803683370190505b50905060005b835181101561046b576103646106b9565b856001600160a01b031663c44b11f785848151811061037f57fe5b60200260200101516040518263ffffffff1660e01b81526004016103a3919061091b565b60206040518083038186803b1580156103bb57600080fd5b505afa1580156103cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103f391906108a4565b905060006104008261067d565b50505090508061042b57600084848151811061041857fe5b6020026020010181815250505050610463565b6104488a86858151811061043b57fe5b602002602001015161058d565b84848151811061045457fe5b60200260200101818152505050505b600101610353565b5061048a8773eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee61058d565b8184518151811061049757fe5b6020908102919091010152909450925050505b9250929050565b60608084830267ffffffffffffffff811180156104cd57600080fd5b506040519080825280602002602001820160405280156104f7578160200160208202803683370190505b50905060005b858110156105835760005b8481101561057a5761055588888481811061051f57fe5b90506020020160208101906105349190610719565b87878481811061054057fe5b90506020020160208101906100f19190610719565b83518490848802840190811061056757fe5b6020908102919091010152600101610508565b506001016104fd565b5095945050505050565b60006001600160a01b03821673eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee14156105c557506001600160a01b03821631610677565b6105d7826001600160a01b0316610103565b1561065f576040516370a0823160e01b81526001600160a01b038316906370a082319061060890869060040161091b565b60206040518083038186803b15801561062057600080fd5b505afa158015610634573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061065891906108c9565b9050610677565b60405162461bcd60e51b8152600401610062906109a2565b92915050565b51670100000000000000811615159167020000000000000082161515916704000000000000008116151591670800000000000000909116151590565b6040518060200160405280600081525090565b805161067781610a15565b60008083601f8401126106e8578182fd5b50813567ffffffffffffffff8111156106ff578182fd5b60208301915083602080830285010111156104aa57600080fd5b60006020828403121561072a578081fd5b813561073581610a15565b9392505050565b60006020828403121561074d578081fd5b815161073581610a15565b6000806040838503121561076a578081fd5b823561077581610a15565b9150602083013561078581610a15565b809150509250929050565b600080600080604085870312156107a5578182fd5b843567ffffffffffffffff808211156107bc578384fd5b6107c8888389016106d7565b909650945060208701359150808211156107e0578384fd5b506107ed878288016106d7565b95989497509550505050565b6000602080838503121561080b578182fd5b825167ffffffffffffffff80821115610822578384fd5b818501915085601f830112610835578384fd5b815181811115610843578485fd5b83810291506108538483016109ee565b8181528481019084860184860187018a101561086d578788fd5b8795505b83861015610897576108838a826106cc565b835260019590950194918601918601610871565b5098975050505050505050565b6000602082840312156108b5578081fd5b6108bf60206109ee565b9151825250919050565b6000602082840312156108da578081fd5b5051919050565b6000815180845260208085019450808401835b83811015610910578151875295820195908201906001016108f4565b509495945050505050565b6001600160a01b0391909116815260200190565b604080825283519082018190526000906020906060840190828701845b828110156109715781516001600160a01b03168452928401929084019060010161094c565b5050508381038285015261098581866108e1565b9695505050505050565b60006020825261073560208301846108e1565b6020808252600d908201526c24a72b20a624a22faa27a5a2a760991b604082015260600190565b602080825260029082015261191960f11b604082015260600190565b90815260200190565b60405181810167ffffffffffffffff81118282101715610a0d57600080fd5b604052919050565b6001600160a01b0381168114610a2a57600080fd5b5056fea26469706673582212207ae67703d49267c117fb5657d5acf71315b42fa382a2989a68cd98ccc5351bc964736f6c634300060c0033";

// node_modules/@aave/contract-helpers/dist/esm/wallet-balance-provider/index.js
class WalletBalanceProvider {
  constructor(context) {
    this._contract = WalletBalanceProviderFactory.connect(context.walletBalanceProviderAddress, context.provider);
  }
  async balanceOf(user, token) {
    if (!utils5.isAddress(user)) {
      throw new Error("User address is not a valid ethereum address");
    }
    if (!utils5.isAddress(token)) {
      throw new Error("Token address is not a valid ethereum address");
    }
    return this._contract.balanceOf(user, token);
  }
  async batchBalanceOf(users, tokens) {
    if (!users.every((u) => utils5.isAddress(u))) {
      throw new Error("One of the user address is not a valid ethereum address");
    }
    if (!tokens.every((u) => utils5.isAddress(u))) {
      throw new Error("One of the token address is not a valid ethereum address");
    }
    return this._contract.batchBalanceOf(users, tokens);
  }
  async getUserWalletBalancesForLendingPoolProvider(user, lendingPoolAddressProvider) {
    if (!utils5.isAddress(user)) {
      throw new Error("User address is not a valid ethereum address");
    }
    if (!utils5.isAddress(lendingPoolAddressProvider)) {
      throw new Error("Lending pool address provider is not a valid ethereum address");
    }
    return this._contract.getUserWalletBalances(lendingPoolAddressProvider, user);
  }
}

// node_modules/@aave/contract-helpers/dist/esm/erc20-contract/index.js
var utils6 = __toESM(require_utils5(), 1);

// node_modules/@aave/contract-helpers/dist/esm/erc20-contract/typechain/IERC20Detailed__factory.js
class IERC20Detailed__factory {
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi5, signerOrProvider);
  }
  static createInterface() {
    return new exports_utils.Interface(_abi5);
  }
}
var _abi5 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@aave/contract-helpers/dist/esm/erc20-contract/index.js
class ERC20Service extends BaseService {
  constructor(provider) {
    super(provider, IERC20Detailed__factory);
    this.tokenDecimals = {};
    this.tokenMetadata = {};
    this.approve = this.approve.bind(this);
    this.approveTxData = this.approveTxData.bind(this);
    this.isApproved = this.isApproved.bind(this);
    this.getTokenData = this.getTokenData.bind(this);
    this.decimalsOf = this.decimalsOf.bind(this);
    this.contractInterface = IERC20Detailed__factory.createInterface();
  }
  approve({ user, token, spender, amount }) {
    const erc20Contract = this.getContractInstance(token);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => erc20Contract.populateTransaction.approve(spender, amount),
      from: user
    });
    return {
      tx: txCallback,
      txType: eEthereumTxType.ERC20_APPROVAL,
      gas: this.generateTxPriceEstimation([], txCallback)
    };
  }
  approveTxData({ user, token, spender, amount }) {
    const tx = {};
    const txData = this.contractInterface.encodeFunctionData("approve", [
      spender,
      amount
    ]);
    tx.data = txData;
    tx.to = token;
    tx.from = user;
    tx.gasLimit = BigNumber.from(gasLimitRecommendations[ProtocolAction.approval].recommended);
    return tx;
  }
  async isApproved({ user, token, spender, amount, nativeDecimals }) {
    if (token.toLowerCase() === API_ETH_MOCK_ADDRESS.toLowerCase())
      return true;
    const decimals = await this.decimalsOf(token);
    const erc20Contract = this.getContractInstance(token);
    const allowance = await erc20Contract.allowance(user, spender);
    const amountBNWithDecimals = amount === "-1" ? BigNumber.from(SUPER_BIG_ALLOWANCE_NUMBER) : BigNumber.from(valueToWei(nativeDecimals ? utils6.formatUnits(amount, decimals) : amount, decimals));
    return allowance.gte(amountBNWithDecimals);
  }
  async approvedAmount({ user, token, spender }) {
    if (token.toLowerCase() === API_ETH_MOCK_ADDRESS.toLowerCase())
      return -1;
    const erc20Contract = this.getContractInstance(token);
    const allowance = await erc20Contract.allowance(user, spender);
    if (allowance.toString() === MAX_UINT_AMOUNT) {
      return -1;
    }
    const decimals = await this.decimalsOf(token);
    return Number(exports_ethers.utils.formatUnits(allowance, decimals));
  }
  async decimalsOf(token) {
    if (token.toLowerCase() === API_ETH_MOCK_ADDRESS.toLowerCase())
      return 18;
    if (!this.tokenDecimals[token]) {
      const erc20Contract = this.getContractInstance(token);
      this.tokenDecimals[token] = await erc20Contract.decimals();
    }
    return this.tokenDecimals[token];
  }
  async getTokenData(token) {
    if (token.toLowerCase() === API_ETH_MOCK_ADDRESS.toLowerCase()) {
      return {
        name: "Ethereum",
        symbol: "ETH",
        decimals: 18,
        address: token
      };
    }
    if (token.toLowerCase() === "0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2".toLowerCase()) {
      return {
        name: "Maker",
        symbol: "MKR",
        decimals: 18,
        address: token
      };
    }
    if (!this.tokenMetadata[token]) {
      const { name: nameGetter, symbol: symbolGetter } = this.getContractInstance(token);
      const [name, symbol, decimals] = await Promise.all([
        nameGetter(),
        symbolGetter(),
        this.decimalsOf(token)
      ]);
      this.tokenMetadata[token] = {
        name,
        symbol,
        decimals,
        address: token
      };
    }
    return this.tokenMetadata[token];
  }
}
__decorate([
  ERC20Validator,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("token")),
  __param(0, isEthAddress("spender")),
  __param(0, isPositiveAmount("amount")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Object)
], ERC20Service.prototype, "approve", null);
__decorate([
  ERC20Validator,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("token")),
  __param(0, isEthAddress("spender")),
  __param(0, isPositiveAmount("amount")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Object)
], ERC20Service.prototype, "approveTxData", null);
__decorate([
  ERC20Validator,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("token")),
  __param(0, isEthAddress("spender")),
  __param(0, isPositiveOrMinusOneAmount("amount")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], ERC20Service.prototype, "isApproved", null);
__decorate([
  ERC20Validator,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("token")),
  __param(0, isEthAddress("spender")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], ERC20Service.prototype, "approvedAmount", null);
__decorate([
  ERC20Validator,
  __param(0, isEthAddress()),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [String]),
  __metadata("design:returntype", Promise)
], ERC20Service.prototype, "decimalsOf", null);
__decorate([
  ERC20Validator,
  __param(0, isEthAddress()),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [String]),
  __metadata("design:returntype", Promise)
], ERC20Service.prototype, "getTokenData", null);

// node_modules/@aave/contract-helpers/dist/esm/paraswap-liquiditySwapAdapter-contract/typechain/IParaSwapLiquiditySwapAdapter__factory.js
class IParaSwapLiquiditySwapAdapter__factory {
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi6, signerOrProvider);
  }
}
var _abi6 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "assetToSwapFrom",
        type: "address"
      },
      {
        internalType: "address",
        name: "assetToSwapTo",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amountToSwap",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "minAmountToReceive",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "swapAllBalanceOffset",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "swapCalldata",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "augustus",
        type: "address"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        internalType: "struct IParaSwapLiquiditySwapAdapter.PermitSignature",
        name: "permitParams",
        type: "tuple"
      }
    ],
    name: "swapAndDeposit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@aave/contract-helpers/dist/esm/paraswap-liquiditySwapAdapter-contract/index.js
function augustusFromAmountOffsetFromCalldata(calldata) {
  switch (calldata.slice(0, 10)) {
    case "0xda8567c8":
      return 100;
    case "0x58b9d179":
      return 4;
    case "0x0863b7ac":
      return 68;
    case "0x8f00eccb":
      return 68;
    case "0xec1d21dd":
      return 68;
    case "0x54840d1a":
      return 4;
    case "0xf5661034":
      return 68;
    case "0x0b86a4c1":
      return 36;
    case "0x64466805":
      return 68;
    case "0xa94e78ef":
      return 68;
    case "0x46c67b6d":
      return 68;
    case "0xb22f4db8":
      return 68;
    case "0x19fc5be0":
      return 68;
    case "0x3865bde6":
      return 68;
    case "0x58f15100":
      return 68;
    case "0xa6866da9":
      return 68;
    default:
      throw new Error("Unrecognized function selector for Augustus");
  }
}

class LiquiditySwapAdapterService extends BaseService {
  constructor(provider, swapCollateralAdapterAddress) {
    super(provider, IParaSwapLiquiditySwapAdapter__factory);
    this.liquiditySwapAdapterAddress = swapCollateralAdapterAddress !== null && swapCollateralAdapterAddress !== undefined ? swapCollateralAdapterAddress : "";
    this.swapAndDeposit = this.swapAndDeposit.bind(this);
  }
  swapAndDeposit({ user, assetToSwapFrom, assetToSwapTo, amountToSwap, minAmountToReceive, permitParams, augustus, swapCallData, swapAll }, txs) {
    const liquiditySwapContract = this.getContractInstance(this.liquiditySwapAdapterAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => liquiditySwapContract.populateTransaction.swapAndDeposit(assetToSwapFrom, assetToSwapTo, amountToSwap, minAmountToReceive, swapAll ? augustusFromAmountOffsetFromCalldata(swapCallData) : 0, swapCallData, augustus, permitParams),
      from: user
    });
    return {
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs !== null && txs !== undefined ? txs : [], txCallback, ProtocolAction.swapCollateral)
    };
  }
}
__decorate([
  LiquiditySwapValidator,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("assetToSwapFrom")),
  __param(0, isEthAddress("assetToSwapTo")),
  __param(0, isEthAddress("augustus")),
  __param(0, isPositiveAmount("amountToSwap")),
  __param(0, isPositiveAmount("minAmountToReceive")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Array]),
  __metadata("design:returntype", Object)
], LiquiditySwapAdapterService.prototype, "swapAndDeposit", null);

// node_modules/@aave/contract-helpers/dist/esm/paraswap-repayWithCollateralAdapter-contract/typechain/ParaSwapRepayAdapter__factory.js
var _abi7 = [
  {
    inputs: [
      {
        internalType: "contract IPoolAddressesProvider",
        name: "addressesProvider",
        type: "address"
      },
      {
        internalType: "contract IParaSwapAugustusRegistry",
        name: "augustusRegistry",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "fromAsset",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "toAsset",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountSold",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "receivedAmount",
        type: "uint256"
      }
    ],
    name: "Bought",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "fromAsset",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "toAsset",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "fromAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "receivedAmount",
        type: "uint256"
      }
    ],
    name: "Swapped",
    type: "event"
  },
  {
    inputs: [],
    name: "ADDRESSES_PROVIDER",
    outputs: [
      {
        internalType: "contract IPoolAddressesProvider",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "AUGUSTUS_REGISTRY",
    outputs: [
      {
        internalType: "contract IParaSwapAugustusRegistry",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MAX_SLIPPAGE_PERCENT",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "ORACLE",
    outputs: [
      {
        internalType: "contract IPriceOracleGetter",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "POOL",
    outputs: [
      {
        internalType: "contract IPool",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "assets",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "premiums",
        type: "uint256[]"
      },
      {
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "params",
        type: "bytes"
      }
    ],
    name: "executeOperation",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      }
    ],
    name: "rescueTokens",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20Detailed",
        name: "collateralAsset",
        type: "address"
      },
      {
        internalType: "contract IERC20Detailed",
        name: "debtAsset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "collateralAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "debtRepayAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "debtRateMode",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "buyAllBalanceOffset",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "paraswapData",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        internalType: "struct BaseParaSwapAdapter.PermitSignature",
        name: "permitSignature",
        type: "tuple"
      }
    ],
    name: "swapAndRepay",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var _bytecode2 = "0x6101006040523480156200001257600080fd5b506040516200333638038062003336833981016040819052620000359162000263565b81818180806001600160a01b03166080816001600160a01b031681525050806001600160a01b031663026b1d5f6040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000092573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000b89190620002a2565b6001600160a01b031660a05250600080546001600160a01b031916339081178255604051909182917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350806001600160a01b031663fca513a86040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000145573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200016b9190620002a2565b6001600160a01b0390811660c05260405163fb04e17b60e01b815260006004820152908316915063fb04e17b90602401602060405180830381865afa158015620001b9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001df9190620002c9565b15620002315760405162461bcd60e51b815260206004820152601c60248201527f4e6f7420612076616c6964204175677573747573206164647265737300000000604482015260640160405180910390fd5b6001600160a01b031660e05250506001805550620002ed565b6001600160a01b03811681146200026057600080fd5b50565b600080604083850312156200027757600080fd5b825162000284816200024a565b602084015190925062000297816200024a565b809150509250929050565b600060208284031215620002b557600080fd5b8151620002c2816200024a565b9392505050565b600060208284031215620002dc57600080fd5b81518015158114620002c257600080fd5b60805160a05160c05160e051612fa06200039660003960008181610176015261111801526000818161014f015261237b0152600081816101b8015281816104bb015281816105750152818161064b015281816106e50152818161079f0152818161087501528181610a7001528181611a6801528181611b2601528181611bfe01528181611cc301528181611d5e01528181611fc6015261217b0152600060e70152612fa06000f3fe608060405234801561001057600080fd5b50600436106100c85760003560e01c80634db9dc97116100815780638da5cb5b1161005b5780638da5cb5b146101da578063920f5c84146101f8578063f2fde38b1461021b57600080fd5b80634db9dc9714610198578063715018a6146101ab5780637535d246146101b357600080fd5b806332e4b286116100b257806332e4b2861461013357806338013f021461014a5780633a8298671461017157600080fd5b8062ae3bf8146100cd5780630542975c146100e2575b600080fd5b6100e06100db366004612585565b61022e565b005b6101097f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b61013c610bb881565b60405190815260200161012a565b6101097f000000000000000000000000000000000000000000000000000000000000000081565b6101097f000000000000000000000000000000000000000000000000000000000000000081565b6100e06101a63660046125eb565b610385565b6100e06108f4565b6101097f000000000000000000000000000000000000000000000000000000000000000081565b60005473ffffffffffffffffffffffffffffffffffffffff16610109565b61020b6102063660046126f9565b6109e4565b604051901515815260200161012a565b6100e0610229366004612585565b610c31565b60005473ffffffffffffffffffffffffffffffffffffffff1633146102b4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b6103826102d660005473ffffffffffffffffffffffffffffffffffffffff1690565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff8416906370a0823190602401602060405180830381865afa158015610340573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061036491906127d4565b73ffffffffffffffffffffffffffffffffffffffff84169190610de2565b50565b600260015414156103f2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016102ab565b60026001556104048886868933610ebb565b955061042089338961041b3686900386018661291f565b61108e565b60006104688585858080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508f92508e91508d90508c6110b4565b90506000610476828a61296a565b905080156106a8576040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000081166004830152600060248301528c169063095ea7b3906044016020604051808303816000875af1158015610513573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105379190612981565b506040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018390528c169063095ea7b3906044016020604051808303816000875af11580156105cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105f19190612981565b506040517fe8eda9df00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8c8116600483015260248201839052336044830152600060648301527f0000000000000000000000000000000000000000000000000000000000000000169063e8eda9df90608401600060405180830381600087803b15801561068f57600080fd5b505af11580156106a3573d6000803e3d6000fd5b505050505b6040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000081166004830152600060248301528b169063095ea7b3906044016020604051808303816000875af115801561073d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107619190612981565b506040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018a90528b169063095ea7b3906044016020604051808303816000875af11580156107f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061081b9190612981565b506040517f573ade8100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8b81166004830152602482018a9052604482018990523360648301527f0000000000000000000000000000000000000000000000000000000000000000169063573ade81906084016020604051808303816000875af11580156108be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108e291906127d4565b50506001805550505050505050505050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610975576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016102ab565b6000805460405173ffffffffffffffffffffffffffffffffffffffff909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a3600080547fffffffffffffffffffffffff0000000000000000000000000000000000000000169055565b600060026001541415610a53576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016102ab565b60026001553373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614610af7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f43414c4c45525f4d5553545f42455f504f4f4c0000000000000000000000000060448201526064016102ab565b600189148015610b075750600187145b8015610b135750600185145b610b9f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f464c4153484c4f414e5f4d554c5449504c455f4153534554535f4e4f545f535560448201527f50504f525445440000000000000000000000000000000000000000000000000060648201526084016102ab565b600088886000818110610bb457610bb46129a3565b905060200201359050600087876000818110610bd257610bd26129a3565b905060200201359050600086905060008d8d6000818110610bf557610bf56129a3565b9050602002016020810190610c0a9190612585565b9050610c1a8787858585896119ed565b505060018080559c9b505050505050505050505050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610cb2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016102ab565b73ffffffffffffffffffffffffffffffffffffffff8116610d55576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016102ab565b6000805460405173ffffffffffffffffffffffffffffffffffffffff808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b6040517fa9059cbb0000000000000000000000000000000000000000000000000000000080825273ffffffffffffffffffffffffffffffffffffffff84166004830152602482018390529060008060448382895af1610e45573d6000803e3d6000fd5b50610e4f84611e35565b610eb5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f475076323a206661696c6564207472616e73666572000000000000000000000060448201526064016102ab565b50505050565b600080610ec787611f01565b905060006001876002811115610edf57610edf6129d2565b6002811115610ef057610ef06129d2565b14610f0057816101400151610f07565b8161012001515b6040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86811660048301529192506000918316906370a0823190602401602060405180830381865afa158015610f79573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f9d91906127d4565b90508615611017578581111561100f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f494e53554646494349454e545f414d4f554e545f544f5f52455041590000000060448201526064016102ab565b809550611081565b80861115611081576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f494e56414c49445f444542545f52455041595f414d4f554e540000000000000060448201526064016102ab565b5093979650505050505050565b600061109985611f01565b610100015190506110ad8582868686612038565b5050505050565b6000806000878060200190518101906110cd9190612a73565b6040517ffb04e17b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff80831660048301529294509092507f00000000000000000000000000000000000000000000000000000000000000009091169063fb04e17b90602401602060405180830381865afa158015611161573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111859190612981565b6111eb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f494e56414c49445f41554755535455530000000000000000000000000000000060448201526064016102ab565b60006111f688612251565b60ff169050600061120688612251565b60ff16905060006112168a612333565b905060006112238a612333565b9050600061127b611238612710610bb86123e8565b61127561125061124988600a612c26565b87906123f8565b61126f6112686112618b600a612c26565b88906123f8565b8e906123f8565b90612422565b90612435565b9050808a111561130d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602360248201527f6d6178416d6f756e74546f5377617020657863656564206d617820736c69707060448201527f616765000000000000000000000000000000000000000000000000000000000060648201526084016102ab565b50506040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201526000935073ffffffffffffffffffffffffffffffffffffffff8b1692506370a082319150602401602060405180830381865afa15801561137f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113a391906127d4565b90508581101561140f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f494e53554646494349454e545f42414c414e43455f4245464f52455f5357415060448201526064016102ab565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260009073ffffffffffffffffffffffffffffffffffffffff8916906370a0823190602401602060405180830381865afa15801561147c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114a091906127d4565b905060008373ffffffffffffffffffffffffffffffffffffffff1663d2c4b5986040518163ffffffff1660e01b8152600401602060405180830381865afa1580156114ef573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115139190612c42565b6040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff808316600483015260006024830152919250908b169063095ea7b3906044016020604051808303816000875af115801561158c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115b09190612981565b506040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8281166004830152602482018a90528b169063095ea7b3906044016020604051808303816000875af1158015611626573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061164a9190612981565b508b156116dd5760048c1015801561166e5750845161166a906020612478565b8c11155b6116d4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f544f5f414d4f554e545f4f46465345545f4f55545f4f465f52414e474500000060448201526064016102ab565b8660208d018601525b60008473ffffffffffffffffffffffffffffffffffffffff16866040516117049190612c5f565b6000604051808303816000865af19150503d8060008114611741576040519150601f19603f3d011682016040523d82523d6000602084013e611746565b606091505b5050905080611759573d6000803e3d6000fd5b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260009073ffffffffffffffffffffffffffffffffffffffff8d16906370a0823190602401602060405180830381865afa1580156117c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117ea91906127d4565b90506117f6818661296a565b975089881115611862576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f57524f4e475f42414c414e43455f41465445525f53574150000000000000000060448201526064016102ab565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201526000906118ff90869073ffffffffffffffffffffffffffffffffffffffff8f16906370a0823190602401602060405180830381865afa1580156118d5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118f991906127d4565b90612478565b90508981101561196b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f494e53554646494349454e545f414d4f554e545f52454345495645440000000060448201526064016102ab565b8b73ffffffffffffffffffffffffffffffffffffffff168d73ffffffffffffffffffffffffffffffffffffffff167fbf77fd13a39d14dc0da779342c14105c38d9a5d0c60f2caa22f5fd1d5525416d8b846040516119d3929190918252602082015260400190565b60405180910390a350505050505050509695505050505050565b60008080808080611a008b8d018d612c7b565b955095509550955095509550611a19868486888d610ebb565b94506000611a2b85848b8a8c8b6110b4565b6040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000081166004830152600060248301529192509088169063095ea7b3906044016020604051808303816000875af1158015611ac4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ae89190612981565b506040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000811660048301526024820188905288169063095ea7b3906044016020604051808303816000875af1158015611b7e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ba29190612981565b506040517f573ade8100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff888116600483015260248201889052604482018690528b811660648301527f0000000000000000000000000000000000000000000000000000000000000000169063573ade81906084016020604051808303816000875af1158015611c47573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c6b91906127d4565b506000611c78828d6123e8565b9050611c868a8c838661108e565b6040517f095ea7b300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000081166004830152600060248301528b169063095ea7b3906044016020604051808303816000875af1158015611d1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d3f9190612981565b508973ffffffffffffffffffffffffffffffffffffffff1663095ea7b37f0000000000000000000000000000000000000000000000000000000000000000611d908f8d6123e890919063ffffffff16565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b16815273ffffffffffffffffffffffffffffffffffffffff909216600483015260248201526044016020604051808303816000875af1158015611e00573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e249190612981565b505050505050505050505050505050565b6000611e75565b7f08c379a00000000000000000000000000000000000000000000000000000000060005260206004528060245250806044525060646000fd5b3d8015611eb45760208114611eee57611eaf7f475076323a206d616c666f726d6564207472616e7366657220726573756c7400601f611e3c565b611efb565b823b611ee557611ee57f475076323a206e6f74206120636f6e74726163740000000000000000000000006014611e3c565b60019150611efb565b3d6000803e600051151591505b50919050565b604080516102008101825260006101e08201818152825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081018290526101408101829052610160810182905261018081018290526101a081018290526101c08101919091526040517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83811660048301527f000000000000000000000000000000000000000000000000000000000000000016906335ea6a75906024016101e060405180830381865afa15801561200e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120329190612dc0565b92915050565b60208101511561210557805160208201516040808401516060850151608086015192517fd505accf00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff89811660048301523060248301526044820196909652606481019490945260ff909116608484015260a483015260c48201529085169063d505accf9060e401600060405180830381600087803b1580156120ec57600080fd5b505af1158015612100573d6000803e3d6000fd5b505050505b61212773ffffffffffffffffffffffffffffffffffffffff8516843085612488565b6040517f69328dec00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86811660048301526024820184905230604483015283917f0000000000000000000000000000000000000000000000000000000000000000909116906369328dec906064016020604051808303816000875af11580156121c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121ea91906127d4565b146110ad576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f554e45585045435445445f414d4f554e545f57495448445241574e000000000060448201526064016102ab565b6000808273ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561229f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122c39190612ee3565b9050604d8160ff161115612032576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f544f4f5f4d414e595f444543494d414c535f4f4e5f544f4b454e00000000000060448201526064016102ab565b6040517fb3596f0700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff82811660048301526000917f00000000000000000000000000000000000000000000000000000000000000009091169063b3596f0790602401602060405180830381865afa1580156123c4573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061203291906127d4565b8082018281101561203257600080fd5b60008215806124195750508181028183828161241657612416612f00565b04145b61203257600080fd5b600061242e8284612f2f565b9392505050565b600081157fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec778390048411151761246a57600080fd5b506127109102611388010490565b8082038281111561203257600080fd5b6040517f23b872dd0000000000000000000000000000000000000000000000000000000080825273ffffffffffffffffffffffffffffffffffffffff8581166004840152841660248301526044820183905290600080606483828a5af16124f3573d6000803e3d6000fd5b506124fd85611e35565b6110ad576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f475076323a206661696c6564207472616e7366657246726f6d0000000000000060448201526064016102ab565b73ffffffffffffffffffffffffffffffffffffffff8116811461038257600080fd5b60006020828403121561259757600080fd5b813561242e81612563565b60008083601f8401126125b457600080fd5b50813567ffffffffffffffff8111156125cc57600080fd5b6020830191508360208285010111156125e457600080fd5b9250929050565b6000806000806000806000806000898b0361018081121561260b57600080fd5b8a3561261681612563565b995060208b013561262681612563565b985060408b0135975060608b0135965060808b0135955060a08b0135945060c08b013567ffffffffffffffff81111561265e57600080fd5b61266a8d828e016125a2565b90955093505060a07fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff20820112156126a057600080fd5b5060e08a0190509295985092959850929598565b60008083601f8401126126c657600080fd5b50813567ffffffffffffffff8111156126de57600080fd5b6020830191508360208260051b85010111156125e457600080fd5b600080600080600080600080600060a08a8c03121561271757600080fd5b893567ffffffffffffffff8082111561272f57600080fd5b61273b8d838e016126b4565b909b50995060208c013591508082111561275457600080fd5b6127608d838e016126b4565b909950975060408c013591508082111561277957600080fd5b6127858d838e016126b4565b909750955060608c0135915061279a82612563565b90935060808b013590808211156127b057600080fd5b506127bd8c828d016125a2565b915080935050809150509295985092959850929598565b6000602082840312156127e657600080fd5b5051919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516101e0810167ffffffffffffffff81118282101715612840576128406127ed565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561288d5761288d6127ed565b604052919050565b60ff8116811461038257600080fd5b600060a082840312156128b657600080fd5b60405160a0810181811067ffffffffffffffff821117156128d9576128d96127ed565b8060405250809150823581526020830135602082015260408301356128fd81612895565b8060408301525060608301356060820152608083013560808201525092915050565b600060a0828403121561293157600080fd5b61242e83836128a4565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008282101561297c5761297c61293b565b500390565b60006020828403121561299357600080fd5b8151801515811461242e57600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b600067ffffffffffffffff821115612a1b57612a1b6127ed565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b60005b83811015612a62578181015183820152602001612a4a565b83811115610eb55750506000910152565b60008060408385031215612a8657600080fd5b825167ffffffffffffffff811115612a9d57600080fd5b8301601f81018513612aae57600080fd5b8051612ac1612abc82612a01565b612846565b818152866020838501011115612ad657600080fd5b612ae7826020830160208601612a47565b8094505050506020830151612afb81612563565b809150509250929050565b600181815b80851115612b5f57817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04821115612b4557612b4561293b565b80851615612b5257918102915b93841c9390800290612b0b565b509250929050565b600082612b7657506001612032565b81612b8357506000612032565b8160018114612b995760028114612ba357612bbf565b6001915050612032565b60ff841115612bb457612bb461293b565b50506001821b612032565b5060208310610133831016604e8410600b8410161715612be2575081810a612032565b612bec8383612b06565b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04821115612c1e57612c1e61293b565b029392505050565b600061242e8383612b67565b8051612c3d81612563565b919050565b600060208284031215612c5457600080fd5b815161242e81612563565b60008251612c71818460208701612a47565b9190910192915050565b6000806000806000806101408789031215612c9557600080fd5b8635612ca081612563565b9550602087013594506040870135935060608701359250608087013567ffffffffffffffff811115612cd157600080fd5b8701601f81018913612ce257600080fd5b8035612cf0612abc82612a01565b8181528a6020838501011115612d0557600080fd5b81602084016020830137600060208383010152809450505050612d2b8860a089016128a4565b90509295509295509295565b600060208284031215612d4957600080fd5b6040516020810181811067ffffffffffffffff82111715612d6c57612d6c6127ed565b6040529151825250919050565b80516fffffffffffffffffffffffffffffffff81168114612c3d57600080fd5b805164ffffffffff81168114612c3d57600080fd5b805161ffff81168114612c3d57600080fd5b60006101e08284031215612dd357600080fd5b612ddb61281c565b612de58484612d37565b8152612df360208401612d79565b6020820152612e0460408401612d79565b6040820152612e1560608401612d79565b6060820152612e2660808401612d79565b6080820152612e3760a08401612d79565b60a0820152612e4860c08401612d99565b60c0820152612e5960e08401612dae565b60e0820152610100612e6c818501612c32565b90820152610120612e7e848201612c32565b90820152610140612e90848201612c32565b90820152610160612ea2848201612c32565b90820152610180612eb4848201612d79565b908201526101a0612ec6848201612d79565b908201526101c0612ed8848201612d79565b908201529392505050565b600060208284031215612ef557600080fd5b815161242e81612895565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082612f65577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b50049056fea26469706673582212201ae79dd35f34ecf1387bee8e87022a83fa61b3a7ba8b1ecade15267edadaceb264736f6c634300080a0033";

class ParaSwapRepayAdapter__factory extends ContractFactory {
  constructor(signer) {
    super(_abi7, _bytecode2, signer);
  }
  deploy(addressesProvider, augustusRegistry, overrides) {
    return super.deploy(addressesProvider, augustusRegistry, overrides || {});
  }
  getDeployTransaction(addressesProvider, augustusRegistry, overrides) {
    return super.getDeployTransaction(addressesProvider, augustusRegistry, overrides || {});
  }
  attach(address4) {
    return super.attach(address4);
  }
  connect(signer) {
    return super.connect(signer);
  }
  static createInterface() {
    return new exports_utils.Interface(_abi7);
  }
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi7, signerOrProvider);
  }
}
ParaSwapRepayAdapter__factory.bytecode = _bytecode2;
ParaSwapRepayAdapter__factory.abi = _abi7;

// node_modules/@aave/contract-helpers/dist/esm/paraswap-repayWithCollateralAdapter-contract/index.js
class ParaswapRepayWithCollateral extends BaseService {
  constructor(provider, repayWithCollateralAddress) {
    super(provider, ParaSwapRepayAdapter__factory);
    this.repayWithCollateralAddress = repayWithCollateralAddress !== null && repayWithCollateralAddress !== undefined ? repayWithCollateralAddress : "";
    this.swapAndRepay = this.swapAndRepay.bind(this);
  }
  swapAndRepay({ collateralAsset, debtAsset, collateralAmount, debtRepayAmount, debtRateMode, repayAll, permitParams, swapAndRepayCallData, user, augustus }, txs) {
    const numericInterestRate = debtRateMode === InterestRate.Stable ? 1 : 2;
    const swapAndRepayContract = this.getContractInstance(this.repayWithCollateralAddress);
    const callDataEncoded = exports_utils.defaultAbiCoder.encode(["bytes", "address"], [swapAndRepayCallData, augustus]);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => swapAndRepayContract.populateTransaction.swapAndRepay(collateralAsset, debtAsset, collateralAmount, debtRepayAmount, numericInterestRate, repayAll ? augustusToAmountOffsetFromCalldata(swapAndRepayCallData) : 0, callDataEncoded, permitParams),
      from: user
    });
    return {
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs !== null && txs !== undefined ? txs : [], txCallback, ProtocolAction.repayCollateral)
    };
  }
}
__decorate([
  RepayWithCollateralValidator,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("collateralAsset")),
  __param(0, isEthAddress("debtAsset")),
  __param(0, isPositiveAmount("collateralAmount")),
  __param(0, isPositiveAmount("debtRepayAmount")),
  __param(0, isEthAddress("augustus")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Array]),
  __metadata("design:returntype", Object)
], ParaswapRepayWithCollateral.prototype, "swapAndRepay", null);

// node_modules/@aave/contract-helpers/dist/esm/synthetix-contract/typechain/ISynthetix__factory.js
class ISynthetix__factory {
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi8, signerOrProvider);
  }
}
var _abi8 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "transferableSynthetix",
    outputs: [
      {
        internalType: "uint256",
        name: "transferable",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@aave/contract-helpers/dist/esm/synthetix-contract/index.js
var synthetixProxyByChainId = {
  [ChainId.mainnet]: "0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f"
};

class SynthetixService extends BaseService {
  constructor(provider) {
    super(provider, ISynthetix__factory);
    this.synthetixValidation = this.synthetixValidation.bind(this);
  }
  async synthetixValidation({
    user,
    reserve,
    amount
  }) {
    const { chainId } = await this.provider.getNetwork();
    if (synthetixProxyByChainId[chainId] && reserve.toLowerCase() === synthetixProxyByChainId[chainId].toLowerCase()) {
      const synthContract = this.getContractInstance(synthetixProxyByChainId[chainId]);
      const transferableAmount = await synthContract.transferableSynthetix(user);
      return BigNumber.from(amount).lte(transferableAmount);
    }
    return true;
  }
}
__decorate([
  SynthetixValidator,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("reserve")),
  __param(0, isPositiveAmount("amount")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], SynthetixService.prototype, "synthetixValidation", null);

// node_modules/@aave/contract-helpers/dist/esm/baseDebtToken-contract/typechain/IDebtTokenBase__factory.js
class IDebtTokenBase__factory {
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi9, signerOrProvider);
  }
  static createInterface() {
    return new exports_utils.Interface(_abi9);
  }
}
var _abi9 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "delegatee",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approveDelegation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "fromUser",
        type: "address"
      },
      {
        internalType: "address",
        name: "toUser",
        type: "address"
      }
    ],
    name: "borrowAllowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@aave/contract-helpers/dist/esm/baseDebtToken-contract/index.js
class BaseDebtToken extends BaseService {
  constructor(provider, erc20Service) {
    super(provider, IDebtTokenBase__factory);
    this.erc20Service = erc20Service;
    this.debtTokenInterface = IDebtTokenBase__factory.createInterface();
  }
  approveDelegation({ user, delegatee, debtTokenAddress, amount }) {
    const debtTokenContract = this.getContractInstance(debtTokenAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => debtTokenContract.populateTransaction.approveDelegation(delegatee, amount),
      from: user
    });
    return {
      tx: txCallback,
      txType: eEthereumTxType.ERC20_APPROVAL,
      gas: this.generateTxPriceEstimation([], txCallback)
    };
  }
  async approvedDelegationAmount({ user, delegatee, debtTokenAddress }) {
    const debtTokenContract = this.getContractInstance(debtTokenAddress);
    const allowance = await debtTokenContract.borrowAllowance(user, delegatee);
    const decimals = await this.erc20Service.decimalsOf(debtTokenAddress);
    return Number(exports_ethers.utils.formatUnits(allowance, decimals));
  }
  generateApproveDelegationTxData({ user, delegatee, debtTokenAddress, amount }) {
    const txData = this.debtTokenInterface.encodeFunctionData("approveDelegation", [delegatee, amount]);
    const approveDelegationTx = {
      data: txData,
      to: debtTokenAddress,
      from: user,
      gasLimit: BigNumber.from(gasLimitRecommendations[ProtocolAction.creditDelegationApproval].recommended)
    };
    return approveDelegationTx;
  }
  async isDelegationApproved({ debtTokenAddress, allowanceGiver, allowanceReceiver, amount, nativeDecimals }) {
    const decimals = await this.erc20Service.decimalsOf(debtTokenAddress);
    const debtTokenContract = this.getContractInstance(debtTokenAddress);
    const delegatedAllowance = await debtTokenContract.borrowAllowance(allowanceGiver, allowanceReceiver);
    const amountBNWithDecimals = nativeDecimals ? BigNumber.from(amount) : BigNumber.from(valueToWei(amount, decimals));
    return delegatedAllowance.gte(amountBNWithDecimals);
  }
}
__decorate([
  DebtTokenValidator,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("delegatee")),
  __param(0, isEthAddress("debtTokenAddress")),
  __param(0, isPositiveAmount("amount")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Object)
], BaseDebtToken.prototype, "approveDelegation", null);
__decorate([
  DebtTokenValidator,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("delegatee")),
  __param(0, isEthAddress("debtTokenAddress")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], BaseDebtToken.prototype, "approvedDelegationAmount", null);
__decorate([
  DebtTokenValidator,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("delegatee")),
  __param(0, isEthAddress("debtTokenAddress")),
  __param(0, isPositiveAmount("amount")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Object)
], BaseDebtToken.prototype, "generateApproveDelegationTxData", null);
__decorate([
  DebtTokenValidator,
  __param(0, isEthAddress("debtTokenAddress")),
  __param(0, isEthAddress("allowanceGiver")),
  __param(0, isEthAddress("allowanceReceiver")),
  __param(0, isPositiveAmount("amount")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], BaseDebtToken.prototype, "isDelegationApproved", null);

// node_modules/@aave/contract-helpers/dist/esm/wethgateway-contract/typechain/IWETHGateway__factory.js
class IWETHGateway__factory {
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi10, signerOrProvider);
  }
  static createInterface() {
    return new exports_utils.Interface(_abi10);
  }
}
var _abi10 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "lendingPool",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "interesRateMode",
        type: "uint256"
      },
      {
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "borrowETH",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "lendingPool",
        type: "address"
      },
      {
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "depositETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "lendingPool",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "rateMode",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      }
    ],
    name: "repayETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "lendingPool",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      }
    ],
    name: "withdrawETH",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@aave/contract-helpers/dist/esm/wethgateway-contract/index.js
class WETHGatewayService extends BaseService {
  constructor(provider, erc20Service, wethGatewayAddress) {
    super(provider, IWETHGateway__factory);
    this.erc20Service = erc20Service;
    this.baseDebtTokenService = new BaseDebtToken(this.provider, this.erc20Service);
    this.wethGatewayAddress = wethGatewayAddress !== null && wethGatewayAddress !== undefined ? wethGatewayAddress : "";
    this.depositETH = this.depositETH.bind(this);
    this.withdrawETH = this.withdrawETH.bind(this);
    this.repayETH = this.repayETH.bind(this);
    this.borrowETH = this.borrowETH.bind(this);
    this.wethGatewayInstance = IWETHGateway__factory.createInterface();
    this.generateDepositEthTxData = (args) => {
      var _a, _b;
      const txData = this.wethGatewayInstance.encodeFunctionData("depositETH", [
        args.lendingPool,
        (_a = args.onBehalfOf) !== null && _a !== undefined ? _a : args.user,
        (_b = args.referralCode) !== null && _b !== undefined ? _b : "0"
      ]);
      const actionTx = {
        data: txData,
        to: this.wethGatewayAddress,
        from: args.user,
        value: BigNumber.from(args.amount),
        gasLimit: BigNumber.from(gasLimitRecommendations[ProtocolAction.deposit].limit)
      };
      return actionTx;
    };
    this.generateBorrowEthTxData = (args) => {
      var _a;
      const numericRateMode = args.interestRateMode === InterestRate.Variable ? 2 : 1;
      const txData = this.wethGatewayInstance.encodeFunctionData("borrowETH", [
        args.lendingPool,
        args.amount,
        numericRateMode,
        (_a = args.referralCode) !== null && _a !== undefined ? _a : "0"
      ]);
      const actionTx = {
        data: txData,
        to: this.wethGatewayAddress,
        from: args.user,
        gasLimit: BigNumber.from(gasLimitRecommendations[ProtocolAction.borrowETH].limit)
      };
      return actionTx;
    };
    this.generateRepayEthTxData = ({ interestRateMode, lendingPool, amount, user, onBehalfOf }) => {
      const numericRateMode = interestRateMode === InterestRate.Variable ? 2 : 1;
      const txData = this.wethGatewayInstance.encodeFunctionData("repayETH", [
        lendingPool,
        amount,
        numericRateMode,
        onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user
      ]);
      const actionTx = {
        data: txData,
        to: this.wethGatewayAddress,
        from: user,
        value: BigNumber.from(amount),
        gasLimit: BigNumber.from(gasLimitRecommendations[ProtocolAction.repayETH].limit)
      };
      return actionTx;
    };
  }
  depositETH({ lendingPool, user, amount, onBehalfOf, referralCode }) {
    const convertedAmount = valueToWei(amount, 18);
    const wethGatewayContract = this.getContractInstance(this.wethGatewayAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => wethGatewayContract.populateTransaction.depositETH(lendingPool, onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user, referralCode !== null && referralCode !== undefined ? referralCode : "0"),
      from: user,
      value: convertedAmount
    });
    return [
      {
        tx: txCallback,
        txType: eEthereumTxType.DLP_ACTION,
        gas: this.generateTxPriceEstimation([], txCallback)
      }
    ];
  }
  async borrowETH({ lendingPool, user, amount, debtTokenAddress, interestRateMode, referralCode }) {
    const txs = [];
    const convertedAmount = valueToWei(amount, 18);
    const numericRateMode = interestRateMode === InterestRate.Variable ? 2 : 1;
    if (!debtTokenAddress) {
      throw new Error(`To borrow ETH you need to pass the stable or variable WETH debt Token Address corresponding the interestRateMode`);
    }
    const delegationApproved = await this.baseDebtTokenService.isDelegationApproved({
      debtTokenAddress,
      allowanceGiver: user,
      allowanceReceiver: this.wethGatewayAddress,
      amount
    });
    if (!delegationApproved) {
      const approveDelegationTx = this.baseDebtTokenService.approveDelegation({
        user,
        delegatee: this.wethGatewayAddress,
        debtTokenAddress,
        amount: exports_lib.MaxUint256.toString()
      });
      txs.push(approveDelegationTx);
    }
    const wethGatewayContract = this.getContractInstance(this.wethGatewayAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => wethGatewayContract.populateTransaction.borrowETH(lendingPool, convertedAmount, numericRateMode, referralCode !== null && referralCode !== undefined ? referralCode : "0"),
      from: user
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.borrowETH)
    });
    return txs;
  }
  async withdrawETH({ lendingPool, user, amount, onBehalfOf, aTokenAddress }) {
    const txs = [];
    const { isApproved, approve } = this.erc20Service;
    const convertedAmount = amount === "-1" ? exports_lib.MaxUint256.toString() : valueToWei(amount, 18);
    const approved = await isApproved({
      token: aTokenAddress,
      user,
      spender: this.wethGatewayAddress,
      amount
    });
    if (!approved) {
      const approveTx = approve({
        user,
        token: aTokenAddress,
        spender: this.wethGatewayAddress,
        amount: exports_lib.MaxUint256.toString()
      });
      txs.push(approveTx);
    }
    const wethGatewayContract = this.getContractInstance(this.wethGatewayAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => wethGatewayContract.populateTransaction.withdrawETH(lendingPool, convertedAmount, onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user),
      from: user
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.withdrawETH)
    });
    return txs;
  }
  repayETH({ lendingPool, user, amount, interestRateMode, onBehalfOf }) {
    const convertedAmount = valueToWei(amount, 18);
    const numericRateMode = interestRateMode === InterestRate.Variable ? 2 : 1;
    const wethGatewayContract = this.getContractInstance(this.wethGatewayAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => wethGatewayContract.populateTransaction.repayETH(lendingPool, convertedAmount, numericRateMode, onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user),
      gasSurplus: 30,
      from: user,
      value: convertedAmount
    });
    return [
      {
        tx: txCallback,
        txType: eEthereumTxType.DLP_ACTION,
        gas: this.generateTxPriceEstimation([], txCallback)
      }
    ];
  }
}
__decorate([
  WETHValidator,
  __param(0, isEthAddress("lendingPool")),
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("onBehalfOf")),
  __param(0, isPositiveAmount("amount")),
  __param(0, is0OrPositiveAmount("referralCode")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Array)
], WETHGatewayService.prototype, "depositETH", null);
__decorate([
  WETHValidator,
  __param(0, isEthAddress("lendingPool")),
  __param(0, isEthAddress("user")),
  __param(0, isPositiveAmount("amount")),
  __param(0, isEthAddress("debtTokenAddress")),
  __param(0, is0OrPositiveAmount("referralCode")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], WETHGatewayService.prototype, "borrowETH", null);
__decorate([
  WETHValidator,
  __param(0, isEthAddress("lendingPool")),
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("onBehalfOf")),
  __param(0, isPositiveOrMinusOneAmount("amount")),
  __param(0, isEthAddress("aTokenAddress")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], WETHGatewayService.prototype, "withdrawETH", null);
__decorate([
  WETHValidator,
  __param(0, isEthAddress("lendingPool")),
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("onBehalfOf")),
  __param(0, isPositiveAmount("amount")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Array)
], WETHGatewayService.prototype, "repayETH", null);

// node_modules/@aave/contract-helpers/dist/esm/erc20-2612/typechain/IERC202612__factory.js
var _abi11 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "_nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

class IERC202612__factory {
  static createInterface() {
    return new exports_utils.Interface(_abi11);
  }
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi11, signerOrProvider);
  }
}
IERC202612__factory.abi = _abi11;

// node_modules/@aave/contract-helpers/dist/esm/erc20-2612/index.js
class ERC20_2612Service extends BaseService {
  constructor(provider) {
    super(provider, IERC202612__factory);
    this.getNonce = this.getNonce.bind(this);
  }
  async getNonce({ token, owner }) {
    const tokenContract = this.getContractInstance(token);
    let nonce;
    try {
      nonce = await tokenContract.nonces(owner);
      return nonce.toNumber();
    } catch (_4) {
    }
    try {
      nonce = await tokenContract._nonces(owner);
      return nonce.toNumber();
    } catch (_4) {
      console.log(`Token ${token} does not implement nonces or _nonces method`);
    }
    return null;
  }
}
__decorate([
  ERC20Validator,
  __param(0, isEthAddress("token")),
  __param(0, isEthAddress("owner")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], ERC20_2612Service.prototype, "getNonce", null);

// node_modules/@aave/contract-helpers/dist/esm/v3-pool-rollups/index.js
var utils11 = __toESM(require_utils5(), 1);

// node_modules/@aave/contract-helpers/dist/esm/v3-pool-contract/typechain/IPool__factory.js
var _abi12 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "backer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "fee",
        type: "uint256"
      }
    ],
    name: "BackUnbacked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "enum DataTypes.InterestRateMode",
        name: "interestRateMode",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "borrowRate",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint16",
        name: "referral",
        type: "uint16"
      }
    ],
    name: "Borrow",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "enum DataTypes.InterestRateMode",
        name: "interestRateMode",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "premium",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "FlashLoan",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalDebt",
        type: "uint256"
      }
    ],
    name: "IsolationModeTotalDebtUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "collateralAsset",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "debtAsset",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "debtToCover",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "liquidatedCollateralAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "liquidator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "receiveAToken",
        type: "bool"
      }
    ],
    name: "LiquidationCall",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint16",
        name: "referral",
        type: "uint16"
      }
    ],
    name: "MintUnbacked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountMinted",
        type: "uint256"
      }
    ],
    name: "MintedToTreasury",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "RebalanceStableBorrowRate",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "repayer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "useATokens",
        type: "bool"
      }
    ],
    name: "Repay",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "liquidityRate",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stableBorrowRate",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "variableBorrowRate",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "liquidityIndex",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "variableBorrowIndex",
        type: "uint256"
      }
    ],
    name: "ReserveDataUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "ReserveUsedAsCollateralDisabled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "ReserveUsedAsCollateralEnabled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "Supply",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "enum DataTypes.InterestRateMode",
        name: "interestRateMode",
        type: "uint8"
      }
    ],
    name: "SwapBorrowRateMode",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint8",
        name: "categoryId",
        type: "uint8"
      }
    ],
    name: "UserEModeSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdraw",
    type: "event"
  },
  {
    inputs: [],
    name: "ADDRESSES_PROVIDER",
    outputs: [
      {
        internalType: "contract IPoolAddressesProvider",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "BRIDGE_PROTOCOL_FEE",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FLASHLOAN_PREMIUM_TOTAL",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FLASHLOAN_PREMIUM_TO_PROTOCOL",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MAX_NUMBER_RESERVES",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "fee",
        type: "uint256"
      }
    ],
    name: "backUnbacked",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "interestRateMode",
        type: "uint256"
      },
      {
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      },
      {
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      }
    ],
    name: "borrow",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint8",
        name: "id",
        type: "uint8"
      },
      {
        components: [
          {
            internalType: "uint16",
            name: "ltv",
            type: "uint16"
          },
          {
            internalType: "uint16",
            name: "liquidationThreshold",
            type: "uint16"
          },
          {
            internalType: "uint16",
            name: "liquidationBonus",
            type: "uint16"
          },
          {
            internalType: "address",
            name: "priceSource",
            type: "address"
          },
          {
            internalType: "string",
            name: "label",
            type: "string"
          }
        ],
        internalType: "struct DataTypes.EModeCategory",
        name: "config",
        type: "tuple"
      }
    ],
    name: "configureEModeCategory",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      }
    ],
    name: "dropReserve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "balanceFromBefore",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "balanceToBefore",
        type: "uint256"
      }
    ],
    name: "finalizeTransfer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiverAddress",
        type: "address"
      },
      {
        internalType: "address[]",
        name: "assets",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "interestRateModes",
        type: "uint256[]"
      },
      {
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "params",
        type: "bytes"
      },
      {
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "flashLoan",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiverAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "params",
        type: "bytes"
      },
      {
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "flashLoanSimple",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      }
    ],
    name: "getConfiguration",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "data",
            type: "uint256"
          }
        ],
        internalType: "struct DataTypes.ReserveConfigurationMap",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint8",
        name: "id",
        type: "uint8"
      }
    ],
    name: "getEModeCategoryData",
    outputs: [
      {
        components: [
          {
            internalType: "uint16",
            name: "ltv",
            type: "uint16"
          },
          {
            internalType: "uint16",
            name: "liquidationThreshold",
            type: "uint16"
          },
          {
            internalType: "uint16",
            name: "liquidationBonus",
            type: "uint16"
          },
          {
            internalType: "address",
            name: "priceSource",
            type: "address"
          },
          {
            internalType: "string",
            name: "label",
            type: "string"
          }
        ],
        internalType: "struct DataTypes.EModeCategory",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      }
    ],
    name: "getReserveData",
    outputs: [
      {
        components: [
          {
            components: [
              {
                internalType: "uint256",
                name: "data",
                type: "uint256"
              }
            ],
            internalType: "struct DataTypes.ReserveConfigurationMap",
            name: "configuration",
            type: "tuple"
          },
          {
            internalType: "uint128",
            name: "liquidityIndex",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "currentLiquidityRate",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "variableBorrowIndex",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "currentVariableBorrowRate",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "currentStableBorrowRate",
            type: "uint128"
          },
          {
            internalType: "uint40",
            name: "lastUpdateTimestamp",
            type: "uint40"
          },
          {
            internalType: "uint16",
            name: "id",
            type: "uint16"
          },
          {
            internalType: "address",
            name: "aTokenAddress",
            type: "address"
          },
          {
            internalType: "address",
            name: "stableDebtTokenAddress",
            type: "address"
          },
          {
            internalType: "address",
            name: "variableDebtTokenAddress",
            type: "address"
          },
          {
            internalType: "address",
            name: "interestRateStrategyAddress",
            type: "address"
          },
          {
            internalType: "uint128",
            name: "accruedToTreasury",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "unbacked",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "isolationModeTotalDebt",
            type: "uint128"
          }
        ],
        internalType: "struct DataTypes.ReserveData",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      }
    ],
    name: "getReserveNormalizedIncome",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      }
    ],
    name: "getReserveNormalizedVariableDebt",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getReservesList",
    outputs: [
      {
        internalType: "address[]",
        name: "",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "getUserAccountData",
    outputs: [
      {
        internalType: "uint256",
        name: "totalCollateralBase",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "totalDebtBase",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "availableBorrowsBase",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "currentLiquidationThreshold",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "ltv",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "healthFactor",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "getUserConfiguration",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "data",
            type: "uint256"
          }
        ],
        internalType: "struct DataTypes.UserConfigurationMap",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "getUserEMode",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "address",
        name: "aTokenAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "stableDebtAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "variableDebtAddress",
        type: "address"
      },
      {
        internalType: "address",
        name: "interestRateStrategyAddress",
        type: "address"
      }
    ],
    name: "initReserve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "collateralAsset",
        type: "address"
      },
      {
        internalType: "address",
        name: "debtAsset",
        type: "address"
      },
      {
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "debtToCover",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "receiveAToken",
        type: "bool"
      }
    ],
    name: "liquidationCall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "assets",
        type: "address[]"
      }
    ],
    name: "mintToTreasury",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "mintUnbacked",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "rebalanceStableBorrowRate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "interestRateMode",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      }
    ],
    name: "repay",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "interestRateMode",
        type: "uint256"
      }
    ],
    name: "repayWithATokens",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "interestRateMode",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "permitV",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "permitR",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "permitS",
        type: "bytes32"
      }
    ],
    name: "repayWithPermit",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "configuration",
        type: "uint256"
      }
    ],
    name: "setConfiguration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "address",
        name: "rateStrategyAddress",
        type: "address"
      }
    ],
    name: "setReserveInterestRateStrategyAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint8",
        name: "categoryId",
        type: "uint8"
      }
    ],
    name: "setUserEMode",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "bool",
        name: "useAsCollateral",
        type: "bool"
      }
    ],
    name: "setUserUseReserveAsCollateral",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "supply",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "onBehalfOf",
        type: "address"
      },
      {
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "permitV",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "permitR",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "permitS",
        type: "bytes32"
      }
    ],
    name: "supplyWithPermit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "interestRateMode",
        type: "uint256"
      }
    ],
    name: "swapBorrowRateMode",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "bridgeProtocolFee",
        type: "uint256"
      }
    ],
    name: "updateBridgeProtocolFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "flashLoanPremiumTotal",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "flashLoanPremiumToProtocol",
        type: "uint256"
      }
    ],
    name: "updateFlashloanPremiums",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "withdraw",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

class IPool__factory {
  static createInterface() {
    return new exports_utils.Interface(_abi12);
  }
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi12, signerOrProvider);
  }
}
IPool__factory.abi = _abi12;

// node_modules/@aave/contract-helpers/dist/esm/v3-pool-rollups/typechain/IL2Pool__factory.js
var _abi13 = [
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "args",
        type: "bytes32"
      }
    ],
    name: "borrow",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "args1",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "args2",
        type: "bytes32"
      }
    ],
    name: "liquidationCall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "args",
        type: "bytes32"
      }
    ],
    name: "rebalanceStableBorrowRate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "args",
        type: "bytes32"
      }
    ],
    name: "repay",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "args",
        type: "bytes32"
      }
    ],
    name: "repayWithATokens",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "args",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "repayWithPermit",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "args",
        type: "bytes32"
      }
    ],
    name: "setUserUseReserveAsCollateral",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "args",
        type: "bytes32"
      }
    ],
    name: "supply",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "args",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "supplyWithPermit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "args",
        type: "bytes32"
      }
    ],
    name: "swapBorrowRateMode",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "args",
        type: "bytes32"
      }
    ],
    name: "withdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

class IL2Pool__factory {
  static createInterface() {
    return new exports_utils.Interface(_abi13);
  }
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi13, signerOrProvider);
  }
}
IL2Pool__factory.abi = _abi13;

// node_modules/@aave/contract-helpers/dist/esm/v3-pool-rollups/typechain/L2Encoder__factory.js
var _abi14 = [
  {
    inputs: [
      {
        internalType: "contract IPool",
        name: "pool",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "POOL",
    outputs: [
      {
        internalType: "contract IPool",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "interestRateMode",
        type: "uint256"
      },
      {
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "encodeBorrowParams",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "collateralAsset",
        type: "address"
      },
      {
        internalType: "address",
        name: "debtAsset",
        type: "address"
      },
      {
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "debtToCover",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "receiveAToken",
        type: "bool"
      }
    ],
    name: "encodeLiquidationCall",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "address",
        name: "user",
        type: "address"
      }
    ],
    name: "encodeRebalanceStableBorrowRate",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "interestRateMode",
        type: "uint256"
      }
    ],
    name: "encodeRepayParams",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "interestRateMode",
        type: "uint256"
      }
    ],
    name: "encodeRepayWithATokensParams",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "interestRateMode",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "permitV",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "permitR",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "permitS",
        type: "bytes32"
      }
    ],
    name: "encodeRepayWithPermitParams",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "bool",
        name: "useAsCollateral",
        type: "bool"
      }
    ],
    name: "encodeSetUserUseReserveAsCollateral",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      }
    ],
    name: "encodeSupplyParams",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint16",
        name: "referralCode",
        type: "uint16"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "permitV",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "permitR",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "permitS",
        type: "bytes32"
      }
    ],
    name: "encodeSupplyWithPermitParams",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "interestRateMode",
        type: "uint256"
      }
    ],
    name: "encodeSwapBorrowRateMode",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "encodeWithdrawParams",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var _bytecode3 = "0x60a060405234801561001057600080fd5b5060405161143138038061143183398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b6080516113606100d16000396000818161016b0152818161027e015281816103760152818161043f015281816105180152818161062e0152818161073c015281816107fc0152818161094101528181610a700152610b5501526113606000f3fe608060405234801561001057600080fd5b50600436106100d45760003560e01c806388d5185211610081578063b76398e41161005b578063b76398e414610200578063fc0eed8514610213578063fed63a931461022157600080fd5b806388d51852146101b25780638da7fb18146101da5780639d2ffc1b146101ed57600080fd5b80635cc7bc10116100b25780635cc7bc1014610125578063671a7fae146101385780637535d2461461016657600080fd5b80631a64acf2146100d95780631a8f6dee146100ff5780631fd3479714610112575b600080fd5b6100ec6100e7366004610e66565b610234565b6040519081526020015b60405180910390f35b6100ec61010d366004610eb0565b61032c565b6100ec610120366004610ee9565b6103f5565b6100ec610133366004610ee9565b6104ce565b61014b610146366004610f2b565b6105e0565b604080519384526020840192909252908201526060016100f6565b61018d7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100f6565b6101c56101c0366004610fa9565b6106f0565b604080519283526020830191909152016100f6565b6100ec6101e836600461100d565b6108e2565b6100ec6101fb36600461100d565b6108f7565b6100ec61020e366004611042565b610a26565b6100ec61010d366004611084565b61014b61022f3660046110b9565b610b07565b6040517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff858116600483015260009182917f000000000000000000000000000000000000000000000000000000000000000016906335ea6a75906024016101e060405180830381865afa1580156102c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ea9190611207565b60e081015190915060006102fd87610c5d565b9050600061030a87610d08565b60109290921b60909290921b60989690961b9590950101019695505050505050565b6040517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff838116600483015260009182917f000000000000000000000000000000000000000000000000000000000000000016906335ea6a75906024016101e060405180830381865afa1580156103be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103e29190611207565b60e00151601084901b0191505092915050565b6040517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff838116600483015260009182917f000000000000000000000000000000000000000000000000000000000000000016906335ea6a75906024016101e060405180830381865afa158015610487573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104ab9190611207565b60e081015190915060006104be85610d08565b60101b9190910195945050505050565b6040517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff838116600483015260009182917f000000000000000000000000000000000000000000000000000000000000000016906335ea6a75906024016101e060405180830381865afa158015610560573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105849190611207565b60e081015190915060007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff85146105c3576105be85610c5d565b6104be565b5071ffffffffffffffffffffffffffffffff000001949350505050565b6040517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff88811660048301526000918291829182917f000000000000000000000000000000000000000000000000000000000000000016906335ea6a75906024016101e060405180830381865afa158015610676573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069a9190611207565b60e081015190915060006106ad8c610c5d565b905060006106ba8b610d9b565b905060008a60c01b8260a01b018d60901b018360101b0184019050808a8a97509750975050505050509750975097945050505050565b6040517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8681166004830152600091829182917f0000000000000000000000000000000000000000000000000000000000000000909116906335ea6a75906024016101e060405180830381865afa158015610786573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107aa9190611207565b60e08101516040517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8a8116600483015292935090916000917f0000000000000000000000000000000000000000000000000000000000000000909116906335ea6a75906024016101e060405180830381865afa158015610846573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061086a9190611207565b60e081015190915060007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff89146108a9576108a489610c5d565b6108bb565b6fffffffffffffffffffffffffffffffff5b60109290921b9390930160208a901b019550608087901b0193505050509550959350505050565b60006108ef8484846108f7565b949350505050565b6040517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff848116600483015260009182917f000000000000000000000000000000000000000000000000000000000000000016906335ea6a75906024016101e060405180830381865afa158015610989573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109ad9190611207565b60e081015190915060007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff86146109ec576109e786610c5d565b6109fe565b6fffffffffffffffffffffffffffffffff5b90506000610a0b86610d08565b60901b60109290921b91909101919091019695505050505050565b6040517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff848116600483015260009182917f000000000000000000000000000000000000000000000000000000000000000016906335ea6a75906024016101e060405180830381865afa158015610ab8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610adc9190611207565b60e08101519091506000610aef86610c5d565b60101b609086901b0191909101925050509392505050565b6040517f35ea6a7500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff88811660048301526000918291829182917f000000000000000000000000000000000000000000000000000000000000000016906335ea6a75906024016101e060405180830381865afa158015610b9d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bc19190611207565b60e081015190915060007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8c14610c0057610bfb8c610c5d565b610c12565b6fffffffffffffffffffffffffffffffff5b90506000610c1f8c610d08565b90506000610c2c8c610d9b565b60b89b909b1b60989b909b1b9a909a0160909190911b0160109190911b01019b959a50939850939650505050505050565b60006fffffffffffffffffffffffffffffffff821115610d04576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203160448201527f323820626974730000000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b5090565b600060ff821115610d04576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203860448201527f20626974730000000000000000000000000000000000000000000000000000006064820152608401610cfb565b600063ffffffff821115610d04576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203360448201527f32206269747300000000000000000000000000000000000000000000000000006064820152608401610cfb565b73ffffffffffffffffffffffffffffffffffffffff81168114610e5357600080fd5b50565b61ffff81168114610e5357600080fd5b60008060008060808587031215610e7c57600080fd5b8435610e8781610e31565b935060208501359250604085013591506060850135610ea581610e56565b939692955090935050565b60008060408385031215610ec357600080fd5b8235610ece81610e31565b91506020830135610ede81610e31565b809150509250929050565b60008060408385031215610efc57600080fd5b8235610f0781610e31565b946020939093013593505050565b803560ff81168114610f2657600080fd5b919050565b600080600080600080600060e0888a031215610f4657600080fd5b8735610f5181610e31565b9650602088013595506040880135610f6881610e56565b945060608801359350610f7d60808901610f15565b925060a0880135915060c0880135905092959891949750929550565b80358015158114610f2657600080fd5b600080600080600060a08688031215610fc157600080fd5b8535610fcc81610e31565b94506020860135610fdc81610e31565b93506040860135610fec81610e31565b92506060860135915061100160808701610f99565b90509295509295909350565b60008060006060848603121561102257600080fd5b833561102d81610e31565b95602085013595506040909401359392505050565b60008060006060848603121561105757600080fd5b833561106281610e31565b925060208401359150604084013561107981610e56565b809150509250925092565b6000806040838503121561109757600080fd5b82356110a281610e31565b91506110b060208401610f99565b90509250929050565b600080600080600080600060e0888a0312156110d457600080fd5b87356110df81610e31565b9650602088013595506040880135945060608801359350610f7d60808901610f15565b6040516101e0810167ffffffffffffffff8111828210171561114d577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405290565b60006020828403121561116557600080fd5b6040516020810181811067ffffffffffffffff821117156111af577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040529151825250919050565b80516fffffffffffffffffffffffffffffffff81168114610f2657600080fd5b805164ffffffffff81168114610f2657600080fd5b8051610f2681610e56565b8051610f2681610e31565b60006101e0828403121561121a57600080fd5b611222611102565b61122c8484611153565b815261123a602084016111bc565b602082015261124b604084016111bc565b604082015261125c606084016111bc565b606082015261126d608084016111bc565b608082015261127e60a084016111bc565b60a082015261128f60c084016111dc565b60c08201526112a060e084016111f1565b60e08201526101006112b38185016111fc565b908201526101206112c58482016111fc565b908201526101406112d78482016111fc565b908201526101606112e98482016111fc565b908201526101806112fb8482016111bc565b908201526101a061130d8482016111bc565b908201526101c061131f8482016111bc565b90820152939250505056fea2646970667358221220550a5d1ca13779d56fd6a3f9cf5cee982d93d61310d74a95690bcec9ee75ab4a64736f6c634300080a0033";

class L2Encoder__factory extends ContractFactory {
  constructor(...args) {
    if (args.length === 1) {
      super(_abi14, _bytecode3, args[0]);
    } else {
      super(...args);
    }
  }
  deploy(pool, overrides) {
    return super.deploy(pool, overrides || {});
  }
  getDeployTransaction(pool, overrides) {
    return super.getDeployTransaction(pool, overrides || {});
  }
  attach(address4) {
    return super.attach(address4);
  }
  connect(signer) {
    return super.connect(signer);
  }
  static createInterface() {
    return new exports_utils.Interface(_abi14);
  }
  static connect(address4, signerOrProvider) {
    return new Contract(address4, _abi14, signerOrProvider);
  }
}
L2Encoder__factory.bytecode = _bytecode3;
L2Encoder__factory.abi = _abi14;

// node_modules/@aave/contract-helpers/dist/esm/v3-pool-rollups/index.js
class L2Pool extends BaseService {
  constructor(provider, l2PoolConfig) {
    super(provider, IL2Pool__factory);
    const { l2PoolAddress, encoderAddress } = l2PoolConfig !== null && l2PoolConfig !== undefined ? l2PoolConfig : {};
    this.l2PoolAddress = l2PoolAddress !== null && l2PoolAddress !== undefined ? l2PoolAddress : "";
    this.encoderAddress = encoderAddress !== null && encoderAddress !== undefined ? encoderAddress : "";
    this.encoderInterface = L2Encoder__factory.createInterface();
    this.l2PoolContractInstance = IL2Pool__factory.createInterface();
    this.poolContractInstance = IPool__factory.createInterface();
    this.generateSupplyTxData = ({ user, reserve, onBehalfOf, amount, referralCode }) => {
      const actionTx = {};
      const txData = this.poolContractInstance.encodeFunctionData("supply", [
        reserve,
        amount,
        onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user,
        referralCode !== null && referralCode !== undefined ? referralCode : "0"
      ]);
      actionTx.to = this.l2PoolAddress;
      actionTx.from = user;
      actionTx.data = txData;
      return actionTx;
    };
    this.generateBorrowTxData = ({ user, reserve, amount, numericRateMode, referralCode, onBehalfOf }) => {
      const actionTx = {};
      const txData = this.poolContractInstance.encodeFunctionData("borrow", [
        reserve,
        amount,
        numericRateMode,
        referralCode !== null && referralCode !== undefined ? referralCode : "0",
        onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user
      ]);
      actionTx.to = this.l2PoolAddress;
      actionTx.from = user;
      actionTx.data = txData;
      actionTx.gasLimit = BigNumber.from(gasLimitRecommendations[ProtocolAction.borrow].limit);
      return actionTx;
    };
    this.generateSupplyWithPermitTxData = ({ user, reserve, amount, onBehalfOf, referralCode, deadline, permitR, permitS, permitV }) => {
      const actionTx = {};
      const txData = this.poolContractInstance.encodeFunctionData("supplyWithPermit", [
        reserve,
        amount,
        onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user,
        referralCode !== null && referralCode !== undefined ? referralCode : "0",
        deadline,
        permitV,
        permitR,
        permitS
      ]);
      actionTx.to = this.l2PoolAddress;
      actionTx.from = user;
      actionTx.data = txData;
      return actionTx;
    };
    this.generateEncodedSupplyTxData = ({ encodedTxData, user }) => {
      const actionTx = {};
      const txData = this.l2PoolContractInstance.encodeFunctionData("supply", [
        encodedTxData
      ]);
      actionTx.to = this.l2PoolAddress;
      actionTx.data = txData;
      actionTx.from = user;
      actionTx.gasLimit = BigNumber.from(gasLimitRecommendations[ProtocolAction.supply].limit);
      return actionTx;
    };
    this.generateEncodedBorrowTxData = ({ encodedTxData, user }) => {
      const actionTx = {};
      const txData = this.l2PoolContractInstance.encodeFunctionData("borrow", [
        encodedTxData
      ]);
      actionTx.to = this.l2PoolAddress;
      actionTx.data = txData;
      actionTx.from = user;
      actionTx.gasLimit = BigNumber.from(gasLimitRecommendations[ProtocolAction.borrow].limit);
      return actionTx;
    };
    this.generateEncodedSupplyWithPermitTxData = ({ encodedTxData, signature, user }) => {
      const actionTx = {};
      const decomposedSignature = utils11.splitSignature(signature);
      const txData = this.l2PoolContractInstance.encodeFunctionData("supplyWithPermit", [encodedTxData, decomposedSignature.r, decomposedSignature.s]);
      actionTx.to = this.l2PoolAddress;
      actionTx.data = txData;
      actionTx.from = user;
      actionTx.gasLimit = BigNumber.from(gasLimitRecommendations[ProtocolAction.supplyWithPermit].limit);
      return actionTx;
    };
    this.generateEncodedRepayTxData = ({ encodedTxData, user }) => {
      const actionTx = {};
      const txData = this.l2PoolContractInstance.encodeFunctionData("repay", [
        encodedTxData
      ]);
      actionTx.to = this.l2PoolAddress;
      actionTx.data = txData;
      actionTx.from = user;
      actionTx.gasLimit = BigNumber.from(gasLimitRecommendations[ProtocolAction.repay].limit);
      return actionTx;
    };
    this.generateEncodedRepayWithPermitTxData = ({ encodedTxData, user, signature }) => {
      const actionTx = {};
      const decomposedSignature = utils11.splitSignature(signature);
      const txData = this.l2PoolContractInstance.encodeFunctionData("repayWithPermit", [encodedTxData, decomposedSignature.r, decomposedSignature.s]);
      actionTx.to = this.l2PoolAddress;
      actionTx.data = txData;
      actionTx.from = user;
      actionTx.gasLimit = BigNumber.from(gasLimitRecommendations[ProtocolAction.repayWithPermit].limit);
      return actionTx;
    };
    this.generateEncodedRepayWithATokensTxData = ({ encodedTxData, user }) => {
      const actionTx = {};
      const txData = this.l2PoolContractInstance.encodeFunctionData("repayWithATokens", [encodedTxData]);
      actionTx.to = this.l2PoolAddress;
      actionTx.data = txData;
      actionTx.from = user;
      actionTx.gasLimit = BigNumber.from(gasLimitRecommendations[ProtocolAction.repayWithATokens].limit);
      return actionTx;
    };
  }
  async supply({ user, reserve, amount, referralCode }, txs) {
    const encoder = this.getEncoder();
    const encodedParams = await encoder.encodeSupplyParams(reserve, amount, referralCode !== null && referralCode !== undefined ? referralCode : 0);
    const l2PoolContract = this.getContractInstance(this.l2PoolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => l2PoolContract.populateTransaction.supply(encodedParams),
      from: user,
      value: getTxValue(reserve, amount)
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.supply)
    });
    return txs;
  }
  async supplyWithPermit({ user, reserve, amount, deadline, referralCode, permitR, permitS, permitV }, txs) {
    const encoder = this.getEncoder();
    const encodedParams = await encoder.encodeSupplyWithPermitParams(reserve, amount, referralCode !== null && referralCode !== undefined ? referralCode : 0, deadline, permitV, permitR, permitS);
    const l2PoolContract = this.getContractInstance(this.l2PoolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => l2PoolContract.populateTransaction.supplyWithPermit(encodedParams[0], permitR, permitS),
      from: user
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback)
    });
    return txs;
  }
  async withdraw({ user, reserve, amount }) {
    const encoder = this.getEncoder();
    const encodedParams = await encoder.encodeWithdrawParams(reserve, amount);
    const l2PoolContract = this.getContractInstance(this.l2PoolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => l2PoolContract.populateTransaction.withdraw(encodedParams),
      from: user,
      action: ProtocolAction.withdraw
    });
    return [
      {
        tx: txCallback,
        txType: eEthereumTxType.DLP_ACTION,
        gas: this.generateTxPriceEstimation([], txCallback, ProtocolAction.supply)
      }
    ];
  }
  async borrow({ user, reserve, amount, numericRateMode, referralCode }) {
    const encoder = this.getEncoder();
    const encodedParams = await encoder.encodeBorrowParams(reserve, amount, numericRateMode, referralCode !== null && referralCode !== undefined ? referralCode : 0);
    const l2PoolContract = this.getContractInstance(this.l2PoolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => l2PoolContract.populateTransaction.borrow(encodedParams),
      from: user
    });
    return [
      {
        tx: txCallback,
        txType: eEthereumTxType.DLP_ACTION,
        gas: this.generateTxPriceEstimation([], txCallback)
      }
    ];
  }
  async repay({ reserve, user, amount, numericRateMode }, txs) {
    const encoder = this.getEncoder();
    const encodedParams = await encoder.encodeRepayParams(reserve, amount, numericRateMode);
    const l2PoolContract = this.getContractInstance(this.l2PoolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => l2PoolContract.populateTransaction.repay(encodedParams),
      from: user,
      value: getTxValue(reserve, amount)
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.repay)
    });
    return txs;
  }
  async repayWithPermit({ user, reserve, amount, numericRateMode, permitR, permitS, permitV, deadline }, txs) {
    const encoder = this.getEncoder();
    const encodedParams = await encoder.encodeRepayWithPermitParams(reserve, amount, numericRateMode, deadline, permitV, permitR, permitS);
    const l2PoolContract = this.getContractInstance(this.l2PoolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => l2PoolContract.populateTransaction.repayWithPermit(encodedParams[0], permitR, permitS),
      from: user,
      value: getTxValue(reserve, amount)
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.repay)
    });
    return txs;
  }
  async repayWithATokens({ reserve, user, amount, numericRateMode }, txs) {
    const encoder = this.getEncoder();
    const encodedParams = await encoder.encodeRepayWithATokensParams(reserve, amount, numericRateMode);
    const l2PoolContract = this.getContractInstance(this.l2PoolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => l2PoolContract.populateTransaction.repayWithATokens(encodedParams),
      from: user,
      value: getTxValue(reserve, amount)
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.repay)
    });
    return txs;
  }
  async swapBorrowRateMode({ reserve, numericRateMode, user }) {
    const encoder = this.getEncoder();
    const encodedParams = await encoder.encodeSwapBorrowRateMode(reserve, numericRateMode);
    const l2PoolContract = this.getContractInstance(this.l2PoolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => l2PoolContract.populateTransaction.swapBorrowRateMode(encodedParams),
      from: user
    });
    return [
      {
        tx: txCallback,
        txType: eEthereumTxType.DLP_ACTION,
        gas: this.generateTxPriceEstimation([], txCallback)
      }
    ];
  }
  async setUserUseReserveAsCollateral({ reserve, usageAsCollateral, user }) {
    const encoder = this.getEncoder();
    const encodedParams = await encoder.encodeSetUserUseReserveAsCollateral(reserve, usageAsCollateral);
    const l2PoolContract = this.getContractInstance(this.l2PoolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => l2PoolContract.populateTransaction.setUserUseReserveAsCollateral(encodedParams),
      from: user
    });
    return [
      {
        tx: txCallback,
        txType: eEthereumTxType.DLP_ACTION,
        gas: this.generateTxPriceEstimation([], txCallback)
      }
    ];
  }
  async liquidationCall({ liquidator, liquidatedUser, debtReserve, collateralReserve, debtToCover, getAToken }, txs) {
    const encoder = this.getEncoder();
    const encodedParams = await encoder.encodeLiquidationCall(collateralReserve, debtReserve, liquidatedUser, debtToCover, getAToken !== null && getAToken !== undefined ? getAToken : false);
    const l2PoolContract = this.getContractInstance(this.l2PoolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => l2PoolContract.populateTransaction.liquidationCall(encodedParams[0], encodedParams[1]),
      from: liquidator,
      value: getTxValue(debtReserve, debtToCover)
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation([], txCallback, ProtocolAction.liquidationCall)
    });
    return txs;
  }
  getEncoder() {
    if (!this.encoderContract && this.encoderAddress !== "") {
      this.encoderContract = L2Encoder__factory.connect(this.encoderAddress, this.provider);
    }
    return this.encoderContract;
  }
}
__decorate([
  L2PValidator,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Array]),
  __metadata("design:returntype", Promise)
], L2Pool.prototype, "supply", null);
__decorate([
  L2PValidator,
  __param(0, isDeadline32Bytes("deadline")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Array]),
  __metadata("design:returntype", Promise)
], L2Pool.prototype, "supplyWithPermit", null);
__decorate([
  L2PValidator,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], L2Pool.prototype, "withdraw", null);
__decorate([
  L2PValidator,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], L2Pool.prototype, "borrow", null);
__decorate([
  L2PValidator,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Array]),
  __metadata("design:returntype", Promise)
], L2Pool.prototype, "repay", null);
__decorate([
  L2PValidator,
  __param(0, isDeadline32Bytes("deadline")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Array]),
  __metadata("design:returntype", Promise)
], L2Pool.prototype, "repayWithPermit", null);
__decorate([
  L2PValidator,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Array]),
  __metadata("design:returntype", Promise)
], L2Pool.prototype, "repayWithATokens", null);
__decorate([
  L2PValidator,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], L2Pool.prototype, "swapBorrowRateMode", null);
__decorate([
  L2PValidator,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], L2Pool.prototype, "setUserUseReserveAsCollateral", null);
__decorate([
  L2PValidator,
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object, Array]),
  __metadata("design:returntype", Promise)
], L2Pool.prototype, "liquidationCall", null);

// node_modules/@aave/contract-helpers/dist/esm/v3-pool-contract/index.js
var buildParaSwapLiquiditySwapParams = (assetToSwapTo, minAmountToReceive, swapAllBalanceOffset, swapCalldata, augustus, permitAmount, deadline, v2, r, s) => {
  return exports_utils.defaultAbiCoder.encode([
    "address",
    "uint256",
    "uint256",
    "bytes",
    "address",
    "tuple(uint256,uint256,uint8,bytes32,bytes32)"
  ], [
    assetToSwapTo,
    minAmountToReceive,
    swapAllBalanceOffset,
    swapCalldata,
    augustus,
    [permitAmount, deadline, v2, r, s]
  ]);
};

class Pool extends BaseService {
  constructor(provider, lendingPoolConfig) {
    super(provider, IPool__factory);
    const { POOL: POOL2, FLASH_LIQUIDATION_ADAPTER, REPAY_WITH_COLLATERAL_ADAPTER, SWAP_COLLATERAL_ADAPTER, WETH_GATEWAY: WETH_GATEWAY2, L2_ENCODER } = lendingPoolConfig !== null && lendingPoolConfig !== undefined ? lendingPoolConfig : {};
    this.poolAddress = POOL2 !== null && POOL2 !== undefined ? POOL2 : "";
    this.flashLiquidationAddress = FLASH_LIQUIDATION_ADAPTER !== null && FLASH_LIQUIDATION_ADAPTER !== undefined ? FLASH_LIQUIDATION_ADAPTER : "";
    this.swapCollateralAddress = SWAP_COLLATERAL_ADAPTER !== null && SWAP_COLLATERAL_ADAPTER !== undefined ? SWAP_COLLATERAL_ADAPTER : "";
    this.repayWithCollateralAddress = REPAY_WITH_COLLATERAL_ADAPTER !== null && REPAY_WITH_COLLATERAL_ADAPTER !== undefined ? REPAY_WITH_COLLATERAL_ADAPTER : "";
    this.l2EncoderAddress = L2_ENCODER !== null && L2_ENCODER !== undefined ? L2_ENCODER : "";
    this.erc20_2612Service = new ERC20_2612Service(provider);
    this.erc20Service = new ERC20Service(provider);
    this.synthetixService = new SynthetixService(provider);
    this.wethGatewayService = new WETHGatewayService(provider, this.erc20Service, WETH_GATEWAY2);
    this.liquiditySwapAdapterService = new LiquiditySwapAdapterService(provider, SWAP_COLLATERAL_ADAPTER);
    this.paraswapRepayWithCollateralAdapterService = new ParaswapRepayWithCollateral(provider, REPAY_WITH_COLLATERAL_ADAPTER);
    this.l2PoolService = new L2Pool(provider, {
      l2PoolAddress: this.poolAddress,
      encoderAddress: this.l2EncoderAddress
    });
  }
  async getReserveData(reserve) {
    const lendingPoolContract = this.getContractInstance(this.poolAddress);
    return lendingPoolContract.getReserveData(reserve);
  }
  async deposit({ user, reserve, amount, onBehalfOf, referralCode }) {
    if (reserve.toLowerCase() === API_ETH_MOCK_ADDRESS.toLowerCase()) {
      return this.wethGatewayService.depositETH({
        lendingPool: this.poolAddress,
        user,
        amount,
        onBehalfOf,
        referralCode
      });
    }
    const { isApproved, approve, decimalsOf } = this.erc20Service;
    const txs = [];
    const reserveDecimals = await decimalsOf(reserve);
    const convertedAmount = valueToWei(amount, reserveDecimals);
    const fundsAvailable = await this.synthetixService.synthetixValidation({
      user,
      reserve,
      amount: convertedAmount
    });
    if (!fundsAvailable) {
      throw new Error("Not enough funds to execute operation");
    }
    const approved = await isApproved({
      token: reserve,
      user,
      spender: this.poolAddress,
      amount
    });
    if (!approved) {
      const approveTx = approve({
        user,
        token: reserve,
        spender: this.poolAddress,
        amount: DEFAULT_APPROVE_AMOUNT
      });
      txs.push(approveTx);
    }
    const lendingPoolContract = this.getContractInstance(this.poolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => lendingPoolContract.populateTransaction.deposit(reserve, convertedAmount, onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user, referralCode !== null && referralCode !== undefined ? referralCode : "0"),
      from: user,
      value: getTxValue(reserve, convertedAmount),
      action: ProtocolAction.supply
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.supply)
    });
    return txs;
  }
  async supply({ user, reserve, amount, onBehalfOf, referralCode, useOptimizedPath }) {
    if (reserve.toLowerCase() === API_ETH_MOCK_ADDRESS.toLowerCase()) {
      return this.wethGatewayService.depositETH({
        lendingPool: this.poolAddress,
        user,
        amount,
        onBehalfOf,
        referralCode
      });
    }
    const { isApproved, approve, decimalsOf } = this.erc20Service;
    const txs = [];
    const reserveDecimals = await decimalsOf(reserve);
    const convertedAmount = valueToWei(amount, reserveDecimals);
    const fundsAvailable = await this.synthetixService.synthetixValidation({
      user,
      reserve,
      amount: convertedAmount
    });
    if (!fundsAvailable) {
      throw new Error("Not enough funds to execute operation");
    }
    const approved = await isApproved({
      token: reserve,
      user,
      spender: this.poolAddress,
      amount
    });
    if (!approved) {
      const approveTx = approve({
        user,
        token: reserve,
        spender: this.poolAddress,
        amount: DEFAULT_APPROVE_AMOUNT
      });
      txs.push(approveTx);
    }
    const lendingPoolContract = this.getContractInstance(this.poolAddress);
    if (useOptimizedPath) {
      return this.l2PoolService.supply({ user, reserve, amount: convertedAmount, referralCode }, txs);
    }
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => lendingPoolContract.populateTransaction.supply(reserve, convertedAmount, onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user, referralCode !== null && referralCode !== undefined ? referralCode : "0"),
      from: user,
      value: getTxValue(reserve, convertedAmount),
      action: ProtocolAction.supply
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.supply)
    });
    return txs;
  }
  async signERC20Approval({ user, reserve, amount, deadline }) {
    const { getTokenData, isApproved } = this.erc20Service;
    const { name, decimals } = await getTokenData(reserve);
    const convertedAmount = amount === "-1" ? exports_lib.MaxUint256.toString() : valueToWei(amount, decimals);
    const approved = await isApproved({
      token: reserve,
      user,
      spender: this.poolAddress,
      amount
    });
    if (approved) {
      return "";
    }
    const { chainId } = await this.provider.getNetwork();
    const nonce = await this.erc20_2612Service.getNonce({
      token: reserve,
      owner: user
    });
    if (nonce === null) {
      return "";
    }
    const typeData = {
      types: {
        EIP712Domain: [
          { name: "name", type: "string" },
          { name: "version", type: "string" },
          { name: "chainId", type: "uint256" },
          { name: "verifyingContract", type: "address" }
        ],
        Permit: [
          { name: "owner", type: "address" },
          { name: "spender", type: "address" },
          { name: "value", type: "uint256" },
          { name: "nonce", type: "uint256" },
          { name: "deadline", type: "uint256" }
        ]
      },
      primaryType: "Permit",
      domain: {
        name,
        version: "1",
        chainId,
        verifyingContract: reserve
      },
      message: {
        owner: user,
        spender: this.poolAddress,
        value: convertedAmount,
        nonce,
        deadline
      }
    };
    return JSON.stringify(typeData);
  }
  async supplyWithPermit({ user, reserve, onBehalfOf, amount, referralCode, signature, useOptimizedPath, deadline }) {
    const txs = [];
    const { decimalsOf } = this.erc20Service;
    const poolContract = this.getContractInstance(this.poolAddress);
    const stakedTokenDecimals = await decimalsOf(reserve);
    const convertedAmount = valueToWei(amount, stakedTokenDecimals);
    const sig = splitSignature(signature);
    const fundsAvailable = await this.synthetixService.synthetixValidation({
      user,
      reserve,
      amount: convertedAmount
    });
    if (!fundsAvailable) {
      throw new Error("Not enough funds to execute operation");
    }
    if (useOptimizedPath) {
      return this.l2PoolService.supplyWithPermit({
        user,
        reserve,
        amount: convertedAmount,
        referralCode,
        deadline,
        permitV: sig.v,
        permitR: sig.r,
        permitS: sig.s
      }, txs);
    }
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => poolContract.populateTransaction.supplyWithPermit(reserve, convertedAmount, onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user, referralCode !== null && referralCode !== undefined ? referralCode : 0, deadline, sig.v, sig.r, sig.s),
      from: user,
      action: ProtocolAction.supplyWithPermit
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.supplyWithPermit)
    });
    return txs;
  }
  async withdraw({ user, reserve, amount, onBehalfOf, aTokenAddress, useOptimizedPath }) {
    if (reserve.toLowerCase() === API_ETH_MOCK_ADDRESS.toLowerCase()) {
      if (!aTokenAddress) {
        throw new Error("To withdraw ETH you need to pass the aWETH token address");
      }
      return this.wethGatewayService.withdrawETH({
        lendingPool: this.poolAddress,
        user,
        amount,
        onBehalfOf,
        aTokenAddress
      });
    }
    const { decimalsOf } = this.erc20Service;
    const decimals = await decimalsOf(reserve);
    const convertedAmount = amount === "-1" ? exports_lib.MaxUint256.toString() : valueToWei(amount, decimals);
    if (useOptimizedPath) {
      return this.l2PoolService.withdraw({
        user,
        reserve,
        amount: convertedAmount
      });
    }
    const poolContract = this.getContractInstance(this.poolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => poolContract.populateTransaction.withdraw(reserve, convertedAmount, onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user),
      from: user,
      action: ProtocolAction.withdraw
    });
    return [
      {
        tx: txCallback,
        txType: eEthereumTxType.DLP_ACTION,
        gas: this.generateTxPriceEstimation([], txCallback, ProtocolAction.withdraw)
      }
    ];
  }
  async borrow({ user, reserve, amount, interestRateMode, debtTokenAddress, onBehalfOf, referralCode, useOptimizedPath }) {
    if (reserve.toLowerCase() === API_ETH_MOCK_ADDRESS.toLowerCase()) {
      if (!debtTokenAddress) {
        throw new Error(`To borrow ETH you need to pass the stable or variable WETH debt Token Address corresponding the interestRateMode`);
      }
      return this.wethGatewayService.borrowETH({
        lendingPool: this.poolAddress,
        user,
        amount,
        debtTokenAddress,
        interestRateMode,
        referralCode
      });
    }
    const { decimalsOf } = this.erc20Service;
    const reserveDecimals = await decimalsOf(reserve);
    const formatAmount = valueToWei(amount, reserveDecimals);
    const numericRateMode = interestRateMode === InterestRate.Variable ? 2 : 1;
    if (useOptimizedPath) {
      return this.l2PoolService.borrow({
        user,
        reserve,
        amount: formatAmount,
        numericRateMode,
        referralCode
      });
    }
    const poolContract = this.getContractInstance(this.poolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => poolContract.populateTransaction.borrow(reserve, formatAmount, numericRateMode, referralCode !== null && referralCode !== undefined ? referralCode : 0, onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user),
      from: user,
      action: ProtocolAction.borrow
    });
    return [
      {
        tx: txCallback,
        txType: eEthereumTxType.DLP_ACTION,
        gas: this.generateTxPriceEstimation([], txCallback, ProtocolAction.borrow)
      }
    ];
  }
  async repay({ user, reserve, amount, interestRateMode, onBehalfOf, useOptimizedPath }) {
    if (reserve.toLowerCase() === API_ETH_MOCK_ADDRESS.toLowerCase()) {
      return this.wethGatewayService.repayETH({
        lendingPool: this.poolAddress,
        user,
        amount,
        interestRateMode,
        onBehalfOf
      });
    }
    const txs = [];
    const { isApproved, approve, decimalsOf } = this.erc20Service;
    const poolContract = this.getContractInstance(this.poolAddress);
    const { populateTransaction: populateTransaction2 } = poolContract;
    const numericRateMode = interestRateMode === InterestRate.Variable ? 2 : 1;
    const decimals = await decimalsOf(reserve);
    const convertedAmount = amount === "-1" ? exports_lib.MaxUint256.toString() : valueToWei(amount, decimals);
    if (amount !== "-1") {
      const fundsAvailable = await this.synthetixService.synthetixValidation({
        user,
        reserve,
        amount: convertedAmount
      });
      if (!fundsAvailable) {
        throw new Error("Not enough funds to execute operation");
      }
    }
    const approved = await isApproved({
      token: reserve,
      user,
      spender: this.poolAddress,
      amount
    });
    if (!approved) {
      const approveTx = approve({
        user,
        token: reserve,
        spender: this.poolAddress,
        amount: DEFAULT_APPROVE_AMOUNT
      });
      txs.push(approveTx);
    }
    if (useOptimizedPath) {
      return this.l2PoolService.repay({
        user,
        reserve,
        amount: convertedAmount,
        numericRateMode
      }, txs);
    }
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => populateTransaction2.repay(reserve, convertedAmount, numericRateMode, onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user),
      from: user,
      value: getTxValue(reserve, convertedAmount),
      action: ProtocolAction.repay
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.repay)
    });
    return txs;
  }
  async repayWithPermit({ user, reserve, amount, interestRateMode, onBehalfOf, signature, useOptimizedPath, deadline }) {
    const txs = [];
    const { decimalsOf } = this.erc20Service;
    const poolContract = this.getContractInstance(this.poolAddress);
    const { populateTransaction: populateTransaction2 } = poolContract;
    const numericRateMode = interestRateMode === InterestRate.Variable ? 2 : 1;
    const decimals = await decimalsOf(reserve);
    const sig = splitSignature(signature);
    const convertedAmount = amount === "-1" ? exports_lib.MaxUint256.toString() : valueToWei(amount, decimals);
    if (amount !== "-1") {
      const fundsAvailable = await this.synthetixService.synthetixValidation({
        user,
        reserve,
        amount: convertedAmount
      });
      if (!fundsAvailable) {
        throw new Error("Not enough funds to execute operation");
      }
    }
    if (useOptimizedPath) {
      return this.l2PoolService.repayWithPermit({
        user,
        reserve,
        amount: convertedAmount,
        numericRateMode,
        deadline,
        permitR: sig.r,
        permitS: sig.s,
        permitV: sig.v
      }, txs);
    }
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => populateTransaction2.repayWithPermit(reserve, convertedAmount, numericRateMode, onBehalfOf !== null && onBehalfOf !== undefined ? onBehalfOf : user, deadline, sig.v, sig.r, sig.s),
      from: user,
      value: getTxValue(reserve, convertedAmount),
      action: ProtocolAction.repayWithPermit
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.repayWithPermit)
    });
    return txs;
  }
  async swapBorrowRateMode({ user, reserve, interestRateMode, useOptimizedPath }) {
    const numericRateMode = interestRateMode === InterestRate.Variable ? 2 : 1;
    if (useOptimizedPath) {
      return this.l2PoolService.swapBorrowRateMode({
        user,
        reserve,
        numericRateMode
      });
    }
    const poolContract = this.getContractInstance(this.poolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => poolContract.populateTransaction.swapBorrowRateMode(reserve, numericRateMode),
      from: user
    });
    return [
      {
        txType: eEthereumTxType.DLP_ACTION,
        tx: txCallback,
        gas: this.generateTxPriceEstimation([], txCallback)
      }
    ];
  }
  async setUsageAsCollateral({ user, reserve, usageAsCollateral, useOptimizedPath }) {
    const poolContract = this.getContractInstance(this.poolAddress);
    if (useOptimizedPath) {
      return this.l2PoolService.setUserUseReserveAsCollateral({
        user,
        reserve,
        usageAsCollateral
      });
    }
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => poolContract.populateTransaction.setUserUseReserveAsCollateral(reserve, usageAsCollateral),
      from: user
    });
    return [
      {
        tx: txCallback,
        txType: eEthereumTxType.DLP_ACTION,
        gas: this.generateTxPriceEstimation([], txCallback)
      }
    ];
  }
  async liquidationCall({ liquidator, liquidatedUser, debtReserve, collateralReserve, purchaseAmount, getAToken, liquidateAll, useOptimizedPath }) {
    const txs = [];
    const { isApproved, approve, decimalsOf } = this.erc20Service;
    const approved = await isApproved({
      token: debtReserve,
      user: liquidator,
      spender: this.poolAddress,
      amount: purchaseAmount
    });
    if (!approved) {
      const approveTx = approve({
        user: liquidator,
        token: debtReserve,
        spender: this.poolAddress,
        amount: DEFAULT_APPROVE_AMOUNT
      });
      txs.push(approveTx);
    }
    let convertedAmount = exports_lib.MaxUint256.toString();
    if (!liquidateAll) {
      const reserveDecimals = await decimalsOf(debtReserve);
      convertedAmount = valueToWei(purchaseAmount, reserveDecimals);
    }
    if (useOptimizedPath) {
      return this.l2PoolService.liquidationCall({
        liquidator,
        liquidatedUser,
        debtReserve,
        collateralReserve,
        debtToCover: convertedAmount,
        getAToken
      }, txs);
    }
    const poolContract = this.getContractInstance(this.poolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => poolContract.populateTransaction.liquidationCall(collateralReserve, debtReserve, liquidatedUser, convertedAmount, getAToken !== null && getAToken !== undefined ? getAToken : false),
      from: liquidator,
      value: getTxValue(debtReserve, convertedAmount)
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.liquidationCall)
    });
    return txs;
  }
  async swapCollateral({ user, flash, fromAsset, fromAToken, toAsset, fromAmount, minToAmount, permitSignature, swapAll, referralCode, augustus, swapCallData }) {
    const txs = [];
    const permitParams = permitSignature !== null && permitSignature !== undefined ? permitSignature : {
      amount: "0",
      deadline: "0",
      v: 0,
      r: "0x0000000000000000000000000000000000000000000000000000000000000000",
      s: "0x0000000000000000000000000000000000000000000000000000000000000000"
    };
    const approved = await this.erc20Service.isApproved({
      token: fromAToken,
      user,
      spender: this.swapCollateralAddress,
      amount: fromAmount
    });
    if (!approved) {
      const approveTx = this.erc20Service.approve({
        user,
        token: fromAToken,
        spender: this.swapCollateralAddress,
        amount: exports_lib.MaxUint256.toString()
      });
      txs.push(approveTx);
    }
    const tokenDecimals = await this.erc20Service.decimalsOf(fromAsset);
    const convertedAmount = valueToWei(fromAmount, tokenDecimals);
    const tokenToDecimals = await this.erc20Service.decimalsOf(toAsset);
    const amountSlippageConverted = valueToWei(minToAmount, tokenToDecimals);
    const poolContract = this.getContractInstance(this.poolAddress);
    if (flash) {
      const params = buildParaSwapLiquiditySwapParams(toAsset, amountSlippageConverted, swapAll ? augustusFromAmountOffsetFromCalldata(swapCallData) : 0, swapCallData, augustus, permitParams.amount, permitParams.deadline, permitParams.v, permitParams.r, permitParams.s);
      const amountWithSurplus = (Number(fromAmount) + Number(fromAmount) * Number(SURPLUS) / 100).toString();
      const convertedAmountWithSurplus = valueToWei(amountWithSurplus, tokenDecimals);
      const txCallback = this.generateTxCallback({
        rawTxMethod: async () => poolContract.populateTransaction.flashLoanSimple(this.swapCollateralAddress, fromAsset, swapAll ? convertedAmountWithSurplus : convertedAmount, params, referralCode !== null && referralCode !== undefined ? referralCode : "0"),
        from: user,
        action: ProtocolAction.swapCollateral
      });
      txs.push({
        tx: txCallback,
        txType: eEthereumTxType.DLP_ACTION,
        gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.swapCollateral)
      });
      return txs;
    }
    const swapAndDepositTx = this.liquiditySwapAdapterService.swapAndDeposit({
      user,
      assetToSwapFrom: fromAsset,
      assetToSwapTo: toAsset,
      amountToSwap: convertedAmount,
      minAmountToReceive: amountSlippageConverted,
      swapAll,
      swapCallData,
      augustus,
      permitParams
    }, txs);
    txs.push(swapAndDepositTx);
    return txs;
  }
  async paraswapRepayWithCollateral({ user, fromAsset, fromAToken, assetToRepay, repayWithAmount, repayAmount, permitSignature, repayAllDebt, rateMode, referralCode, flash, swapAndRepayCallData, augustus }) {
    const txs = [];
    const permitParams = permitSignature !== null && permitSignature !== undefined ? permitSignature : {
      amount: "0",
      deadline: "0",
      v: 0,
      r: "0x0000000000000000000000000000000000000000000000000000000000000000",
      s: "0x0000000000000000000000000000000000000000000000000000000000000000"
    };
    const approved = await this.erc20Service.isApproved({
      token: fromAToken,
      user,
      spender: this.repayWithCollateralAddress,
      amount: repayWithAmount
    });
    if (!approved) {
      const approveTx = this.erc20Service.approve({
        user,
        token: fromAToken,
        spender: this.repayWithCollateralAddress,
        amount: exports_lib.MaxUint256.toString()
      });
      txs.push(approveTx);
    }
    const fromDecimals = await this.erc20Service.decimalsOf(fromAsset);
    const convertedRepayWithAmount = valueToWei(repayWithAmount, fromDecimals);
    const repayWithAmountWithSurplus = (Number(repayWithAmount) + Number(repayWithAmount) * Number(SURPLUS) / 100).toString();
    const convertedRepayWithAmountWithSurplus = valueToWei(repayWithAmountWithSurplus, fromDecimals);
    const decimals = await this.erc20Service.decimalsOf(assetToRepay);
    const convertedRepayAmount = valueToWei(repayAmount, decimals);
    const numericInterestRate = rateMode === InterestRate.Stable ? 1 : 2;
    if (flash) {
      const callDataEncoded = exports_utils.defaultAbiCoder.encode(["bytes", "address"], [swapAndRepayCallData, augustus]);
      const params = exports_utils.defaultAbiCoder.encode([
        "address",
        "uint256",
        "uint256",
        "uint256",
        "bytes",
        "uint256",
        "uint256",
        "uint8",
        "bytes32",
        "bytes32"
      ], [
        assetToRepay,
        convertedRepayAmount,
        repayAllDebt ? augustusToAmountOffsetFromCalldata(swapAndRepayCallData) : 0,
        numericInterestRate,
        callDataEncoded,
        permitParams.amount,
        permitParams.deadline,
        permitParams.v,
        permitParams.r,
        permitParams.s
      ]);
      const poolContract = this.getContractInstance(this.poolAddress);
      const txCallback = this.generateTxCallback({
        rawTxMethod: async () => poolContract.populateTransaction.flashLoanSimple(this.repayWithCollateralAddress, fromAsset, repayAllDebt ? convertedRepayWithAmountWithSurplus : convertedRepayWithAmount, params, referralCode !== null && referralCode !== undefined ? referralCode : "0"),
        from: user,
        action: ProtocolAction.repayCollateral
      });
      txs.push({
        tx: txCallback,
        txType: eEthereumTxType.DLP_ACTION,
        gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.repayCollateral)
      });
      return txs;
    }
    const swapAndRepayTx = this.paraswapRepayWithCollateralAdapterService.swapAndRepay({
      user,
      collateralAsset: fromAsset,
      debtAsset: assetToRepay,
      collateralAmount: convertedRepayWithAmount,
      debtRepayAmount: convertedRepayAmount,
      debtRateMode: rateMode,
      permitParams,
      repayAll: repayAllDebt !== null && repayAllDebt !== undefined ? repayAllDebt : false,
      swapAndRepayCallData,
      augustus
    }, txs);
    txs.push(swapAndRepayTx);
    return txs;
  }
  async flashLiquidation({ user, collateralAsset, borrowedAsset, debtTokenCover, liquidateAll, initiator, useEthPath }) {
    const addSurplus = (amount) => {
      return (Number(amount) + Number(amount) * Number(amount) / 100).toString();
    };
    const txs = [];
    const poolContract = this.getContractInstance(this.poolAddress);
    const tokenDecimals = await this.erc20Service.decimalsOf(borrowedAsset);
    const convertedDebt = valueToWei(debtTokenCover, tokenDecimals);
    const convertedDebtTokenCover = liquidateAll ? exports_lib.MaxUint256.toString() : convertedDebt;
    const flashBorrowAmount = liquidateAll ? valueToWei(addSurplus(debtTokenCover), tokenDecimals) : convertedDebt;
    const params = exports_utils.defaultAbiCoder.encode(["address", "address", "address", "uint256", "bool"], [
      collateralAsset,
      borrowedAsset,
      user,
      convertedDebtTokenCover,
      useEthPath !== null && useEthPath !== undefined ? useEthPath : false
    ]);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => poolContract.populateTransaction.flashLoanSimple(this.flashLiquidationAddress, borrowedAsset, flashBorrowAmount, params, "0"),
      from: initiator
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.liquidationFlash)
    });
    return txs;
  }
  async repayWithATokens({ user, amount, reserve, rateMode, useOptimizedPath }) {
    if (reserve.toLowerCase() === API_ETH_MOCK_ADDRESS.toLowerCase()) {
      throw new Error("Can not repay with aTokens with eth. Should be WETH instead");
    }
    const txs = [];
    const { decimalsOf } = this.erc20Service;
    const poolContract = this.getContractInstance(this.poolAddress);
    const { populateTransaction: populateTransaction2 } = poolContract;
    const numericRateMode = rateMode === InterestRate.Variable ? 2 : 1;
    const decimals = await decimalsOf(reserve);
    const convertedAmount = amount === "-1" ? exports_lib.MaxUint256.toString() : valueToWei(amount, decimals);
    if (useOptimizedPath) {
      return this.l2PoolService.repayWithATokens({
        user,
        reserve,
        amount: convertedAmount,
        numericRateMode
      }, txs);
    }
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => populateTransaction2.repayWithATokens(reserve, convertedAmount, numericRateMode),
      from: user,
      value: getTxValue(reserve, convertedAmount)
    });
    txs.push({
      tx: txCallback,
      txType: eEthereumTxType.DLP_ACTION,
      gas: this.generateTxPriceEstimation(txs, txCallback, ProtocolAction.repay)
    });
    return txs;
  }
  setUserEMode({ user, categoryId }) {
    const poolContract = this.getContractInstance(this.poolAddress);
    const txCallback = this.generateTxCallback({
      rawTxMethod: async () => poolContract.populateTransaction.setUserEMode(categoryId),
      from: user
    });
    return [
      {
        tx: txCallback,
        txType: eEthereumTxType.DLP_ACTION,
        gas: this.generateTxPriceEstimation([], txCallback, ProtocolAction.repay)
      }
    ];
  }
  async migrateV3({ migrator, borrowedAssets, borrowedAmounts, interestRatesModes, user, suppliedPositions, borrowedPositions, permits }) {
    const poolContract = this.getContractInstance(this.poolAddress);
    const mappedBorrowedPositions = borrowedPositions.map((borrowPosition) => [
      borrowPosition.address,
      borrowPosition.amount,
      borrowPosition.rateMode.toString()
    ]);
    const mappedPermits = permits.map((permit) => [
      permit.aToken,
      permit.value,
      permit.deadline,
      permit.v,
      permit.r,
      permit.s
    ]);
    const params = exports_utils.defaultAbiCoder.encode([
      "address[]",
      "(address, uint256, uint256)[]",
      "(address, uint256, uint256, uint8, bytes32, bytes32)[]"
    ], [suppliedPositions, mappedBorrowedPositions, mappedPermits]);
    return poolContract.populateTransaction.flashLoan(migrator, borrowedAssets, borrowedAmounts, interestRatesModes, user, params, "0");
  }
}
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("reserve")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [String]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "getReserveData", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("reserve")),
  __param(0, isPositiveAmount("amount")),
  __param(0, isEthAddress("onBehalfOf")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "deposit", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("reserve")),
  __param(0, isPositiveAmount("amount")),
  __param(0, isEthAddress("onBehalfOf")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "supply", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("reserve")),
  __param(0, isPositiveOrMinusOneAmount("amount")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "signERC20Approval", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("reserve")),
  __param(0, isEthAddress("onBehalfOf")),
  __param(0, isPositiveAmount("amount")),
  __param(0, isPositiveAmount("referralCode")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "supplyWithPermit", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("reserve")),
  __param(0, isPositiveOrMinusOneAmount("amount")),
  __param(0, isEthAddress("onBehalfOf")),
  __param(0, isEthAddress("aTokenAddress")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "withdraw", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("reserve")),
  __param(0, isPositiveAmount("amount")),
  __param(0, isEthAddress("debtTokenAddress")),
  __param(0, isEthAddress("onBehalfOf")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "borrow", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("reserve")),
  __param(0, isPositiveOrMinusOneAmount("amount")),
  __param(0, isEthAddress("onBehalfOf")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "repay", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("reserve")),
  __param(0, isPositiveOrMinusOneAmount("amount")),
  __param(0, isEthAddress("onBehalfOf")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "repayWithPermit", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("reserve")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "swapBorrowRateMode", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("reserve")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "setUsageAsCollateral", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("liquidator")),
  __param(0, isEthAddress("liquidatedUser")),
  __param(0, isEthAddress("debtReserve")),
  __param(0, isEthAddress("collateralReserve")),
  __param(0, isPositiveAmount("purchaseAmount")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "liquidationCall", null);
__decorate([
  LPSwapCollateralValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("fromAsset")),
  __param(0, isEthAddress("fromAToken")),
  __param(0, isEthAddress("toAsset")),
  __param(0, isEthAddress("augustus")),
  __param(0, isPositiveAmount("fromAmount")),
  __param(0, isPositiveAmount("minToAmount")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "swapCollateral", null);
__decorate([
  LPRepayWithCollateralValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("fromAsset")),
  __param(0, isEthAddress("fromAToken")),
  __param(0, isEthAddress("assetToRepay")),
  __param(0, isPositiveAmount("repayWithAmount")),
  __param(0, isPositiveAmount("repayAmount")),
  __param(0, isEthAddress("augustus")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "paraswapRepayWithCollateral", null);
__decorate([
  LPFlashLiquidationValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("collateralAsset")),
  __param(0, isEthAddress("borrowedAsset")),
  __param(0, isPositiveAmount("debtTokenCover")),
  __param(0, isEthAddress("initiator")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "flashLiquidation", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, isEthAddress("reserve")),
  __param(0, isPositiveOrMinusOneAmount("amount")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "repayWithATokens", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("user")),
  __param(0, is0OrPositiveAmount("categoryId")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Array)
], Pool.prototype, "setUserEMode", null);
__decorate([
  LPValidatorV3,
  __param(0, isEthAddress("migrator")),
  __param(0, isEthAddress("user")),
  __param(0, isEthAddressArray("borrowedAssets")),
  __metadata("design:type", Function),
  __metadata("design:paramtypes", [Object]),
  __metadata("design:returntype", Promise)
], Pool.prototype, "migrateV3", null);

// src/scripts/helpers/wallet-providers.ts
function getWalletBalanceProvider() {
  return new WalletBalanceProvider({
    walletBalanceProviderAddress: exports_AaveV3Sepolia.WALLET_BALANCE_PROVIDER,
    provider
  });
}
var RPC_PROVIDER_URL = "https://ethereum-sepolia.publicnode.com";
var provider = new exports_lib2.JsonRpcProvider(RPC_PROVIDER_URL, {
  name: "Sepolia",
  chainId: 11155111
});

// src/scripts/helpers/contract-providers.ts
var poolDataProviderContract = new UiPoolDataProvider({
  uiPoolDataProviderAddress: exports_AaveV3Sepolia.UI_POOL_DATA_PROVIDER,
  provider,
  chainId: ChainId.sepolia
});
var incentiveDataProviderContract = new UiIncentiveDataProvider({
  uiIncentiveDataProviderAddress: exports_AaveV3Sepolia.UI_INCENTIVE_DATA_PROVIDER,
  provider,
  chainId: ChainId.sepolia
});

// src/scripts/helpers/aave-contract-data.ts
async function fetchMarketsData() {
  const [reserves, reserveIncentives] = await Promise.allSettled([
    await poolDataProviderContract.getReservesHumanized({
      lendingPoolAddressProvider: exports_AaveV3Sepolia.POOL_ADDRESSES_PROVIDER
    }),
    await incentiveDataProviderContract.getReservesIncentivesDataHumanized({
      lendingPoolAddressProvider: exports_AaveV3Sepolia.POOL_ADDRESSES_PROVIDER
    })
  ]);
  return {
    reserves: reserves?.value,
    reserveIncentives: reserveIncentives?.value
  };
}
async function fetchUserData(accountAddress) {
  const [userReserves, userIncentives] = await Promise.allSettled([
    await poolDataProviderContract.getUserReservesHumanized({
      lendingPoolAddressProvider: exports_AaveV3Sepolia.POOL_ADDRESSES_PROVIDER,
      user: accountAddress
    }),
    await incentiveDataProviderContract.getUserReservesIncentivesDataHumanized({
      lendingPoolAddressProvider: exports_AaveV3Sepolia.POOL_ADDRESSES_PROVIDER,
      user: accountAddress
    })
  ]);
  return {
    userReserves: userReserves?.value,
    userIncentives: userIncentives?.value
  };
}
// src/scripts/helpers/contract-transactions.ts
async function submitTransaction(args) {
  const extendedTxData = await args.tx.tx();
  const { from, ...txData } = extendedTxData;
  const signer = args.provider.getSigner(from);
  const txResponse = await signer.sendTransaction({
    ...txData,
    value: txData.value ? BigNumber.from(txData.value) : undefined
  });
  return txResponse;
}
// node_modules/@aave/math-utils/dist/esm/bignumber.js
function valueToBigNumber(amount) {
  if (amount instanceof BigNumber2) {
    return amount;
  }
  return new BigNumber2(amount);
}
function valueToZDBigNumber(amount) {
  return new BigNumberZeroDecimal(amount);
}
function normalize(n, decimals) {
  return normalizeBN(n, decimals).toString(10);
}
function normalizeBN(n, decimals) {
  return valueToBigNumber(n).shiftedBy(decimals * -1);
}
var BigNumberZeroDecimal = BigNumber2.clone({
  DECIMAL_PLACES: 0,
  ROUNDING_MODE: BigNumber2.ROUND_DOWN
});

// node_modules/@aave/math-utils/dist/esm/constants.js
var SECONDS_PER_YEAR = valueToBigNumber("31536000");
var USD_DECIMALS = 8;
var WEI_DECIMALS = 18;
var RAY_DECIMALS = 27;
var LTV_PRECISION = 4;

// node_modules/@aave/math-utils/dist/esm/ray.math.js
function rayMul(a, b3) {
  return HALF_RAY.plus(valueToZDBigNumber(a).multipliedBy(b3)).div(RAY);
}
function rayDiv(a, b3) {
  const halfB = valueToZDBigNumber(b3).div(2);
  return halfB.plus(valueToZDBigNumber(a).multipliedBy(RAY)).div(b3);
}
function rayToWad(a) {
  const halfRatio = valueToZDBigNumber(WAD_RAY_RATIO).div(2);
  return halfRatio.plus(a).div(WAD_RAY_RATIO);
}
function wadToRay(a) {
  return valueToZDBigNumber(a).multipliedBy(WAD_RAY_RATIO).decimalPlaces(0);
}
function rayPow(a, p) {
  let x = valueToZDBigNumber(a);
  let n = valueToZDBigNumber(p);
  let z2 = n.modulo(2).eq(0) ? valueToZDBigNumber(RAY) : x;
  for (n = n.div(2);!n.eq(0); n = n.div(2)) {
    x = rayMul(x, x);
    if (!n.modulo(2).eq(0)) {
      z2 = rayMul(z2, x);
    }
  }
  return z2;
}
function binomialApproximatedRayPow(a, p) {
  const base = valueToZDBigNumber(a);
  const exp = valueToZDBigNumber(p);
  if (exp.eq(0))
    return RAY;
  const expMinusOne = exp.minus(1);
  const expMinusTwo = exp.gt(2) ? exp.minus(2) : 0;
  const basePowerTwo = rayMul(base, base);
  const basePowerThree = rayMul(basePowerTwo, base);
  const firstTerm = exp.multipliedBy(base);
  const secondTerm = exp.multipliedBy(expMinusOne).multipliedBy(basePowerTwo).div(2);
  const thirdTerm = exp.multipliedBy(expMinusOne).multipliedBy(expMinusTwo).multipliedBy(basePowerThree).div(6);
  return RAY.plus(firstTerm).plus(secondTerm).plus(thirdTerm);
}
var WAD = valueToZDBigNumber(10).pow(18);
var HALF_WAD = WAD.dividedBy(2);
var RAY = valueToZDBigNumber(10).pow(27);
var HALF_RAY = RAY.dividedBy(2);
var WAD_RAY_RATIO = valueToZDBigNumber(10).pow(9);

// node_modules/@aave/math-utils/dist/esm/pool-math.js
function calculateCompoundedInterest({ rate, currentTimestamp, lastUpdateTimestamp }) {
  const timeDelta = valueToZDBigNumber(currentTimestamp - lastUpdateTimestamp);
  const ratePerSecond = valueToZDBigNumber(rate).dividedBy(SECONDS_PER_YEAR);
  return binomialApproximatedRayPow(ratePerSecond, timeDelta);
}
function getCompoundedBalance({ principalBalance: _principalBalance, reserveIndex, reserveRate, lastUpdateTimestamp, currentTimestamp }) {
  const principalBalance = valueToZDBigNumber(_principalBalance);
  if (principalBalance.eq("0")) {
    return principalBalance;
  }
  const compoundedInterest = calculateCompoundedInterest({
    rate: reserveRate,
    currentTimestamp,
    lastUpdateTimestamp
  });
  const cumulatedInterest = rayMul(compoundedInterest, reserveIndex);
  const principalBalanceRay = wadToRay(principalBalance);
  return rayToWad(rayMul(principalBalanceRay, cumulatedInterest));
}
function calculateLinearInterest({ rate, currentTimestamp, lastUpdateTimestamp }) {
  const timeDelta = wadToRay(valueToZDBigNumber(currentTimestamp - lastUpdateTimestamp));
  const timeDeltaInSeconds = rayDiv(timeDelta, wadToRay(SECONDS_PER_YEAR));
  const a = rayMul(rate, timeDeltaInSeconds).plus(RAY);
  return a;
}
function getReserveNormalizedIncome({ rate, index, lastUpdateTimestamp, currentTimestamp }) {
  if (valueToZDBigNumber(rate).eq("0")) {
    return valueToZDBigNumber(index);
  }
  const cumulatedInterest = calculateLinearInterest({
    rate,
    currentTimestamp,
    lastUpdateTimestamp
  });
  return rayMul(cumulatedInterest, index);
}
function getLinearBalance({ balance, index, rate, lastUpdateTimestamp, currentTimestamp }) {
  return rayToWad(rayMul(wadToRay(balance), getReserveNormalizedIncome({
    rate,
    index,
    lastUpdateTimestamp,
    currentTimestamp
  })));
}
function getCompoundedStableBalance({ principalBalance: _principalBalance, userStableRate, lastUpdateTimestamp, currentTimestamp }) {
  const principalBalance = valueToZDBigNumber(_principalBalance);
  if (principalBalance.eq("0")) {
    return principalBalance;
  }
  const cumulatedInterest = calculateCompoundedInterest({
    rate: userStableRate,
    currentTimestamp,
    lastUpdateTimestamp
  });
  const principalBalanceRay = wadToRay(principalBalance);
  return rayToWad(rayMul(principalBalanceRay, cumulatedInterest));
}
function calculateHealthFactorFromBalances({ borrowBalanceMarketReferenceCurrency, collateralBalanceMarketReferenceCurrency, currentLiquidationThreshold }) {
  if (valueToBigNumber(borrowBalanceMarketReferenceCurrency).eq(0)) {
    return valueToBigNumber("-1");
  }
  return valueToBigNumber(collateralBalanceMarketReferenceCurrency).multipliedBy(currentLiquidationThreshold).shiftedBy(LTV_PRECISION * -1).div(borrowBalanceMarketReferenceCurrency);
}
function calculateAvailableBorrowsMarketReferenceCurrency({ collateralBalanceMarketReferenceCurrency, borrowBalanceMarketReferenceCurrency, currentLtv }) {
  if (valueToZDBigNumber(currentLtv).eq(0)) {
    return valueToZDBigNumber("0");
  }
  const availableBorrowsMarketReferenceCurrency = valueToZDBigNumber(collateralBalanceMarketReferenceCurrency).multipliedBy(currentLtv).shiftedBy(LTV_PRECISION * -1).minus(borrowBalanceMarketReferenceCurrency);
  return availableBorrowsMarketReferenceCurrency.gt("0") ? availableBorrowsMarketReferenceCurrency : valueToZDBigNumber("0");
}
function getMarketReferenceCurrencyAndUsdBalance({ balance, priceInMarketReferenceCurrency, marketReferenceCurrencyDecimals, decimals, marketReferencePriceInUsdNormalized }) {
  const marketReferenceCurrencyBalance = valueToZDBigNumber(balance).multipliedBy(priceInMarketReferenceCurrency).shiftedBy(decimals * -1);
  const usdBalance = marketReferenceCurrencyBalance.multipliedBy(marketReferencePriceInUsdNormalized).shiftedBy(marketReferenceCurrencyDecimals * -1);
  return { marketReferenceCurrencyBalance, usdBalance };
}

// node_modules/@aave/math-utils/dist/esm/formatters/incentive/calculate-accrued-incentives.js
function calculateAccruedIncentives({ principalUserBalance, reserveIndex, userIndex, precision, reserveIndexTimestamp, emissionPerSecond, totalSupply, currentTimestamp, emissionEndTimestamp }) {
  if (totalSupply.isEqualTo(new bignumber_default(0))) {
    return new bignumber_default(0);
  }
  const actualCurrentTimestamp = currentTimestamp > emissionEndTimestamp ? emissionEndTimestamp : currentTimestamp;
  const timeDelta = actualCurrentTimestamp - reserveIndexTimestamp;
  let currentReserveIndex;
  if (reserveIndexTimestamp >= Number(currentTimestamp) || reserveIndexTimestamp >= emissionEndTimestamp) {
    currentReserveIndex = reserveIndex;
  } else {
    currentReserveIndex = emissionPerSecond.multipliedBy(timeDelta).shiftedBy(precision).dividedBy(totalSupply).plus(reserveIndex);
  }
  const reward = principalUserBalance.multipliedBy(currentReserveIndex.minus(userIndex)).shiftedBy(precision * -1);
  return reward;
}

// node_modules/@aave/math-utils/dist/esm/formatters/incentive/calculate-user-reserve-incentives.js
function calculateUserReserveIncentives({ reserveIncentives, userIncentives, currentTimestamp, userReserveData }) {
  const calculatedUserIncentives = [];
  userIncentives.aTokenIncentivesUserData.userRewardsInformation.forEach((userReserveIncentive) => {
    const reserveIncentive = reserveIncentives.aIncentiveData.rewardsTokenInformation.find((reward) => reward.rewardTokenAddress === userReserveIncentive.rewardTokenAddress);
    if (reserveIncentive) {
      const accruedRewards = userReserveData ? calculateAccruedIncentives({
        principalUserBalance: new bignumber_default(userReserveData.scaledATokenBalance),
        reserveIndex: new bignumber_default(reserveIncentive.tokenIncentivesIndex),
        userIndex: new bignumber_default(userReserveIncentive.tokenIncentivesUserIndex),
        precision: reserveIncentive.precision,
        reserveIndexTimestamp: reserveIncentive.incentivesLastUpdateTimestamp,
        emissionPerSecond: new bignumber_default(reserveIncentive.emissionPerSecond),
        totalSupply: rayDiv(new bignumber_default(userReserveData.reserve.totalLiquidity).shiftedBy(userReserveData.reserve.decimals), new bignumber_default(userReserveData.reserve.liquidityIndex)),
        currentTimestamp,
        emissionEndTimestamp: reserveIncentive.emissionEndTimestamp
      }) : new bignumber_default("0");
      calculatedUserIncentives.push({
        tokenAddress: userIncentives.aTokenIncentivesUserData.tokenAddress,
        incentiveController: userIncentives.aTokenIncentivesUserData.incentiveControllerAddress,
        rewardTokenAddress: userReserveIncentive.rewardTokenAddress,
        rewardTokenDecimals: userReserveIncentive.rewardTokenDecimals,
        accruedRewards,
        unclaimedRewards: new bignumber_default(userReserveIncentive.userUnclaimedRewards),
        rewardPriceFeed: normalize(userReserveIncentive.rewardPriceFeed, userReserveIncentive.priceFeedDecimals),
        rewardTokenSymbol: userReserveIncentive.rewardTokenSymbol
      });
    }
  });
  userIncentives.vTokenIncentivesUserData.userRewardsInformation.forEach((userReserveIncentive) => {
    const reserveIncentive = reserveIncentives.vIncentiveData.rewardsTokenInformation.find((reward) => reward.rewardTokenAddress === userReserveIncentive.rewardTokenAddress);
    if (reserveIncentive) {
      const accruedRewards = userReserveData ? calculateAccruedIncentives({
        principalUserBalance: new bignumber_default(userReserveData.scaledVariableDebt),
        reserveIndex: new bignumber_default(reserveIncentive.tokenIncentivesIndex),
        userIndex: new bignumber_default(userReserveIncentive.tokenIncentivesUserIndex),
        precision: reserveIncentive.precision,
        reserveIndexTimestamp: reserveIncentive.incentivesLastUpdateTimestamp,
        emissionPerSecond: new bignumber_default(reserveIncentive.emissionPerSecond),
        totalSupply: new bignumber_default(userReserveData.reserve.totalScaledVariableDebt).shiftedBy(userReserveData.reserve.decimals),
        currentTimestamp,
        emissionEndTimestamp: reserveIncentive.emissionEndTimestamp
      }) : new bignumber_default("0");
      calculatedUserIncentives.push({
        tokenAddress: userIncentives.vTokenIncentivesUserData.tokenAddress,
        incentiveController: userIncentives.vTokenIncentivesUserData.incentiveControllerAddress,
        rewardTokenAddress: userReserveIncentive.rewardTokenAddress,
        rewardTokenDecimals: userReserveIncentive.rewardTokenDecimals,
        accruedRewards,
        unclaimedRewards: new bignumber_default(userReserveIncentive.userUnclaimedRewards),
        rewardPriceFeed: normalize(userReserveIncentive.rewardPriceFeed, userReserveIncentive.priceFeedDecimals),
        rewardTokenSymbol: userReserveIncentive.rewardTokenSymbol
      });
    }
  });
  userIncentives.sTokenIncentivesUserData.userRewardsInformation.forEach((userReserveIncentive) => {
    const reserveIncentive = reserveIncentives.sIncentiveData.rewardsTokenInformation.find((reward) => reward.rewardTokenAddress === userReserveIncentive.rewardTokenAddress);
    if (reserveIncentive) {
      const accruedRewards = userReserveData ? calculateAccruedIncentives({
        principalUserBalance: new bignumber_default(userReserveData.principalStableDebt),
        reserveIndex: new bignumber_default(reserveIncentive.tokenIncentivesIndex),
        userIndex: new bignumber_default(userReserveIncentive.tokenIncentivesUserIndex),
        precision: reserveIncentive.precision,
        reserveIndexTimestamp: reserveIncentive.incentivesLastUpdateTimestamp,
        emissionPerSecond: new bignumber_default(reserveIncentive.emissionPerSecond),
        totalSupply: new bignumber_default(userReserveData.reserve.totalPrincipalStableDebt).shiftedBy(userReserveData.reserve.decimals),
        currentTimestamp,
        emissionEndTimestamp: reserveIncentive.emissionEndTimestamp
      }) : new bignumber_default("0");
      calculatedUserIncentives.push({
        tokenAddress: userIncentives.sTokenIncentivesUserData.tokenAddress,
        incentiveController: userIncentives.sTokenIncentivesUserData.incentiveControllerAddress,
        rewardTokenAddress: userReserveIncentive.rewardTokenAddress,
        rewardTokenDecimals: userReserveIncentive.rewardTokenDecimals,
        accruedRewards,
        unclaimedRewards: new bignumber_default(userReserveIncentive.userUnclaimedRewards),
        rewardPriceFeed: normalize(userReserveIncentive.rewardPriceFeed, userReserveIncentive.priceFeedDecimals),
        rewardTokenSymbol: userReserveIncentive.rewardTokenSymbol
      });
    }
  });
  return calculatedUserIncentives;
}

// node_modules/@aave/math-utils/dist/esm/formatters/incentive/calculate-all-user-incentives.js
function calculateAllUserIncentives({ reserveIncentives, userIncentives, userReserves, currentTimestamp }) {
  const allRewards = userIncentives.map((userIncentive) => {
    const reserve = reserveIncentives.find((reserve2) => reserve2.underlyingAsset === userIncentive.underlyingAsset);
    const userReserve = userReserves.find((userReserve2) => userReserve2.reserve.underlyingAsset === userIncentive.underlyingAsset);
    if (reserve) {
      const reserveRewards = calculateUserReserveIncentives({
        reserveIncentives: reserve,
        userIncentives: userIncentive,
        userReserveData: userReserve,
        currentTimestamp
      });
      return reserveRewards;
    }
    return [];
  }).flat();
  const incentiveDict = {};
  allRewards.forEach((reward) => {
    if (!incentiveDict[reward.rewardTokenAddress]) {
      incentiveDict[reward.rewardTokenAddress] = {
        assets: [],
        rewardTokenSymbol: reward.rewardTokenSymbol,
        claimableRewards: reward.unclaimedRewards,
        incentiveControllerAddress: reward.incentiveController,
        rewardTokenDecimals: reward.rewardTokenDecimals,
        rewardPriceFeed: reward.rewardPriceFeed
      };
    }
    if (reward.accruedRewards.gt(0)) {
      incentiveDict[reward.rewardTokenAddress].claimableRewards = incentiveDict[reward.rewardTokenAddress].claimableRewards.plus(reward.accruedRewards);
      incentiveDict[reward.rewardTokenAddress].assets.push(reward.tokenAddress);
    }
  });
  return incentiveDict;
}

// node_modules/@aave/math-utils/dist/esm/formatters/incentive/calculate-incentive-apr.js
function calculateIncentiveAPR({ emissionPerSecond, rewardTokenPriceInMarketReferenceCurrency, priceInMarketReferenceCurrency, totalTokenSupply, decimals }) {
  const emissionPerSecondNormalized = normalizeBN(emissionPerSecond, WEI_DECIMALS).multipliedBy(rewardTokenPriceInMarketReferenceCurrency);
  if (emissionPerSecondNormalized.eq(0)) {
    return "0";
  }
  const emissionPerYear = emissionPerSecondNormalized.multipliedBy(SECONDS_PER_YEAR);
  const totalSupplyNormalized = valueToBigNumber(normalize(totalTokenSupply, decimals)).multipliedBy(priceInMarketReferenceCurrency);
  return emissionPerYear.dividedBy(totalSupplyNormalized).toFixed();
}

// node_modules/@aave/math-utils/dist/esm/formatters/incentive/calculate-reserve-incentives.js
function calculateRewardTokenPrice(reserves, address4, priceFeed, priceFeedDecimals) {
  if (Number(priceFeed) > 0) {
    return normalize(priceFeed, priceFeedDecimals);
  }
  address4 = address4.toLowerCase();
  if (address4.toLowerCase() === "0x4da27a545c0c5b758a6ba100e3a049001de870f5") {
    address4 = "0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9";
  }
  const rewardReserve = reserves.find((reserve) => reserve.underlyingAsset.toLowerCase() === address4);
  if (rewardReserve) {
    return rewardReserve.formattedPriceInMarketReferenceCurrency;
  }
  return "0";
}
function calculateReserveIncentives({ reserves, reserveIncentiveData, totalLiquidity, totalVariableDebt, totalStableDebt, decimals, priceInMarketReferenceCurrency }) {
  const aIncentivesData = reserveIncentiveData.aIncentiveData.rewardsTokenInformation.map((reward) => {
    const aIncentivesAPR = rewardEmissionActive(reward) ? calculateIncentiveAPR({
      emissionPerSecond: reward.emissionPerSecond,
      rewardTokenPriceInMarketReferenceCurrency: calculateRewardTokenPrice(reserves, reward.rewardTokenAddress, reward.rewardPriceFeed, reward.priceFeedDecimals),
      priceInMarketReferenceCurrency,
      totalTokenSupply: totalLiquidity,
      decimals,
      rewardTokenDecimals: reward.rewardTokenDecimals
    }) : "0";
    const aIncentiveData = {
      incentiveAPR: aIncentivesAPR,
      rewardTokenAddress: reward.rewardTokenAddress,
      rewardTokenSymbol: reward.rewardTokenSymbol
    };
    return aIncentiveData;
  });
  const vIncentivesData = reserveIncentiveData.vIncentiveData.rewardsTokenInformation.map((reward) => {
    const vIncentivesAPR = rewardEmissionActive(reward) ? calculateIncentiveAPR({
      emissionPerSecond: reward.emissionPerSecond,
      rewardTokenPriceInMarketReferenceCurrency: calculateRewardTokenPrice(reserves, reward.rewardTokenAddress, reward.rewardPriceFeed, reward.priceFeedDecimals),
      priceInMarketReferenceCurrency,
      totalTokenSupply: totalVariableDebt,
      decimals,
      rewardTokenDecimals: reward.rewardTokenDecimals
    }) : "0";
    const vIncentiveData = {
      incentiveAPR: vIncentivesAPR,
      rewardTokenAddress: reward.rewardTokenAddress,
      rewardTokenSymbol: reward.rewardTokenSymbol
    };
    return vIncentiveData;
  });
  const sIncentivesData = reserveIncentiveData.sIncentiveData.rewardsTokenInformation.map((reward) => {
    const sIncentivesAPR = rewardEmissionActive(reward) ? calculateIncentiveAPR({
      emissionPerSecond: reward.emissionPerSecond,
      rewardTokenPriceInMarketReferenceCurrency: calculateRewardTokenPrice(reserves, reward.rewardTokenAddress, reward.rewardPriceFeed, reward.priceFeedDecimals),
      priceInMarketReferenceCurrency,
      totalTokenSupply: totalStableDebt,
      decimals,
      rewardTokenDecimals: reward.rewardTokenDecimals
    }) : "0";
    const sIncentiveData = {
      incentiveAPR: sIncentivesAPR,
      rewardTokenAddress: reward.rewardTokenAddress,
      rewardTokenSymbol: reward.rewardTokenSymbol
    };
    return sIncentiveData;
  });
  return {
    underlyingAsset: reserveIncentiveData.underlyingAsset,
    aIncentivesData,
    vIncentivesData,
    sIncentivesData
  };
}
var rewardEmissionActive = (reward) => {
  if (reward.emissionEndTimestamp > reward.incentivesLastUpdateTimestamp) {
    return true;
  }
  return false;
};

// node_modules/@aave/math-utils/dist/esm/formatters/user/format-user-reserve.js
function formatUserReserve({ reserve: _reserve, marketReferenceCurrencyDecimals }) {
  const { userReserve } = _reserve;
  const { reserve } = userReserve;
  const reserveDecimals = reserve.decimals;
  const normalizeWithReserve = (n) => normalize(n, reserve.decimals);
  const exactStableBorrowRate = rayPow(valueToZDBigNumber(userReserve.stableBorrowRate).dividedBy(SECONDS_PER_YEAR).plus(RAY), SECONDS_PER_YEAR).minus(RAY);
  return Object.assign(Object.assign({}, userReserve), { underlyingBalance: normalize(_reserve.underlyingBalance, reserveDecimals), underlyingBalanceMarketReferenceCurrency: normalize(_reserve.underlyingBalanceMarketReferenceCurrency, marketReferenceCurrencyDecimals), underlyingBalanceUSD: _reserve.underlyingBalanceUSD.toString(), stableBorrows: normalizeWithReserve(_reserve.stableBorrows), stableBorrowsMarketReferenceCurrency: normalize(_reserve.stableBorrowsMarketReferenceCurrency, marketReferenceCurrencyDecimals), stableBorrowsUSD: _reserve.stableBorrowsUSD.toString(), variableBorrows: normalizeWithReserve(_reserve.variableBorrows), variableBorrowsMarketReferenceCurrency: normalize(_reserve.variableBorrowsMarketReferenceCurrency, marketReferenceCurrencyDecimals), variableBorrowsUSD: _reserve.variableBorrowsUSD.toString(), totalBorrows: normalizeWithReserve(_reserve.totalBorrows), totalBorrowsMarketReferenceCurrency: normalize(_reserve.totalBorrowsMarketReferenceCurrency, marketReferenceCurrencyDecimals), totalBorrowsUSD: _reserve.totalBorrowsUSD.toString(), stableBorrowAPR: normalize(userReserve.stableBorrowRate, RAY_DECIMALS), stableBorrowAPY: normalize(exactStableBorrowRate, RAY_DECIMALS) });
}

// node_modules/@aave/math-utils/dist/esm/formatters/usd/normalized-to-usd.js
function normalizedToUsd(value, marketReferencePriceInUsd, marketReferenceCurrencyDecimals) {
  return value.multipliedBy(marketReferencePriceInUsd).shiftedBy(marketReferenceCurrencyDecimals * -1);
}

// node_modules/@aave/math-utils/dist/esm/formatters/user/calculate-user-reserve-totals.js
function calculateUserReserveTotals({ userReserves, userEmodeCategoryId }) {
  let totalLiquidityMarketReferenceCurrency = valueToZDBigNumber("0");
  let totalCollateralMarketReferenceCurrency = valueToZDBigNumber("0");
  let totalBorrowsMarketReferenceCurrency = valueToZDBigNumber("0");
  let currentLtv = valueToBigNumber("0");
  let currentLiquidationThreshold = valueToBigNumber("0");
  let isInIsolationMode = false;
  let isolatedReserve;
  userReserves.forEach((userReserveSummary) => {
    totalLiquidityMarketReferenceCurrency = totalLiquidityMarketReferenceCurrency.plus(userReserveSummary.underlyingBalanceMarketReferenceCurrency);
    totalBorrowsMarketReferenceCurrency = totalBorrowsMarketReferenceCurrency.plus(userReserveSummary.variableBorrowsMarketReferenceCurrency).plus(userReserveSummary.stableBorrowsMarketReferenceCurrency);
    if (userReserveSummary.userReserve.reserve.reserveLiquidationThreshold !== "0" && userReserveSummary.userReserve.usageAsCollateralEnabledOnUser) {
      if (userReserveSummary.userReserve.reserve.debtCeiling !== "0") {
        isolatedReserve = userReserveSummary.userReserve.reserve;
        isInIsolationMode = true;
      }
      totalCollateralMarketReferenceCurrency = totalCollateralMarketReferenceCurrency.plus(userReserveSummary.underlyingBalanceMarketReferenceCurrency);
      if (userEmodeCategoryId && userEmodeCategoryId === userReserveSummary.userReserve.reserve.eModeCategoryId) {
        currentLtv = currentLtv.plus(valueToBigNumber(userReserveSummary.underlyingBalanceMarketReferenceCurrency).multipliedBy(userReserveSummary.userReserve.reserve.eModeLtv));
        currentLiquidationThreshold = currentLiquidationThreshold.plus(valueToBigNumber(userReserveSummary.underlyingBalanceMarketReferenceCurrency).multipliedBy(userReserveSummary.userReserve.reserve.eModeLiquidationThreshold));
      } else {
        currentLtv = currentLtv.plus(valueToBigNumber(userReserveSummary.underlyingBalanceMarketReferenceCurrency).multipliedBy(userReserveSummary.userReserve.reserve.baseLTVasCollateral));
        currentLiquidationThreshold = currentLiquidationThreshold.plus(valueToBigNumber(userReserveSummary.underlyingBalanceMarketReferenceCurrency).multipliedBy(userReserveSummary.userReserve.reserve.reserveLiquidationThreshold));
      }
    }
  });
  if (currentLtv.gt(0)) {
    currentLtv = valueToZDBigNumber(currentLtv.div(totalCollateralMarketReferenceCurrency));
  }
  if (currentLiquidationThreshold.gt(0)) {
    currentLiquidationThreshold = valueToZDBigNumber(currentLiquidationThreshold.div(totalCollateralMarketReferenceCurrency));
  }
  return {
    totalLiquidityMarketReferenceCurrency,
    totalBorrowsMarketReferenceCurrency,
    totalCollateralMarketReferenceCurrency,
    currentLtv,
    currentLiquidationThreshold,
    isInIsolationMode,
    isolatedReserve
  };
}

// node_modules/@aave/math-utils/dist/esm/formatters/user/generate-raw-user-summary.js
function generateRawUserSummary({ userReserves, marketReferencePriceInUsd, marketReferenceCurrencyDecimals, userEmodeCategoryId }) {
  const { totalLiquidityMarketReferenceCurrency, totalBorrowsMarketReferenceCurrency, totalCollateralMarketReferenceCurrency, currentLtv, currentLiquidationThreshold, isInIsolationMode, isolatedReserve } = calculateUserReserveTotals({ userReserves, userEmodeCategoryId });
  const _availableBorrowsMarketReferenceCurrency = calculateAvailableBorrowsMarketReferenceCurrency({
    collateralBalanceMarketReferenceCurrency: totalCollateralMarketReferenceCurrency,
    borrowBalanceMarketReferenceCurrency: totalBorrowsMarketReferenceCurrency,
    currentLtv
  });
  const availableBorrowsMarketReferenceCurrency = isInIsolationMode && isolatedReserve ? bignumber_default.min(bignumber_default.max(0, normalizeBN(new bignumber_default(isolatedReserve.debtCeiling).minus(isolatedReserve.isolationModeTotalDebt), isolatedReserve.debtCeilingDecimals - marketReferenceCurrencyDecimals)), _availableBorrowsMarketReferenceCurrency) : _availableBorrowsMarketReferenceCurrency;
  return {
    isInIsolationMode,
    isolatedReserve,
    totalLiquidityUSD: normalizedToUsd(totalLiquidityMarketReferenceCurrency, marketReferencePriceInUsd, marketReferenceCurrencyDecimals),
    totalCollateralUSD: normalizedToUsd(totalCollateralMarketReferenceCurrency, marketReferencePriceInUsd, marketReferenceCurrencyDecimals),
    totalBorrowsUSD: normalizedToUsd(totalBorrowsMarketReferenceCurrency, marketReferencePriceInUsd, marketReferenceCurrencyDecimals),
    totalLiquidityMarketReferenceCurrency,
    totalCollateralMarketReferenceCurrency,
    totalBorrowsMarketReferenceCurrency,
    availableBorrowsMarketReferenceCurrency,
    availableBorrowsUSD: normalizedToUsd(availableBorrowsMarketReferenceCurrency, marketReferencePriceInUsd, marketReferenceCurrencyDecimals),
    currentLoanToValue: currentLtv,
    currentLiquidationThreshold,
    healthFactor: calculateHealthFactorFromBalances({
      collateralBalanceMarketReferenceCurrency: totalCollateralMarketReferenceCurrency,
      borrowBalanceMarketReferenceCurrency: totalBorrowsMarketReferenceCurrency,
      currentLiquidationThreshold
    })
  };
}

// node_modules/@aave/math-utils/dist/esm/formatters/user/generate-user-reserve-summary.js
function generateUserReserveSummary({ userReserve, marketReferencePriceInUsdNormalized, marketReferenceCurrencyDecimals, currentTimestamp }) {
  const poolReserve = userReserve.reserve;
  const { priceInMarketReferenceCurrency, decimals } = poolReserve;
  const underlyingBalance = getLinearBalance({
    balance: userReserve.scaledATokenBalance,
    index: poolReserve.liquidityIndex,
    rate: poolReserve.liquidityRate,
    lastUpdateTimestamp: poolReserve.lastUpdateTimestamp,
    currentTimestamp
  });
  const { marketReferenceCurrencyBalance: underlyingBalanceMarketReferenceCurrency, usdBalance: underlyingBalanceUSD } = getMarketReferenceCurrencyAndUsdBalance({
    balance: underlyingBalance,
    priceInMarketReferenceCurrency,
    marketReferenceCurrencyDecimals,
    decimals,
    marketReferencePriceInUsdNormalized
  });
  const variableBorrows = getCompoundedBalance({
    principalBalance: userReserve.scaledVariableDebt,
    reserveIndex: poolReserve.variableBorrowIndex,
    reserveRate: poolReserve.variableBorrowRate,
    lastUpdateTimestamp: poolReserve.lastUpdateTimestamp,
    currentTimestamp
  });
  const { marketReferenceCurrencyBalance: variableBorrowsMarketReferenceCurrency, usdBalance: variableBorrowsUSD } = getMarketReferenceCurrencyAndUsdBalance({
    balance: variableBorrows,
    priceInMarketReferenceCurrency,
    marketReferenceCurrencyDecimals,
    decimals,
    marketReferencePriceInUsdNormalized
  });
  const stableBorrows = getCompoundedStableBalance({
    principalBalance: userReserve.principalStableDebt,
    userStableRate: userReserve.stableBorrowRate,
    lastUpdateTimestamp: userReserve.stableBorrowLastUpdateTimestamp,
    currentTimestamp
  });
  const { marketReferenceCurrencyBalance: stableBorrowsMarketReferenceCurrency, usdBalance: stableBorrowsUSD } = getMarketReferenceCurrencyAndUsdBalance({
    balance: stableBorrows,
    priceInMarketReferenceCurrency,
    marketReferenceCurrencyDecimals,
    decimals,
    marketReferencePriceInUsdNormalized
  });
  return {
    userReserve,
    underlyingBalance,
    underlyingBalanceMarketReferenceCurrency,
    underlyingBalanceUSD,
    variableBorrows,
    variableBorrowsMarketReferenceCurrency,
    variableBorrowsUSD,
    stableBorrows,
    stableBorrowsMarketReferenceCurrency,
    stableBorrowsUSD,
    totalBorrows: variableBorrows.plus(stableBorrows),
    totalBorrowsMarketReferenceCurrency: variableBorrowsMarketReferenceCurrency.plus(stableBorrowsMarketReferenceCurrency),
    totalBorrowsUSD: variableBorrowsUSD.plus(stableBorrowsUSD)
  };
}

// node_modules/@aave/math-utils/dist/esm/formatters/user/index.js
function formatUserSummary({ currentTimestamp, marketReferencePriceInUsd, marketReferenceCurrencyDecimals, userReserves, formattedReserves, userEmodeCategoryId }) {
  const normalizedMarketRefPriceInUsd = normalize(marketReferencePriceInUsd, USD_DECIMALS);
  const combinedReserves = [];
  userReserves.forEach((userReserve) => {
    const reserve = formattedReserves.find((r) => r.underlyingAsset.toLowerCase() === userReserve.underlyingAsset.toLowerCase());
    if (reserve) {
      combinedReserves.push(Object.assign(Object.assign({}, userReserve), { reserve }));
    }
  });
  const computedUserReserves = combinedReserves.map((userReserve) => generateUserReserveSummary({
    userReserve,
    marketReferencePriceInUsdNormalized: normalizedMarketRefPriceInUsd,
    marketReferenceCurrencyDecimals,
    currentTimestamp
  }));
  const formattedUserReserves = computedUserReserves.map((computedUserReserve) => formatUserReserve({
    reserve: computedUserReserve,
    marketReferenceCurrencyDecimals
  }));
  const userData = generateRawUserSummary({
    userReserves: computedUserReserves,
    marketReferencePriceInUsd: normalizedMarketRefPriceInUsd,
    marketReferenceCurrencyDecimals,
    userEmodeCategoryId
  });
  return {
    userReservesData: formattedUserReserves,
    totalLiquidityMarketReferenceCurrency: normalize(userData.totalLiquidityMarketReferenceCurrency, marketReferenceCurrencyDecimals),
    totalLiquidityUSD: userData.totalLiquidityUSD.toString(),
    totalCollateralMarketReferenceCurrency: normalize(userData.totalCollateralMarketReferenceCurrency, marketReferenceCurrencyDecimals),
    totalCollateralUSD: userData.totalCollateralUSD.toString(),
    totalBorrowsMarketReferenceCurrency: normalize(userData.totalBorrowsMarketReferenceCurrency, marketReferenceCurrencyDecimals),
    totalBorrowsUSD: userData.totalBorrowsUSD.toString(),
    netWorthUSD: userData.totalLiquidityUSD.minus(userData.totalBorrowsUSD).toString(),
    availableBorrowsMarketReferenceCurrency: normalize(userData.availableBorrowsMarketReferenceCurrency, marketReferenceCurrencyDecimals),
    availableBorrowsUSD: userData.availableBorrowsUSD.toString(),
    currentLoanToValue: normalize(userData.currentLoanToValue, LTV_PRECISION),
    currentLiquidationThreshold: normalize(userData.currentLiquidationThreshold, LTV_PRECISION),
    healthFactor: userData.healthFactor.toFixed(),
    isInIsolationMode: userData.isInIsolationMode,
    isolatedReserve: userData.isolatedReserve
  };
}
function formatUserSummaryAndIncentives({ currentTimestamp, marketReferencePriceInUsd, marketReferenceCurrencyDecimals, userReserves, formattedReserves, userEmodeCategoryId, reserveIncentives, userIncentives }) {
  const formattedUserSummary = formatUserSummary({
    currentTimestamp,
    marketReferencePriceInUsd,
    marketReferenceCurrencyDecimals,
    userReserves,
    formattedReserves,
    userEmodeCategoryId
  });
  const calculatedUserIncentives = calculateAllUserIncentives({
    reserveIncentives,
    userIncentives,
    userReserves: formattedUserSummary.userReservesData,
    currentTimestamp
  });
  return Object.assign(Object.assign({}, formattedUserSummary), { calculatedUserIncentives });
}

// node_modules/@aave/math-utils/dist/esm/formatters/compounded-interest/calculate-compounded-interest.js
function calculateCompoundedRate({ rate, duration }) {
  return rayPow(valueToZDBigNumber(rate).dividedBy(SECONDS_PER_YEAR).plus(RAY), duration).minus(RAY);
}

// node_modules/@aave/math-utils/dist/esm/formatters/usd/native-to-usd.js
function nativeToUSD({ amount, currencyDecimals, priceInMarketReferenceCurrency, marketReferenceCurrencyDecimals, normalizedMarketReferencePriceInUsd }) {
  return valueToBigNumber(amount.toString()).multipliedBy(priceInMarketReferenceCurrency).multipliedBy(normalizedMarketReferencePriceInUsd).dividedBy(new bignumber_default(1).shiftedBy(currencyDecimals + marketReferenceCurrencyDecimals)).toString();
}

// node_modules/@aave/math-utils/dist/esm/formatters/reserve/calculate-reserve-debt.js
function calculateReserveDebt(reserveDebt, currentTimestamp) {
  const totalVariableDebt = getTotalVariableDebt(reserveDebt, currentTimestamp);
  const totalStableDebt = getTotalStableDebt(reserveDebt, currentTimestamp);
  const totalDebt = totalVariableDebt.plus(totalStableDebt);
  const totalLiquidity = totalDebt.plus(reserveDebt.availableLiquidity);
  return {
    totalVariableDebt,
    totalStableDebt,
    totalDebt,
    totalLiquidity
  };
}
var getTotalVariableDebt = function(reserveDebt, currentTimestamp) {
  return rayMul(rayMul(reserveDebt.totalScaledVariableDebt, reserveDebt.variableBorrowIndex), calculateCompoundedInterest({
    rate: reserveDebt.variableBorrowRate,
    currentTimestamp,
    lastUpdateTimestamp: reserveDebt.lastUpdateTimestamp
  }));
};
var getTotalStableDebt = function(reserveDebt, currentTimestamp) {
  return rayMul(reserveDebt.totalPrincipalStableDebt, calculateCompoundedInterest({
    rate: reserveDebt.averageStableRate,
    currentTimestamp,
    lastUpdateTimestamp: reserveDebt.stableDebtLastUpdateTimestamp
  }));
};

// node_modules/@aave/math-utils/dist/esm/formatters/reserve/index.js
var getComputedReserveFields = function({ reserve, currentTimestamp }) {
  const { totalDebt, totalStableDebt, totalVariableDebt, totalLiquidity } = calculateReserveDebt(reserve, currentTimestamp);
  const borrowUsageRatio = totalLiquidity.eq(0) ? "0" : valueToBigNumber(totalDebt).dividedBy(totalLiquidity).toFixed();
  const supplyUsageRatio = totalLiquidity.eq(0) ? "0" : valueToBigNumber(totalDebt).dividedBy(totalLiquidity.plus(reserve.unbacked)).toFixed();
  const reserveLiquidationBonus = normalize(valueToBigNumber(reserve.reserveLiquidationBonus).minus(10 ** LTV_PRECISION), LTV_PRECISION);
  const eModeLiquidationBonus = normalize(valueToBigNumber(reserve.eModeLiquidationBonus).minus(10 ** LTV_PRECISION), LTV_PRECISION);
  const availableLiquidity = reserve.borrowCap === "0" ? new bignumber_default(reserve.availableLiquidity) : bignumber_default.min(reserve.availableLiquidity, new bignumber_default(reserve.borrowCap).shiftedBy(reserve.decimals).minus(totalDebt.plus(1)));
  const supplyAPY = calculateCompoundedRate({
    rate: reserve.liquidityRate,
    duration: SECONDS_PER_YEAR
  });
  const variableBorrowAPY = calculateCompoundedRate({
    rate: reserve.variableBorrowRate,
    duration: SECONDS_PER_YEAR
  });
  const stableBorrowAPY = calculateCompoundedRate({
    rate: reserve.stableBorrowRate,
    duration: SECONDS_PER_YEAR
  });
  return {
    totalDebt,
    totalStableDebt,
    totalVariableDebt,
    totalLiquidity,
    borrowUsageRatio,
    supplyUsageRatio,
    formattedReserveLiquidationBonus: reserveLiquidationBonus,
    formattedEModeLiquidationBonus: eModeLiquidationBonus,
    formattedEModeLiquidationThreshold: reserve.eModeLiquidationThreshold.toString(),
    formattedEModeLtv: reserve.eModeLtv.toString(),
    supplyAPY,
    variableBorrowAPY,
    stableBorrowAPY,
    formattedAvailableLiquidity: availableLiquidity,
    unborrowedLiquidity: reserve.availableLiquidity
  };
};
var formatEnhancedReserve = function({ reserve }) {
  const normalizeWithReserve = (n) => normalize(n, reserve.decimals);
  const isIsolated = reserve.debtCeiling !== "0";
  const availableDebtCeilingUSD = isIsolated ? normalize(valueToBigNumber(reserve.debtCeiling).minus(reserve.isolationModeTotalDebt), reserve.debtCeilingDecimals) : "0";
  return Object.assign(Object.assign({}, reserve), {
    totalVariableDebt: normalizeWithReserve(reserve.totalVariableDebt),
    totalStableDebt: normalizeWithReserve(reserve.totalStableDebt),
    totalLiquidity: normalizeWithReserve(reserve.totalLiquidity),
    formattedAvailableLiquidity: normalizeWithReserve(reserve.availableLiquidity),
    unborrowedLiquidity: normalizeWithReserve(reserve.unborrowedLiquidity),
    borrowUsageRatio: reserve.borrowUsageRatio,
    supplyUsageRatio: reserve.supplyUsageRatio,
    totalDebt: normalizeWithReserve(reserve.totalDebt),
    formattedBaseLTVasCollateral: normalize(reserve.baseLTVasCollateral, LTV_PRECISION),
    formattedEModeLtv: normalize(reserve.eModeLtv, LTV_PRECISION),
    reserveFactor: normalize(reserve.reserveFactor, LTV_PRECISION),
    supplyAPY: normalize(reserve.supplyAPY, RAY_DECIMALS),
    supplyAPR: normalize(reserve.liquidityRate, RAY_DECIMALS),
    variableBorrowAPY: normalize(reserve.variableBorrowAPY, RAY_DECIMALS),
    variableBorrowAPR: normalize(reserve.variableBorrowRate, RAY_DECIMALS),
    stableBorrowAPY: normalize(reserve.stableBorrowAPY, RAY_DECIMALS),
    stableBorrowAPR: normalize(reserve.stableBorrowRate, RAY_DECIMALS),
    formattedReserveLiquidationThreshold: normalize(reserve.reserveLiquidationThreshold, 4),
    formattedEModeLiquidationThreshold: normalize(reserve.eModeLiquidationThreshold, 4),
    formattedReserveLiquidationBonus: normalize(valueToBigNumber(reserve.reserveLiquidationBonus).minus(10 ** LTV_PRECISION), 4),
    formattedEModeLiquidationBonus: normalize(valueToBigNumber(reserve.eModeLiquidationBonus).minus(10 ** LTV_PRECISION), 4),
    totalScaledVariableDebt: normalizeWithReserve(reserve.totalScaledVariableDebt),
    totalPrincipalStableDebt: normalizeWithReserve(reserve.totalPrincipalStableDebt),
    debtCeilingUSD: isIsolated ? normalize(reserve.debtCeiling, reserve.debtCeilingDecimals) : "0",
    isolationModeTotalDebtUSD: isIsolated ? normalize(reserve.isolationModeTotalDebt, reserve.debtCeilingDecimals) : "0",
    availableDebtCeilingUSD,
    isIsolated
  });
};
function formatReserveUSD({ reserve, currentTimestamp, marketReferencePriceInUsd, marketReferenceCurrencyDecimals }) {
  const normalizedMarketReferencePriceInUsd = normalizeBN(marketReferencePriceInUsd, USD_DECIMALS);
  const computedFields = getComputedReserveFields({
    reserve,
    currentTimestamp
  });
  const formattedReserve = formatEnhancedReserve({
    reserve: Object.assign(Object.assign({}, reserve), computedFields)
  });
  return Object.assign(Object.assign({}, formattedReserve), {
    totalLiquidityUSD: nativeToUSD({
      amount: computedFields.totalLiquidity,
      currencyDecimals: reserve.decimals,
      marketReferenceCurrencyDecimals,
      priceInMarketReferenceCurrency: reserve.priceInMarketReferenceCurrency,
      normalizedMarketReferencePriceInUsd
    }),
    availableLiquidityUSD: nativeToUSD({
      amount: computedFields.formattedAvailableLiquidity,
      currencyDecimals: reserve.decimals,
      marketReferenceCurrencyDecimals,
      priceInMarketReferenceCurrency: reserve.priceInMarketReferenceCurrency,
      normalizedMarketReferencePriceInUsd
    }),
    totalDebtUSD: nativeToUSD({
      amount: computedFields.totalDebt,
      currencyDecimals: reserve.decimals,
      marketReferenceCurrencyDecimals,
      priceInMarketReferenceCurrency: reserve.priceInMarketReferenceCurrency,
      normalizedMarketReferencePriceInUsd
    }),
    totalVariableDebtUSD: nativeToUSD({
      amount: computedFields.totalVariableDebt,
      currencyDecimals: reserve.decimals,
      marketReferenceCurrencyDecimals,
      priceInMarketReferenceCurrency: reserve.priceInMarketReferenceCurrency,
      normalizedMarketReferencePriceInUsd
    }),
    totalStableDebtUSD: nativeToUSD({
      amount: computedFields.totalStableDebt,
      currencyDecimals: reserve.decimals,
      marketReferenceCurrencyDecimals,
      priceInMarketReferenceCurrency: reserve.priceInMarketReferenceCurrency,
      normalizedMarketReferencePriceInUsd
    }),
    formattedPriceInMarketReferenceCurrency: normalize(reserve.priceInMarketReferenceCurrency, marketReferenceCurrencyDecimals),
    priceInMarketReferenceCurrency: reserve.priceInMarketReferenceCurrency,
    priceInUSD: nativeToUSD({
      amount: new bignumber_default(1).shiftedBy(reserve.decimals),
      currencyDecimals: reserve.decimals,
      marketReferenceCurrencyDecimals,
      priceInMarketReferenceCurrency: reserve.priceInMarketReferenceCurrency,
      normalizedMarketReferencePriceInUsd
    }),
    borrowCapUSD: normalizedToUsd(new bignumber_default(reserve.borrowCap), reserve.priceInMarketReferenceCurrency, marketReferenceCurrencyDecimals).toString(),
    supplyCapUSD: normalizedToUsd(new bignumber_default(reserve.supplyCap), reserve.priceInMarketReferenceCurrency, marketReferenceCurrencyDecimals).toString(),
    unbackedUSD: normalizedToUsd(new bignumber_default(reserve.unbacked), reserve.priceInMarketReferenceCurrency, marketReferenceCurrencyDecimals).toString()
  });
}
function formatReserves({ reserves, currentTimestamp, marketReferencePriceInUsd, marketReferenceCurrencyDecimals }) {
  return reserves.map((reserve) => {
    const formattedReserve = formatReserveUSD({
      reserve,
      currentTimestamp,
      marketReferencePriceInUsd,
      marketReferenceCurrencyDecimals
    });
    return Object.assign(Object.assign({}, reserve), formattedReserve);
  });
}
function formatReservesAndIncentives({ reserves, currentTimestamp, marketReferencePriceInUsd, marketReferenceCurrencyDecimals, reserveIncentives }) {
  const formattedReserves = formatReserves({
    reserves,
    currentTimestamp,
    marketReferenceCurrencyDecimals,
    marketReferencePriceInUsd
  });
  return formattedReserves.map((reserve) => {
    const reserveIncentive = reserveIncentives.find((reserveIncentive2) => reserveIncentive2.underlyingAsset === reserve.underlyingAsset);
    if (!reserveIncentive)
      return reserve;
    const incentive2 = calculateReserveIncentives({
      reserves: formattedReserves,
      reserveIncentiveData: reserveIncentive,
      totalLiquidity: normalize(reserve.totalLiquidity, -reserve.decimals),
      totalVariableDebt: normalize(reserve.totalVariableDebt, -reserve.decimals),
      totalStableDebt: normalize(reserve.totalStableDebt, -reserve.decimals),
      priceInMarketReferenceCurrency: reserve.formattedPriceInMarketReferenceCurrency,
      decimals: reserve.decimals,
      marketReferenceCurrencyDecimals
    });
    return Object.assign(Object.assign({}, reserve), incentive2);
  });
}

// src/scripts/helpers/aave-max-amount-borrow.ts
var roundToTokenDecimals = function(inputValue, tokenDecimals) {
  const [whole, decimals] = inputValue.split(".");
  if (!decimals || decimals.length <= tokenDecimals) {
    return inputValue;
  }
  const adjustedDecimals = decimals.slice(0, tokenDecimals);
  return whole + "." + adjustedDecimals;
};
function getMaxGhoMintAmount(user, poolReserve) {
  const userAvailableBorrows = valueToBigNumber(user?.availableBorrowsMarketReferenceCurrency || 0);
  const availableBorrowCap = poolReserve.borrowCap === "0" ? valueToBigNumber(exports_lib.MaxUint256.toString()) : valueToBigNumber(Number(poolReserve.borrowCap)).minus(valueToBigNumber(poolReserve.totalDebt));
  const maxAmountUserCanMint = bignumber_default.max(bignumber_default.min(userAvailableBorrows, availableBorrowCap), 0);
  const shouldAddMargin = user.totalBorrowsMarketReferenceCurrency !== "0" || poolReserve.borrowCapUSD && poolReserve.totalDebt !== "0" && maxAmountUserCanMint.gte(availableBorrowCap) || user.isInIsolationMode && user.isolatedReserve?.isolationModeTotalDebt !== "0" && valueToBigNumber(user.isolatedReserve?.debtCeiling || "0").minus(user.isolatedReserve?.isolationModeTotalDebt || "0").shiftedBy(-(user.isolatedReserve?.debtCeilingDecimals || 0)).multipliedBy("0.99").lt(user.availableBorrowsUSD);
  const amountWithMargin = shouldAddMargin ? maxAmountUserCanMint.multipliedBy("0.99") : maxAmountUserCanMint;
  return roundToTokenDecimals(amountWithMargin.toString(10), 18);
}
// src/scripts/abi/Pool.ts
var POOL_ABI = [
  {
    inputs: [{ internalType: "contract IPoolAddressesProvider", name: "provider", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "reserve", type: "address" },
      { indexed: true, internalType: "address", name: "backer", type: "address" },
      { indexed: false, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "fee", type: "uint256" }
    ],
    name: "BackUnbacked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "reserve", type: "address" },
      { indexed: false, internalType: "address", name: "user", type: "address" },
      { indexed: true, internalType: "address", name: "onBehalfOf", type: "address" },
      { indexed: false, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: false, internalType: "enum DataTypes.InterestRateMode", name: "interestRateMode", type: "uint8" },
      { indexed: false, internalType: "uint256", name: "borrowRate", type: "uint256" },
      { indexed: true, internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "Borrow",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "target", type: "address" },
      { indexed: false, internalType: "address", name: "initiator", type: "address" },
      { indexed: true, internalType: "address", name: "asset", type: "address" },
      { indexed: false, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: false, internalType: "enum DataTypes.InterestRateMode", name: "interestRateMode", type: "uint8" },
      { indexed: false, internalType: "uint256", name: "premium", type: "uint256" },
      { indexed: true, internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "FlashLoan",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "asset", type: "address" },
      { indexed: false, internalType: "uint256", name: "totalDebt", type: "uint256" }
    ],
    name: "IsolationModeTotalDebtUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "collateralAsset", type: "address" },
      { indexed: true, internalType: "address", name: "debtAsset", type: "address" },
      { indexed: true, internalType: "address", name: "user", type: "address" },
      { indexed: false, internalType: "uint256", name: "debtToCover", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "liquidatedCollateralAmount", type: "uint256" },
      { indexed: false, internalType: "address", name: "liquidator", type: "address" },
      { indexed: false, internalType: "bool", name: "receiveAToken", type: "bool" }
    ],
    name: "LiquidationCall",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "reserve", type: "address" },
      { indexed: false, internalType: "address", name: "user", type: "address" },
      { indexed: true, internalType: "address", name: "onBehalfOf", type: "address" },
      { indexed: false, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: true, internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "MintUnbacked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "reserve", type: "address" },
      { indexed: false, internalType: "uint256", name: "amountMinted", type: "uint256" }
    ],
    name: "MintedToTreasury",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "reserve", type: "address" },
      { indexed: true, internalType: "address", name: "user", type: "address" }
    ],
    name: "RebalanceStableBorrowRate",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "reserve", type: "address" },
      { indexed: true, internalType: "address", name: "user", type: "address" },
      { indexed: true, internalType: "address", name: "repayer", type: "address" },
      { indexed: false, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: false, internalType: "bool", name: "useATokens", type: "bool" }
    ],
    name: "Repay",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "reserve", type: "address" },
      { indexed: false, internalType: "uint256", name: "liquidityRate", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "stableBorrowRate", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "variableBorrowRate", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "liquidityIndex", type: "uint256" },
      { indexed: false, internalType: "uint256", name: "variableBorrowIndex", type: "uint256" }
    ],
    name: "ReserveDataUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "reserve", type: "address" },
      { indexed: true, internalType: "address", name: "user", type: "address" }
    ],
    name: "ReserveUsedAsCollateralDisabled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "reserve", type: "address" },
      { indexed: true, internalType: "address", name: "user", type: "address" }
    ],
    name: "ReserveUsedAsCollateralEnabled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "reserve", type: "address" },
      { indexed: false, internalType: "address", name: "user", type: "address" },
      { indexed: true, internalType: "address", name: "onBehalfOf", type: "address" },
      { indexed: false, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: true, internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "Supply",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "reserve", type: "address" },
      { indexed: true, internalType: "address", name: "user", type: "address" },
      { indexed: false, internalType: "enum DataTypes.InterestRateMode", name: "interestRateMode", type: "uint8" }
    ],
    name: "SwapBorrowRateMode",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "user", type: "address" },
      { indexed: false, internalType: "uint8", name: "categoryId", type: "uint8" }
    ],
    name: "UserEModeSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "reserve", type: "address" },
      { indexed: true, internalType: "address", name: "user", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "Withdraw",
    type: "event"
  },
  {
    inputs: [],
    name: "ADDRESSES_PROVIDER",
    outputs: [{ internalType: "contract IPoolAddressesProvider", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "BRIDGE_PROTOCOL_FEE",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FLASHLOAN_PREMIUM_TOTAL",
    outputs: [{ internalType: "uint128", name: "", type: "uint128" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "FLASHLOAN_PREMIUM_TO_PROTOCOL",
    outputs: [{ internalType: "uint128", name: "", type: "uint128" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MAX_NUMBER_RESERVES",
    outputs: [{ internalType: "uint16", name: "", type: "uint16" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MAX_STABLE_RATE_BORROW_SIZE_PERCENT",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "POOL_REVISION",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "fee", type: "uint256" }
    ],
    name: "backUnbacked",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "interestRateMode", type: "uint256" },
      { internalType: "uint16", name: "referralCode", type: "uint16" },
      { internalType: "address", name: "onBehalfOf", type: "address" }
    ],
    name: "borrow",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint8", name: "id", type: "uint8" },
      {
        components: [
          { internalType: "uint16", name: "ltv", type: "uint16" },
          { internalType: "uint16", name: "liquidationThreshold", type: "uint16" },
          { internalType: "uint16", name: "liquidationBonus", type: "uint16" },
          { internalType: "address", name: "priceSource", type: "address" },
          { internalType: "string", name: "label", type: "string" }
        ],
        internalType: "struct DataTypes.EModeCategory",
        name: "category",
        type: "tuple"
      }
    ],
    name: "configureEModeCategory",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "onBehalfOf", type: "address" },
      { internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "dropReserve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "balanceFromBefore", type: "uint256" },
      { internalType: "uint256", name: "balanceToBefore", type: "uint256" }
    ],
    name: "finalizeTransfer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "receiverAddress", type: "address" },
      { internalType: "address[]", name: "assets", type: "address[]" },
      { internalType: "uint256[]", name: "amounts", type: "uint256[]" },
      { internalType: "uint256[]", name: "interestRateModes", type: "uint256[]" },
      { internalType: "address", name: "onBehalfOf", type: "address" },
      { internalType: "bytes", name: "params", type: "bytes" },
      { internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "flashLoan",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "receiverAddress", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "bytes", name: "params", type: "bytes" },
      { internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "flashLoanSimple",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "getConfiguration",
    outputs: [
      {
        components: [{ internalType: "uint256", name: "data", type: "uint256" }],
        internalType: "struct DataTypes.ReserveConfigurationMap",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint8", name: "id", type: "uint8" }],
    name: "getEModeCategoryData",
    outputs: [
      {
        components: [
          { internalType: "uint16", name: "ltv", type: "uint16" },
          { internalType: "uint16", name: "liquidationThreshold", type: "uint16" },
          { internalType: "uint16", name: "liquidationBonus", type: "uint16" },
          { internalType: "address", name: "priceSource", type: "address" },
          { internalType: "string", name: "label", type: "string" }
        ],
        internalType: "struct DataTypes.EModeCategory",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint16", name: "id", type: "uint16" }],
    name: "getReserveAddressById",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "getReserveData",
    outputs: [
      {
        components: [
          {
            components: [{ internalType: "uint256", name: "data", type: "uint256" }],
            internalType: "struct DataTypes.ReserveConfigurationMap",
            name: "configuration",
            type: "tuple"
          },
          { internalType: "uint128", name: "liquidityIndex", type: "uint128" },
          { internalType: "uint128", name: "currentLiquidityRate", type: "uint128" },
          { internalType: "uint128", name: "variableBorrowIndex", type: "uint128" },
          { internalType: "uint128", name: "currentVariableBorrowRate", type: "uint128" },
          { internalType: "uint128", name: "currentStableBorrowRate", type: "uint128" },
          { internalType: "uint40", name: "lastUpdateTimestamp", type: "uint40" },
          { internalType: "uint16", name: "id", type: "uint16" },
          { internalType: "address", name: "aTokenAddress", type: "address" },
          { internalType: "address", name: "stableDebtTokenAddress", type: "address" },
          { internalType: "address", name: "variableDebtTokenAddress", type: "address" },
          { internalType: "address", name: "interestRateStrategyAddress", type: "address" },
          { internalType: "uint128", name: "accruedToTreasury", type: "uint128" },
          { internalType: "uint128", name: "unbacked", type: "uint128" },
          { internalType: "uint128", name: "isolationModeTotalDebt", type: "uint128" }
        ],
        internalType: "struct DataTypes.ReserveData",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "getReserveNormalizedIncome",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "getReserveNormalizedVariableDebt",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getReservesList",
    outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "user", type: "address" }],
    name: "getUserAccountData",
    outputs: [
      { internalType: "uint256", name: "totalCollateralBase", type: "uint256" },
      { internalType: "uint256", name: "totalDebtBase", type: "uint256" },
      { internalType: "uint256", name: "availableBorrowsBase", type: "uint256" },
      { internalType: "uint256", name: "currentLiquidationThreshold", type: "uint256" },
      { internalType: "uint256", name: "ltv", type: "uint256" },
      { internalType: "uint256", name: "healthFactor", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "user", type: "address" }],
    name: "getUserConfiguration",
    outputs: [
      {
        components: [{ internalType: "uint256", name: "data", type: "uint256" }],
        internalType: "struct DataTypes.UserConfigurationMap",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "user", type: "address" }],
    name: "getUserEMode",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "address", name: "aTokenAddress", type: "address" },
      { internalType: "address", name: "stableDebtAddress", type: "address" },
      { internalType: "address", name: "variableDebtAddress", type: "address" },
      { internalType: "address", name: "interestRateStrategyAddress", type: "address" }
    ],
    name: "initReserve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "contract IPoolAddressesProvider", name: "provider", type: "address" }],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "collateralAsset", type: "address" },
      { internalType: "address", name: "debtAsset", type: "address" },
      { internalType: "address", name: "user", type: "address" },
      { internalType: "uint256", name: "debtToCover", type: "uint256" },
      { internalType: "bool", name: "receiveAToken", type: "bool" }
    ],
    name: "liquidationCall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address[]", name: "assets", type: "address[]" }],
    name: "mintToTreasury",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "onBehalfOf", type: "address" },
      { internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "mintUnbacked",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "address", name: "user", type: "address" }
    ],
    name: "rebalanceStableBorrowRate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "interestRateMode", type: "uint256" },
      { internalType: "address", name: "onBehalfOf", type: "address" }
    ],
    name: "repay",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "interestRateMode", type: "uint256" }
    ],
    name: "repayWithATokens",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "interestRateMode", type: "uint256" },
      { internalType: "address", name: "onBehalfOf", type: "address" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "uint8", name: "permitV", type: "uint8" },
      { internalType: "bytes32", name: "permitR", type: "bytes32" },
      { internalType: "bytes32", name: "permitS", type: "bytes32" }
    ],
    name: "repayWithPermit",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "rescueTokens",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "asset", type: "address" }],
    name: "resetIsolationModeTotalDebt",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      {
        components: [{ internalType: "uint256", name: "data", type: "uint256" }],
        internalType: "struct DataTypes.ReserveConfigurationMap",
        name: "configuration",
        type: "tuple"
      }
    ],
    name: "setConfiguration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "address", name: "rateStrategyAddress", type: "address" }
    ],
    name: "setReserveInterestRateStrategyAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint8", name: "categoryId", type: "uint8" }],
    name: "setUserEMode",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "bool", name: "useAsCollateral", type: "bool" }
    ],
    name: "setUserUseReserveAsCollateral",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "onBehalfOf", type: "address" },
      { internalType: "uint16", name: "referralCode", type: "uint16" }
    ],
    name: "supply",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "onBehalfOf", type: "address" },
      { internalType: "uint16", name: "referralCode", type: "uint16" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "uint8", name: "permitV", type: "uint8" },
      { internalType: "bytes32", name: "permitR", type: "bytes32" },
      { internalType: "bytes32", name: "permitS", type: "bytes32" }
    ],
    name: "supplyWithPermit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "interestRateMode", type: "uint256" }
    ],
    name: "swapBorrowRateMode",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "protocolFee", type: "uint256" }],
    name: "updateBridgeProtocolFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint128", name: "flashLoanPremiumTotal", type: "uint128" },
      { internalType: "uint128", name: "flashLoanPremiumToProtocol", type: "uint128" }
    ],
    name: "updateFlashloanPremiums",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "to", type: "address" }
    ],
    name: "withdraw",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/scripts/alpinejs/stores/current-user.ts
function registerStoreCurrentUser(storeName) {
  window.Alpine.store(storeName, {
    getWalletBalanceProvider,
    status: window.ethereum.isConnected() ? "connected" : "disconnected",
    account: undefined,
    assets: {
      fetchStatus: "idle",
      balances: {}
    },
    aavePortfolio: {
      fetchStatus: "idle",
      summary: undefined
    },
    async init() {
      await this.checkAccount();
      window.ethereum.on("accountsChanged", async (data) => {
        if (data[0]) {
          this.account = data[0];
          this.watchContractsEvents();
          await Promise.allSettled([await this.fetchAssets(), await this.getAavePortfolio()]);
        }
      });
      window.ethereum.on("chainChanged", (chainId) => {
        console.log("chain changed", chainId);
      });
      window.ethereum.on("connect", (connectInfo) => {
        console.log("connectInfo", connectInfo);
      });
      window.ethereum.on("disconnect", (data) => {
        console.log("disconnect", data);
      });
    },
    async watchContractsEvents() {
      for (const [key, asset] of Object.entries(exports_AaveV3Sepolia.ASSETS)) {
        const erc20Contract = new Contract(asset.UNDERLYING, IERC20_ABI, provider);
        erc20Contract.on("Transfer", async (from, to, value, event) => {
          if ([from.toLowerCase(), to.toLowerCase()].includes(this.account)) {
            await this.fetchSingleAsset(asset.UNDERLYING);
            window.dispatchEvent(new CustomEvent("ERC20_TRANSFER", {
              detail: {
                token: {
                  address: asset.UNDERLYING,
                  symbol: key,
                  amount: normalize(value.toString(), asset.decimals ?? 18)
                },
                fromAddress: from.toLowerCase(),
                toAddress: to.toLowerCase()
              }
            }));
          }
        });
      }
      const poolContract = new Contract(exports_AaveV3Sepolia.POOL, POOL_ABI, provider);
      poolContract.on("Supply", async (reserve, user, onBehalfOf, amount, referralCode) => {
        if (user.toLowerCase() === this.account.toLowerCase()) {
          const tokenSymbol = Object.keys(exports_AaveV3Sepolia.ASSETS).filter((asset) => exports_AaveV3Sepolia.ASSETS[asset].UNDERLYING.toLowerCase() === reserve.toLowerCase())?.[0];
          await Promise.allSettled([await this.fetchSingleAsset(reserve), await this.getAavePortfolio()]);
          window.dispatchEvent(new CustomEvent("USER_SUPPLY_POOL", {
            detail: {
              userAddress: user,
              onBehalfOfAddress: onBehalfOf,
              referralCode,
              token: {
                address: exports_AaveV3Sepolia.ASSETS[tokenSymbol].UNDERLYING,
                symbol: tokenSymbol,
                amount: normalize(amount.toString(), exports_AaveV3Sepolia.ASSETS[tokenSymbol].decimals ?? 18)
              }
            }
          }));
        }
      });
      poolContract.on("Borrow", async (reserve, user, onBehalfOf, amount, interestRateMode, borrowRate, referralCode) => {
        if (user.toLowerCase() === this.account.toLowerCase() || onBehalfOf.toLowerCase() === this.account.toLowerCase()) {
          const tokenSymbol = Object.keys(exports_AaveV3Sepolia.ASSETS).filter((asset) => exports_AaveV3Sepolia.ASSETS[asset].UNDERLYING.toLowerCase() === reserve.toLowerCase())?.[0];
          await Promise.allSettled([await this.fetchSingleAsset(reserve), await this.getAavePortfolio()]);
          window.dispatchEvent(new CustomEvent("USER_BORROW_FROM_RESERVE", {
            detail: {
              userAddress: user.toLowerCase(),
              onBehalfOfAddress: onBehalfOf.toLowerCase(),
              interestRateMode: interestRateMode === 1 ? InterestRate.Stable : InterestRate.Variable,
              borrowRate,
              referralCode,
              token: {
                address: exports_AaveV3Sepolia.ASSETS[tokenSymbol].UNDERLYING,
                symbol: tokenSymbol,
                amount: normalize(amount.toString(), exports_AaveV3Sepolia.ASSETS[tokenSymbol].decimals ?? 18)
              }
            }
          }));
        }
      });
      poolContract.on("Repay", async (reserve, user, repayer, amount, useATokens) => {
        if (user.toLowerCase() === this.account.toLowerCase() || repayer?.toLowerCase() === this.account.toLowerCase()) {
          const tokenSymbol = Object.keys(exports_AaveV3Sepolia.ASSETS).filter((asset) => exports_AaveV3Sepolia.ASSETS[asset].UNDERLYING.toLowerCase() === reserve.toLowerCase())?.[0];
          await Promise.allSettled([await this.fetchSingleAsset(reserve), await this.getAavePortfolio()]);
          window.dispatchEvent(new CustomEvent("USER_REPAY_DEBT", {
            detail: {
              userAddress: user.toLowerCase(),
              repayerAddress: repayer.toLowerCase(),
              useATokens,
              token: {
                address: exports_AaveV3Sepolia.ASSETS[tokenSymbol].UNDERLYING,
                symbol: tokenSymbol,
                amount: normalize(amount.toString(), exports_AaveV3Sepolia.ASSETS[tokenSymbol].decimals ?? 18)
              }
            }
          }));
        }
      }), poolContract.on("Withdraw", async (reserve, user, to, amount) => {
        if (user.toLowerCase() === this.account.toLowerCase()) {
          const tokenSymbol = Object.keys(exports_AaveV3Sepolia.ASSETS).filter((asset) => exports_AaveV3Sepolia.ASSETS[asset].UNDERLYING.toLowerCase() === reserve.toLowerCase())?.[0];
          await Promise.allSettled([await this.fetchSingleAsset(reserve), await this.getAavePortfolio()]);
          window.dispatchEvent(new CustomEvent("USER_WITHDRAW_ASSET", {
            detail: {
              userAddress: user.toLowerCase(),
              withdrawTo: to,
              token: {
                address: exports_AaveV3Sepolia.ASSETS[tokenSymbol].UNDERLYING,
                symbol: tokenSymbol,
                amount: normalize(amount.toString(), exports_AaveV3Sepolia.ASSETS[tokenSymbol].decimals ?? 18)
              }
            }
          }));
        }
      });
    },
    async fetchAssets() {
      const previousStatus = this.assets.fetchStatus;
      this.assets.fetchStatus = previousStatus === "success" ? "refreshing" : "pending";
      const assetsContractsData = Object.keys(exports_AaveV3Sepolia.ASSETS).map((symbol) => {
        return {
          symbol,
          ...exports_AaveV3Sepolia.ASSETS[symbol]
        };
      });
      const balanceProvider = this.getWalletBalanceProvider();
      const balances = await balanceProvider.batchBalanceOf([this.account], [...assetsContractsData.map((asset) => asset.UNDERLYING)]);
      assetsContractsData.map((asset, i) => {
        this.assets.balances[asset.symbol] = {
          fetchStatus: "success",
          value: balances[i],
          formatted: normalize(balances[i].toString(), asset.decimals ?? 18)
        };
      });
      this.assets.fetchStatus = "success";
    },
    async fetchSingleAsset(tokenAddress) {
      const assetSymbol = Object.keys(exports_AaveV3Sepolia.ASSETS).find((symbol) => exports_AaveV3Sepolia.ASSETS[symbol].UNDERLYING === tokenAddress);
      const asset = exports_AaveV3Sepolia.ASSETS[assetSymbol];
      this.assets.balances[assetSymbol] = {
        ...this.assets.balances[`${assetSymbol}`],
        fetchStatus: "refreshing"
      };
      const balanceProvider = this.getWalletBalanceProvider();
      const balance = await balanceProvider.balanceOf(this.account, tokenAddress);
      this.assets.balances[assetSymbol] = {
        fetchStatus: "success",
        value: balance,
        formatted: normalize(balance.toString(), asset.decimals ?? 18)
      };
    },
    async getAavePortfolio() {
      const previousStatus = this.aavePortfolio.fetchStatus;
      this.aavePortfolio.fetchStatus = previousStatus === "success" ? "refreshing" : "pending";
      const [reservesData, userData] = await Promise.allSettled([
        await fetchMarketsData(),
        await fetchUserData(`${this.account}`)
      ]);
      const { reserves, reserveIncentives } = reservesData.value;
      const { userReserves, userIncentives } = userData.value;
      const currentTimestamp = Math.floor(Date.now() / 1000);
      const reservesArray = reserves.reservesData;
      const baseCurrencyData = reserves.baseCurrencyData;
      const userReservesArray = userReserves.userReserves;
      const formattedPoolReserves = formatReserves({
        reserves: reservesArray,
        currentTimestamp,
        marketReferenceCurrencyDecimals: baseCurrencyData.marketReferenceCurrencyDecimals,
        marketReferencePriceInUsd: baseCurrencyData.marketReferenceCurrencyPriceInUsd
      });
      const summary = formatUserSummaryAndIncentives({
        currentTimestamp,
        marketReferencePriceInUsd: baseCurrencyData.marketReferenceCurrencyPriceInUsd,
        marketReferenceCurrencyDecimals: baseCurrencyData.marketReferenceCurrencyDecimals,
        userReserves: userReservesArray,
        formattedReserves: formattedPoolReserves,
        userEmodeCategoryId: userReserves.userEmodeCategoryId,
        reserveIncentives,
        userIncentives
      });
      const maxBorrowAmount = valueToBigNumber(summary?.totalBorrowsMarketReferenceCurrency || "0").plus(summary?.availableBorrowsMarketReferenceCurrency || "0");
      const collateralUsage = maxBorrowAmount.eq(0) ? "0" : valueToBigNumber(summary?.totalBorrowsMarketReferenceCurrency || "0").div(maxBorrowAmount).toFixed();
      const extendedSummary = summary;
      summary.userReservesData.map((asset, i) => {
        let maxAmountToBorrow = getMaxGhoMintAmount(summary, {
          borrowCap: asset.reserve.borrowCap,
          borrowCapUSD: asset.reserve.borrowCapUSD,
          availableLiquidityUSD: asset.reserve.availableLiquidityUSD,
          totalDebt: asset.reserve.totalDebt,
          isFrozen: false,
          decimals: asset.reserve.decimals,
          formattedAvailableLiquidity: asset.reserve.availableLiquidity,
          formattedPriceInMarketReferenceCurrency: asset.reserve.priceInMarketReferenceCurrency
        });
        extendedSummary.userReservesData[i].reserve.maxGhoMintAmount = maxAmountToBorrow.toString();
        extendedSummary.userReservesData[i].reserve.maxGhoMintAmountUSD = maxAmountToBorrow.toString();
        extendedSummary.userReservesData[i].reserve.borrowRateMode = parseFloat(extendedSummary.userReservesData[i].variableBorrows) === 0 ? InterestRate.Stable : InterestRate.Variable;
      });
      this.aavePortfolio.summary = {
        ...extendedSummary,
        collateralUsage
      };
      summary.availableBorrowsMarketReferenceCurrency;
      this.aavePortfolio.fetchStatus = "success";
    },
    async checkAccount() {
      this.status = "reconnecting";
      const [account] = await window.ethereum.request({ method: "eth_accounts" });
      if (account) {
        this.account = account;
        this.status = "connected";
        this.watchContractsEvents();
        await Promise.allSettled([await this.fetchAssets(), await this.getAavePortfolio()]);
      } else {
        this.status = "disconnected";
      }
    },
    async connect() {
      this.status = "connecting";
      const [account] = await window.ethereum.request({ method: "eth_requestAccounts" });
      if (account) {
        this.account = account;
        this.status = "connected";
      } else {
        this.status = "disconnected";
      }
    }
  });
}
// src/scripts/alpinejs/stores/aave-markets.ts
function registerStoreAaveMarkets(storeName) {
  window.Alpine.store(storeName, {
    fetchStatus: "idle",
    markets: undefined,
    async init() {
      await fetchMarketsData();
    },
    async watchContractsEvents() {
      const poolContract = new Contract(exports_AaveV3Sepolia.POOL, POOL_ABI, provider);
      poolContract.on("Supply", async () => {
        await fetchMarketsData();
      });
      poolContract.on("Borrow", async () => {
        await fetchMarketsData();
      });
      poolContract.on("Withdraw", async () => {
        await fetchMarketsData();
      });
      poolContract.on("Repay", async () => {
        await fetchMarketsData();
      });
    },
    async fetchMarketsData() {
      const previousStatus = this.fetchStatus;
      this.fetchStatus = previousStatus === "success" ? "refreshing" : "pending";
      const reservesData = await fetchMarketsData();
      const { reserves, reserveIncentives } = reservesData;
      const currentTimestamp = Math.floor(Date.now() / 1000);
      const reservesArray = reserves.reservesData;
      const baseCurrencyData = reserves.baseCurrencyData;
      const formattedPoolReserves = formatReservesAndIncentives({
        reserves: reservesArray,
        currentTimestamp,
        marketReferenceCurrencyDecimals: baseCurrencyData.marketReferenceCurrencyDecimals,
        marketReferencePriceInUsd: baseCurrencyData.marketReferenceCurrencyPriceInUsd,
        reserveIncentives
      });
      this.markets = formattedPoolReserves;
      this.fetchStatus = "success";
    }
  });
}
// src/scripts/alpinejs/data-contexts/wallet-aave-data-portfolio.ts
function registerDataWalletAavePortfolio(sliceName) {
  window.Alpine.data(sliceName, () => ({
    fetchStatus: "idle",
    summary: undefined,
    address: undefined,
    async getSummary() {
      this.fetchStatus = "pending";
      const [reservesData, userData] = await Promise.allSettled([
        await fetchMarketsData(),
        await fetchUserData(`${this.address}`)
      ]);
      const { reserves, reserveIncentives } = reservesData.value;
      const { userReserves, userIncentives } = userData.value;
      const currentTimestamp = Math.floor(Date.now() / 1000);
      const reservesArray = reserves.reservesData;
      const baseCurrencyData = reserves.baseCurrencyData;
      const userReservesArray = userReserves.userReserves;
      const formattedPoolReserves = formatReserves({
        reserves: reservesArray,
        currentTimestamp,
        marketReferenceCurrencyDecimals: baseCurrencyData.marketReferenceCurrencyDecimals,
        marketReferencePriceInUsd: baseCurrencyData.marketReferenceCurrencyPriceInUsd
      });
      const summary = formatUserSummaryAndIncentives({
        currentTimestamp,
        marketReferencePriceInUsd: baseCurrencyData.marketReferenceCurrencyPriceInUsd,
        marketReferenceCurrencyDecimals: baseCurrencyData.marketReferenceCurrencyDecimals,
        userReserves: userReservesArray,
        formattedReserves: formattedPoolReserves,
        userEmodeCategoryId: userReserves.userEmodeCategoryId,
        reserveIncentives,
        userIncentives
      });
      const maxBorrowAmount = valueToBigNumber(summary?.totalBorrowsMarketReferenceCurrency || "0").plus(summary?.availableBorrowsMarketReferenceCurrency || "0");
      const collateralUsage = maxBorrowAmount.eq(0) ? "0" : valueToBigNumber(summary?.totalBorrowsMarketReferenceCurrency || "0").div(maxBorrowAmount).toFixed();
      this.summary = {
        ...summary,
        collateralUsage
      };
      this.fetchStatus = "success";
    }
  }));
}
// src/scripts/alpinejs/data-contexts/aave-supply-pool.ts
function registerDataAaveSupplyPool(sliceName) {
  window.Alpine.data(sliceName, () => ({
    status: "idle",
    amount: 0,
    token: undefined,
    txsHashes: undefined,
    async supplyTokens(args) {
      try {
        this.txsHashes = undefined;
        this.status = "signaturePending";
        const storeCurrentUser = window.Alpine.store("currentUser");
        const walletProvider = new exports_lib2.Web3Provider(window.ethereum);
        const poolContractProvider = new Pool(provider, {
          POOL: exports_AaveV3Sepolia.POOL,
          WETH_GATEWAY: exports_AaveV3Sepolia.WETH_GATEWAY
        });
        const tokenAddress = `${this.token.UNDERLYING}`;
        const deadline = Math.round(Date.now() / 600 + 3600).toString();
        const supplyData = {
          user: storeCurrentUser.account,
          reserve: tokenAddress,
          amount: this.amount.toString(),
          deadline
        };
        const approval = await poolContractProvider.signERC20Approval(supplyData);
        const signature = await walletProvider.send("eth_signTypedData_v4", [storeCurrentUser.account, approval]);
        const txData = {
          ...supplyData,
          signature
        };
        const txs = await poolContractProvider.supplyWithPermit(txData);
        this.status = "transactionPending";
        const resultTxs = await Promise.allSettled(txs.map(async (tx) => {
          return await submitTransaction({
            provider: walletProvider,
            tx
          });
        }));
        if (resultTxs.filter((tx) => tx.status === "rejected")?.length > 0) {
          this.status = "error";
          return;
        }
        this.txsHashes = resultTxs.filter((tx) => {
          if (tx.status === "fulfilled")
            return tx?.value?.hash;
        });
        await Promise.allSettled(resultTxs.map(async (tx) => {
          if (tx.status === "fulfilled")
            await tx?.value?.wait();
        }));
        this.status = "transactionSuccessful";
      } catch (e) {
        console.error(e);
        this.status = "error";
      }
    }
  }));
}
// src/scripts/alpinejs/data-contexts/aave-borrow-reserve-asset.ts
function registerDataAaveBorrowReserveAsset(sliceName) {
  window.Alpine.data(sliceName, () => ({
    status: "idle",
    amount: 0,
    interestRateMode: InterestRate.None,
    token: undefined,
    txsHashes: undefined,
    async borrow() {
      try {
        this.txsHashes = undefined;
        this.status = "signaturePending";
        const storeCurrentUser = window.Alpine.store("currentUser");
        const walletProvider = new exports_lib2.Web3Provider(window.ethereum);
        const poolContractProvider = new Pool(provider, {
          POOL: exports_AaveV3Sepolia.POOL,
          WETH_GATEWAY: exports_AaveV3Sepolia.WETH_GATEWAY
        });
        const data = {
          user: storeCurrentUser.account,
          amount: this.amount.toString(),
          reserve: this.token.UNDERLYING,
          interestRateMode: this.interestRateMode
        };
        const txs = await poolContractProvider.borrow({
          ...data
        });
        this.status = "transactionPending";
        const resultTxs = await Promise.allSettled(txs.map(async (tx) => {
          return await submitTransaction({
            provider: walletProvider,
            tx
          });
        }));
        if (resultTxs.filter((tx) => tx.status === "rejected")?.length > 0) {
          this.status = "error";
          return;
        }
        this.txsHashes = resultTxs.filter((tx) => {
          if (tx.status === "fulfilled")
            return tx?.value?.hash;
        });
        await Promise.allSettled(resultTxs.map(async (tx) => {
          if (tx.status === "fulfilled")
            await tx?.value?.wait();
        }));
        this.status = "transactionSuccessful";
      } catch (e) {
        console.error(e);
        this.status = "error";
      }
    }
  }));
}
// src/scripts/alpinejs/data-contexts/erc20-transfer.ts
function registerDataERC20Transfer(sliceName) {
  window.Alpine.data(sliceName, () => ({
    status: "idle",
    txHash: undefined,
    token: undefined,
    amount: 0,
    recipientAddress: undefined,
    async transferTokens(args) {
      try {
        this.txHash = undefined;
        this.status = "signaturePending";
        const storeCurrentUser = window.Alpine.store("currentUser");
        const walletProvider = new exports_lib2.Web3Provider(window.ethereum);
        const signer = walletProvider.getSigner(storeCurrentUser.account);
        if (args?.token)
          this.token = args.token;
        if (args?.amount)
          this.amount = args.amount;
        if (args?.recipientAddress)
          this.recipientAddress = args.recipientAddress;
        const tokenAddress = this.token?.UNDERLYING;
        const tokenDecimals = this.token?.decimals;
        const contract = new Contract(tokenAddress, IERC20_ABI, signer);
        const amount = exports_utils.parseUnits(this.amount?.toString(), tokenDecimals);
        const tx = await contract.transfer(this.recipientAddress, amount);
        this.status = "transactionPending";
        await tx.wait();
        this.txHash = tx.hash;
        this.status = "transactionSuccessful";
      } catch (e) {
        console.error(e);
        this.status = "error";
      }
    }
  }));
}
// src/scripts/alpinejs/data-contexts/erc20-balance-of.ts
function registerDataERC20BalanceOf(sliceName) {
  window.Alpine.data(sliceName, () => ({
    fetchStatus: "idle",
    balance: undefined,
    async getTokenBalanceForAddress(args) {
      this.fetchStatus = "pending";
      const storeCurrentUser = window.Alpine.store("currentUser");
      const balanceProvider = storeCurrentUser.getWalletBalanceProvider();
      const balance = await balanceProvider.balanceOf(args.walletAddress, args.tokenAddress);
      this.balance = {
        value: balance,
        formatted: normalize(balance.toString(), args?.tokenDecimal ?? 18)
      };
      this.fetchStatus = "success";
    }
  }));
}
// src/scripts/alpinejs/data-contexts/aave-repay-debt.ts
function registerDataAaveRepayDebt(sliceName) {
  window.Alpine.data(sliceName, () => ({
    status: "idle",
    amount: 0,
    interestRateMode: InterestRate.Variable,
    token: undefined,
    txsHashes: undefined,
    async repayDebt(args) {
      try {
        this.txsHashes = undefined;
        this.status = "signaturePending";
        const storeCurrentUser = window.Alpine.store("currentUser");
        const walletProvider = new exports_lib2.Web3Provider(window.ethereum);
        const poolContractProvider = new Pool(provider, {
          POOL: exports_AaveV3Sepolia.POOL,
          WETH_GATEWAY: exports_AaveV3Sepolia.WETH_GATEWAY
        });
        const deadline = Math.round(Date.now() / 600 + 3600).toString();
        const repayDebtData = {
          user: storeCurrentUser.account,
          amount: this.amount.toString(),
          reserve: this.token.UNDERLYING,
          interestRateMode: this.interestRateMode,
          deadline,
          onBehalfOf: args?.onBehalfOfAddress ?? storeCurrentUser.account
        };
        const approval = await poolContractProvider.signERC20Approval(repayDebtData);
        const signature = await walletProvider.send("eth_signTypedData_v4", [storeCurrentUser.account, approval]);
        const txData = {
          ...repayDebtData,
          signature
        };
        const txs = await poolContractProvider.repayWithPermit(txData);
        this.status = "transactionPending";
        const resultTxs = await Promise.allSettled(txs.map(async (tx) => {
          const result = await submitTransaction({
            provider: walletProvider,
            tx
          });
          return result;
        }));
        if (resultTxs.filter((tx) => tx.status === "rejected")?.length > 0) {
          this.status = "error";
          return;
        }
        this.txsHashes = resultTxs.filter((tx) => {
          if (tx.status === "fulfilled")
            return tx?.value?.hash;
        });
        await Promise.allSettled(resultTxs.map(async (tx) => {
          if (tx.status === "fulfilled")
            await tx?.value?.wait();
        }));
        this.status = "transactionSuccessful";
      } catch (e) {
        console.error(e);
        this.status = "error";
      }
    }
  }));
}
// src/scripts/alpinejs/data-contexts/aave-withdraw-asset.ts
function registerDataAaveWithdrawAsset(sliceName) {
  window.Alpine.data(sliceName, () => ({
    status: "idle",
    amount: 0,
    token: undefined,
    txsHashes: undefined,
    async withdrawAsset() {
      try {
        this.txsHashes = undefined;
        this.status = "signaturePending";
        const storeCurrentUser = window.Alpine.store("currentUser");
        const walletProvider = new exports_lib2.Web3Provider(window.ethereum);
        const poolContractProvider = new Pool(provider, {
          POOL: exports_AaveV3Sepolia.POOL,
          WETH_GATEWAY: exports_AaveV3Sepolia.WETH_GATEWAY
        });
        const data = {
          user: storeCurrentUser.account,
          amount: this.amount.toString(),
          reserve: this.token.UNDERLYING,
          aTokenAddress: this.token.A_TOKEN
        };
        const txs = await poolContractProvider.withdraw({
          ...data
        });
        this.status = "transactionPending";
        const resultTxs = await Promise.allSettled(txs.map(async (tx) => {
          return await submitTransaction({
            provider: walletProvider,
            tx
          });
        }));
        if (resultTxs.filter((tx) => tx.status === "rejected")?.length > 0) {
          this.status = "error";
          return;
        }
        this.txsHashes = resultTxs.filter((tx) => {
          if (tx.status === "fulfilled")
            return tx?.value?.hash;
        });
        await Promise.allSettled(resultTxs.map(async (tx) => {
          if (tx.status === "fulfilled")
            await tx?.value?.wait();
        }));
        this.status = "transactionSuccessful";
      } catch (e) {
        console.error(e);
        this.status = "error";
      }
    }
  }));
}
// src/scripts/alpinejs/magics/format.ts
function registerMagic$formatERC20Balance(directiveName) {
  window.Alpine.magic(directiveName, () => {
    return (subject, symbol) => new Intl.NumberFormat(navigator.language, { style: "currency", currency: "USD" }).format(subject).replace("$US", symbol);
  });
}
function registerMagic$formatNumber(directiveName) {
  window.Alpine.magic(directiveName, () => {
    return (subject, options) => new Intl.NumberFormat(navigator.language, options).format(subject);
  });
}
// src/scripts/alpinejs/magics/aave-assets.ts
function registerMagic$assetBySymbol(directiveName) {
  window.Alpine.magic(directiveName, () => {
    return (subject) => exports_AaveV3Sepolia.ASSETS[subject];
  });
}
function registerMagic$assetsDictionary(directiveName) {
  window.Alpine.magic(directiveName, () => {
    return (subject) => exports_AaveV3Sepolia.ASSETS;
  });
}
// src/scripts/ghooey.ts
function setupGhooey() {
  document.addEventListener("alpine:init", async () => {
    registerStoreCurrentUser(STORE_CURRENT_USER);
    registerStoreAaveMarkets(STORE_AAVE_MARKET);
    registerDataWalletAavePortfolio(DATA_SLICE_WALLET_AAVE_PORTFOLIO);
    registerDataAaveSupplyPool(DATA_SLICE_AAVE_SUPPLY);
    registerDataAaveBorrowReserveAsset(DATA_SLICE_AAVE_BORROW_RESERVE_ASSET);
    registerDataERC20Transfer(DATA_SLICE_ERC20_TRANSFER);
    registerDataERC20BalanceOf(DATA_SLICE_ERC20_BALANCE_OF);
    registerDataAaveRepayDebt(DATA_SLICE_AAVE_REPAY_DEBT);
    registerDataAaveWithdrawAsset(DATA_SLICE_AAVE_WITHDRAW_ASSET);
    registerMagic$formatERC20Balance(MAGIC_FORMAT_ERC20_BALANCE);
    registerMagic$formatNumber(MAGIC_FORMAT_NUMBER);
    registerMagic$assetsDictionary(MAGIC_AAVE_ASSETS_DICTIONARY);
    registerMagic$assetBySymbol(MAGIC_AAVE_ASSET_BY_SYMBOL);
  });
}
var STORE_CURRENT_USER = "currentUser";
var STORE_AAVE_MARKET = "aaveMarkets";
var DATA_SLICE_WALLET_AAVE_PORTFOLIO = "walletAavePortfolio";
var DATA_SLICE_AAVE_SUPPLY = "aaveSupply";
var DATA_SLICE_ERC20_TRANSFER = "erc20Transfer";
var DATA_SLICE_ERC20_BALANCE_OF = "erc20BalanceOf";
var DATA_SLICE_AAVE_BORROW_RESERVE_ASSET = "aaveBorrowReserveAsset";
var DATA_SLICE_AAVE_REPAY_DEBT = "aaveRepayDebt";
var DATA_SLICE_AAVE_WITHDRAW_ASSET = "aaveWithdrawAsset";
var MAGIC_FORMAT_ERC20_BALANCE = "formatERC20Balance";
var MAGIC_FORMAT_NUMBER = "formatNumber";
var MAGIC_AAVE_ASSETS_DICTIONARY = "aaveAssetsDictionary";
var MAGIC_AAVE_ASSET_BY_SYMBOL = "aaveAssetBySymbol";
export {
  setupGhooey
};
